(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[6],{

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js ***!
  \***********************************************************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n\n\n\n\n/**\n * @desc Base class for all xeokit components.\n *\n * ## Component IDs\n *\n * Every Component has an ID that's unique within the parent {@link Scene}. xeokit generates\n * the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a\n * scene comprised of {@link Scene}, {@link Material}, {@link ReadableGeometry} and\n * {@link Mesh} components, while letting xeokit generate its own ID for\n * the {@link ReadableGeometry}:\n *\n *````JavaScript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {Mesh} from \"../src/scene/mesh/Mesh.js\";\n * import {buildTorusGeometry} from \"../src/scene/geometry/builders/buildTorusGeometry.js\";\n * import {ReadableGeometry} from \"../src/scene/geometry/ReadableGeometry.js\";\n * import {PhongMaterial} from \"../src/scene/materials/PhongMaterial.js\";\n * import {Texture} from \"../src/scene/materials/Texture.js\";\n * import {Fresnel} from \"../src/scene/materials/Fresnel.js\";\n *\n * const viewer = new Viewer({\n *        canvasId: \"myCanvas\"\n *    });\n *\n * viewer.scene.camera.eye = [0, 0, 5];\n * viewer.scene.camera.look = [0, 0, 0];\n * viewer.scene.camera.up = [0, 1, 0];\n *\n * new Mesh(viewer.scene, {\n *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({\n *          center: [0, 0, 0],\n *          radius: 1.5,\n *          tube: 0.5,\n *          radialSegments: 32,\n *          tubeSegments: 24,\n *          arc: Math.PI * 2.0\n *      }),\n *      material: new PhongMaterial(viewer.scene, {\n *          id: \"myMaterial\",\n *          ambient: [0.9, 0.3, 0.9],\n *          shininess: 30,\n *          diffuseMap: new Texture(viewer.scene, {\n *              src: \"textures/diffuse/uvGrid2.jpg\"\n *          }),\n *          specularFresnel: new Fresnel(viewer.scene, {\n *              leftColor: [1.0, 1.0, 1.0],\n *              rightColor: [0.0, 0.0, 0.0],\n *              power: 4\n *          })\n *     })\n * });\n *````\n *\n * We can then find those components like this:\n *\n * ````javascript\n * // Find the Material\n * var material = viewer.scene.components[\"myMaterial\"];\n *\n * // Find all PhongMaterials in the Scene\n * var phongMaterials = viewer.scene.types[\"PhongMaterial\"];\n *\n * // Find our Material within the PhongMaterials\n * var materialAgain = phongMaterials[\"myMaterial\"];\n * ````\n *\n * ## Restriction on IDs\n *\n * Auto-generated IDs are of the form ````\"__0\"````, ````\"__1\"````, ````\"__2\"```` ... and so on.\n *\n * Scene maintains a map of these IDs, along with a counter that it increments each time it generates a new ID.\n *\n * If Scene has created the IDs listed above, and we then destroy the ````Component```` with ID ````\"__1\"````,\n * Scene will mark that ID as available, and will reuse it for the next default ID.\n *\n * Therefore, two restrictions your on IDs:\n *\n * * don't use IDs that begin with two underscores, and\n * * don't reuse auto-generated IDs of destroyed Components.\n *\n * ## Logging\n *\n * Components have methods to log ID-prefixed messages to the JavaScript console:\n *\n * ````javascript\n * material.log(\"Everything is fine, situation normal.\");\n * material.warn(\"Wait, whats that red light?\");\n * material.error(\"Aw, snap!\");\n * ````\n *\n * The logged messages will look like this in the console:\n *\n * ````text\n * [LOG]   myMaterial: Everything is fine, situation normal.\n * [WARN]  myMaterial: Wait, whats that red light..\n * [ERROR] myMaterial: Aw, snap!\n * ````\n *\n * ## Destruction\n *\n * Get notification of destruction of Components:\n *\n * ````javascript\n * material.once(\"destroyed\", function() {\n *     this.log(\"Component was destroyed: \" + this.id);\n * });\n * ````\n *\n * Or get notification of destruction of any Component within its {@link Scene}:\n *\n * ````javascript\n * scene.on(\"componentDestroyed\", function(component) {\n *     this.log(\"Component was destroyed: \" + component.id);\n * });\n * ````\n *\n * Then destroy a component like this:\n *\n * ````javascript\n * material.destroy();\n * ````\n */\nclass Component {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"Component\";\n    }\n\n    /**\n     * @private\n     */\n    get isComponent() {\n        return true;\n    }\n\n    constructor(owner = null, cfg = {}) {\n\n        /**\n         * The parent {@link Scene} that contains this Component.\n         *\n         * @property scene\n         * @type {Scene}\n         * @final\n         */\n        this.scene = null;\n\n        if (this.type === \"Scene\") {\n            this.scene = this;\n            /**\n             * The viewer that contains this Scene.\n             * @property viewer\n             * @type {Viewer}\n             */\n            this.viewer = cfg.viewer;\n        } else {\n            if (owner.type === \"Scene\") {\n                this.scene = owner;\n            } else if (owner instanceof Component) {\n                this.scene = owner.scene;\n            } else {\n                throw \"Invalid param: owner must be a Component\"\n            }\n            this._owner = owner;\n            this._renderer = this.scene._renderer;\n        }\n\n        this._dontClear = !!cfg.dontClear; // Prevent Scene#clear from destroying this component\n\n        this._renderer = this.scene._renderer;\n\n        /**\n         Arbitrary, user-defined metadata on this component.\n\n         @property metadata\n         @type Object\n         */\n        this.meta = cfg.meta || {};\n\n\n        /**\n         * ID of this Component, unique within the {@link Scene}.\n         *\n         * Components are mapped by this ID in {@link Scene#components}.\n         *\n         * @property id\n         * @type {String|Number}\n         */\n        this.id = cfg.id; // Auto-generated by Scene by default\n\n        /**\n         True as soon as this Component has been destroyed\n\n         @property destroyed\n         @type {Boolean}\n         */\n        this.destroyed = false;\n\n        this._attached = {}; // Attached components with names.\n        this._attachments = null; // Attached components keyed to IDs - lazy-instantiated\n        this._subIdMap = null; // Subscription subId pool\n        this._subIdEvents = null; // Subscription subIds mapped to event names\n        this._eventSubs = null; // Event names mapped to subscribers\n        this._eventSubsNum = null;\n        this._events = null; // Maps names to events\n        this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events\n        this._ownedComponents = null; // // Components created with #create - lazy-instantiated\n\n        if (this !== this.scene) { // Don't add scene to itself\n            this.scene._addComponent(this); // Assigns this component an automatic ID if not yet assigned\n        }\n\n        this._updateScheduled = false; // True when #_update will be called on next tick\n\n        if (owner) {\n            owner._own(this);\n        }\n    }\n\n    // /**\n    //  * Unique ID for this Component within its {@link Scene}.\n    //  *\n    //  * @property\n    //  * @type {String}\n    //  */\n    // get id() {\n    //     return this._id;\n    // }\n\n    /**\n     Indicates that we need to redraw the scene.\n\n     This is called by certain subclasses after they have made some sort of state update that requires the\n     renderer to perform a redraw.\n\n     For example: a {@link Mesh} calls this on itself whenever you update its\n     {@link Mesh#layer} property, which manually controls its render order in\n     relation to other Meshes.\n\n     If this component has a ````castsShadow```` property that's set ````true````, then this will also indicate\n     that the renderer needs to redraw shadow map associated with this component. Components like\n     {@link DirLight} have that property set when they produce light that creates shadows, while\n     components like {@link Mesh\"}}layer{{/crossLink}} have that property set when they cast shadows.\n\n     @protected\n     */\n    glRedraw() {\n        this._renderer.imageDirty();\n        if (this.castsShadow) { // Light source or object\n            this._renderer.shadowsDirty();\n        }\n    }\n\n    /**\n     Indicates that we need to re-sort the renderer's state-ordered drawables list.\n\n     For efficiency, the renderer keeps its list of drawables ordered so that runs of the same state updates can be\n     combined.  This method is called by certain subclasses after they have made some sort of state update that would\n     require re-ordering of the drawables list.\n\n     For example: a {@link DirLight} calls this on itself whenever you update {@link DirLight#dir}.\n\n     @protected\n     */\n    glResort() {\n        this._renderer.needStateSort();\n    }\n\n    /**\n     * The {@link Component} that owns the lifecycle of this Component, if any.\n     *\n     * When that component is destroyed, this component will be automatically destroyed also.\n     *\n     * Will be null if this Component has no owner.\n     *\n     * @property owner\n     * @type {Component}\n     */\n    get owner() {\n        return this._owner;\n    }\n\n    /**\n     * Tests if this component is of the given type, or is a subclass of the given type.\n     * @type {Boolean}\n     */\n    isType(type) {\n        return this.type === type;\n    }\n\n    /**\n     * Fires an event on this component.\n     *\n     * Notifies existing subscribers to the event, optionally retains the event to give to\n     * any subsequent notifications on the event as they are made.\n     *\n     * @param {String} event The event type name\n     * @param {Object} value The event parameters\n     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers\n     */\n    fire(event, value, forget) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n            this._eventSubsNum = {};\n        }\n        if (forget !== true) {\n            this._events[event] = value || true; // Save notification\n        }\n        const subs = this._eventSubs[event];\n        let sub;\n        if (subs) { // Notify subscriptions\n            for (const subId in subs) {\n                if (subs.hasOwnProperty(subId)) {\n                    sub = subs[subId];\n                    this._eventCallDepth++;\n                    if (this._eventCallDepth < 300) {\n                        sub.callback.call(sub.scope, value);\n                    } else {\n                        this.error(\"fire: potential stack overflow from recursive event '\" + event + \"' - dropping this event\");\n                    }\n                    this._eventCallDepth--;\n                }\n            }\n        }\n    }\n\n    /**\n     * Subscribes to an event on this component.\n     *\n     * The callback is be called with this component as scope.\n     *\n     * @param {String} event The event\n     * @param {Function} callback Called fired on the event\n     * @param {Object} [scope=this] Scope for the callback\n     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.\n     */\n    on(event, callback, scope) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._subIdMap) {\n            this._subIdMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__[\"Map\"](); // Subscription subId pool\n        }\n        if (!this._subIdEvents) {\n            this._subIdEvents = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n        }\n        if (!this._eventSubsNum) {\n            this._eventSubsNum = {};\n        }\n        let subs = this._eventSubs[event];\n        if (!subs) {\n            subs = {};\n            this._eventSubs[event] = subs;\n            this._eventSubsNum[event] = 1;\n        } else {\n            this._eventSubsNum[event]++;\n        }\n        const subId = this._subIdMap.addItem(); // Create unique subId\n        subs[subId] = {\n            callback: callback,\n            scope: scope || this\n        };\n        this._subIdEvents[subId] = event;\n        const value = this._events[event];\n        if (value !== undefined) { // A publication exists, notify callback immediately\n            callback.call(scope || this, value);\n        }\n        return subId;\n    }\n\n    /**\n     * Cancels an event subscription that was previously made with {@link Component#on} or {@link Component#once}.\n     *\n     * @param {String} subId Subscription ID\n     */\n    off(subId) {\n        if (subId === undefined || subId === null) {\n            return;\n        }\n        if (!this._subIdEvents) {\n            return;\n        }\n        const event = this._subIdEvents[subId];\n        if (event) {\n            delete this._subIdEvents[subId];\n            const subs = this._eventSubs[event];\n            if (subs) {\n                delete subs[subId];\n                this._eventSubsNum[event]--;\n            }\n            this._subIdMap.removeItem(subId); // Release subId\n        }\n    }\n\n    /**\n     * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.\n     *\n     * This is equivalent to calling {@link Component#on}, and then calling {@link Component#off} inside the callback function.\n     *\n     * @param {String} event Data event to listen to\n     * @param {Function} callback Called when fresh data is available at the event\n     * @param {Object} [scope=this] Scope for the callback\n     */\n    once(event, callback, scope) {\n        const self = this;\n        const subId = this.on(event,\n            function (value) {\n                self.off(subId);\n                callback.call(scope || this, value);\n            },\n            scope);\n    }\n\n    /**\n     * Returns true if there are any subscribers to the given event on this component.\n     *\n     * @param {String} event The event\n     * @return {Boolean} True if there are any subscribers to the given event on this component.\n     */\n    hasSubs(event) {\n        return (this._eventSubsNum && (this._eventSubsNum[event] > 0));\n    }\n\n    /**\n     * Logs a console debugging message for this component.\n     *\n     * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*\n     *\n     * Also fires the message as a \"log\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    log(message) {\n        message = \"[LOG]\" + this._message(message);\n        window.console.log(message);\n        this.scene.fire(\"log\", message);\n    }\n\n    _message(message) {\n        return \" [\" + this.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(this.id) + \"]: \" + message;\n    }\n\n    /**\n     * Logs a warning for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as a \"warn\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    warn(message) {\n        message = \"[WARN]\" + this._message(message);\n        window.console.warn(message);\n        this.scene.fire(\"warn\", message);\n    }\n\n    /**\n     * Logs an error for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as an \"error\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    error(message) {\n        message = \"[ERROR]\" + this._message(message);\n        window.console.error(message);\n        this.scene.fire(\"error\", message);\n    }\n\n    /**\n     * Adds a child component to this.\n     *\n     * When component not given, attaches the scene's default instance for the given name (if any).\n     * Publishes the new child component on this component, keyed to the given name.\n     *\n     * @param {*} params\n     * @param {String} params.name component name\n     * @param {Component} [params.component] The component\n     * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will\n     * cause an exception if the given child is not the same type or a subtype of this.\n     * @param {Boolean} [params.sceneDefault=false]\n     * @param {Boolean} [params.sceneSingleton=false]\n     * @param {Function} [params.onAttached] Optional callback called when component attached\n     * @param {Function} [params.onAttached.callback] Callback function\n     * @param {Function} [params.onAttached.scope] Optional scope for callback\n     * @param {Function} [params.onDetached] Optional callback called when component is detached\n     * @param {Function} [params.onDetached.callback] Callback function\n     * @param {Function} [params.onDetached.scope] Optional scope for callback\n     * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component\n     * @param {Boolean} [params.recompiles=true] When true, fires \"dirty\" events on this component\n     * @private\n     */\n    _attach(params) {\n\n        const name = params.name;\n\n        if (!name) {\n            this.error(\"Component 'name' expected\");\n            return;\n        }\n\n        let component = params.component;\n        const sceneDefault = params.sceneDefault;\n        const sceneSingleton = params.sceneSingleton;\n        const type = params.type;\n        const on = params.on;\n        const recompiles = params.recompiles !== false;\n\n        // True when child given as config object, where parent manages its instantiation and destruction\n        let managingLifecycle = false;\n\n        if (component) {\n\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isNumeric(component) || _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isString(component)) {\n\n                // Component ID given\n                // Both numeric and string IDs are supported\n\n                const id = component;\n\n                component = this.scene.components[id];\n\n                if (!component) {\n\n                    // Quote string IDs in errors\n\n                    this.error(\"Component not found: \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(id));\n                    return;\n                }\n            }\n        }\n\n        if (!component) {\n\n            if (sceneSingleton === true) {\n\n                // Using the first instance of the component type we find\n\n                const instances = this.scene.types[type];\n                for (const id2 in instances) {\n                    if (instances.hasOwnProperty) {\n                        component = instances[id2];\n                        break;\n                    }\n                }\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n\n            } else if (sceneDefault === true) {\n\n                // Using a default scene component\n\n                component = this.scene[name];\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n            }\n        }\n\n        if (component) {\n\n            if (component.scene.id !== this.scene.id) {\n                this.error(\"Not in same scene: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                return;\n            }\n\n            if (type) {\n\n                if (!component.isType(type)) {\n                    this.error(\"Expected a \" + type + \" type or subtype: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                    return;\n                }\n            }\n        }\n\n        if (!this._attachments) {\n            this._attachments = {};\n        }\n\n        const oldComponent = this._attached[name];\n        let subs;\n        let i;\n        let len;\n\n        if (oldComponent) {\n\n            if (component && oldComponent.id === component.id) {\n\n                // Reject attempt to reattach same component\n                return;\n            }\n\n            const oldAttachment = this._attachments[oldComponent.id];\n\n            // Unsubscribe from events on old component\n\n            subs = oldAttachment.subs;\n\n            for (i = 0, len = subs.length; i < len; i++) {\n                oldComponent.off(subs[i]);\n            }\n\n            delete this._attached[name];\n            delete this._attachments[oldComponent.id];\n\n            const onDetached = oldAttachment.params.onDetached;\n            if (onDetached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onDetached)) {\n                    onDetached(oldComponent);\n                } else {\n                    onDetached.scope ? onDetached.callback.call(onDetached.scope, oldComponent) : onDetached.callback(oldComponent);\n                }\n            }\n\n            if (oldAttachment.managingLifecycle) {\n\n                // Note that we just unsubscribed from all events fired by the child\n                // component, so destroying it won't fire events back at us now.\n\n                oldComponent.destroy();\n            }\n        }\n\n        if (component) {\n\n            // Set and publish the new component on this component\n\n            const attachment = {\n                params: params,\n                component: component,\n                subs: [],\n                managingLifecycle: managingLifecycle\n            };\n\n            attachment.subs.push(\n                component.once(\"destroyed\",\n                    function () {\n                        attachment.params.component = null;\n                        this._attach(attachment.params);\n                    },\n                    this));\n\n            if (recompiles) {\n                attachment.subs.push(\n                    component.on(\"dirty\",\n                        function () {\n                            this.fire(\"dirty\", this);\n                        },\n                        this));\n            }\n\n            this._attached[name] = component;\n            this._attachments[component.id] = attachment;\n\n            // Bind destruct listener to new component to remove it\n            // from this component when destroyed\n\n            const onAttached = params.onAttached;\n            if (onAttached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onAttached)) {\n                    onAttached(component);\n                } else {\n                    onAttached.scope ? onAttached.callback.call(onAttached.scope, component) : onAttached.callback(component);\n                }\n            }\n\n            if (on) {\n\n                let event;\n                let subIdr;\n                let callback;\n                let scope;\n\n                for (event in on) {\n                    if (on.hasOwnProperty(event)) {\n\n                        subIdr = on[event];\n\n                        if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(subIdr)) {\n                            callback = subIdr;\n                            scope = null;\n                        } else {\n                            callback = subIdr.callback;\n                            scope = subIdr.scope;\n                        }\n\n                        if (!callback) {\n                            continue;\n                        }\n\n                        attachment.subs.push(component.on(event, callback, scope));\n                    }\n                }\n            }\n        }\n\n        if (recompiles) {\n            this.fire(\"dirty\", this); // FIXME: May trigger spurous mesh recompilations unless able to limit with param?\n        }\n\n        this.fire(name, component); // Component can be null\n\n        return component;\n    }\n\n    _checkComponent(expectedType, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (expectedType !== component.type) {\n            this.error(\"Expected a \" + expectedType + \" Component\");\n            return;\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        return component;\n    }\n\n    _checkComponent2(expectedTypes, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        for (var i = 0, len = expectedTypes.length; i < len; i++) {\n            if (expectedTypes[i] === component.type) {\n                return component;\n            }\n        }\n        this.error(\"Expected component types: \" + expectedTypes);\n        return null;\n    }\n\n    _own(component) {\n        if (!this._ownedComponents) {\n            this._ownedComponents = {};\n        }\n        if (!this._ownedComponents[component.id]) {\n            this._ownedComponents[component.id] = component;\n        }\n        component.once(\"destroyed\", () => {\n            delete this._ownedComponents[component.id];\n        }, this);\n    }\n\n    /**\n     * Protected method, called by sub-classes to queue a call to _update().\n     * @protected\n     * @param {Number} [priority=1]\n     */\n    _needUpdate(priority) {\n        if (!this._updateScheduled) {\n            this._updateScheduled = true;\n            if (priority === 0) {\n                this._doUpdate();\n            } else {\n                _core_js__WEBPACK_IMPORTED_MODULE_0__[\"core\"].scheduleTask(this._doUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    _doUpdate() {\n        if (this._updateScheduled) {\n            this._updateScheduled = false;\n            if (this._update) {\n                this._update();\n            }\n        }\n    }\n\n    /**\n     * Protected virtual template method, optionally implemented\n     * by sub-classes to perform a scheduled task.\n     *\n     * @protected\n     */\n    _update() {\n    }\n\n    /**\n     * Destroys all {@link Component}s that are owned by this. These are Components that were instantiated with\n     * this Component as their first constructor argument.\n     */\n    clear() {\n        if (this._ownedComponents) {\n            for (var id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    const component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n    }\n\n    /**\n     * Destroys this component.\n     */\n    destroy() {\n\n        if (this.destroyed) {\n            return;\n        }\n\n        /**\n         * Fired when this Component is destroyed.\n         * @event destroyed\n         */\n        this.fire(\"destroyed\", this.destroyed = true); // Must fire before we blow away subscription maps, below\n\n        // Unsubscribe from child components and destroy then\n\n        let id;\n        let attachment;\n        let component;\n        let subs;\n        let i;\n        let len;\n\n        if (this._attachments) {\n            for (id in this._attachments) {\n                if (this._attachments.hasOwnProperty(id)) {\n                    attachment = this._attachments[id];\n                    component = attachment.component;\n                    subs = attachment.subs;\n                    for (i = 0, len = subs.length; i < len; i++) {\n                        component.off(subs[i]);\n                    }\n                    if (attachment.managingLifecycle) {\n                        component.destroy();\n                    }\n                }\n            }\n        }\n\n        if (this._ownedComponents) {\n            for (id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n\n        this.scene._removeComponent(this);\n\n        // Memory leak avoidance\n        this._attached = {};\n        this._attachments = null;\n        this._subIdMap = null;\n        this._subIdEvents = null;\n        this._eventSubs = null;\n        this._events = null;\n        this._eventCallDepth = 0;\n        this._ownedComponents = null;\n        this._updateScheduled = false;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL0NvbXBvbmVudC5qcz9hMDM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFDRTtBQUNFOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSx1QkFBdUIsWUFBWSxHQUFHLGVBQWUsR0FBRyx1QkFBdUI7QUFDL0UsSUFBSSxXQUFXO0FBQ2YsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixRQUFRO0FBQ1IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMscUNBQXFDOztBQUVyQyxrQ0FBa0M7QUFDbEMsMkNBQTJDO0FBQzNDOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQyxNQUFNLGlCQUFpQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLHNCQUFzQixhQUFhLE9BQU8sWUFBWTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixlQUFlLDJDQUEyQyxtQkFBbUI7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTyxvRUFBb0UsV0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQUcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsbUJBQW1CLEtBQUsscUJBQXFCO0FBQ2pIO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQ2pHO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QywrQ0FBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPLGdFQUFnRTtBQUN0RjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQiwrQ0FBSyx5QkFBeUIsK0NBQUs7O0FBRW5EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlELCtDQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEVBQTBFLCtDQUFLO0FBQy9FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvR0FBb0csK0NBQUs7QUFDekc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBSztBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFLO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QiwrQ0FBSztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLDZDQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvQ29tcG9uZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjb3JlfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7TWFwfSBmcm9tIFwiLi91dGlscy9NYXAuanNcIjtcblxuLyoqXG4gKiBAZGVzYyBCYXNlIGNsYXNzIGZvciBhbGwgeGVva2l0IGNvbXBvbmVudHMuXG4gKlxuICogIyMgQ29tcG9uZW50IElEc1xuICpcbiAqIEV2ZXJ5IENvbXBvbmVudCBoYXMgYW4gSUQgdGhhdCdzIHVuaXF1ZSB3aXRoaW4gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LiB4ZW9raXQgZ2VuZXJhdGVzXG4gKiB0aGUgSURzIGF1dG9tYXRpY2FsbHkgYnkgZGVmYXVsdCwgaG93ZXZlciB5b3UgY2FuIGFsc28gc3BlY2lmeSB0aGVtIHlvdXJzZWxmLiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgd2UncmUgY3JlYXRpbmcgYVxuICogc2NlbmUgY29tcHJpc2VkIG9mIHtAbGluayBTY2VuZX0sIHtAbGluayBNYXRlcmlhbH0sIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fSBhbmRcbiAqIHtAbGluayBNZXNofSBjb21wb25lbnRzLCB3aGlsZSBsZXR0aW5nIHhlb2tpdCBnZW5lcmF0ZSBpdHMgb3duIElEIGZvclxuICogdGhlIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fTpcbiAqXG4gKmBgYGBKYXZhU2NyaXB0XG4gKiBpbXBvcnQge1ZpZXdlcn0gZnJvbSBcIi4uL3NyYy92aWV3ZXIvVmlld2VyLmpzXCI7XG4gKiBpbXBvcnQge01lc2h9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWVzaC9NZXNoLmpzXCI7XG4gKiBpbXBvcnQge2J1aWxkVG9ydXNHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9idWlsZGVycy9idWlsZFRvcnVzR2VvbWV0cnkuanNcIjtcbiAqIGltcG9ydCB7UmVhZGFibGVHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9SZWFkYWJsZUdlb21ldHJ5LmpzXCI7XG4gKiBpbXBvcnQge1Bob25nTWF0ZXJpYWx9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWF0ZXJpYWxzL1Bob25nTWF0ZXJpYWwuanNcIjtcbiAqIGltcG9ydCB7VGV4dHVyZX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvVGV4dHVyZS5qc1wiO1xuICogaW1wb3J0IHtGcmVzbmVsfSBmcm9tIFwiLi4vc3JjL3NjZW5lL21hdGVyaWFscy9GcmVzbmVsLmpzXCI7XG4gKlxuICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXdlcih7XG4gKiAgICAgICAgY2FudmFzSWQ6IFwibXlDYW52YXNcIlxuICogICAgfSk7XG4gKlxuICogdmlld2VyLnNjZW5lLmNhbWVyYS5leWUgPSBbMCwgMCwgNV07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmxvb2sgPSBbMCwgMCwgMF07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLnVwID0gWzAsIDEsIDBdO1xuICpcbiAqIG5ldyBNZXNoKHZpZXdlci5zY2VuZSwge1xuICogICAgICBnZW9tZXRyeTogbmV3IFJlYWRhYmxlR2VvbWV0cnkodmlld2VyLnNjZW5lLCBidWlsZFRvcnVzR2VvbWV0cnkoe1xuICogICAgICAgICAgY2VudGVyOiBbMCwgMCwgMF0sXG4gKiAgICAgICAgICByYWRpdXM6IDEuNSxcbiAqICAgICAgICAgIHR1YmU6IDAuNSxcbiAqICAgICAgICAgIHJhZGlhbFNlZ21lbnRzOiAzMixcbiAqICAgICAgICAgIHR1YmVTZWdtZW50czogMjQsXG4gKiAgICAgICAgICBhcmM6IE1hdGguUEkgKiAyLjBcbiAqICAgICAgfSksXG4gKiAgICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgIGlkOiBcIm15TWF0ZXJpYWxcIixcbiAqICAgICAgICAgIGFtYmllbnQ6IFswLjksIDAuMywgMC45XSxcbiAqICAgICAgICAgIHNoaW5pbmVzczogMzAsXG4gKiAgICAgICAgICBkaWZmdXNlTWFwOiBuZXcgVGV4dHVyZSh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgICAgICBzcmM6IFwidGV4dHVyZXMvZGlmZnVzZS91dkdyaWQyLmpwZ1wiXG4gKiAgICAgICAgICB9KSxcbiAqICAgICAgICAgIHNwZWN1bGFyRnJlc25lbDogbmV3IEZyZXNuZWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgbGVmdENvbG9yOiBbMS4wLCAxLjAsIDEuMF0sXG4gKiAgICAgICAgICAgICAgcmlnaHRDb2xvcjogWzAuMCwgMC4wLCAwLjBdLFxuICogICAgICAgICAgICAgIHBvd2VyOiA0XG4gKiAgICAgICAgICB9KVxuICogICAgIH0pXG4gKiB9KTtcbiAqYGBgYFxuICpcbiAqIFdlIGNhbiB0aGVuIGZpbmQgdGhvc2UgY29tcG9uZW50cyBsaWtlIHRoaXM6XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIC8vIEZpbmQgdGhlIE1hdGVyaWFsXG4gKiB2YXIgbWF0ZXJpYWwgPSB2aWV3ZXIuc2NlbmUuY29tcG9uZW50c1tcIm15TWF0ZXJpYWxcIl07XG4gKlxuICogLy8gRmluZCBhbGwgUGhvbmdNYXRlcmlhbHMgaW4gdGhlIFNjZW5lXG4gKiB2YXIgcGhvbmdNYXRlcmlhbHMgPSB2aWV3ZXIuc2NlbmUudHlwZXNbXCJQaG9uZ01hdGVyaWFsXCJdO1xuICpcbiAqIC8vIEZpbmQgb3VyIE1hdGVyaWFsIHdpdGhpbiB0aGUgUGhvbmdNYXRlcmlhbHNcbiAqIHZhciBtYXRlcmlhbEFnYWluID0gcGhvbmdNYXRlcmlhbHNbXCJteU1hdGVyaWFsXCJdO1xuICogYGBgYFxuICpcbiAqICMjIFJlc3RyaWN0aW9uIG9uIElEc1xuICpcbiAqIEF1dG8tZ2VuZXJhdGVkIElEcyBhcmUgb2YgdGhlIGZvcm0gYGBgYFwiX18wXCJgYGBgLCBgYGBgXCJfXzFcImBgYGAsIGBgYGBcIl9fMlwiYGBgYCAuLi4gYW5kIHNvIG9uLlxuICpcbiAqIFNjZW5lIG1haW50YWlucyBhIG1hcCBvZiB0aGVzZSBJRHMsIGFsb25nIHdpdGggYSBjb3VudGVyIHRoYXQgaXQgaW5jcmVtZW50cyBlYWNoIHRpbWUgaXQgZ2VuZXJhdGVzIGEgbmV3IElELlxuICpcbiAqIElmIFNjZW5lIGhhcyBjcmVhdGVkIHRoZSBJRHMgbGlzdGVkIGFib3ZlLCBhbmQgd2UgdGhlbiBkZXN0cm95IHRoZSBgYGBgQ29tcG9uZW50YGBgYCB3aXRoIElEIGBgYGBcIl9fMVwiYGBgYCxcbiAqIFNjZW5lIHdpbGwgbWFyayB0aGF0IElEIGFzIGF2YWlsYWJsZSwgYW5kIHdpbGwgcmV1c2UgaXQgZm9yIHRoZSBuZXh0IGRlZmF1bHQgSUQuXG4gKlxuICogVGhlcmVmb3JlLCB0d28gcmVzdHJpY3Rpb25zIHlvdXIgb24gSURzOlxuICpcbiAqICogZG9uJ3QgdXNlIElEcyB0aGF0IGJlZ2luIHdpdGggdHdvIHVuZGVyc2NvcmVzLCBhbmRcbiAqICogZG9uJ3QgcmV1c2UgYXV0by1nZW5lcmF0ZWQgSURzIG9mIGRlc3Ryb3llZCBDb21wb25lbnRzLlxuICpcbiAqICMjIExvZ2dpbmdcbiAqXG4gKiBDb21wb25lbnRzIGhhdmUgbWV0aG9kcyB0byBsb2cgSUQtcHJlZml4ZWQgbWVzc2FnZXMgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZTpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogbWF0ZXJpYWwubG9nKFwiRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlwiKTtcbiAqIG1hdGVyaWFsLndhcm4oXCJXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodD9cIik7XG4gKiBtYXRlcmlhbC5lcnJvcihcIkF3LCBzbmFwIVwiKTtcbiAqIGBgYGBcbiAqXG4gKiBUaGUgbG9nZ2VkIG1lc3NhZ2VzIHdpbGwgbG9vayBsaWtlIHRoaXMgaW4gdGhlIGNvbnNvbGU6XG4gKlxuICogYGBgYHRleHRcbiAqIFtMT0ddICAgbXlNYXRlcmlhbDogRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlxuICogW1dBUk5dICBteU1hdGVyaWFsOiBXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodC4uXG4gKiBbRVJST1JdIG15TWF0ZXJpYWw6IEF3LCBzbmFwIVxuICogYGBgYFxuICpcbiAqICMjIERlc3RydWN0aW9uXG4gKlxuICogR2V0IG5vdGlmaWNhdGlvbiBvZiBkZXN0cnVjdGlvbiBvZiBDb21wb25lbnRzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5vbmNlKFwiZGVzdHJveWVkXCIsIGZ1bmN0aW9uKCkge1xuICogICAgIHRoaXMubG9nKFwiQ29tcG9uZW50IHdhcyBkZXN0cm95ZWQ6IFwiICsgdGhpcy5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBPciBnZXQgbm90aWZpY2F0aW9uIG9mIGRlc3RydWN0aW9uIG9mIGFueSBDb21wb25lbnQgd2l0aGluIGl0cyB7QGxpbmsgU2NlbmV9OlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBzY2VuZS5vbihcImNvbXBvbmVudERlc3Ryb3llZFwiLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAqICAgICB0aGlzLmxvZyhcIkNvbXBvbmVudCB3YXMgZGVzdHJveWVkOiBcIiArIGNvbXBvbmVudC5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBUaGVuIGRlc3Ryb3kgYSBjb21wb25lbnQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5kZXN0cm95KCk7XG4gKiBgYGBgXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ29tcG9uZW50XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgaXNDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKG93bmVyID0gbnVsbCwgY2ZnID0ge30pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9IHRoYXQgY29udGFpbnMgdGhpcyBDb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzY2VuZVxuICAgICAgICAgKiBAdHlwZSB7U2NlbmV9XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gdGhpcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZpZXdlciB0aGF0IGNvbnRhaW5zIHRoaXMgU2NlbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Vmlld2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlciA9IGNmZy52aWV3ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3duZXIudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG93bmVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lciBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBvd25lci5zY2VuZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmFtOiBvd25lciBtdXN0IGJlIGEgQ29tcG9uZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuc2NlbmUuX3JlbmRlcmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9udENsZWFyID0gISFjZmcuZG9udENsZWFyOyAvLyBQcmV2ZW50IFNjZW5lI2NsZWFyIGZyb20gZGVzdHJveWluZyB0aGlzIGNvbXBvbmVudFxuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5zY2VuZS5fcmVuZGVyZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBBcmJpdHJhcnksIHVzZXItZGVmaW5lZCBtZXRhZGF0YSBvbiB0aGlzIGNvbXBvbmVudC5cblxuICAgICAgICAgQHByb3BlcnR5IG1ldGFkYXRhXG4gICAgICAgICBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0YSA9IGNmZy5tZXRhIHx8IHt9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoaXMgQ29tcG9uZW50LCB1bmlxdWUgd2l0aGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb21wb25lbnRzIGFyZSBtYXBwZWQgYnkgdGhpcyBJRCBpbiB7QGxpbmsgU2NlbmUjY29tcG9uZW50c30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfE51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBjZmcuaWQ7IC8vIEF1dG8tZ2VuZXJhdGVkIGJ5IFNjZW5lIGJ5IGRlZmF1bHRcblxuICAgICAgICAvKipcbiAgICAgICAgIFRydWUgYXMgc29vbiBhcyB0aGlzIENvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWRcblxuICAgICAgICAgQHByb3BlcnR5IGRlc3Ryb3llZFxuICAgICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkID0ge307IC8vIEF0dGFjaGVkIGNvbXBvbmVudHMgd2l0aCBuYW1lcy5cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMgPSBudWxsOyAvLyBBdHRhY2hlZCBjb21wb25lbnRzIGtleWVkIHRvIElEcyAtIGxhenktaW5zdGFudGlhdGVkXG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDsgLy8gU3Vic2NyaXB0aW9uIHN1YklkIHBvb2xcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsOyAvLyBTdWJzY3JpcHRpb24gc3ViSWRzIG1hcHBlZCB0byBldmVudCBuYW1lc1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsOyAvLyBFdmVudCBuYW1lcyBtYXBwZWQgdG8gc3Vic2NyaWJlcnNcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDsgLy8gTWFwcyBuYW1lcyB0byBldmVudHNcbiAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGggPSAwOyAvLyBIZWxwcyB1cyBjYXRjaCBzdGFjayBvdmVyZmxvd3MgZnJvbSByZWN1cnNpdmUgZXZlbnRzXG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7IC8vIC8vIENvbXBvbmVudHMgY3JlYXRlZCB3aXRoICNjcmVhdGUgLSBsYXp5LWluc3RhbnRpYXRlZFxuXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnNjZW5lKSB7IC8vIERvbid0IGFkZCBzY2VuZSB0byBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX2FkZENvbXBvbmVudCh0aGlzKTsgLy8gQXNzaWducyB0aGlzIGNvbXBvbmVudCBhbiBhdXRvbWF0aWMgSUQgaWYgbm90IHlldCBhc3NpZ25lZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7IC8vIFRydWUgd2hlbiAjX3VwZGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiBuZXh0IHRpY2tcblxuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICAgIG93bmVyLl9vd24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgQ29tcG9uZW50IHdpdGhpbiBpdHMge0BsaW5rIFNjZW5lfS5cbiAgICAvLyAgKlxuICAgIC8vICAqIEBwcm9wZXJ0eVxuICAgIC8vICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgLy8gICovXG4gICAgLy8gZ2V0IGlkKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmVkcmF3IHRoZSBzY2VuZS5cblxuICAgICBUaGlzIGlzIGNhbGxlZCBieSBjZXJ0YWluIHN1YmNsYXNzZXMgYWZ0ZXIgdGhleSBoYXZlIG1hZGUgc29tZSBzb3J0IG9mIHN0YXRlIHVwZGF0ZSB0aGF0IHJlcXVpcmVzIHRoZVxuICAgICByZW5kZXJlciB0byBwZXJmb3JtIGEgcmVkcmF3LlxuXG4gICAgIEZvciBleGFtcGxlOiBhIHtAbGluayBNZXNofSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIGl0c1xuICAgICB7QGxpbmsgTWVzaCNsYXllcn0gcHJvcGVydHksIHdoaWNoIG1hbnVhbGx5IGNvbnRyb2xzIGl0cyByZW5kZXIgb3JkZXIgaW5cbiAgICAgcmVsYXRpb24gdG8gb3RoZXIgTWVzaGVzLlxuXG4gICAgIElmIHRoaXMgY29tcG9uZW50IGhhcyBhIGBgYGBjYXN0c1NoYWRvd2BgYGAgcHJvcGVydHkgdGhhdCdzIHNldCBgYGBgdHJ1ZWBgYGAsIHRoZW4gdGhpcyB3aWxsIGFsc28gaW5kaWNhdGVcbiAgICAgdGhhdCB0aGUgcmVuZGVyZXIgbmVlZHMgdG8gcmVkcmF3IHNoYWRvdyBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LiBDb21wb25lbnRzIGxpa2VcbiAgICAge0BsaW5rIERpckxpZ2h0fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBwcm9kdWNlIGxpZ2h0IHRoYXQgY3JlYXRlcyBzaGFkb3dzLCB3aGlsZVxuICAgICBjb21wb25lbnRzIGxpa2Uge0BsaW5rIE1lc2hcIn19bGF5ZXJ7ey9jcm9zc0xpbmt9fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBjYXN0IHNoYWRvd3MuXG5cbiAgICAgQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdsUmVkcmF3KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbWFnZURpcnR5KCk7XG4gICAgICAgIGlmICh0aGlzLmNhc3RzU2hhZG93KSB7IC8vIExpZ2h0IHNvdXJjZSBvciBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNoYWRvd3NEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmUtc29ydCB0aGUgcmVuZGVyZXIncyBzdGF0ZS1vcmRlcmVkIGRyYXdhYmxlcyBsaXN0LlxuXG4gICAgIEZvciBlZmZpY2llbmN5LCB0aGUgcmVuZGVyZXIga2VlcHMgaXRzIGxpc3Qgb2YgZHJhd2FibGVzIG9yZGVyZWQgc28gdGhhdCBydW5zIG9mIHRoZSBzYW1lIHN0YXRlIHVwZGF0ZXMgY2FuIGJlXG4gICAgIGNvbWJpbmVkLiAgVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGNlcnRhaW4gc3ViY2xhc3NlcyBhZnRlciB0aGV5IGhhdmUgbWFkZSBzb21lIHNvcnQgb2Ygc3RhdGUgdXBkYXRlIHRoYXQgd291bGRcbiAgICAgcmVxdWlyZSByZS1vcmRlcmluZyBvZiB0aGUgZHJhd2FibGVzIGxpc3QuXG5cbiAgICAgRm9yIGV4YW1wbGU6IGEge0BsaW5rIERpckxpZ2h0fSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIHtAbGluayBEaXJMaWdodCNkaXJ9LlxuXG4gICAgIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnbFJlc29ydCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIubmVlZFN0YXRlU29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQ29tcG9uZW50fSB0aGF0IG93bnMgdGhlIGxpZmVjeWNsZSBvZiB0aGlzIENvbXBvbmVudCwgaWYgYW55LlxuICAgICAqXG4gICAgICogV2hlbiB0aGF0IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQsIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgYWxzby5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgbnVsbCBpZiB0aGlzIENvbXBvbmVudCBoYXMgbm8gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3duZXJcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBvd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX293bmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgY29tcG9uZW50IGlzIG9mIHRoZSBnaXZlbiB0eXBlLCBvciBpcyBhIHN1YmNsYXNzIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBOb3RpZmllcyBleGlzdGluZyBzdWJzY3JpYmVycyB0byB0aGUgZXZlbnQsIG9wdGlvbmFsbHkgcmV0YWlucyB0aGUgZXZlbnQgdG8gZ2l2ZSB0b1xuICAgICAqIGFueSBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMgb24gdGhlIGV2ZW50IGFzIHRoZXkgYXJlIG1hZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmdldD1mYWxzZV0gV2hlbiB0cnVlLCBkb2VzIG5vdCByZXRhaW4gZm9yIHN1YnNlcXVlbnQgc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50LCB2YWx1ZSwgZm9yZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNOdW0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yZ2V0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdmFsdWUgfHwgdHJ1ZTsgLy8gU2F2ZSBub3RpZmljYXRpb25cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgbGV0IHN1YjtcbiAgICAgICAgaWYgKHN1YnMpIHsgLy8gTm90aWZ5IHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViSWQgaW4gc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzLmhhc093blByb3BlcnR5KHN1YklkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWJzW3N1YklkXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbERlcHRoIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2suY2FsbChzdWIuc2NvcGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJmaXJlOiBwb3RlbnRpYWwgc3RhY2sgb3ZlcmZsb3cgZnJvbSByZWN1cnNpdmUgZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgLSBkcm9wcGluZyB0aGlzIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Q2FsbERlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBhbiBldmVudCBvbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBiZSBjYWxsZWQgd2l0aCB0aGlzIGNvbXBvbmVudCBhcyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgZmlyZWQgb24gdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBIYW5kbGUgdG8gdGhlIHN1YnNjcmlwdGlvbiwgd2hpY2ggbWF5IGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgd2l0aCB7QGxpbmsgI29mZn0uXG4gICAgICovXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZE1hcCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRNYXAgPSBuZXcgTWFwKCk7IC8vIFN1YnNjcmlwdGlvbiBzdWJJZCBwb29sXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudFN1YnNOdW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFzdWJzKSB7XG4gICAgICAgICAgICBzdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNbZXZlbnRdID0gc3VicztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRNYXAuYWRkSXRlbSgpOyAvLyBDcmVhdGUgdW5pcXVlIHN1YklkXG4gICAgICAgIHN1YnNbc3ViSWRdID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlIHx8IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgLy8gQSBwdWJsaWNhdGlvbiBleGlzdHMsIG5vdGlmeSBjYWxsYmFjayBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSB8fCB0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uIHRoYXQgd2FzIHByZXZpb3VzbHkgbWFkZSB3aXRoIHtAbGluayBDb21wb25lbnQjb259IG9yIHtAbGluayBDb21wb25lbnQjb25jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViSWQgU3Vic2NyaXB0aW9uIElEXG4gICAgICovXG4gICAgb2ZmKHN1YklkKSB7XG4gICAgICAgIGlmIChzdWJJZCA9PT0gdW5kZWZpbmVkIHx8IHN1YklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdO1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZEV2ZW50c1tzdWJJZF07XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNbc3ViSWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YklkTWFwLnJlbW92ZUl0ZW0oc3ViSWQpOyAvLyBSZWxlYXNlIHN1YklkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGV2ZW50LCB0aGVuIHVuLXN1YnNjcmliZXMgYXMgc29vbiBhcyB0aGUgZXZlbnQgaXMgc3ViSWRkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvbn0sIGFuZCB0aGVuIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvZmZ9IGluc2lkZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRGF0YSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBmcmVzaCBkYXRhIGlzIGF2YWlsYWJsZSBhdCB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlPXRoaXNdIFNjb3BlIGZvciB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvbmNlKGV2ZW50LCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5vbihldmVudCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub2ZmKHN1YklkKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlIHx8IHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY29wZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgc3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIGV2ZW50IG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIGFueSBzdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgaGFzU3VicyhldmVudCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2V2ZW50U3Vic051bSAmJiAodGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSA+IDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY29uc29sZSBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbTE9HXSBbPGNvbXBvbmVudCB0eXBlPiA8Y29tcG9uZW50IGlkPjogPG1lc3NhZ2U+YGBgYCpcbiAgICAgKlxuICAgICAqIEFsc28gZmlyZXMgdGhlIG1lc3NhZ2UgYXMgYSBcImxvZ1wiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIltMT0ddXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcImxvZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBfbWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBcIiBbXCIgKyB0aGlzLnR5cGUgKyBcIiBcIiArIHV0aWxzLmluUXVvdGVzKHRoaXMuaWQpICsgXCJdOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIHdhcm5pbmcgZm9yIHRoaXMgY29tcG9uZW50IHRvIHRoZSBKYXZhU2NyaXB0IGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbV0FSTl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhIFwid2FyblwiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbV0FSTl1cIiArIHRoaXMuX21lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcIndhcm5cIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcnJvciBmb3IgdGhpcyBjb21wb25lbnQgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZS5cbiAgICAgKlxuICAgICAqIFRoZSBjb25zb2xlIG1lc3NhZ2Ugd2lsbCBoYXZlIHRoaXMgZm9ybWF0OiAqYGBgYFtFUlJPUl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhbiBcImVycm9yXCIgZXZlbnQgb24gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbRVJST1JdXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zY2VuZS5maXJlKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGlzLlxuICAgICAqXG4gICAgICogV2hlbiBjb21wb25lbnQgbm90IGdpdmVuLCBhdHRhY2hlcyB0aGUgc2NlbmUncyBkZWZhdWx0IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbmFtZSAoaWYgYW55KS5cbiAgICAgKiBQdWJsaXNoZXMgdGhlIG5ldyBjaGlsZCBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnQsIGtleWVkIHRvIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gW3BhcmFtcy5jb21wb25lbnRdIFRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy50eXBlXSBPcHRpb25hbCBleHBlY3RlZCB0eXBlIG9mIGJhc2UgdHlwZSBvZiB0aGUgY2hpbGQ7IHdoZW4gc3VwcGxpZWQsIHdpbGxcbiAgICAgKiBjYXVzZSBhbiBleGNlcHRpb24gaWYgdGhlIGdpdmVuIGNoaWxkIGlzIG5vdCB0aGUgc2FtZSB0eXBlIG9yIGEgc3VidHlwZSBvZiB0aGlzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5zY2VuZURlZmF1bHQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNjZW5lU2luZ2xldG9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZF0gT3B0aW9uYWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gY29tcG9uZW50IGF0dGFjaGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkF0dGFjaGVkLmNhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZC5zY29wZV0gT3B0aW9uYWwgc2NvcGUgZm9yIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkXSBPcHRpb25hbCBjYWxsYmFjayBjYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgZGV0YWNoZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1zLm9uRGV0YWNoZWQuY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkLnNjb3BlXSBPcHRpb25hbCBzY29wZSBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3tTdHJpbmc6RnVuY3Rpb259fSBbcGFyYW1zLm9uXSBDYWxsYmFja3MgdG8gc3Vic2NyaWJlIHRvIHByb3BlcnRpZXMgb24gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnJlY29tcGlsZXM9dHJ1ZV0gV2hlbiB0cnVlLCBmaXJlcyBcImRpcnR5XCIgZXZlbnRzIG9uIHRoaXMgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoKHBhcmFtcykge1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcblxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgJ25hbWUnIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHBhcmFtcy5jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IHNjZW5lRGVmYXVsdCA9IHBhcmFtcy5zY2VuZURlZmF1bHQ7XG4gICAgICAgIGNvbnN0IHNjZW5lU2luZ2xldG9uID0gcGFyYW1zLnNjZW5lU2luZ2xldG9uO1xuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGNvbnN0IG9uID0gcGFyYW1zLm9uO1xuICAgICAgICBjb25zdCByZWNvbXBpbGVzID0gcGFyYW1zLnJlY29tcGlsZXMgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vIFRydWUgd2hlbiBjaGlsZCBnaXZlbiBhcyBjb25maWcgb2JqZWN0LCB3aGVyZSBwYXJlbnQgbWFuYWdlcyBpdHMgaW5zdGFudGlhdGlvbiBhbmQgZGVzdHJ1Y3Rpb25cbiAgICAgICAgbGV0IG1hbmFnaW5nTGlmZWN5Y2xlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1lcmljKGNvbXBvbmVudCkgfHwgdXRpbHMuaXNTdHJpbmcoY29tcG9uZW50KSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50IElEIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gQm90aCBudW1lcmljIGFuZCBzdHJpbmcgSURzIGFyZSBzdXBwb3J0ZWRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5zY2VuZS5jb21wb25lbnRzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUXVvdGUgc3RyaW5nIElEcyBpbiBlcnJvcnNcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29tcG9uZW50IG5vdCBmb3VuZDogXCIgKyB1dGlscy5pblF1b3RlcyhpZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKHNjZW5lU2luZ2xldG9uID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCB0eXBlIHdlIGZpbmRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuc2NlbmUudHlwZXNbdHlwZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZDIgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGluc3RhbmNlc1tpZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiU2NlbmUgaGFzIG5vIGRlZmF1bHQgY29tcG9uZW50IGZvciAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmVEZWZhdWx0ID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBhIGRlZmF1bHQgc2NlbmUgY29tcG9uZW50XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlNjZW5lIGhhcyBubyBkZWZhdWx0IGNvbXBvbmVudCBmb3IgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIk5vdCBpbiBzYW1lIHNjZW5lOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5pc1R5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgXCIgKyB0eXBlICsgXCIgdHlwZSBvciBzdWJ0eXBlOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRDb21wb25lbnQgPSB0aGlzLl9hdHRhY2hlZFtuYW1lXTtcbiAgICAgICAgbGV0IHN1YnM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmIChvbGRDb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBvbGRDb21wb25lbnQuaWQgPT09IGNvbXBvbmVudC5pZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGF0dGVtcHQgdG8gcmVhdHRhY2ggc2FtZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dGFjaG1lbnQgPSB0aGlzLl9hdHRhY2htZW50c1tvbGRDb21wb25lbnQuaWRdO1xuXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIGV2ZW50cyBvbiBvbGQgY29tcG9uZW50XG5cbiAgICAgICAgICAgIHN1YnMgPSBvbGRBdHRhY2htZW50LnN1YnM7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN1YnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQub2ZmKHN1YnNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNoZWRbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNobWVudHNbb2xkQ29tcG9uZW50LmlkXTtcblxuICAgICAgICAgICAgY29uc3Qgb25EZXRhY2hlZCA9IG9sZEF0dGFjaG1lbnQucGFyYW1zLm9uRGV0YWNoZWQ7XG4gICAgICAgICAgICBpZiAob25EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9uRGV0YWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGV0YWNoZWQob2xkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbkRldGFjaGVkLnNjb3BlID8gb25EZXRhY2hlZC5jYWxsYmFjay5jYWxsKG9uRGV0YWNoZWQuc2NvcGUsIG9sZENvbXBvbmVudCkgOiBvbkRldGFjaGVkLmNhbGxiYWNrKG9sZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2xkQXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGp1c3QgdW5zdWJzY3JpYmVkIGZyb20gYWxsIGV2ZW50cyBmaXJlZCBieSB0aGUgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQsIHNvIGRlc3Ryb3lpbmcgaXQgd29uJ3QgZmlyZSBldmVudHMgYmFjayBhdCB1cyBub3cuXG5cbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICAvLyBTZXQgYW5kIHB1Ymxpc2ggdGhlIG5ldyBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnRcblxuICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdWJzOiBbXSxcbiAgICAgICAgICAgICAgICBtYW5hZ2luZ0xpZmVjeWNsZTogbWFuYWdpbmdMaWZlY3ljbGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbmNlKFwiZGVzdHJveWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucGFyYW1zLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2goYXR0YWNobWVudC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzKSk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvbXBpbGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5zdWJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbihcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFtuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzW2NvbXBvbmVudC5pZF0gPSBhdHRhY2htZW50O1xuXG4gICAgICAgICAgICAvLyBCaW5kIGRlc3RydWN0IGxpc3RlbmVyIHRvIG5ldyBjb21wb25lbnQgdG8gcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBmcm9tIHRoaXMgY29tcG9uZW50IHdoZW4gZGVzdHJveWVkXG5cbiAgICAgICAgICAgIGNvbnN0IG9uQXR0YWNoZWQgPSBwYXJhbXMub25BdHRhY2hlZDtcbiAgICAgICAgICAgIGlmIChvbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob25BdHRhY2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25BdHRhY2hlZChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQXR0YWNoZWQuc2NvcGUgPyBvbkF0dGFjaGVkLmNhbGxiYWNrLmNhbGwob25BdHRhY2hlZC5zY29wZSwgY29tcG9uZW50KSA6IG9uQXR0YWNoZWQuY2FsbGJhY2soY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCBzdWJJZHI7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGxldCBzY29wZTtcblxuICAgICAgICAgICAgICAgIGZvciAoZXZlbnQgaW4gb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJJZHIgPSBvbltldmVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHN1YklkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHN1YklkcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc3ViSWRyLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc3ViSWRyLnNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKGNvbXBvbmVudC5vbihldmVudCwgY2FsbGJhY2ssIHNjb3BlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb21waWxlcykge1xuICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7IC8vIEZJWE1FOiBNYXkgdHJpZ2dlciBzcHVyb3VzIG1lc2ggcmVjb21waWxhdGlvbnMgdW5sZXNzIGFibGUgdG8gbGltaXQgd2l0aCBwYXJhbT9cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZShuYW1lLCBjb21wb25lbnQpOyAvLyBDb21wb25lbnQgY2FuIGJlIG51bGxcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIF9jaGVja0NvbXBvbmVudChleHBlY3RlZFR5cGUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzSUQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuc2NlbmUuY29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbXBvbmVudCBub3QgZm91bmQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBDb21wb25lbnQgb3IgSURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGNvbXBvbmVudC50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBcIiArIGV4cGVjdGVkVHlwZSArIFwiIENvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgX2NoZWNrQ29tcG9uZW50MihleHBlY3RlZFR5cGVzLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0lEKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lLmNvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgbm90IGZvdW5kOiBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgQ29tcG9uZW50IG9yIElEXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlc1tpXSA9PT0gY29tcG9uZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBjb21wb25lbnQgdHlwZXM6IFwiICsgZXhwZWN0ZWRUeXBlcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9vd24oY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX293bmVkQ29tcG9uZW50c1tjb21wb25lbnQuaWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHNbY29tcG9uZW50LmlkXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnQub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2NvbXBvbmVudC5pZF07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3RlY3RlZCBtZXRob2QsIGNhbGxlZCBieSBzdWItY2xhc3NlcyB0byBxdWV1ZSBhIGNhbGwgdG8gX3VwZGF0ZSgpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5PTFdXG4gICAgICovXG4gICAgX25lZWRVcGRhdGUocHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1VwZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3JlLnNjaGVkdWxlVGFzayh0aGlzLl9kb1VwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kb1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm90ZWN0ZWQgdmlydHVhbCB0ZW1wbGF0ZSBtZXRob2QsIG9wdGlvbmFsbHkgaW1wbGVtZW50ZWRcbiAgICAgKiBieSBzdWItY2xhc3NlcyB0byBwZXJmb3JtIGEgc2NoZWR1bGVkIHRhc2suXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbGwge0BsaW5rIENvbXBvbmVudH1zIHRoYXQgYXJlIG93bmVkIGJ5IHRoaXMuIFRoZXNlIGFyZSBDb21wb25lbnRzIHRoYXQgd2VyZSBpbnN0YW50aWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgQ29tcG9uZW50IGFzIHRoZWlyIGZpcnN0IGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9vd25lZENvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBDb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBAZXZlbnQgZGVzdHJveWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoXCJkZXN0cm95ZWRcIiwgdGhpcy5kZXN0cm95ZWQgPSB0cnVlKTsgLy8gTXVzdCBmaXJlIGJlZm9yZSB3ZSBibG93IGF3YXkgc3Vic2NyaXB0aW9uIG1hcHMsIGJlbG93XG5cbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBjaGlsZCBjb21wb25lbnRzIGFuZCBkZXN0cm95IHRoZW5cblxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGxldCBhdHRhY2htZW50O1xuICAgICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgICBsZXQgc3VicztcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5fYXR0YWNobWVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBhdHRhY2htZW50LmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgc3VicyA9IGF0dGFjaG1lbnQuc3VicztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm9mZihzdWJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoaWQgaW4gdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVkQ29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX293bmVkQ29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS5fcmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xuXG4gICAgICAgIC8vIE1lbW9yeSBsZWFrIGF2b2lkYW5jZVxuICAgICAgICB0aGlzLl9hdHRhY2hlZCA9IHt9O1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudENhbGxEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHtDb21wb25lbnR9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js":
/*!******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js ***!
  \******************************************************************/
/*! exports provided: core */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony import */ var _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/Queue.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n\n\n\n\n\nconst scenesRenderInfo = {}; // Used for throttling FPS for each Scene\nconst sceneIDMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__[\"Map\"](); // Ensures unique scene IDs\nconst taskQueue = new _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__[\"Queue\"](); // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule\nconst tickEvent = {sceneId: null, time: null, startTime: null, prevTime: null, deltaTime: null};\nconst taskBudget = 10; // Millisecs we're allowed to spend on tasks in each frame\nconst fpsSamples = [];\nconst numFPSSamples = 30;\n\nlet defaultScene = null;// Default singleton Scene, lazy-initialized in getter\nlet lastTime = 0;\nlet elapsedTime;\nlet totalFPS = 0;\n\n/**\n * @private\n */\nfunction Core() {\n\n    /**\n     Semantic version number. The value for this is set by an expression that's concatenated to\n     the end of the built binary by the xeokit build script.\n     @property version\n     @namespace xeokit\n     @type {String}\n     */\n    this.version = \"1.0.0\";\n\n    /**\n     Existing {@link Scene}s , mapped to their IDs\n     @property scenes\n     @namespace xeokit\n     @type {{Scene}}\n     */\n    this.scenes = {};\n\n    this._superTypes = {}; // For each component type, a list of its supertypes, ordered upwards in the hierarchy.\n\n    /**\n     * Registers a scene on xeokit.\n     * This is called within the xeokit.Scene constructor.\n     * @private\n     */\n    this._addScene = function (scene) {\n        if (scene.id) { // User-supplied ID\n            if (core.scenes[scene.id]) {\n                console.error(`[ERROR] Scene ${_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"utils\"].inQuotes(scene.id)} already exists`);\n                return;\n            }\n        } else { // Auto-generated ID\n            scene.id = sceneIDMap.addItem({});\n        }\n        core.scenes[scene.id] = scene;\n        const ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n        const ticksPerRender = scene.ticksPerRender;\n        scenesRenderInfo[scene.id] = {\n            ticksPerOcclusionTest: ticksPerOcclusionTest,\n            ticksPerRender: ticksPerRender,\n            renderCountdown: ticksPerRender\n        };\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes++;\n        scene.once(\"destroyed\", () => { // Unregister destroyed scenes\n            sceneIDMap.removeItem(scene.id);\n            delete core.scenes[scene.id];\n            delete scenesRenderInfo[scene.id];\n            _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes--;\n        });\n    };\n\n    /**\n     * @private\n     */\n    this.clear = function () {\n        let scene;\n        for (const id in core.scenes) {\n            if (core.scenes.hasOwnProperty(id)) {\n                scene = core.scenes[id];\n                // Only clear the default Scene\n                // but destroy all the others\n                if (id === \"default.scene\") {\n                    scene.clear();\n                } else {\n                    scene.destroy();\n                    delete core.scenes[scene.id];\n                }\n            }\n        }\n    };\n\n    /**\n     * Schedule a task to run at the next frame.\n     *\n     * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeokit processes the queue\n     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not\n     * get a chance to run during the task are left in the queue to be run next time.\n     *\n     * @param {Function} callback Callback that runs the task.\n     * @param {Object} [scope] Scope for the callback.\n     */\n    this.scheduleTask = function (callback, scope) {\n        taskQueue.push(callback);\n        taskQueue.push(scope);\n    };\n\n    this.runTasks = function (until = -1) { // Pops and processes tasks in the queue, until the given number of milliseconds has elapsed.\n        let time = (new Date()).getTime();\n        let callback;\n        let scope;\n        let tasksRun = 0;\n        while (taskQueue.length > 0 && (until < 0 || time < until)) {\n            callback = taskQueue.shift();\n            scope = taskQueue.shift();\n            if (scope) {\n                callback.call(scope);\n            } else {\n                callback();\n            }\n            time = (new Date()).getTime();\n            tasksRun++;\n        }\n        return tasksRun;\n    };\n\n    this.getNumTasks = function () {\n        return taskQueue.length;\n    };\n}\n\n/**\n * @private\n * @type {Core}\n */\nconst core = new Core();\n\n\nconst frame = function () {\n    let time = Date.now();\n    if (lastTime > 0) { // Log FPS stats\n        elapsedTime = time - lastTime;\n        var newFPS = 1000 / elapsedTime; // Moving average of FPS\n        totalFPS += newFPS;\n        fpsSamples.push(newFPS);\n        if (fpsSamples.length >= numFPSSamples) {\n            totalFPS -= fpsSamples.shift();\n        }\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.fps = Math.round(totalFPS / fpsSamples.length);\n    }\n    runTasks(time);\n    fireTickEvents(time);\n    renderScenes();\n    lastTime = time;\n    window.requestAnimationFrame(frame);\n};\n\nfunction runTasks(time) { // Process as many enqueued tasks as we can within the per-frame task budget\n    const tasksRun = core.runTasks(time + taskBudget);\n    const tasksScheduled = core.getNumTasks();\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksRun = tasksRun;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksScheduled = tasksScheduled;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksBudget = taskBudget;\n}\n\nfunction fireTickEvents(time) { // Fire tick event on each Scene\n    tickEvent.time = time;\n    for (var id in core.scenes) {\n        if (core.scenes.hasOwnProperty(id)) {\n            var scene = core.scenes[id];\n            tickEvent.sceneId = id;\n            tickEvent.startTime = scene.startTime;\n            tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;\n            /**\n             * Fired on each game loop iteration.\n             *\n             * @event tick\n             * @param {String} sceneID The ID of this Scene.\n             * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.\n             * @param {Number} time The time in seconds since 1970 of this \"tick\" event.\n             * @param {Number} prevTime The time of the previous \"tick\" event from this Scene.\n             * @param {Number} deltaTime The time in seconds since the previous \"tick\" event from this Scene.\n             */\n            scene.fire(\"tick\", tickEvent, true);\n        }\n    }\n    tickEvent.prevTime = time;\n}\n\nfunction renderScenes() {\n    const scenes = core.scenes;\n    const forceRender = false;\n    let scene;\n    let renderInfo;\n    let ticksPerOcclusionTest;\n    let ticksPerRender;\n    let id;\n    for (id in scenes) {\n        if (scenes.hasOwnProperty(id)) {\n\n            scene = scenes[id];\n            renderInfo = scenesRenderInfo[id];\n\n            if (!renderInfo) {\n                renderInfo = scenesRenderInfo[id] = {}; // FIXME\n            }\n\n            ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n            if (renderInfo.ticksPerOcclusionTest !== ticksPerOcclusionTest) {\n                renderInfo.ticksPerOcclusionTest = ticksPerOcclusionTest;\n                renderInfo.renderCountdown = ticksPerOcclusionTest;\n            }\n            if (--scene.occlusionTestCountdown <= 0) {\n                scene.doOcclusionTest();\n                scene.occlusionTestCountdown = ticksPerOcclusionTest;\n            }\n\n            ticksPerRender = scene.ticksPerRender;\n            if (renderInfo.ticksPerRender !== ticksPerRender) {\n                renderInfo.ticksPerRender = ticksPerRender;\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n            if (--renderInfo.renderCountdown === 0) {\n                scene.render(forceRender);\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n        }\n    }\n}\n\nwindow.requestAnimationFrame(frame);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL2NvcmUuanM/MzFjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDSjtBQUNGO0FBQ0E7O0FBRWpDLDRCQUE0QjtBQUM1Qix1QkFBdUIsaURBQUcsR0FBRztBQUM3QixzQkFBc0IscURBQUssR0FBRyw4Q0FBOEM7QUFDNUUsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLCtDQUErQywrQ0FBSyxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFLO0FBQ2pCLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLCtDQUFLO0FBQ1QsSUFBSSwrQ0FBSztBQUNULElBQUksK0NBQUs7QUFDVDs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UXVldWV9IGZyb20gJy4vdXRpbHMvUXVldWUuanMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4vdXRpbHMvTWFwLmpzJztcbmltcG9ydCB7c3RhdHN9IGZyb20gJy4vc3RhdHMuanMnO1xuaW1wb3J0IHt1dGlsc30gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHNjZW5lc1JlbmRlckluZm8gPSB7fTsgLy8gVXNlZCBmb3IgdGhyb3R0bGluZyBGUFMgZm9yIGVhY2ggU2NlbmVcbmNvbnN0IHNjZW5lSURNYXAgPSBuZXcgTWFwKCk7IC8vIEVuc3VyZXMgdW5pcXVlIHNjZW5lIElEc1xuY29uc3QgdGFza1F1ZXVlID0gbmV3IFF1ZXVlKCk7IC8vIFRhc2sgcXVldWUsIHdoaWNoIGlzIHB1bXBlZCBvbiBlYWNoIGZyYW1lOyB0YXNrcyBhcmUgcHVzaGVkIHRvIGl0IHdpdGggY2FsbHMgdG8geGVva2l0LnNjaGVkdWxlXG5jb25zdCB0aWNrRXZlbnQgPSB7c2NlbmVJZDogbnVsbCwgdGltZTogbnVsbCwgc3RhcnRUaW1lOiBudWxsLCBwcmV2VGltZTogbnVsbCwgZGVsdGFUaW1lOiBudWxsfTtcbmNvbnN0IHRhc2tCdWRnZXQgPSAxMDsgLy8gTWlsbGlzZWNzIHdlJ3JlIGFsbG93ZWQgdG8gc3BlbmQgb24gdGFza3MgaW4gZWFjaCBmcmFtZVxuY29uc3QgZnBzU2FtcGxlcyA9IFtdO1xuY29uc3QgbnVtRlBTU2FtcGxlcyA9IDMwO1xuXG5sZXQgZGVmYXVsdFNjZW5lID0gbnVsbDsvLyBEZWZhdWx0IHNpbmdsZXRvbiBTY2VuZSwgbGF6eS1pbml0aWFsaXplZCBpbiBnZXR0ZXJcbmxldCBsYXN0VGltZSA9IDA7XG5sZXQgZWxhcHNlZFRpbWU7XG5sZXQgdG90YWxGUFMgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG5cbiAgICAvKipcbiAgICAgU2VtYW50aWMgdmVyc2lvbiBudW1iZXIuIFRoZSB2YWx1ZSBmb3IgdGhpcyBpcyBzZXQgYnkgYW4gZXhwcmVzc2lvbiB0aGF0J3MgY29uY2F0ZW5hdGVkIHRvXG4gICAgIHRoZSBlbmQgb2YgdGhlIGJ1aWx0IGJpbmFyeSBieSB0aGUgeGVva2l0IGJ1aWxkIHNjcmlwdC5cbiAgICAgQHByb3BlcnR5IHZlcnNpb25cbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSBcIjEuMC4wXCI7XG5cbiAgICAvKipcbiAgICAgRXhpc3Rpbmcge0BsaW5rIFNjZW5lfXMgLCBtYXBwZWQgdG8gdGhlaXIgSURzXG4gICAgIEBwcm9wZXJ0eSBzY2VuZXNcbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge3tTY2VuZX19XG4gICAgICovXG4gICAgdGhpcy5zY2VuZXMgPSB7fTtcblxuICAgIHRoaXMuX3N1cGVyVHlwZXMgPSB7fTsgLy8gRm9yIGVhY2ggY29tcG9uZW50IHR5cGUsIGEgbGlzdCBvZiBpdHMgc3VwZXJ0eXBlcywgb3JkZXJlZCB1cHdhcmRzIGluIHRoZSBoaWVyYXJjaHkuXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzY2VuZSBvbiB4ZW9raXQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2l0aGluIHRoZSB4ZW9raXQuU2NlbmUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hZGRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgICBpZiAoc2NlbmUuaWQpIHsgLy8gVXNlci1zdXBwbGllZCBJRFxuICAgICAgICAgICAgaWYgKGNvcmUuc2NlbmVzW3NjZW5lLmlkXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFUlJPUl0gU2NlbmUgJHt1dGlscy5pblF1b3RlcyhzY2VuZS5pZCl9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBdXRvLWdlbmVyYXRlZCBJRFxuICAgICAgICAgICAgc2NlbmUuaWQgPSBzY2VuZUlETWFwLmFkZEl0ZW0oe30pO1xuICAgICAgICB9XG4gICAgICAgIGNvcmUuc2NlbmVzW3NjZW5lLmlkXSA9IHNjZW5lO1xuICAgICAgICBjb25zdCB0aWNrc1Blck9jY2x1c2lvblRlc3QgPSBzY2VuZS50aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgIGNvbnN0IHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdID0ge1xuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0OiB0aWNrc1Blck9jY2x1c2lvblRlc3QsXG4gICAgICAgICAgICB0aWNrc1BlclJlbmRlcjogdGlja3NQZXJSZW5kZXIsXG4gICAgICAgICAgICByZW5kZXJDb3VudGRvd246IHRpY2tzUGVyUmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRzLmNvbXBvbmVudHMuc2NlbmVzKys7XG4gICAgICAgIHNjZW5lLm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4geyAvLyBVbnJlZ2lzdGVyIGRlc3Ryb3llZCBzY2VuZXNcbiAgICAgICAgICAgIHNjZW5lSURNYXAucmVtb3ZlSXRlbShzY2VuZS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgY29yZS5zY2VuZXNbc2NlbmUuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdO1xuICAgICAgICAgICAgc3RhdHMuY29tcG9uZW50cy5zY2VuZXMtLTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIGNvcmUuc2NlbmVzKSB7XG4gICAgICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICAgICAgLy8gT25seSBjbGVhciB0aGUgZGVmYXVsdCBTY2VuZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBkZXN0cm95IGFsbCB0aGUgb3RoZXJzXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBcImRlZmF1bHQuc2NlbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBzY2VuZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvcmUuc2NlbmVzW3NjZW5lLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSB0YXNrIHRvIHJ1biBhdCB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoaXMgcHVzaGVzIHRoZSB0YXNrIHRvIGEgRklGTyBxdWV1ZS4gV2l0aGluIGVhY2ggZnJhbWUgaW50ZXJ2YWwsIHhlb2tpdCBwcm9jZXNzZXMgdGhlIHF1ZXVlXG4gICAgICogZm9yIGEgY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgcG9wcGluZyB0YXNrcyBhbmQgcnVubmluZyB0aGVtLiBBZnRlciBlYWNoIGZyYW1lIGludGVydmFsLCB0YXNrcyB0aGF0IGRpZCBub3RcbiAgICAgKiBnZXQgYSBjaGFuY2UgdG8gcnVuIGR1cmluZyB0aGUgdGFzayBhcmUgbGVmdCBpbiB0aGUgcXVldWUgdG8gYmUgcnVuIG5leHQgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgcnVucyB0aGUgdGFzay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHRoaXMuc2NoZWR1bGVUYXNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0YXNrUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRhc2tRdWV1ZS5wdXNoKHNjb3BlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5ydW5UYXNrcyA9IGZ1bmN0aW9uICh1bnRpbCA9IC0xKSB7IC8vIFBvcHMgYW5kIHByb2Nlc3NlcyB0YXNrcyBpbiB0aGUgcXVldWUsIHVudGlsIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkLlxuICAgICAgICBsZXQgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgbGV0IHNjb3BlO1xuICAgICAgICBsZXQgdGFza3NSdW4gPSAwO1xuICAgICAgICB3aGlsZSAodGFza1F1ZXVlLmxlbmd0aCA+IDAgJiYgKHVudGlsIDwgMCB8fCB0aW1lIDwgdW50aWwpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2tRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgc2NvcGUgPSB0YXNrUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0YXNrc1J1bisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrc1J1bjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXROdW1UYXNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhc2tRdWV1ZS5sZW5ndGg7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0NvcmV9XG4gKi9cbmNvbnN0IGNvcmUgPSBuZXcgQ29yZSgpO1xuXG5cbmNvbnN0IGZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobGFzdFRpbWUgPiAwKSB7IC8vIExvZyBGUFMgc3RhdHNcbiAgICAgICAgZWxhcHNlZFRpbWUgPSB0aW1lIC0gbGFzdFRpbWU7XG4gICAgICAgIHZhciBuZXdGUFMgPSAxMDAwIC8gZWxhcHNlZFRpbWU7IC8vIE1vdmluZyBhdmVyYWdlIG9mIEZQU1xuICAgICAgICB0b3RhbEZQUyArPSBuZXdGUFM7XG4gICAgICAgIGZwc1NhbXBsZXMucHVzaChuZXdGUFMpO1xuICAgICAgICBpZiAoZnBzU2FtcGxlcy5sZW5ndGggPj0gbnVtRlBTU2FtcGxlcykge1xuICAgICAgICAgICAgdG90YWxGUFMgLT0gZnBzU2FtcGxlcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmZyYW1lLmZwcyA9IE1hdGgucm91bmQodG90YWxGUFMgLyBmcHNTYW1wbGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJ1blRhc2tzKHRpbWUpO1xuICAgIGZpcmVUaWNrRXZlbnRzKHRpbWUpO1xuICAgIHJlbmRlclNjZW5lcygpO1xuICAgIGxhc3RUaW1lID0gdGltZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blRhc2tzKHRpbWUpIHsgLy8gUHJvY2VzcyBhcyBtYW55IGVucXVldWVkIHRhc2tzIGFzIHdlIGNhbiB3aXRoaW4gdGhlIHBlci1mcmFtZSB0YXNrIGJ1ZGdldFxuICAgIGNvbnN0IHRhc2tzUnVuID0gY29yZS5ydW5UYXNrcyh0aW1lICsgdGFza0J1ZGdldCk7XG4gICAgY29uc3QgdGFza3NTY2hlZHVsZWQgPSBjb3JlLmdldE51bVRhc2tzKCk7XG4gICAgc3RhdHMuZnJhbWUudGFza3NSdW4gPSB0YXNrc1J1bjtcbiAgICBzdGF0cy5mcmFtZS50YXNrc1NjaGVkdWxlZCA9IHRhc2tzU2NoZWR1bGVkO1xuICAgIHN0YXRzLmZyYW1lLnRhc2tzQnVkZ2V0ID0gdGFza0J1ZGdldDtcbn1cblxuZnVuY3Rpb24gZmlyZVRpY2tFdmVudHModGltZSkgeyAvLyBGaXJlIHRpY2sgZXZlbnQgb24gZWFjaCBTY2VuZVxuICAgIHRpY2tFdmVudC50aW1lID0gdGltZTtcbiAgICBmb3IgKHZhciBpZCBpbiBjb3JlLnNjZW5lcykge1xuICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB2YXIgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICB0aWNrRXZlbnQuc2NlbmVJZCA9IGlkO1xuICAgICAgICAgICAgdGlja0V2ZW50LnN0YXJ0VGltZSA9IHNjZW5lLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRpY2tFdmVudC5kZWx0YVRpbWUgPSB0aWNrRXZlbnQucHJldlRpbWUgIT0gbnVsbCA/IHRpY2tFdmVudC50aW1lIC0gdGlja0V2ZW50LnByZXZUaW1lIDogMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlyZWQgb24gZWFjaCBnYW1lIGxvb3AgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB0aWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2NlbmVJRCBUaGUgSUQgb2YgdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIHRoYXQgdGhpcyBTY2VuZSB3YXMgaW5zdGFudGlhdGVkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIG9mIHRoaXMgXCJ0aWNrXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJldlRpbWUgVGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIFwidGlja1wiIGV2ZW50IGZyb20gdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgcHJldmlvdXMgXCJ0aWNrXCIgZXZlbnQgZnJvbSB0aGlzIFNjZW5lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzY2VuZS5maXJlKFwidGlja1wiLCB0aWNrRXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2tFdmVudC5wcmV2VGltZSA9IHRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNjZW5lcygpIHtcbiAgICBjb25zdCBzY2VuZXMgPSBjb3JlLnNjZW5lcztcbiAgICBjb25zdCBmb3JjZVJlbmRlciA9IGZhbHNlO1xuICAgIGxldCBzY2VuZTtcbiAgICBsZXQgcmVuZGVySW5mbztcbiAgICBsZXQgdGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgIGxldCB0aWNrc1BlclJlbmRlcjtcbiAgICBsZXQgaWQ7XG4gICAgZm9yIChpZCBpbiBzY2VuZXMpIHtcbiAgICAgICAgaWYgKHNjZW5lcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblxuICAgICAgICAgICAgc2NlbmUgPSBzY2VuZXNbaWRdO1xuICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNjZW5lc1JlbmRlckluZm9baWRdO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvID0gc2NlbmVzUmVuZGVySW5mb1tpZF0gPSB7fTsgLy8gRklYTUVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0ID0gc2NlbmUudGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgICAgICAgICAgaWYgKHJlbmRlckluZm8udGlja3NQZXJPY2NsdXNpb25UZXN0ICE9PSB0aWNrc1Blck9jY2x1c2lvblRlc3QpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyT2NjbHVzaW9uVGVzdCA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPD0gMCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLmRvT2NjbHVzaW9uVGVzdCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPSB0aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICBpZiAocmVuZGVySW5mby50aWNrc1BlclJlbmRlciAhPT0gdGlja3NQZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyUmVuZGVyID0gdGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICAgICAgcmVuZGVySW5mby5yZW5kZXJDb3VudGRvd24gPSB0aWNrc1BlclJlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXJlbmRlckluZm8ucmVuZGVyQ291bnRkb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUucmVuZGVyKGZvcmNlUmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyUmVuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcblxuZXhwb3J0IHtjb3JlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/Material.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/Material.js ***!
  \********************************************************************************/
/*! exports provided: Material */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return Material; });\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/**\n * @desc A **Material** defines the surface appearance of attached {@link Mesh}es.\n *\n * Material is the base class for:\n *\n * * {@link MetallicMaterial} - physically-based material for metallic surfaces. Use this one for things made of metal.\n * * {@link SpecularMaterial} - physically-based material for non-metallic (dielectric) surfaces. Use this one for insulators, such as ceramics, plastics, wood etc.\n * * {@link PhongMaterial} - material for classic Blinn-Phong shading. This is less demanding of graphics hardware than the physically-based materials.\n * * {@link LambertMaterial} - material for fast, flat-shaded CAD rendering without textures. Use this for navigating huge CAD or BIM models interactively. This material gives the best rendering performance and uses the least memory.\n * * {@link EmphasisMaterial} - defines the appearance of Meshes when \"xrayed\" or \"highlighted\".\n * * {@link EdgeMaterial} - defines the appearance of Meshes when edges are emphasized.\n *\n * A {@link Scene} is allowed to contain a mixture of these material types.\n *\n */\n\n\n\nclass Material extends _Component_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"] {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"Material\";\n    }\n\n    constructor(owner, cfg={}) {\n        super(owner, cfg);\n        _stats_js__WEBPACK_IMPORTED_MODULE_1__[\"stats\"].memory.materials++;\n    }\n\n    destroy() {\n        super.destroy();\n        _stats_js__WEBPACK_IMPORTED_MODULE_1__[\"stats\"].memory.materials--;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGVyaWFscy9NYXRlcmlhbC5qcz9kZjI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVCQUF1QjtBQUM3QixNQUFNLHVCQUF1QjtBQUM3QixNQUFNLG9CQUFvQjtBQUMxQixNQUFNLHNCQUFzQjtBQUM1QixNQUFNLHVCQUF1QjtBQUM3QixNQUFNLG1CQUFtQjtBQUN6QjtBQUNBLE1BQU0sWUFBWTtBQUNsQjtBQUNBO0FBQzBDO0FBQ1I7O0FBRWxDLHVCQUF1Qix1REFBUzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLFFBQVEsK0NBQUs7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7O0FBRWtCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGVyaWFscy9NYXRlcmlhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGRlc2MgQSAqKk1hdGVyaWFsKiogZGVmaW5lcyB0aGUgc3VyZmFjZSBhcHBlYXJhbmNlIG9mIGF0dGFjaGVkIHtAbGluayBNZXNofWVzLlxuICpcbiAqIE1hdGVyaWFsIGlzIHRoZSBiYXNlIGNsYXNzIGZvcjpcbiAqXG4gKiAqIHtAbGluayBNZXRhbGxpY01hdGVyaWFsfSAtIHBoeXNpY2FsbHktYmFzZWQgbWF0ZXJpYWwgZm9yIG1ldGFsbGljIHN1cmZhY2VzLiBVc2UgdGhpcyBvbmUgZm9yIHRoaW5ncyBtYWRlIG9mIG1ldGFsLlxuICogKiB7QGxpbmsgU3BlY3VsYXJNYXRlcmlhbH0gLSBwaHlzaWNhbGx5LWJhc2VkIG1hdGVyaWFsIGZvciBub24tbWV0YWxsaWMgKGRpZWxlY3RyaWMpIHN1cmZhY2VzLiBVc2UgdGhpcyBvbmUgZm9yIGluc3VsYXRvcnMsIHN1Y2ggYXMgY2VyYW1pY3MsIHBsYXN0aWNzLCB3b29kIGV0Yy5cbiAqICoge0BsaW5rIFBob25nTWF0ZXJpYWx9IC0gbWF0ZXJpYWwgZm9yIGNsYXNzaWMgQmxpbm4tUGhvbmcgc2hhZGluZy4gVGhpcyBpcyBsZXNzIGRlbWFuZGluZyBvZiBncmFwaGljcyBoYXJkd2FyZSB0aGFuIHRoZSBwaHlzaWNhbGx5LWJhc2VkIG1hdGVyaWFscy5cbiAqICoge0BsaW5rIExhbWJlcnRNYXRlcmlhbH0gLSBtYXRlcmlhbCBmb3IgZmFzdCwgZmxhdC1zaGFkZWQgQ0FEIHJlbmRlcmluZyB3aXRob3V0IHRleHR1cmVzLiBVc2UgdGhpcyBmb3IgbmF2aWdhdGluZyBodWdlIENBRCBvciBCSU0gbW9kZWxzIGludGVyYWN0aXZlbHkuIFRoaXMgbWF0ZXJpYWwgZ2l2ZXMgdGhlIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGFuZCB1c2VzIHRoZSBsZWFzdCBtZW1vcnkuXG4gKiAqIHtAbGluayBFbXBoYXNpc01hdGVyaWFsfSAtIGRlZmluZXMgdGhlIGFwcGVhcmFuY2Ugb2YgTWVzaGVzIHdoZW4gXCJ4cmF5ZWRcIiBvciBcImhpZ2hsaWdodGVkXCIuXG4gKiAqIHtAbGluayBFZGdlTWF0ZXJpYWx9IC0gZGVmaW5lcyB0aGUgYXBwZWFyYW5jZSBvZiBNZXNoZXMgd2hlbiBlZGdlcyBhcmUgZW1waGFzaXplZC5cbiAqXG4gKiBBIHtAbGluayBTY2VuZX0gaXMgYWxsb3dlZCB0byBjb250YWluIGEgbWl4dHVyZSBvZiB0aGVzZSBtYXRlcmlhbCB0eXBlcy5cbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICcuLi9Db21wb25lbnQuanMnO1xuaW1wb3J0IHtzdGF0c30gZnJvbSAnLi4vc3RhdHMuanMnO1xuXG5jbGFzcyBNYXRlcmlhbCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTWF0ZXJpYWxcIjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihvd25lciwgY2ZnPXt9KSB7XG4gICAgICAgIHN1cGVyKG93bmVyLCBjZmcpO1xuICAgICAgICBzdGF0cy5tZW1vcnkubWF0ZXJpYWxzKys7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBzdGF0cy5tZW1vcnkubWF0ZXJpYWxzLS07XG4gICAgfVxufVxuXG5leHBvcnQge01hdGVyaWFsfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/Material.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/PhongMaterial.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/PhongMaterial.js ***!
  \*************************************************************************************/
/*! exports provided: PhongMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PhongMaterial\", function() { return PhongMaterial; });\n/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/Material.js\");\n/* harmony import */ var _webgl_RenderState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/RenderState.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n\n\n\n\nconst alphaModes = {\"opaque\": 0, \"mask\": 1, \"blend\": 2};\nconst alphaModeNames = [\"opaque\", \"mask\", \"blend\"];\n\n/**\n * @desc Configures the normal rendered appearance of {@link Mesh}es using the non-physically-correct Blinn-Phong shading model.\n *\n * * Useful for non-realistic objects like gizmos.\n * * {@link SpecularMaterial} is best for insulators, such as wood, ceramics and plastic.\n * * {@link MetallicMaterial} is best for conductive materials, such as metal.\n * * {@link LambertMaterial} is appropriate for high-detail models that need to render as efficiently as possible.\n *\n * ## Usage\n *\n * In the example below, we'll create a {@link Mesh} with a PhongMaterial with a diffuse {@link Texture} and a specular {@link Fresnel}, using a {@link buildTorusGeometry} to create the {@link Geometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#materials_PhongMaterial)]\n *\n *  ```` javascript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {Mesh} from \"../src/scene/mesh/Mesh.js\";\n * import {buildTorusGeometry} from \"../src/scene/geometry/builders/buildTorusGeometry.js\";\n * import {ReadableGeometry} from \"../src/scene/geometry/ReadableGeometry.js\";\n * import {PhongMaterial} from \"../src/scene/materials/PhongMaterial.js\";\n * import {Texture} from \"../src/scene/materials/Texture.js\";\n * import {Fresnel} from \"../src/scene/materials/Fresnel.js\";\n *\n * const viewer = new Viewer({\n *        canvasId: \"myCanvas\"\n *    });\n *\n * viewer.scene.camera.eye = [0, 0, 5];\n * viewer.scene.camera.look = [0, 0, 0];\n * viewer.scene.camera.up = [0, 1, 0];\n *\n * new Mesh(viewer.scene, {\n *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({\n *          center: [0, 0, 0],\n *          radius: 1.5,\n *          tube: 0.5,\n *          radialSegments: 32,\n *          tubeSegments: 24,\n *          arc: Math.PI * 2.0\n *      }),\n *      material: new PhongMaterial(viewer.scene, {\n *          ambient: [0.9, 0.3, 0.9],\n *          shininess: 30,\n *          diffuseMap: new Texture(viewer.scene, {\n *              src: \"textures/diffuse/uvGrid2.jpg\"\n *          }),\n *          specularFresnel: new Fresnel(viewer.scene, {\n *              leftColor: [1.0, 1.0, 1.0],\n *              rightColor: [0.0, 0.0, 0.0],\n *              power: 4\n *          })\n *     })\n * });\n * ````\n *\n * ## PhongMaterial Properties\n *\n *  The following table summarizes PhongMaterial properties:\n *\n * | Property | Type | Range | Default Value | Space | Description |\n * |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|\n * | {@link PhongMaterial#ambient} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |\n * | {@link PhongMaterial#diffuse} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |\n * | {@link PhongMaterial#specular} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular light reflected by the material. |\n * | {@link PhongMaterial#emissive} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |\n * | {@link PhongMaterial#alpha} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |\n * | {@link PhongMaterial#shininess} | Number | [0, 128] | 80 | linear | Determines the size and sharpness of specular highlights. |\n * | {@link PhongMaterial#reflectivity} | Number | [0, 1] | 1 | linear | Determines the amount of reflectivity. |\n * | {@link PhongMaterial#diffuseMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#diffuse}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |\n * | {@link PhongMaterial#specularMap} | {@link Texture} |  | null | sRGB | Texture RGB components multiplying by {@link PhongMaterial#specular}. If the fourth component (A) is present, it multiplies by {@link PhongMaterial#alpha}. |\n * | {@link PhongMaterial#emissiveMap} | {@link Texture} |  | null | linear | Texture with RGB components multiplying by {@link PhongMaterial#emissive}. |\n * | {@link PhongMaterial#alphaMap} | {@link Texture} |  | null | linear | Texture with first component multiplying by {@link PhongMaterial#alpha}. |\n * | {@link PhongMaterial#occlusionMap} | {@link Texture} |  | null | linear | Ambient occlusion texture multiplying by {@link PhongMaterial#ambient}, {@link PhongMaterial#diffuse} and {@link PhongMaterial#specular}. |\n * | {@link PhongMaterial#normalMap} | {@link Texture} |  | null | linear | Tangent-space normal map. |\n * | {@link PhongMaterial#diffuseFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#diffuse}. |\n * | {@link PhongMaterial#specularFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#specular}. |\n * | {@link PhongMaterial#emissiveFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#emissive}. |\n * | {@link PhongMaterial#reflectivityFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#reflectivity}. |\n * | {@link PhongMaterial#alphaFresnel} | {@link Fresnel} |  | null |  | Fresnel term applied to {@link PhongMaterial#alpha}. |\n * | {@link PhongMaterial#lineWidth} | Number | [0..100] | 1 |  | Line width in pixels. |\n * | {@link PhongMaterial#pointSize} | Number | [0..100] | 1 |  | Point size in pixels. |\n * | {@link PhongMaterial#alphaMode} | String | \"opaque\", \"blend\", \"mask\" | \"blend\" |  | Alpha blend mode. |\n * | {@link PhongMaterial#alphaCutoff} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |\n * | {@link PhongMaterial#backfaces} | Boolean |  | false |  | Whether to render geometry backfaces. |\n * | {@link PhongMaterial#frontface} | String | \"ccw\", \"cw\" | \"ccw\" |  | The winding order for geometry frontfaces - \"cw\" for clockwise, or \"ccw\" for counter-clockwise. |\n */\nclass PhongMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__[\"Material\"] {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"PhongMaterial\";\n    }\n\n    /**\n     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.\n     * @param {*} [cfg] The PhongMaterial configuration\n     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.\n     * @param {Number[]} [cfg.ambient=[1.0, 1.0, 1.0 ]]  PhongMaterial ambient color.\n     * @param {Number[]} [cfg.diffuse=[ 1.0, 1.0, 1.0 ]] PhongMaterial diffuse color.\n     * @param {Number[]} [cfg.specular=[ 1.0, 1.0, 1.0 ]]  PhongMaterial specular color.\n     * @param {Number[]} [cfg.emissive=[ 0.0, 0.0, 0.0 ]] PhongMaterial emissive color.\n     * @param {Number} [cfg.alpha=1] Scalar in range 0-1 that controls alpha, where 0 is completely transparent and 1 is completely opaque.\n     * @param {Number} [cfg.shininess=80] Scalar in range 0-128 that determines the size and sharpness of specular highlights.\n     * @param {Number} [cfg.reflectivity=1] Scalar in range 0-1 that controls how much {@link ReflectionMap} is reflected.\n     * @param {Number} [cfg.lineWidth=1] Scalar that controls the width of lines.\n     * @param {Number} [cfg.pointSize=1] Scalar that controls the size of points.\n     * @param {Texture} [cfg.ambientMap=null] A ambient map {@link Texture}, which will multiply by the diffuse property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.diffuseMap=null] A diffuse map {@link Texture}, which will override the effect of the diffuse property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.specularMap=null] A specular map {@link Texture}, which will override the effect of the specular property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.emissiveMap=undefined] An emissive map {@link Texture}, which will override the effect of the emissive property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.normalMap=undefined] A normal map {@link Texture}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.alphaMap=undefined] An alpha map {@link Texture}, which will override the effect of the alpha property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.reflectivityMap=undefined] A reflectivity control map {@link Texture}, which will override the effect of the reflectivity property. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Texture} [cfg.occlusionMap=null] An occlusion map {@link Texture}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Fresnel} [cfg.diffuseFresnel=undefined] A diffuse {@link Fresnel\"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Fresnel} [cfg.specularFresnel=undefined] A specular {@link Fresnel\"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Fresnel} [cfg.emissiveFresnel=undefined] An emissive {@link Fresnel\"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Fresnel} [cfg.alphaFresnel=undefined] An alpha {@link Fresnel\"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {Fresnel} [cfg.reflectivityFresnel=undefined] A reflectivity {@link Fresnel\"}}Fresnel{{/crossLink}}. Must be within the same {@link Scene} as this PhongMaterial.\n     * @param {String} [cfg.alphaMode=\"opaque\"] The alpha blend mode - accepted values are \"opaque\", \"blend\" and \"mask\". See the {@link PhongMaterial#alphaMode} property for more info.\n     * @param {Number} [cfg.alphaCutoff=0.5] The alpha cutoff value. See the {@link PhongMaterial#alphaCutoff} property for more info.\n     * @param {Boolean} [cfg.backfaces=false] Whether to render geometry backfaces.\n     * @param {Boolean} [cfg.frontface=\"ccw\"] The winding order for geometry front faces - \"cw\" for clockwise, or \"ccw\" for counter-clockwise.\n     */\n    constructor(owner, cfg = {}) {\n\n        super(owner, cfg);\n\n        this._state = new _webgl_RenderState_js__WEBPACK_IMPORTED_MODULE_1__[\"RenderState\"]({\n            type: \"PhongMaterial\",\n            ambient: _math_math_js__WEBPACK_IMPORTED_MODULE_2__[\"math\"].vec3([1.0, 1.0, 1.0]),\n            diffuse: _math_math_js__WEBPACK_IMPORTED_MODULE_2__[\"math\"].vec3([1.0, 1.0, 1.0]),\n            specular: _math_math_js__WEBPACK_IMPORTED_MODULE_2__[\"math\"].vec3([1.0, 1.0, 1.0]),\n            emissive: _math_math_js__WEBPACK_IMPORTED_MODULE_2__[\"math\"].vec3([0.0, 0.0, 0.0]),\n            alpha: null,\n            shininess: null,\n            reflectivity: null,\n            alphaMode: null,\n            alphaCutoff: null,\n            lineWidth: null,\n            pointSize: null,\n            backfaces: null,\n            frontface: null, // Boolean for speed; true == \"ccw\", false == \"cw\"\n            hash: null\n        });\n\n        this.ambient = cfg.ambient;\n        this.diffuse = cfg.diffuse;\n        this.specular = cfg.specular;\n        this.emissive = cfg.emissive;\n        this.alpha = cfg.alpha;\n        this.shininess = cfg.shininess;\n        this.reflectivity = cfg.reflectivity;\n        this.lineWidth = cfg.lineWidth;\n        this.pointSize = cfg.pointSize;\n\n        if (cfg.ambientMap) {\n            this._ambientMap = this._checkComponent(\"Texture\", cfg.ambientMap);\n        }\n        if (cfg.diffuseMap) {\n            this._diffuseMap = this._checkComponent(\"Texture\", cfg.diffuseMap);\n        }\n        if (cfg.specularMap) {\n            this._specularMap = this._checkComponent(\"Texture\", cfg.specularMap);\n        }\n        if (cfg.emissiveMap) {\n            this._emissiveMap = this._checkComponent(\"Texture\", cfg.emissiveMap);\n        }\n        if (cfg.alphaMap) {\n            this._alphaMap = this._checkComponent(\"Texture\", cfg.alphaMap);\n        }\n        if (cfg.reflectivityMap) {\n            this._reflectivityMap = this._checkComponent(\"Texture\", cfg.reflectivityMap);\n        }\n        if (cfg.normalMap) {\n            this._normalMap = this._checkComponent(\"Texture\", cfg.normalMap);\n        }\n        if (cfg.occlusionMap) {\n            this._occlusionMap = this._checkComponent(\"Texture\", cfg.occlusionMap);\n        }\n        if (cfg.diffuseFresnel) {\n            this._diffuseFresnel = this._checkComponent(\"Fresnel\", cfg.diffuseFresnel);\n        }\n        if (cfg.specularFresnel) {\n            this._specularFresnel = this._checkComponent(\"Fresnel\", cfg.specularFresnel);\n        }\n        if (cfg.emissiveFresnel) {\n            this._emissiveFresnel = this._checkComponent(\"Fresnel\", cfg.emissiveFresnel);\n        }\n        if (cfg.alphaFresnel) {\n            this._alphaFresnel = this._checkComponent(\"Fresnel\", cfg.alphaFresnel);\n        }\n        if (cfg.reflectivityFresnel) {\n            this._reflectivityFresnel = this._checkComponent(\"Fresnel\", cfg.reflectivityFresnel);\n        }\n\n        this.alphaMode = cfg.alphaMode;\n        this.alphaCutoff = cfg.alphaCutoff;\n        this.backfaces = cfg.backfaces;\n        this.frontface = cfg.frontface;\n\n        this._makeHash();\n    }\n\n    _makeHash() {\n        const state = this._state;\n        const hash = [\"/p\"]; // 'P' for Phong\n        if (this._normalMap) {\n            hash.push(\"/nm\");\n            if (this._normalMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n        }\n        if (this._ambientMap) {\n            hash.push(\"/am\");\n            if (this._ambientMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n            hash.push(\"/\" + this._ambientMap.encoding);\n        }\n        if (this._diffuseMap) {\n            hash.push(\"/dm\");\n            if (this._diffuseMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n            hash.push(\"/\" + this._diffuseMap.encoding);\n        }\n        if (this._specularMap) {\n            hash.push(\"/sm\");\n            if (this._specularMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n        }\n        if (this._emissiveMap) {\n            hash.push(\"/em\");\n            if (this._emissiveMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n            hash.push(\"/\" + this._emissiveMap.encoding);\n        }\n        if (this._alphaMap) {\n            hash.push(\"/opm\");\n            if (this._alphaMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n        }\n        if (this._reflectivityMap) {\n            hash.push(\"/rm\");\n            if (this._reflectivityMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n        }\n        if (this._occlusionMap) {\n            hash.push(\"/ocm\");\n            if (this._occlusionMap.hasMatrix) {\n                hash.push(\"/mat\");\n            }\n        }\n        if (this._diffuseFresnel) {\n            hash.push(\"/df\");\n        }\n        if (this._specularFresnel) {\n            hash.push(\"/sf\");\n        }\n        if (this._emissiveFresnel) {\n            hash.push(\"/ef\");\n        }\n        if (this._alphaFresnel) {\n            hash.push(\"/of\");\n        }\n        if (this._reflectivityFresnel) {\n            hash.push(\"/rf\");\n        }\n        hash.push(\";\");\n        state.hash = hash.join(\"\");\n    }\n\n    /**\n     * Sets the PhongMaterial's ambient color.\n     *\n     * Default value is ````[0.3, 0.3, 0.3]````.\n     *\n     * @type {Number[]}\n     */\n    set ambient(value) {\n        let ambient = this._state.ambient;\n        if (!ambient) {\n            ambient = this._state.ambient = new Float32Array(3);\n        } else if (value && ambient[0] === value[0] && ambient[1] === value[1] && ambient[2] === value[2]) {\n            return;\n        }\n        if (value) {\n            ambient[0] = value[0];\n            ambient[1] = value[1];\n            ambient[2] = value[2];\n        } else {\n            ambient[0] = .2;\n            ambient[1] = .2;\n            ambient[2] = .2;\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's ambient color.\n     *\n     * Default value is ````[0.3, 0.3, 0.3]````.\n     *\n     * @type {Number[]}\n     */\n    get ambient() {\n        return this._state.ambient;\n    }\n\n    /**\n     * Sets the PhongMaterial's diffuse color.\n     *\n     * Multiplies by {@link PhongMaterial#diffuseMap}.\n     *\n     * Default value is ````[1.0, 1.0, 1.0]````.\n     *\n     * @type {Number[]}\n     */\n    set diffuse(value) {\n        let diffuse = this._state.diffuse;\n        if (!diffuse) {\n            diffuse = this._state.diffuse = new Float32Array(3);\n        } else if (value && diffuse[0] === value[0] && diffuse[1] === value[1] && diffuse[2] === value[2]) {\n            return;\n        }\n        if (value) {\n            diffuse[0] = value[0];\n            diffuse[1] = value[1];\n            diffuse[2] = value[2];\n        } else {\n            diffuse[0] = 1;\n            diffuse[1] = 1;\n            diffuse[2] = 1;\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Sets the PhongMaterial's diffuse color.\n     *\n     * Multiplies by {@link PhongMaterial#diffuseMap}.\n     *\n     * Default value is ````[1.0, 1.0, 1.0]````.\n     *\n     * @type {Number[]}\n     */\n    get diffuse() {\n        return this._state.diffuse;\n    }\n\n    /**\n     * Sets the PhongMaterial's specular color.\n     *\n     * Multiplies by {@link PhongMaterial#specularMap}.\n     * Default value is ````[1.0, 1.0, 1.0]````.\n     * @type {Number[]}\n     */\n    set specular(value) {\n        let specular = this._state.specular;\n        if (!specular) {\n            specular = this._state.specular = new Float32Array(3);\n        } else if (value && specular[0] === value[0] && specular[1] === value[1] && specular[2] === value[2]) {\n            return;\n        }\n        if (value) {\n            specular[0] = value[0];\n            specular[1] = value[1];\n            specular[2] = value[2];\n        } else {\n            specular[0] = 1;\n            specular[1] = 1;\n            specular[2] = 1;\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's specular color.\n     *\n     * Multiplies by {@link PhongMaterial#specularMap}.\n     * Default value is ````[1.0, 1.0, 1.0]````.\n     * @type {Number[]}\n     */\n    get specular() {\n        return this._state.specular;\n    }\n\n    /**\n     * Sets the PhongMaterial's emissive color.\n     *\n     * Multiplies by {@link PhongMaterial#emissiveMap}.\n     *\n     * Default value is ````[0.0, 0.0, 0.0]````.\n     * @type {Number[]}\n     */\n    set emissive(value) {\n        let emissive = this._state.emissive;\n        if (!emissive) {\n            emissive = this._state.emissive = new Float32Array(3);\n        } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {\n            return;\n        }\n        if (value) {\n            emissive[0] = value[0];\n            emissive[1] = value[1];\n            emissive[2] = value[2];\n        } else {\n            emissive[0] = 0;\n            emissive[1] = 0;\n            emissive[2] = 0;\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's emissive color.\n     *\n     * Multiplies by {@link PhongMaterial#emissiveMap}.\n     *\n     * Default value is ````[0.0, 0.0, 0.0]````.\n     * @type {Number[]}\n     */\n    get emissive() {\n        return this._state.emissive;\n    }\n\n    /**\n     * Sets the PhongMaterial alpha.\n     *\n     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.\n     *\n     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.\n     *\n     * Multiplies by {@link PhongMaterial#alphaMap}.\n     *\n     * Default value is ````1.0````.\n     *\n     * @type {Number}\n     */\n    set alpha(value) {\n        value = (value !== undefined && value !== null) ? value : 1.0;\n        if (this._state.alpha === value) {\n            return;\n        }\n        this._state.alpha = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial alpha.\n     *\n     * This is a factor in the range [0..1] indicating how transparent the PhongMaterial is.\n     *\n     * A value of 0.0 indicates fully transparent, 1.0 is fully opaque.\n     *\n     * Multiplies by {@link PhongMaterial#alphaMap}.\n     *\n     * Default value is ````1.0````.\n     *\n     * @type {Number}\n     */\n    get alpha() {\n        return this._state.alpha;\n    }\n\n    /**\n     * Sets the PhongMaterial shininess.\n     *\n     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.\n     *\n     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never\n     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp\n     * highlight.\n     *\n     * Default value is ```` 80.0````.\n     *\n     * @type {Number}\n     */\n    set shininess(value) {\n        this._state.shininess = value !== undefined ? value : 80;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial shininess.\n     *\n     * This is a factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.\n     *\n     * Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never\n     * desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp\n     * highlight.\n     *\n     * Default value is ```` 80.0````.\n     *\n     * @type {Number}\n     */\n    get shininess() {\n        return this._state.shininess;\n    }\n\n    /**\n     * Sets the PhongMaterial's line width.\n     *\n     * This is not supported by WebGL implementations based on DirectX [2019].\n     *\n     * Default value is ````1.0````.\n     *\n     * @type {Number}\n     */\n    set lineWidth(value) {\n        this._state.lineWidth = value || 1.0;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's line width.\n     *\n     * This is not supported by WebGL implementations based on DirectX [2019].\n     *\n     * Default value is ````1.0````.\n     *\n     * @type {Number}\n     */\n    get lineWidth() {\n        return this._state.lineWidth;\n    }\n\n    /**\n     * Sets the PhongMaterial's point size.\n     *\n     * Default value is 1.0.\n     *\n     * @type {Number}\n     */\n    set pointSize(value) {\n        this._state.pointSize = value || 1.0;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's point size.\n     *\n     * Default value is 1.0.\n     *\n     * @type {Number}\n     */\n    get pointSize() {\n        return this._state.pointSize;\n    }\n\n    /**\n     * Sets how much {@link ReflectionMap} is reflected by this PhongMaterial.\n     *\n     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.\n     *\n     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.\n     *\n     * Multiplies by {@link PhongMaterial#reflectivityMap}.\n     *\n     * @type {Number}\n     */\n    set reflectivity(value) {\n        this._state.reflectivity = value !== undefined ? value : 1.0;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets how much {@link ReflectionMap} is reflected by this PhongMaterial.\n     *\n     * This is a scalar in range ````[0-1]````. Default value is ````1.0````.\n     *\n     * The surface will be non-reflective when this is ````0````, and completely mirror-like when it is ````1.0````.\n     *\n     * Multiplies by {@link PhongMaterial#reflectivityMap}.\n     *\n     * @type {Number}\n     */\n    get reflectivity() {\n        return this._state.reflectivity;\n    }\n\n    /**\n     * Gets the PhongMaterials's normal map {@link Texture}.\n     *\n     * @type {Texture}\n     */\n    get normalMap() {\n        return this._normalMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's ambient {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#ambient}.\n     *\n     * @type {Texture}\n     */\n    get ambientMap() {\n        return this._ambientMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's diffuse {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#diffuse}.\n     *\n     * @type {Texture}\n     */\n    get diffuseMap() {\n        return this._diffuseMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's specular {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#specular}.\n     *\n     * @type {Texture}\n     */\n    get specularMap() {\n        return this._specularMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's emissive {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#emissive}.\n     *\n     * @type {Texture}\n     */\n    get emissiveMap() {\n        return this._emissiveMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's alpha {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#alpha}.\n     *\n     * @type {Texture}\n     */\n    get alphaMap() {\n        return this._alphaMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's reflectivity {@link Texture}.\n     *\n     * Multiplies by {@link PhongMaterial#reflectivity}.\n     *\n     * @type {Texture}\n     */\n    get reflectivityMap() {\n        return this._reflectivityMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's ambient occlusion {@link Texture}.\n     *\n     * @type {Texture}\n     */\n    get occlusionMap() {\n        return this._occlusionMap;\n    }\n\n    /**\n     * Gets the PhongMaterials's diffuse {@link Fresnel}.\n     *\n     * Applies to {@link PhongMaterial#diffuse}.\n     *\n     * @type {Fresnel}\n     */\n    get diffuseFresnel() {\n        return this._diffuseFresnel;\n    }\n\n    /**\n     * Gets the PhongMaterials's specular {@link Fresnel}.\n     *\n     * Applies to {@link PhongMaterial#specular}.\n     *\n     * @type {Fresnel}\n     */\n    get specularFresnel() {\n        return this._specularFresnel;\n    }\n\n    /**\n     * Gets the PhongMaterials's emissive {@link Fresnel}.\n     *\n     * Applies to {@link PhongMaterial#emissive}.\n     *\n     * @type {Fresnel}\n     */\n    get emissiveFresnel() {\n        return this._emissiveFresnel;\n    }\n\n    /**\n     * Gets the PhongMaterials's alpha {@link Fresnel}.\n     *\n     * Applies to {@link PhongMaterial#alpha}.\n     *\n     * @type {Fresnel}\n     */\n    get alphaFresnel() {\n        return this._alphaFresnel;\n    }\n\n    /**\n     * Gets the PhongMaterials's reflectivity {@link Fresnel}.\n     *\n     * Applies to {@link PhongMaterial#reflectivity}.\n     *\n     * @type {Fresnel}\n     */\n    get reflectivityFresnel() {\n        return this._reflectivityFresnel;\n    }\n\n    /**\n     * Sets the PhongMaterial's alpha rendering mode.\n     *\n     * This governs how alpha is treated. Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.\n     *\n     * Supported values are:\n     *\n     * * \"opaque\" - The alpha value is ignored and the rendered output is fully opaque (default).\n     * * \"mask\" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.\n     * * \"blend\" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).\n     *\n     *@type {String}\n     */\n    set alphaMode(alphaMode) {\n        alphaMode = alphaMode || \"opaque\";\n        let value = alphaModes[alphaMode];\n        if (value === undefined) {\n            this.error(\"Unsupported value for 'alphaMode': \" + alphaMode + \" - defaulting to 'opaque'\");\n            value = \"opaque\";\n        }\n        if (this._state.alphaMode === value) {\n            return;\n        }\n        this._state.alphaMode = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the PhongMaterial's alpha rendering mode.\n     *\n     *@type {String}\n     */\n    get alphaMode() {\n        return alphaModeNames[this._state.alphaMode];\n    }\n\n    /**\n     * Sets the PhongMaterial's alpha cutoff value.\n     *\n     * This specifies the cutoff threshold when {@link PhongMaterial#alphaMode} equals \"mask\". If the alpha is greater than or equal to this value then it is rendered as fully\n     * opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes.\n     *\n     * Alpha is the combined result of {@link PhongMaterial#alpha} and {@link PhongMaterial#alphaMap}.\n     *\n     * Default value is ````0.5````.\n     *\n     * @type {Number}\n     */\n    set alphaCutoff(alphaCutoff) {\n        if (alphaCutoff === null || alphaCutoff === undefined) {\n            alphaCutoff = 0.5;\n        }\n        if (this._state.alphaCutoff === alphaCutoff) {\n            return;\n        }\n        this._state.alphaCutoff = alphaCutoff;\n    }\n\n    /**\n     * Gets the PhongMaterial's alpha cutoff value.\n     *\n     * @type {Number}\n     */\n    get alphaCutoff() {\n        return this._state.alphaCutoff;\n    }\n\n    /**\n     * Sets whether backfaces are visible on attached {@link Mesh}es.\n     *\n     * The backfaces will belong to {@link Geometry} compoents that are also attached to the {@link Mesh}es.\n     *\n     * Default is ````false````.\n     *\n     * @type {Boolean}\n     */\n    set backfaces(value) {\n        value = !!value;\n        if (this._state.backfaces === value) {\n            return;\n        }\n        this._state.backfaces = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets whether backfaces are visible on attached {@link Mesh}es.\n     *\n     * Default is ````false````.\n     *\n     * @type {Boolean}\n     */\n    get backfaces() {\n        return this._state.backfaces;\n    }\n\n    /**\n     * Sets the winding direction of geometry front faces.\n     *\n     * Default is ````\"ccw\"````.\n     * @type {String}\n     */\n    set frontface(value) {\n        value = value !== \"cw\";\n        if (this._state.frontface === value) {\n            return;\n        }\n        this._state.frontface = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the winding direction of front faces on attached {@link Mesh}es.\n     *\n     * Default is ````\"ccw\"````.\n     * @type {String}\n     */\n    get frontface() {\n        return this._state.frontface ? \"ccw\" : \"cw\";\n    }\n\n    /**\n     * Destroys this PhongMaterial.\n     */\n    destroy() {\n        super.destroy();\n        this._state.destroy();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGVyaWFscy9QaG9uZ01hdGVyaWFsLmpzPzMxN2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF1QztBQUNhO0FBQ2Y7O0FBRXJDLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNLHVCQUF1QjtBQUM3QixNQUFNLHVCQUF1QjtBQUM3QixNQUFNLHNCQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVyxzQ0FBc0MsY0FBYyxpQkFBaUIsY0FBYyxXQUFXLHlCQUF5QixnQkFBZ0IsZUFBZTtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsUUFBUTtBQUNSLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEMsTUFBTSw0QkFBNEI7QUFDbEMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSw4QkFBOEI7QUFDcEMsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSwrQkFBK0IsSUFBSSxjQUFjLDJEQUEyRCw0QkFBNEIsNERBQTRELDBCQUEwQjtBQUNwTyxNQUFNLGdDQUFnQyxJQUFJLGNBQWMsMkRBQTJELDZCQUE2Qiw0REFBNEQsMEJBQTBCO0FBQ3RPLE1BQU0sZ0NBQWdDLElBQUksY0FBYyxrRUFBa0UsNkJBQTZCO0FBQ3ZKLE1BQU0sNkJBQTZCLElBQUksY0FBYyxtRUFBbUUsMEJBQTBCO0FBQ2xKLE1BQU0saUNBQWlDLElBQUksY0FBYyxnRUFBZ0UsNEJBQTRCLEdBQUcsNEJBQTRCLE1BQU0sNkJBQTZCO0FBQ3ZOLE1BQU0sOEJBQThCLElBQUksY0FBYztBQUN0RCxNQUFNLG1DQUFtQyxJQUFJLGNBQWMseUNBQXlDLDRCQUE0QjtBQUNoSSxNQUFNLG9DQUFvQyxJQUFJLGNBQWMseUNBQXlDLDZCQUE2QjtBQUNsSSxNQUFNLG9DQUFvQyxJQUFJLGNBQWMseUNBQXlDLDZCQUE2QjtBQUNsSSxNQUFNLHdDQUF3QyxJQUFJLGNBQWMseUNBQXlDLGlDQUFpQztBQUMxSSxNQUFNLGlDQUFpQyxJQUFJLGNBQWMseUNBQXlDLDBCQUEwQjtBQUM1SCxNQUFNLDhCQUE4QjtBQUNwQyxNQUFNLDhCQUE4QjtBQUNwQyxNQUFNLDhCQUE4QjtBQUNwQyxNQUFNLGdDQUFnQztBQUN0QyxNQUFNLDhCQUE4QjtBQUNwQyxNQUFNLDhCQUE4QjtBQUNwQztBQUNBLDRCQUE0QixxREFBUTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU8sa0VBQWtFLFlBQVk7QUFDcEcsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLGtFQUFrRSxvQkFBb0I7QUFDNUcsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVEsc0NBQXNDLGNBQWMsd0VBQXdFLFlBQVk7QUFDL0osZUFBZSxRQUFRLHNDQUFzQyxjQUFjLG1GQUFtRixZQUFZO0FBQzFLLGVBQWUsUUFBUSx3Q0FBd0MsY0FBYyxvRkFBb0YsWUFBWTtBQUM3SyxlQUFlLFFBQVEsOENBQThDLGNBQWMsb0ZBQW9GLFlBQVk7QUFDbkwsZUFBZSxRQUFRLHlDQUF5QyxjQUFjLDJCQUEyQixZQUFZO0FBQ3JILGVBQWUsUUFBUSx3Q0FBd0MsY0FBYyxpRkFBaUYsWUFBWTtBQUMxSyxlQUFlLFFBQVEsNkRBQTZELGNBQWMsd0ZBQXdGLFlBQVk7QUFDdE0sZUFBZSxRQUFRLDJDQUEyQyxjQUFjLDJCQUEyQixZQUFZO0FBQ3ZILGVBQWUsUUFBUSwyQ0FBMkMsZ0JBQWdCLFNBQVMsWUFBWSwyQkFBMkIsWUFBWTtBQUM5SSxlQUFlLFFBQVEsNkNBQTZDLGdCQUFnQixTQUFTLFlBQVksMkJBQTJCLFlBQVk7QUFDaEosZUFBZSxRQUFRLDhDQUE4QyxnQkFBZ0IsU0FBUyxZQUFZLDJCQUEyQixZQUFZO0FBQ2pKLGVBQWUsUUFBUSx3Q0FBd0MsZ0JBQWdCLFNBQVMsWUFBWSwyQkFBMkIsWUFBWTtBQUMzSSxlQUFlLFFBQVEscURBQXFELGdCQUFnQixTQUFTLFlBQVksMkJBQTJCLFlBQVk7QUFDeEosZUFBZSxPQUFPLDRHQUE0Ryw4QkFBOEI7QUFDaEssZUFBZSxPQUFPLHdEQUF3RCxnQ0FBZ0M7QUFDOUcsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsMEJBQTBCLGlFQUFXO0FBQ3JDO0FBQ0EscUJBQXFCLGtEQUFJO0FBQ3pCLHFCQUFxQixrREFBSTtBQUN6QixzQkFBc0Isa0RBQUk7QUFDMUIsc0JBQXNCLGtEQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDBCQUEwQixNQUFNLDZCQUE2QjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCLE1BQU0sNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBLHFDQUFxQyxlQUFlLDBDQUEwQyxXQUFXO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGVyaWFscy9QaG9uZ01hdGVyaWFsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNYXRlcmlhbH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XG5pbXBvcnQge1JlbmRlclN0YXRlfSBmcm9tICcuLi93ZWJnbC9SZW5kZXJTdGF0ZS5qcyc7XG5pbXBvcnQge21hdGh9IGZyb20gJy4uL21hdGgvbWF0aC5qcyc7XG5cbmNvbnN0IGFscGhhTW9kZXMgPSB7XCJvcGFxdWVcIjogMCwgXCJtYXNrXCI6IDEsIFwiYmxlbmRcIjogMn07XG5jb25zdCBhbHBoYU1vZGVOYW1lcyA9IFtcIm9wYXF1ZVwiLCBcIm1hc2tcIiwgXCJibGVuZFwiXTtcblxuLyoqXG4gKiBAZGVzYyBDb25maWd1cmVzIHRoZSBub3JtYWwgcmVuZGVyZWQgYXBwZWFyYW5jZSBvZiB7QGxpbmsgTWVzaH1lcyB1c2luZyB0aGUgbm9uLXBoeXNpY2FsbHktY29ycmVjdCBCbGlubi1QaG9uZyBzaGFkaW5nIG1vZGVsLlxuICpcbiAqICogVXNlZnVsIGZvciBub24tcmVhbGlzdGljIG9iamVjdHMgbGlrZSBnaXptb3MuXG4gKiAqIHtAbGluayBTcGVjdWxhck1hdGVyaWFsfSBpcyBiZXN0IGZvciBpbnN1bGF0b3JzLCBzdWNoIGFzIHdvb2QsIGNlcmFtaWNzIGFuZCBwbGFzdGljLlxuICogKiB7QGxpbmsgTWV0YWxsaWNNYXRlcmlhbH0gaXMgYmVzdCBmb3IgY29uZHVjdGl2ZSBtYXRlcmlhbHMsIHN1Y2ggYXMgbWV0YWwuXG4gKiAqIHtAbGluayBMYW1iZXJ0TWF0ZXJpYWx9IGlzIGFwcHJvcHJpYXRlIGZvciBoaWdoLWRldGFpbCBtb2RlbHMgdGhhdCBuZWVkIHRvIHJlbmRlciBhcyBlZmZpY2llbnRseSBhcyBwb3NzaWJsZS5cbiAqXG4gKiAjIyBVc2FnZVxuICpcbiAqIEluIHRoZSBleGFtcGxlIGJlbG93LCB3ZSdsbCBjcmVhdGUgYSB7QGxpbmsgTWVzaH0gd2l0aCBhIFBob25nTWF0ZXJpYWwgd2l0aCBhIGRpZmZ1c2Uge0BsaW5rIFRleHR1cmV9IGFuZCBhIHNwZWN1bGFyIHtAbGluayBGcmVzbmVsfSwgdXNpbmcgYSB7QGxpbmsgYnVpbGRUb3J1c0dlb21ldHJ5fSB0byBjcmVhdGUgdGhlIHtAbGluayBHZW9tZXRyeX0uXG4gKlxuICogW1tSdW4gdGhpcyBleGFtcGxlXShodHRwOi8veGVva2l0LmdpdGh1Yi5pby94ZW9raXQtc2RrL2V4YW1wbGVzLyNtYXRlcmlhbHNfUGhvbmdNYXRlcmlhbCldXG4gKlxuICogIGBgYGAgamF2YXNjcmlwdFxuICogaW1wb3J0IHtWaWV3ZXJ9IGZyb20gXCIuLi9zcmMvdmlld2VyL1ZpZXdlci5qc1wiO1xuICogaW1wb3J0IHtNZXNofSBmcm9tIFwiLi4vc3JjL3NjZW5lL21lc2gvTWVzaC5qc1wiO1xuICogaW1wb3J0IHtidWlsZFRvcnVzR2VvbWV0cnl9IGZyb20gXCIuLi9zcmMvc2NlbmUvZ2VvbWV0cnkvYnVpbGRlcnMvYnVpbGRUb3J1c0dlb21ldHJ5LmpzXCI7XG4gKiBpbXBvcnQge1JlYWRhYmxlR2VvbWV0cnl9IGZyb20gXCIuLi9zcmMvc2NlbmUvZ2VvbWV0cnkvUmVhZGFibGVHZW9tZXRyeS5qc1wiO1xuICogaW1wb3J0IHtQaG9uZ01hdGVyaWFsfSBmcm9tIFwiLi4vc3JjL3NjZW5lL21hdGVyaWFscy9QaG9uZ01hdGVyaWFsLmpzXCI7XG4gKiBpbXBvcnQge1RleHR1cmV9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWF0ZXJpYWxzL1RleHR1cmUuanNcIjtcbiAqIGltcG9ydCB7RnJlc25lbH0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvRnJlc25lbC5qc1wiO1xuICpcbiAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3ZXIoe1xuICogICAgICAgIGNhbnZhc0lkOiBcIm15Q2FudmFzXCJcbiAqICAgIH0pO1xuICpcbiAqIHZpZXdlci5zY2VuZS5jYW1lcmEuZXllID0gWzAsIDAsIDVdO1xuICogdmlld2VyLnNjZW5lLmNhbWVyYS5sb29rID0gWzAsIDAsIDBdO1xuICogdmlld2VyLnNjZW5lLmNhbWVyYS51cCA9IFswLCAxLCAwXTtcbiAqXG4gKiBuZXcgTWVzaCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgZ2VvbWV0cnk6IG5ldyBSZWFkYWJsZUdlb21ldHJ5KHZpZXdlci5zY2VuZSwgYnVpbGRUb3J1c0dlb21ldHJ5KHtcbiAqICAgICAgICAgIGNlbnRlcjogWzAsIDAsIDBdLFxuICogICAgICAgICAgcmFkaXVzOiAxLjUsXG4gKiAgICAgICAgICB0dWJlOiAwLjUsXG4gKiAgICAgICAgICByYWRpYWxTZWdtZW50czogMzIsXG4gKiAgICAgICAgICB0dWJlU2VnbWVudHM6IDI0LFxuICogICAgICAgICAgYXJjOiBNYXRoLlBJICogMi4wXG4gKiAgICAgIH0pLFxuICogICAgICBtYXRlcmlhbDogbmV3IFBob25nTWF0ZXJpYWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICBhbWJpZW50OiBbMC45LCAwLjMsIDAuOV0sXG4gKiAgICAgICAgICBzaGluaW5lc3M6IDMwLFxuICogICAgICAgICAgZGlmZnVzZU1hcDogbmV3IFRleHR1cmUodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgc3JjOiBcInRleHR1cmVzL2RpZmZ1c2UvdXZHcmlkMi5qcGdcIlxuICogICAgICAgICAgfSksXG4gKiAgICAgICAgICBzcGVjdWxhckZyZXNuZWw6IG5ldyBGcmVzbmVsKHZpZXdlci5zY2VuZSwge1xuICogICAgICAgICAgICAgIGxlZnRDb2xvcjogWzEuMCwgMS4wLCAxLjBdLFxuICogICAgICAgICAgICAgIHJpZ2h0Q29sb3I6IFswLjAsIDAuMCwgMC4wXSxcbiAqICAgICAgICAgICAgICBwb3dlcjogNFxuICogICAgICAgICAgfSlcbiAqICAgICB9KVxuICogfSk7XG4gKiBgYGBgXG4gKlxuICogIyMgUGhvbmdNYXRlcmlhbCBQcm9wZXJ0aWVzXG4gKlxuICogIFRoZSBmb2xsb3dpbmcgdGFibGUgc3VtbWFyaXplcyBQaG9uZ01hdGVyaWFsIHByb3BlcnRpZXM6XG4gKlxuICogfCBQcm9wZXJ0eSB8IFR5cGUgfCBSYW5nZSB8IERlZmF1bHQgVmFsdWUgfCBTcGFjZSB8IERlc2NyaXB0aW9uIHxcbiAqIHw6LS0tLS0tLS06fDotLS0tOnw6LS0tLS06fDotLS0tLS0tLS0tLS0tOnw6LS0tLS06fDotLS0tLS0tLS0tLTp8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2FtYmllbnR9IHwgQXJyYXkgfCBbMCwgMV0gZm9yIGFsbCBjb21wb25lbnRzIHwgWzEsMSwxLDFdIHwgbGluZWFyIHwgVGhlIFJHQiBjb21wb25lbnRzIG9mIHRoZSBhbWJpZW50IGxpZ2h0IHJlZmxlY3RlZCBieSB0aGUgbWF0ZXJpYWwuIHxcbiAqIHwge0BsaW5rIFBob25nTWF0ZXJpYWwjZGlmZnVzZX0gfCBBcnJheSB8IFswLCAxXSBmb3IgYWxsIGNvbXBvbmVudHMgfCBbMSwxLDEsMV0gfCBsaW5lYXIgfCBUaGUgUkdCIGNvbXBvbmVudHMgb2YgdGhlIGRpZmZ1c2UgbGlnaHQgcmVmbGVjdGVkIGJ5IHRoZSBtYXRlcmlhbC4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzcGVjdWxhcn0gfCBBcnJheSB8IFswLCAxXSBmb3IgYWxsIGNvbXBvbmVudHMgfCBbMSwxLDEsMV0gfCBsaW5lYXIgfCBUaGUgUkdCIGNvbXBvbmVudHMgb2YgdGhlIHNwZWN1bGFyIGxpZ2h0IHJlZmxlY3RlZCBieSB0aGUgbWF0ZXJpYWwuIHxcbiAqIHwge0BsaW5rIFBob25nTWF0ZXJpYWwjZW1pc3NpdmV9IHwgQXJyYXkgfCBbMCwgMV0gZm9yIGFsbCBjb21wb25lbnRzIHwgWzAsMCwwXSB8IGxpbmVhciB8IFRoZSBSR0IgY29tcG9uZW50cyBvZiB0aGUgbGlnaHQgZW1pdHRlZCBieSB0aGUgbWF0ZXJpYWwuIHxcbiAqIHwge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGF9IHwgTnVtYmVyIHwgWzAsIDFdIHwgMSB8IGxpbmVhciB8IFRoZSB0cmFuc3BhcmVuY3kgb2YgdGhlIG1hdGVyaWFsIHN1cmZhY2UgKDAgZnVsbHkgdHJhbnNwYXJlbnQsIDEgZnVsbHkgb3BhcXVlKS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzaGluaW5lc3N9IHwgTnVtYmVyIHwgWzAsIDEyOF0gfCA4MCB8IGxpbmVhciB8IERldGVybWluZXMgdGhlIHNpemUgYW5kIHNoYXJwbmVzcyBvZiBzcGVjdWxhciBoaWdobGlnaHRzLiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI3JlZmxlY3Rpdml0eX0gfCBOdW1iZXIgfCBbMCwgMV0gfCAxIHwgbGluZWFyIHwgRGV0ZXJtaW5lcyB0aGUgYW1vdW50IG9mIHJlZmxlY3Rpdml0eS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlTWFwfSB8IHtAbGluayBUZXh0dXJlfSB8ICB8IG51bGwgfCBzUkdCIHwgVGV4dHVyZSBSR0IgY29tcG9uZW50cyBtdWx0aXBseWluZyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlfS4gSWYgdGhlIGZvdXJ0aCBjb21wb25lbnQgKEEpIGlzIHByZXNlbnQsIGl0IG11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGF9LiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI3NwZWN1bGFyTWFwfSB8IHtAbGluayBUZXh0dXJlfSB8ICB8IG51bGwgfCBzUkdCIHwgVGV4dHVyZSBSR0IgY29tcG9uZW50cyBtdWx0aXBseWluZyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzcGVjdWxhcn0uIElmIHRoZSBmb3VydGggY29tcG9uZW50IChBKSBpcyBwcmVzZW50LCBpdCBtdWx0aXBsaWVzIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI2FscGhhfS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNlbWlzc2l2ZU1hcH0gfCB7QGxpbmsgVGV4dHVyZX0gfCAgfCBudWxsIHwgbGluZWFyIHwgVGV4dHVyZSB3aXRoIFJHQiBjb21wb25lbnRzIG11bHRpcGx5aW5nIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI2VtaXNzaXZlfS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYU1hcH0gfCB7QGxpbmsgVGV4dHVyZX0gfCAgfCBudWxsIHwgbGluZWFyIHwgVGV4dHVyZSB3aXRoIGZpcnN0IGNvbXBvbmVudCBtdWx0aXBseWluZyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYX0uIHxcbiAqIHwge0BsaW5rIFBob25nTWF0ZXJpYWwjb2NjbHVzaW9uTWFwfSB8IHtAbGluayBUZXh0dXJlfSB8ICB8IG51bGwgfCBsaW5lYXIgfCBBbWJpZW50IG9jY2x1c2lvbiB0ZXh0dXJlIG11bHRpcGx5aW5nIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI2FtYmllbnR9LCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlfSBhbmQge0BsaW5rIFBob25nTWF0ZXJpYWwjc3BlY3VsYXJ9LiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI25vcm1hbE1hcH0gfCB7QGxpbmsgVGV4dHVyZX0gfCAgfCBudWxsIHwgbGluZWFyIHwgVGFuZ2VudC1zcGFjZSBub3JtYWwgbWFwLiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2RpZmZ1c2VGcmVzbmVsfSB8IHtAbGluayBGcmVzbmVsfSB8ICB8IG51bGwgfCAgfCBGcmVzbmVsIHRlcm0gYXBwbGllZCB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlfS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzcGVjdWxhckZyZXNuZWx9IHwge0BsaW5rIEZyZXNuZWx9IHwgIHwgbnVsbCB8ICB8IEZyZXNuZWwgdGVybSBhcHBsaWVkIHRvIHtAbGluayBQaG9uZ01hdGVyaWFsI3NwZWN1bGFyfS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNlbWlzc2l2ZUZyZXNuZWx9IHwge0BsaW5rIEZyZXNuZWx9IHwgIHwgbnVsbCB8ICB8IEZyZXNuZWwgdGVybSBhcHBsaWVkIHRvIHtAbGluayBQaG9uZ01hdGVyaWFsI2VtaXNzaXZlfS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNyZWZsZWN0aXZpdHlGcmVzbmVsfSB8IHtAbGluayBGcmVzbmVsfSB8ICB8IG51bGwgfCAgfCBGcmVzbmVsIHRlcm0gYXBwbGllZCB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNyZWZsZWN0aXZpdHl9LiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2FscGhhRnJlc25lbH0gfCB7QGxpbmsgRnJlc25lbH0gfCAgfCBudWxsIHwgIHwgRnJlc25lbCB0ZXJtIGFwcGxpZWQgdG8ge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGF9LiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2xpbmVXaWR0aH0gfCBOdW1iZXIgfCBbMC4uMTAwXSB8IDEgfCAgfCBMaW5lIHdpZHRoIGluIHBpeGVscy4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNwb2ludFNpemV9IHwgTnVtYmVyIHwgWzAuLjEwMF0gfCAxIHwgIHwgUG9pbnQgc2l6ZSBpbiBwaXhlbHMuIHxcbiAqIHwge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGFNb2RlfSB8IFN0cmluZyB8IFwib3BhcXVlXCIsIFwiYmxlbmRcIiwgXCJtYXNrXCIgfCBcImJsZW5kXCIgfCAgfCBBbHBoYSBibGVuZCBtb2RlLiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2FscGhhQ3V0b2ZmfSB8IE51bWJlciB8IFswLi4xXSB8IDAuNSB8ICB8IEFscGhhIGN1dG9mZiB2YWx1ZS4gfFxuICogfCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNiYWNrZmFjZXN9IHwgQm9vbGVhbiB8ICB8IGZhbHNlIHwgIHwgV2hldGhlciB0byByZW5kZXIgZ2VvbWV0cnkgYmFja2ZhY2VzLiB8XG4gKiB8IHtAbGluayBQaG9uZ01hdGVyaWFsI2Zyb250ZmFjZX0gfCBTdHJpbmcgfCBcImNjd1wiLCBcImN3XCIgfCBcImNjd1wiIHwgIHwgVGhlIHdpbmRpbmcgb3JkZXIgZm9yIGdlb21ldHJ5IGZyb250ZmFjZXMgLSBcImN3XCIgZm9yIGNsb2Nrd2lzZSwgb3IgXCJjY3dcIiBmb3IgY291bnRlci1jbG9ja3dpc2UuIHxcbiAqL1xuY2xhc3MgUGhvbmdNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblxuICAgIC8qKlxuICAgICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gXCJQaG9uZ01hdGVyaWFsXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21wb25lbnR9IG93bmVyIE93bmVyIGNvbXBvbmVudC4gV2hlbiBkZXN0cm95ZWQsIHRoZSBvd25lciB3aWxsIGRlc3Ryb3kgdGhpcyBjb21wb25lbnQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0geyp9IFtjZmddIFRoZSBQaG9uZ01hdGVyaWFsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NmZy5pZF0gT3B0aW9uYWwgSUQsIHVuaXF1ZSBhbW9uZyBhbGwgY29tcG9uZW50cyBpbiB0aGUgcGFyZW50IHtAbGluayBTY2VuZX0sIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLmFtYmllbnQ9WzEuMCwgMS4wLCAxLjAgXV0gIFBob25nTWF0ZXJpYWwgYW1iaWVudCBjb2xvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLmRpZmZ1c2U9WyAxLjAsIDEuMCwgMS4wIF1dIFBob25nTWF0ZXJpYWwgZGlmZnVzZSBjb2xvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLnNwZWN1bGFyPVsgMS4wLCAxLjAsIDEuMCBdXSAgUGhvbmdNYXRlcmlhbCBzcGVjdWxhciBjb2xvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLmVtaXNzaXZlPVsgMC4wLCAwLjAsIDAuMCBdXSBQaG9uZ01hdGVyaWFsIGVtaXNzaXZlIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2ZnLmFscGhhPTFdIFNjYWxhciBpbiByYW5nZSAwLTEgdGhhdCBjb250cm9scyBhbHBoYSwgd2hlcmUgMCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGNvbXBsZXRlbHkgb3BhcXVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2ZnLnNoaW5pbmVzcz04MF0gU2NhbGFyIGluIHJhbmdlIDAtMTI4IHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2l6ZSBhbmQgc2hhcnBuZXNzIG9mIHNwZWN1bGFyIGhpZ2hsaWdodHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjZmcucmVmbGVjdGl2aXR5PTFdIFNjYWxhciBpbiByYW5nZSAwLTEgdGhhdCBjb250cm9scyBob3cgbXVjaCB7QGxpbmsgUmVmbGVjdGlvbk1hcH0gaXMgcmVmbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2ZnLmxpbmVXaWR0aD0xXSBTY2FsYXIgdGhhdCBjb250cm9scyB0aGUgd2lkdGggb2YgbGluZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjZmcucG9pbnRTaXplPTFdIFNjYWxhciB0aGF0IGNvbnRyb2xzIHRoZSBzaXplIG9mIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge1RleHR1cmV9IFtjZmcuYW1iaWVudE1hcD1udWxsXSBBIGFtYmllbnQgbWFwIHtAbGluayBUZXh0dXJlfSwgd2hpY2ggd2lsbCBtdWx0aXBseSBieSB0aGUgZGlmZnVzZSBwcm9wZXJ0eS4gTXVzdCBiZSB3aXRoaW4gdGhlIHNhbWUge0BsaW5rIFNjZW5lfSBhcyB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICogQHBhcmFtIHtUZXh0dXJlfSBbY2ZnLmRpZmZ1c2VNYXA9bnVsbF0gQSBkaWZmdXNlIG1hcCB7QGxpbmsgVGV4dHVyZX0sIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGVmZmVjdCBvZiB0aGUgZGlmZnVzZSBwcm9wZXJ0eS4gTXVzdCBiZSB3aXRoaW4gdGhlIHNhbWUge0BsaW5rIFNjZW5lfSBhcyB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICogQHBhcmFtIHtUZXh0dXJlfSBbY2ZnLnNwZWN1bGFyTWFwPW51bGxdIEEgc3BlY3VsYXIgbWFwIHtAbGluayBUZXh0dXJlfSwgd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgZWZmZWN0IG9mIHRoZSBzcGVjdWxhciBwcm9wZXJ0eS4gTXVzdCBiZSB3aXRoaW4gdGhlIHNhbWUge0BsaW5rIFNjZW5lfSBhcyB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICogQHBhcmFtIHtUZXh0dXJlfSBbY2ZnLmVtaXNzaXZlTWFwPXVuZGVmaW5lZF0gQW4gZW1pc3NpdmUgbWFwIHtAbGluayBUZXh0dXJlfSwgd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgZWZmZWN0IG9mIHRoZSBlbWlzc2l2ZSBwcm9wZXJ0eS4gTXVzdCBiZSB3aXRoaW4gdGhlIHNhbWUge0BsaW5rIFNjZW5lfSBhcyB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICogQHBhcmFtIHtUZXh0dXJlfSBbY2ZnLm5vcm1hbE1hcD11bmRlZmluZWRdIEEgbm9ybWFsIG1hcCB7QGxpbmsgVGV4dHVyZX0uIE11c3QgYmUgd2l0aGluIHRoZSBzYW1lIHtAbGluayBTY2VuZX0gYXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZX0gW2NmZy5hbHBoYU1hcD11bmRlZmluZWRdIEFuIGFscGhhIG1hcCB7QGxpbmsgVGV4dHVyZX0sIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGVmZmVjdCBvZiB0aGUgYWxwaGEgcHJvcGVydHkuIE11c3QgYmUgd2l0aGluIHRoZSBzYW1lIHtAbGluayBTY2VuZX0gYXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZX0gW2NmZy5yZWZsZWN0aXZpdHlNYXA9dW5kZWZpbmVkXSBBIHJlZmxlY3Rpdml0eSBjb250cm9sIG1hcCB7QGxpbmsgVGV4dHVyZX0sIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGVmZmVjdCBvZiB0aGUgcmVmbGVjdGl2aXR5IHByb3BlcnR5LiBNdXN0IGJlIHdpdGhpbiB0aGUgc2FtZSB7QGxpbmsgU2NlbmV9IGFzIHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0ge1RleHR1cmV9IFtjZmcub2NjbHVzaW9uTWFwPW51bGxdIEFuIG9jY2x1c2lvbiBtYXAge0BsaW5rIFRleHR1cmV9LiBNdXN0IGJlIHdpdGhpbiB0aGUgc2FtZSB7QGxpbmsgU2NlbmV9IGFzIHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0ge0ZyZXNuZWx9IFtjZmcuZGlmZnVzZUZyZXNuZWw9dW5kZWZpbmVkXSBBIGRpZmZ1c2Uge0BsaW5rIEZyZXNuZWxcIn19RnJlc25lbHt7L2Nyb3NzTGlua319LiBNdXN0IGJlIHdpdGhpbiB0aGUgc2FtZSB7QGxpbmsgU2NlbmV9IGFzIHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0ge0ZyZXNuZWx9IFtjZmcuc3BlY3VsYXJGcmVzbmVsPXVuZGVmaW5lZF0gQSBzcGVjdWxhciB7QGxpbmsgRnJlc25lbFwifX1GcmVzbmVse3svY3Jvc3NMaW5rfX0uIE11c3QgYmUgd2l0aGluIHRoZSBzYW1lIHtAbGluayBTY2VuZX0gYXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqIEBwYXJhbSB7RnJlc25lbH0gW2NmZy5lbWlzc2l2ZUZyZXNuZWw9dW5kZWZpbmVkXSBBbiBlbWlzc2l2ZSB7QGxpbmsgRnJlc25lbFwifX1GcmVzbmVse3svY3Jvc3NMaW5rfX0uIE11c3QgYmUgd2l0aGluIHRoZSBzYW1lIHtAbGluayBTY2VuZX0gYXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqIEBwYXJhbSB7RnJlc25lbH0gW2NmZy5hbHBoYUZyZXNuZWw9dW5kZWZpbmVkXSBBbiBhbHBoYSB7QGxpbmsgRnJlc25lbFwifX1GcmVzbmVse3svY3Jvc3NMaW5rfX0uIE11c3QgYmUgd2l0aGluIHRoZSBzYW1lIHtAbGluayBTY2VuZX0gYXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqIEBwYXJhbSB7RnJlc25lbH0gW2NmZy5yZWZsZWN0aXZpdHlGcmVzbmVsPXVuZGVmaW5lZF0gQSByZWZsZWN0aXZpdHkge0BsaW5rIEZyZXNuZWxcIn19RnJlc25lbHt7L2Nyb3NzTGlua319LiBNdXN0IGJlIHdpdGhpbiB0aGUgc2FtZSB7QGxpbmsgU2NlbmV9IGFzIHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NmZy5hbHBoYU1vZGU9XCJvcGFxdWVcIl0gVGhlIGFscGhhIGJsZW5kIG1vZGUgLSBhY2NlcHRlZCB2YWx1ZXMgYXJlIFwib3BhcXVlXCIsIFwiYmxlbmRcIiBhbmQgXCJtYXNrXCIuIFNlZSB0aGUge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGFNb2RlfSBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2ZnLmFscGhhQ3V0b2ZmPTAuNV0gVGhlIGFscGhhIGN1dG9mZiB2YWx1ZS4gU2VlIHRoZSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYUN1dG9mZn0gcHJvcGVydHkgZm9yIG1vcmUgaW5mby5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuYmFja2ZhY2VzPWZhbHNlXSBXaGV0aGVyIHRvIHJlbmRlciBnZW9tZXRyeSBiYWNrZmFjZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLmZyb250ZmFjZT1cImNjd1wiXSBUaGUgd2luZGluZyBvcmRlciBmb3IgZ2VvbWV0cnkgZnJvbnQgZmFjZXMgLSBcImN3XCIgZm9yIGNsb2Nrd2lzZSwgb3IgXCJjY3dcIiBmb3IgY291bnRlci1jbG9ja3dpc2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXIsIGNmZyA9IHt9KSB7XG5cbiAgICAgICAgc3VwZXIob3duZXIsIGNmZyk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUoe1xuICAgICAgICAgICAgdHlwZTogXCJQaG9uZ01hdGVyaWFsXCIsXG4gICAgICAgICAgICBhbWJpZW50OiBtYXRoLnZlYzMoWzEuMCwgMS4wLCAxLjBdKSxcbiAgICAgICAgICAgIGRpZmZ1c2U6IG1hdGgudmVjMyhbMS4wLCAxLjAsIDEuMF0pLFxuICAgICAgICAgICAgc3BlY3VsYXI6IG1hdGgudmVjMyhbMS4wLCAxLjAsIDEuMF0pLFxuICAgICAgICAgICAgZW1pc3NpdmU6IG1hdGgudmVjMyhbMC4wLCAwLjAsIDAuMF0pLFxuICAgICAgICAgICAgYWxwaGE6IG51bGwsXG4gICAgICAgICAgICBzaGluaW5lc3M6IG51bGwsXG4gICAgICAgICAgICByZWZsZWN0aXZpdHk6IG51bGwsXG4gICAgICAgICAgICBhbHBoYU1vZGU6IG51bGwsXG4gICAgICAgICAgICBhbHBoYUN1dG9mZjogbnVsbCxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIHBvaW50U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGJhY2tmYWNlczogbnVsbCxcbiAgICAgICAgICAgIGZyb250ZmFjZTogbnVsbCwgLy8gQm9vbGVhbiBmb3Igc3BlZWQ7IHRydWUgPT0gXCJjY3dcIiwgZmFsc2UgPT0gXCJjd1wiXG4gICAgICAgICAgICBoYXNoOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYW1iaWVudCA9IGNmZy5hbWJpZW50O1xuICAgICAgICB0aGlzLmRpZmZ1c2UgPSBjZmcuZGlmZnVzZTtcbiAgICAgICAgdGhpcy5zcGVjdWxhciA9IGNmZy5zcGVjdWxhcjtcbiAgICAgICAgdGhpcy5lbWlzc2l2ZSA9IGNmZy5lbWlzc2l2ZTtcbiAgICAgICAgdGhpcy5hbHBoYSA9IGNmZy5hbHBoYTtcbiAgICAgICAgdGhpcy5zaGluaW5lc3MgPSBjZmcuc2hpbmluZXNzO1xuICAgICAgICB0aGlzLnJlZmxlY3Rpdml0eSA9IGNmZy5yZWZsZWN0aXZpdHk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gY2ZnLmxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5wb2ludFNpemUgPSBjZmcucG9pbnRTaXplO1xuXG4gICAgICAgIGlmIChjZmcuYW1iaWVudE1hcCkge1xuICAgICAgICAgICAgdGhpcy5fYW1iaWVudE1hcCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiVGV4dHVyZVwiLCBjZmcuYW1iaWVudE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5kaWZmdXNlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWZmdXNlTWFwID0gdGhpcy5fY2hlY2tDb21wb25lbnQoXCJUZXh0dXJlXCIsIGNmZy5kaWZmdXNlTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLnNwZWN1bGFyTWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGVjdWxhck1hcCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiVGV4dHVyZVwiLCBjZmcuc3BlY3VsYXJNYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuZW1pc3NpdmVNYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXNzaXZlTWFwID0gdGhpcy5fY2hlY2tDb21wb25lbnQoXCJUZXh0dXJlXCIsIGNmZy5lbWlzc2l2ZU1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5hbHBoYU1hcCkge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFNYXAgPSB0aGlzLl9jaGVja0NvbXBvbmVudChcIlRleHR1cmVcIiwgY2ZnLmFscGhhTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLnJlZmxlY3Rpdml0eU1hcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdGl2aXR5TWFwID0gdGhpcy5fY2hlY2tDb21wb25lbnQoXCJUZXh0dXJlXCIsIGNmZy5yZWZsZWN0aXZpdHlNYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcubm9ybWFsTWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxNYXAgPSB0aGlzLl9jaGVja0NvbXBvbmVudChcIlRleHR1cmVcIiwgY2ZnLm5vcm1hbE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5vY2NsdXNpb25NYXApIHtcbiAgICAgICAgICAgIHRoaXMuX29jY2x1c2lvbk1hcCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiVGV4dHVyZVwiLCBjZmcub2NjbHVzaW9uTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmRpZmZ1c2VGcmVzbmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWZmdXNlRnJlc25lbCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRnJlc25lbFwiLCBjZmcuZGlmZnVzZUZyZXNuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuc3BlY3VsYXJGcmVzbmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGVjdWxhckZyZXNuZWwgPSB0aGlzLl9jaGVja0NvbXBvbmVudChcIkZyZXNuZWxcIiwgY2ZnLnNwZWN1bGFyRnJlc25lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5lbWlzc2l2ZUZyZXNuZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXNzaXZlRnJlc25lbCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRnJlc25lbFwiLCBjZmcuZW1pc3NpdmVGcmVzbmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmFscGhhRnJlc25lbCkge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFGcmVzbmVsID0gdGhpcy5fY2hlY2tDb21wb25lbnQoXCJGcmVzbmVsXCIsIGNmZy5hbHBoYUZyZXNuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcucmVmbGVjdGl2aXR5RnJlc25lbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdGl2aXR5RnJlc25lbCA9IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRnJlc25lbFwiLCBjZmcucmVmbGVjdGl2aXR5RnJlc25lbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFscGhhTW9kZSA9IGNmZy5hbHBoYU1vZGU7XG4gICAgICAgIHRoaXMuYWxwaGFDdXRvZmYgPSBjZmcuYWxwaGFDdXRvZmY7XG4gICAgICAgIHRoaXMuYmFja2ZhY2VzID0gY2ZnLmJhY2tmYWNlcztcbiAgICAgICAgdGhpcy5mcm9udGZhY2UgPSBjZmcuZnJvbnRmYWNlO1xuXG4gICAgICAgIHRoaXMuX21ha2VIYXNoKCk7XG4gICAgfVxuXG4gICAgX21ha2VIYXNoKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBjb25zdCBoYXNoID0gW1wiL3BcIl07IC8vICdQJyBmb3IgUGhvbmdcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbE1hcCkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL25tXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vcm1hbE1hcC5oYXNNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBoYXNoLnB1c2goXCIvbWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbWJpZW50TWFwKSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvYW1cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW1iaWVudE1hcC5oYXNNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBoYXNoLnB1c2goXCIvbWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL1wiICsgdGhpcy5fYW1iaWVudE1hcC5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpZmZ1c2VNYXApIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9kbVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWZmdXNlTWFwLmhhc01hdHJpeCkge1xuICAgICAgICAgICAgICAgIGhhc2gucHVzaChcIi9tYXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvXCIgKyB0aGlzLl9kaWZmdXNlTWFwLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3BlY3VsYXJNYXApIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9zbVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVjdWxhck1hcC5oYXNNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBoYXNoLnB1c2goXCIvbWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbWlzc2l2ZU1hcCkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL2VtXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXNzaXZlTWFwLmhhc01hdHJpeCkge1xuICAgICAgICAgICAgICAgIGhhc2gucHVzaChcIi9tYXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvXCIgKyB0aGlzLl9lbWlzc2l2ZU1hcC5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhTWFwKSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvb3BtXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhTWFwLmhhc01hdHJpeCkge1xuICAgICAgICAgICAgICAgIGhhc2gucHVzaChcIi9tYXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3Rpdml0eU1hcCkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3JtXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3Rpdml0eU1hcC5oYXNNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBoYXNoLnB1c2goXCIvbWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vY2NsdXNpb25NYXApIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9vY21cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2NjbHVzaW9uTWFwLmhhc01hdHJpeCkge1xuICAgICAgICAgICAgICAgIGhhc2gucHVzaChcIi9tYXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RpZmZ1c2VGcmVzbmVsKSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvZGZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NwZWN1bGFyRnJlc25lbCkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3NmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbWlzc2l2ZUZyZXNuZWwpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9lZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYWxwaGFGcmVzbmVsKSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvb2ZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3Rpdml0eUZyZXNuZWwpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9yZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoLnB1c2goXCI7XCIpO1xuICAgICAgICBzdGF0ZS5oYXNoID0gaGFzaC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFBob25nTWF0ZXJpYWwncyBhbWJpZW50IGNvbG9yLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAuMywgMC4zLCAwLjNdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgYW1iaWVudCh2YWx1ZSkge1xuICAgICAgICBsZXQgYW1iaWVudCA9IHRoaXMuX3N0YXRlLmFtYmllbnQ7XG4gICAgICAgIGlmICghYW1iaWVudCkge1xuICAgICAgICAgICAgYW1iaWVudCA9IHRoaXMuX3N0YXRlLmFtYmllbnQgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGFtYmllbnRbMF0gPT09IHZhbHVlWzBdICYmIGFtYmllbnRbMV0gPT09IHZhbHVlWzFdICYmIGFtYmllbnRbMl0gPT09IHZhbHVlWzJdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhbWJpZW50WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICBhbWJpZW50WzFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICBhbWJpZW50WzJdID0gdmFsdWVbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbWJpZW50WzBdID0gLjI7XG4gICAgICAgICAgICBhbWJpZW50WzFdID0gLjI7XG4gICAgICAgICAgICBhbWJpZW50WzJdID0gLjI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWwncyBhbWJpZW50IGNvbG9yLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAuMywgMC4zLCAwLjNdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgYW1iaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmFtYmllbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCdzIGRpZmZ1c2UgY29sb3IuXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI2RpZmZ1c2VNYXB9LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzEuMCwgMS4wLCAxLjBdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgZGlmZnVzZSh2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZnVzZSA9IHRoaXMuX3N0YXRlLmRpZmZ1c2U7XG4gICAgICAgIGlmICghZGlmZnVzZSkge1xuICAgICAgICAgICAgZGlmZnVzZSA9IHRoaXMuX3N0YXRlLmRpZmZ1c2UgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGRpZmZ1c2VbMF0gPT09IHZhbHVlWzBdICYmIGRpZmZ1c2VbMV0gPT09IHZhbHVlWzFdICYmIGRpZmZ1c2VbMl0gPT09IHZhbHVlWzJdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBkaWZmdXNlWzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICBkaWZmdXNlWzFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICBkaWZmdXNlWzJdID0gdmFsdWVbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWZmdXNlWzBdID0gMTtcbiAgICAgICAgICAgIGRpZmZ1c2VbMV0gPSAxO1xuICAgICAgICAgICAgZGlmZnVzZVsyXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFBob25nTWF0ZXJpYWwncyBkaWZmdXNlIGNvbG9yLlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlTWFwfS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYFsxLjAsIDEuMCwgMS4wXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGRpZmZ1c2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kaWZmdXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFBob25nTWF0ZXJpYWwncyBzcGVjdWxhciBjb2xvci5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjc3BlY3VsYXJNYXB9LlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYFsxLjAsIDEuMCwgMS4wXWBgYGAuXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIHNldCBzcGVjdWxhcih2YWx1ZSkge1xuICAgICAgICBsZXQgc3BlY3VsYXIgPSB0aGlzLl9zdGF0ZS5zcGVjdWxhcjtcbiAgICAgICAgaWYgKCFzcGVjdWxhcikge1xuICAgICAgICAgICAgc3BlY3VsYXIgPSB0aGlzLl9zdGF0ZS5zcGVjdWxhciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgc3BlY3VsYXJbMF0gPT09IHZhbHVlWzBdICYmIHNwZWN1bGFyWzFdID09PSB2YWx1ZVsxXSAmJiBzcGVjdWxhclsyXSA9PT0gdmFsdWVbMl0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNwZWN1bGFyWzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICBzcGVjdWxhclsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgc3BlY3VsYXJbMl0gPSB2YWx1ZVsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwZWN1bGFyWzBdID0gMTtcbiAgICAgICAgICAgIHNwZWN1bGFyWzFdID0gMTtcbiAgICAgICAgICAgIHNwZWN1bGFyWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUGhvbmdNYXRlcmlhbCdzIHNwZWN1bGFyIGNvbG9yLlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzcGVjdWxhck1hcH0uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzEuMCwgMS4wLCAxLjBdYGBgYC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IHNwZWN1bGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuc3BlY3VsYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCdzIGVtaXNzaXZlIGNvbG9yLlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNlbWlzc2l2ZU1hcH0uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGBbMC4wLCAwLjAsIDAuMF1gYGBgLlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgZW1pc3NpdmUodmFsdWUpIHtcbiAgICAgICAgbGV0IGVtaXNzaXZlID0gdGhpcy5fc3RhdGUuZW1pc3NpdmU7XG4gICAgICAgIGlmICghZW1pc3NpdmUpIHtcbiAgICAgICAgICAgIGVtaXNzaXZlID0gdGhpcy5fc3RhdGUuZW1pc3NpdmUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGVtaXNzaXZlWzBdID09PSB2YWx1ZVswXSAmJiBlbWlzc2l2ZVsxXSA9PT0gdmFsdWVbMV0gJiYgZW1pc3NpdmVbMl0gPT09IHZhbHVlWzJdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBlbWlzc2l2ZVswXSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgZW1pc3NpdmVbMV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgIGVtaXNzaXZlWzJdID0gdmFsdWVbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWlzc2l2ZVswXSA9IDA7XG4gICAgICAgICAgICBlbWlzc2l2ZVsxXSA9IDA7XG4gICAgICAgICAgICBlbWlzc2l2ZVsyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWwncyBlbWlzc2l2ZSBjb2xvci5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjZW1pc3NpdmVNYXB9LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAuMCwgMC4wLCAwLjBdYGBgYC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGVtaXNzaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZW1pc3NpdmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCBhbHBoYS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3IgaW4gdGhlIHJhbmdlIFswLi4xXSBpbmRpY2F0aW5nIGhvdyB0cmFuc3BhcmVudCB0aGUgUGhvbmdNYXRlcmlhbCBpcy5cbiAgICAgKlxuICAgICAqIEEgdmFsdWUgb2YgMC4wIGluZGljYXRlcyBmdWxseSB0cmFuc3BhcmVudCwgMS4wIGlzIGZ1bGx5IG9wYXF1ZS5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGFNYXB9LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgMS4wYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpID8gdmFsdWUgOiAxLjA7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5hbHBoYSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5hbHBoYSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUGhvbmdNYXRlcmlhbCBhbHBoYS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3IgaW4gdGhlIHJhbmdlIFswLi4xXSBpbmRpY2F0aW5nIGhvdyB0cmFuc3BhcmVudCB0aGUgUGhvbmdNYXRlcmlhbCBpcy5cbiAgICAgKlxuICAgICAqIEEgdmFsdWUgb2YgMC4wIGluZGljYXRlcyBmdWxseSB0cmFuc3BhcmVudCwgMS4wIGlzIGZ1bGx5IG9wYXF1ZS5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGFNYXB9LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgMS4wYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGFscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCBzaGluaW5lc3MuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZmFjdG9yIGluIHJhbmdlIFswLi4xMjhdIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2l6ZSBhbmQgc2hhcnBuZXNzIG9mIHRoZSBzcGVjdWxhciBoaWdobGlnaHRzIGNyZWF0ZSBieSB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBMYXJnZXIgdmFsdWVzIHByb2R1Y2Ugc21hbGxlciwgc2hhcnBlciBoaWdobGlnaHRzLiBBIHZhbHVlIG9mIDAuMCBnaXZlcyB2ZXJ5IGxhcmdlIGhpZ2hsaWdodHMgdGhhdCBhcmUgYWxtb3N0IG5ldmVyXG4gICAgICogZGVzaXJhYmxlLiBUcnkgdmFsdWVzIGNsb3NlIHRvIDEwIGZvciBhIGxhcmdlciwgZnV6emllciBoaWdobGlnaHQgYW5kIHZhbHVlcyBvZiAxMDAgb3IgbW9yZSBmb3IgYSBzbWFsbCwgc2hhcnBcbiAgICAgKiBoaWdobGlnaHQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGAgODAuMGBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBzaGluaW5lc3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUuc2hpbmluZXNzID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogODA7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFsIHNoaW5pbmVzcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3IgaW4gcmFuZ2UgWzAuLjEyOF0gdGhhdCBkZXRlcm1pbmVzIHRoZSBzaXplIGFuZCBzaGFycG5lc3Mgb2YgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodHMgY3JlYXRlIGJ5IHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIExhcmdlciB2YWx1ZXMgcHJvZHVjZSBzbWFsbGVyLCBzaGFycGVyIGhpZ2hsaWdodHMuIEEgdmFsdWUgb2YgMC4wIGdpdmVzIHZlcnkgbGFyZ2UgaGlnaGxpZ2h0cyB0aGF0IGFyZSBhbG1vc3QgbmV2ZXJcbiAgICAgKiBkZXNpcmFibGUuIFRyeSB2YWx1ZXMgY2xvc2UgdG8gMTAgZm9yIGEgbGFyZ2VyLCBmdXp6aWVyIGhpZ2hsaWdodCBhbmQgdmFsdWVzIG9mIDEwMCBvciBtb3JlIGZvciBhIHNtYWxsLCBzaGFycFxuICAgICAqIGhpZ2hsaWdodC5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYCA4MC4wYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNoaW5pbmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnNoaW5pbmVzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQaG9uZ01hdGVyaWFsJ3MgbGluZSB3aWR0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBXZWJHTCBpbXBsZW1lbnRhdGlvbnMgYmFzZWQgb24gRGlyZWN0WCBbMjAxOV0uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGAxLjBgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgbGluZVdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlLmxpbmVXaWR0aCA9IHZhbHVlIHx8IDEuMDtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWwncyBsaW5lIHdpZHRoLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IFdlYkdMIGltcGxlbWVudGF0aW9ucyBiYXNlZCBvbiBEaXJlY3RYIFsyMDE5XS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYDEuMGBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsaW5lV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5saW5lV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCdzIHBvaW50IHNpemUuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIDEuMC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc2V0IHBvaW50U2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5wb2ludFNpemUgPSB2YWx1ZSB8fCAxLjA7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFsJ3MgcG9pbnQgc2l6ZS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgMS4wLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcG9pbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUucG9pbnRTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaG93IG11Y2gge0BsaW5rIFJlZmxlY3Rpb25NYXB9IGlzIHJlZmxlY3RlZCBieSB0aGlzIFBob25nTWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgc2NhbGFyIGluIHJhbmdlIGBgYGBbMC0xXWBgYGAuIERlZmF1bHQgdmFsdWUgaXMgYGBgYDEuMGBgYGAuXG4gICAgICpcbiAgICAgKiBUaGUgc3VyZmFjZSB3aWxsIGJlIG5vbi1yZWZsZWN0aXZlIHdoZW4gdGhpcyBpcyBgYGBgMGBgYGAsIGFuZCBjb21wbGV0ZWx5IG1pcnJvci1saWtlIHdoZW4gaXQgaXMgYGBgYDEuMGBgYGAuXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI3JlZmxlY3Rpdml0eU1hcH0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNldCByZWZsZWN0aXZpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUucmVmbGVjdGl2aXR5ID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogMS4wO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBob3cgbXVjaCB7QGxpbmsgUmVmbGVjdGlvbk1hcH0gaXMgcmVmbGVjdGVkIGJ5IHRoaXMgUGhvbmdNYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBzY2FsYXIgaW4gcmFuZ2UgYGBgYFswLTFdYGBgYC4gRGVmYXVsdCB2YWx1ZSBpcyBgYGBgMS4wYGBgYC5cbiAgICAgKlxuICAgICAqIFRoZSBzdXJmYWNlIHdpbGwgYmUgbm9uLXJlZmxlY3RpdmUgd2hlbiB0aGlzIGlzIGBgYGAwYGBgYCwgYW5kIGNvbXBsZXRlbHkgbWlycm9yLWxpa2Ugd2hlbiBpdCBpcyBgYGBgMS4wYGBgYC5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjcmVmbGVjdGl2aXR5TWFwfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJlZmxlY3Rpdml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnJlZmxlY3Rpdml0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIG5vcm1hbCBtYXAge0BsaW5rIFRleHR1cmV9LlxuICAgICAqXG4gICAgICogQHR5cGUge1RleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IG5vcm1hbE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbE1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIGFtYmllbnQge0BsaW5rIFRleHR1cmV9LlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbWJpZW50fS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBhbWJpZW50TWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1iaWVudE1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIGRpZmZ1c2Uge0BsaW5rIFRleHR1cmV9LlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBkaWZmdXNlTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlmZnVzZU1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIHNwZWN1bGFyIHtAbGluayBUZXh0dXJlfS5cbiAgICAgKlxuICAgICAqIE11bHRpcGxpZXMgYnkge0BsaW5rIFBob25nTWF0ZXJpYWwjc3BlY3VsYXJ9LlxuICAgICAqXG4gICAgICogQHR5cGUge1RleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHNwZWN1bGFyTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BlY3VsYXJNYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUGhvbmdNYXRlcmlhbHMncyBlbWlzc2l2ZSB7QGxpbmsgVGV4dHVyZX0uXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI2VtaXNzaXZlfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBlbWlzc2l2ZU1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXNzaXZlTWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3MgYWxwaGEge0BsaW5rIFRleHR1cmV9LlxuICAgICAqXG4gICAgICogTXVsdGlwbGllcyBieSB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYX0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgYWxwaGFNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHBoYU1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIHJlZmxlY3Rpdml0eSB7QGxpbmsgVGV4dHVyZX0uXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHtAbGluayBQaG9uZ01hdGVyaWFsI3JlZmxlY3Rpdml0eX0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgcmVmbGVjdGl2aXR5TWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmbGVjdGl2aXR5TWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3MgYW1iaWVudCBvY2NsdXNpb24ge0BsaW5rIFRleHR1cmV9LlxuICAgICAqXG4gICAgICogQHR5cGUge1RleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IG9jY2x1c2lvbk1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29jY2x1c2lvbk1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFscydzIGRpZmZ1c2Uge0BsaW5rIEZyZXNuZWx9LlxuICAgICAqXG4gICAgICogQXBwbGllcyB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNkaWZmdXNlfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtGcmVzbmVsfVxuICAgICAqL1xuICAgIGdldCBkaWZmdXNlRnJlc25lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpZmZ1c2VGcmVzbmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3Mgc3BlY3VsYXIge0BsaW5rIEZyZXNuZWx9LlxuICAgICAqXG4gICAgICogQXBwbGllcyB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNzcGVjdWxhcn0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RnJlc25lbH1cbiAgICAgKi9cbiAgICBnZXQgc3BlY3VsYXJGcmVzbmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BlY3VsYXJGcmVzbmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3MgZW1pc3NpdmUge0BsaW5rIEZyZXNuZWx9LlxuICAgICAqXG4gICAgICogQXBwbGllcyB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNlbWlzc2l2ZX0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RnJlc25lbH1cbiAgICAgKi9cbiAgICBnZXQgZW1pc3NpdmVGcmVzbmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pc3NpdmVGcmVzbmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3MgYWxwaGEge0BsaW5rIEZyZXNuZWx9LlxuICAgICAqXG4gICAgICogQXBwbGllcyB0byB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYX0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RnJlc25lbH1cbiAgICAgKi9cbiAgICBnZXQgYWxwaGFGcmVzbmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGFGcmVzbmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWxzJ3MgcmVmbGVjdGl2aXR5IHtAbGluayBGcmVzbmVsfS5cbiAgICAgKlxuICAgICAqIEFwcGxpZXMgdG8ge0BsaW5rIFBob25nTWF0ZXJpYWwjcmVmbGVjdGl2aXR5fS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtGcmVzbmVsfVxuICAgICAqL1xuICAgIGdldCByZWZsZWN0aXZpdHlGcmVzbmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmbGVjdGl2aXR5RnJlc25lbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQaG9uZ01hdGVyaWFsJ3MgYWxwaGEgcmVuZGVyaW5nIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGdvdmVybnMgaG93IGFscGhhIGlzIHRyZWF0ZWQuIEFscGhhIGlzIHRoZSBjb21iaW5lZCByZXN1bHQgb2Yge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGF9IGFuZCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYU1hcH0uXG4gICAgICpcbiAgICAgKiBTdXBwb3J0ZWQgdmFsdWVzIGFyZTpcbiAgICAgKlxuICAgICAqICogXCJvcGFxdWVcIiAtIFRoZSBhbHBoYSB2YWx1ZSBpcyBpZ25vcmVkIGFuZCB0aGUgcmVuZGVyZWQgb3V0cHV0IGlzIGZ1bGx5IG9wYXF1ZSAoZGVmYXVsdCkuXG4gICAgICogKiBcIm1hc2tcIiAtIFRoZSByZW5kZXJlZCBvdXRwdXQgaXMgZWl0aGVyIGZ1bGx5IG9wYXF1ZSBvciBmdWxseSB0cmFuc3BhcmVudCBkZXBlbmRpbmcgb24gdGhlIGFscGhhIHZhbHVlIGFuZCB0aGUgc3BlY2lmaWVkIGFscGhhIGN1dG9mZiB2YWx1ZS5cbiAgICAgKiAqIFwiYmxlbmRcIiAtIFRoZSBhbHBoYSB2YWx1ZSBpcyB1c2VkIHRvIGNvbXBvc2l0ZSB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmVhcy4gVGhlIHJlbmRlcmVkIG91dHB1dCBpcyBjb21iaW5lZCB3aXRoIHRoZSBiYWNrZ3JvdW5kIHVzaW5nIHRoZSBub3JtYWwgcGFpbnRpbmcgb3BlcmF0aW9uIChpLmUuIHRoZSBQb3J0ZXIgYW5kIER1ZmYgb3ZlciBvcGVyYXRvcikuXG4gICAgICpcbiAgICAgKkB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGFscGhhTW9kZShhbHBoYU1vZGUpIHtcbiAgICAgICAgYWxwaGFNb2RlID0gYWxwaGFNb2RlIHx8IFwib3BhcXVlXCI7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFscGhhTW9kZXNbYWxwaGFNb2RlXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgJ2FscGhhTW9kZSc6IFwiICsgYWxwaGFNb2RlICsgXCIgLSBkZWZhdWx0aW5nIHRvICdvcGFxdWUnXCIpO1xuICAgICAgICAgICAgdmFsdWUgPSBcIm9wYXF1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5hbHBoYU1vZGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuYWxwaGFNb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaG9uZ01hdGVyaWFsJ3MgYWxwaGEgcmVuZGVyaW5nIG1vZGUuXG4gICAgICpcbiAgICAgKkB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGFscGhhTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGFscGhhTW9kZU5hbWVzW3RoaXMuX3N0YXRlLmFscGhhTW9kZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGhvbmdNYXRlcmlhbCdzIGFscGhhIGN1dG9mZiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc3BlY2lmaWVzIHRoZSBjdXRvZmYgdGhyZXNob2xkIHdoZW4ge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGFNb2RlfSBlcXVhbHMgXCJtYXNrXCIuIElmIHRoZSBhbHBoYSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhpcyB2YWx1ZSB0aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGZ1bGx5XG4gICAgICogb3BhcXVlLCBvdGhlcndpc2UsIGl0IGlzIHJlbmRlcmVkIGFzIGZ1bGx5IHRyYW5zcGFyZW50LiBBIHZhbHVlIGdyZWF0ZXIgdGhhbiAxLjAgd2lsbCByZW5kZXIgdGhlIGVudGlyZSBtYXRlcmlhbCBhcyBmdWxseSB0cmFuc3BhcmVudC4gVGhpcyB2YWx1ZSBpcyBpZ25vcmVkIGZvciBvdGhlciBtb2Rlcy5cbiAgICAgKlxuICAgICAqIEFscGhhIGlzIHRoZSBjb21iaW5lZCByZXN1bHQgb2Yge0BsaW5rIFBob25nTWF0ZXJpYWwjYWxwaGF9IGFuZCB7QGxpbmsgUGhvbmdNYXRlcmlhbCNhbHBoYU1hcH0uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGAwLjVgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgYWxwaGFDdXRvZmYoYWxwaGFDdXRvZmYpIHtcbiAgICAgICAgaWYgKGFscGhhQ3V0b2ZmID09PSBudWxsIHx8IGFscGhhQ3V0b2ZmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFscGhhQ3V0b2ZmID0gMC41O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5hbHBoYUN1dG9mZiA9PT0gYWxwaGFDdXRvZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5hbHBoYUN1dG9mZiA9IGFscGhhQ3V0b2ZmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBob25nTWF0ZXJpYWwncyBhbHBoYSBjdXRvZmYgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBhbHBoYUN1dG9mZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmFscGhhQ3V0b2ZmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBiYWNrZmFjZXMgYXJlIHZpc2libGUgb24gYXR0YWNoZWQge0BsaW5rIE1lc2h9ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYmFja2ZhY2VzIHdpbGwgYmVsb25nIHRvIHtAbGluayBHZW9tZXRyeX0gY29tcG9lbnRzIHRoYXQgYXJlIGFsc28gYXR0YWNoZWQgdG8gdGhlIHtAbGluayBNZXNofWVzLlxuICAgICAqXG4gICAgICogRGVmYXVsdCBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGJhY2tmYWNlcyh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5iYWNrZmFjZXMgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuYmFja2ZhY2VzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYmFja2ZhY2VzIGFyZSB2aXNpYmxlIG9uIGF0dGFjaGVkIHtAbGluayBNZXNofWVzLlxuICAgICAqXG4gICAgICogRGVmYXVsdCBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJhY2tmYWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmJhY2tmYWNlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBvZiBnZW9tZXRyeSBmcm9udCBmYWNlcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgaXMgYGBgYFwiY2N3XCJgYGBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGZyb250ZmFjZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcImN3XCI7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5mcm9udGZhY2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuZnJvbnRmYWNlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBvZiBmcm9udCBmYWNlcyBvbiBhdHRhY2hlZCB7QGxpbmsgTWVzaH1lcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgaXMgYGBgYFwiY2N3XCJgYGBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZyb250ZmFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmZyb250ZmFjZSA/IFwiY2N3XCIgOiBcImN3XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBQaG9uZ01hdGVyaWFsLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtQaG9uZ01hdGVyaWFsfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/materials/PhongMaterial.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js ***!
  \***********************************************************************/
/*! exports provided: math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"math\", function() { return math; });\n// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE: Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    unglobalizeObjectId(modelId, globalId) {\n        const idx = globalId.indexOf(\"#\");\n        return (idx === modelId.length && globalId.startsWith(modelId)) ? globalId.substring(idx + 1) : globalId;\n    },\n\n    globalizeObjectId(modelId, objectId) {\n        return (modelId + \"#\" + objectId)\n    },\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a list of double-precision values to a list of high-part floats and a list of low-part floats.\n     * @param doubleVals\n     * @param floatValsHigh\n     * @param floatValsLow\n     */\n    doublesToFloats(doubleVals, floatValsHigh, floatValsLow) {\n        const floatPair = new Float32Array(2);\n        for (let i = 0, len = doubleVals.length; i < len; i++) {\n            math.splitDouble(doubleVals[i], floatPair);\n            floatValsHigh[i] = floatPair[0];\n            floatValsLow[i] = floatPair[1];\n        }\n    },\n\n    /**\n     * Splits a double value into two floats.\n     * @param value\n     * @param floatPair\n     */\n    splitDouble(value, floatPair) {\n        const hi = Float32Array.from([value])[0];\n        const low = value - hi;\n        floatPair[0] = hi;\n        floatPair[1] = low;\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Returns true if the two 3-element vectors are the same.\n     * @param v1\n     * @param v2\n     * @returns {boolean}\n     */\n    compareVec3(v1, v2) {\n        return (v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2]);\n    },\n\n    /**\n     * Negates a three-element vector.\n     * @method negateVec3\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec3(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        return dest;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Get the geometric mean of the vectors.\n     * @method geometricMeanVec2\n     * @static\n     * @param {...Array(Number)} vectors Vec2 to mean\n     * @return {Array(Number)} The geometric mean vec2\n     */\n    geometricMeanVec2(...vectors) {\n        const geometricMean = new FloatArrayType(vectors[0]);\n        for (let i = 1; i < vectors.length; i++) {\n            geometricMean[0] += vectors[i][0];\n            geometricMean[1] += vectors[i][1];\n        }\n        geometricMean[0] /= vectors.length;\n        geometricMean[1] /= vectors.length;\n        return geometricMean;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n\n    /**\n     * Creates a new matrix that replaces the translation in the rightmost column of the given\n     * affine matrix with the given translation.\n     * @param m\n     * @param translation\n     * @param dest\n     * @returns {*}\n     */\n    setMat4Translation(m, translation, dest) {\n\n        dest[0] = m[0];\n        dest[1] = m[1];\n        dest[2] = m[2];\n        dest[3] = m[3];\n\n        dest[4] = m[4];\n        dest[5] = m[5];\n        dest[6] = m[6];\n        dest[7] = m[7];\n\n        dest[8] = m[8];\n        dest[9] = m[9];\n        dest[10] = m[10];\n        dest[11] = m[11];\n\n        dest[12] = translation[0];\n        dest[13] = translation[1];\n        dest[14] = translation[2];\n        dest[15] = m[15];\n\n        return dest;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /** @private */\n    getColMat4(mat, c) {\n        const i = c * 4;\n        return [mat[i], mat[i + 1], mat[i + 2], mat[i + 3]];\n    },\n\n    /** @private */\n    setRowMat4(mat, r, v) {\n        mat[r] = v[0];\n        mat[r + 4] = v[1];\n        mat[r + 8] = v[2];\n        mat[r + 12] = v[3];\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Returns true if the two 4x4 matrices are the same.\n     * @param m1\n     * @param m2\n     * @returns {boolean}\n     */\n    compareMat4(m1, m2) {\n        return m1[0] === m2[0] &&\n            m1[1] === m2[1] &&\n            m1[2] === m2[2] &&\n            m1[3] === m2[3] &&\n            m1[4] === m2[4] &&\n            m1[5] === m2[5] &&\n            m1[6] === m2[6] &&\n            m1[7] === m2[7] &&\n            m1[8] === m2[8] &&\n            m1[9] === m2[9] &&\n            m1[10] === m2[10] &&\n            m1[11] === m2[11] &&\n            m1[12] === m2[12] &&\n            m1[13] === m2[13] &&\n            m1[14] === m2[14] &&\n            m1[15] === m2[15];\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = p[0] * f;\n        q[1] = p[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n    /**\n     * Linearly interpolates between two 4x4 matrices.\n     * @method lerpMat4\n     * @static\n     */\n    lerpMat4(t, t1, t2, m1, m2, dest) {\n        const result = dest || math.mat4();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = m1[0] + (f * (m2[0] - m1[0]));\n        result[1] = m1[1] + (f * (m2[1] - m1[1]));\n        result[2] = m1[2] + (f * (m2[2] - m1[2]));\n        result[3] = m1[3] + (f * (m2[3] - m1[3]));\n        result[4] = m1[4] + (f * (m2[4] - m1[4]));\n        result[5] = m1[5] + (f * (m2[5] - m1[5]));\n        result[6] = m1[6] + (f * (m2[6] - m1[6]));\n        result[7] = m1[7] + (f * (m2[7] - m1[7]));\n        result[8] = m1[8] + (f * (m2[8] - m1[8]));\n        result[9] = m1[9] + (f * (m2[9] - m1[9]));\n        result[10] = m1[10] + (f * (m2[10] - m1[10]));\n        result[11] = m1[11] + (f * (m2[11] - m1[11]));\n        result[12] = m1[12] + (f * (m2[12] - m1[12]));\n        result[13] = m1[13] + (f * (m2[13] - m1[13]));\n        result[14] = m1[14] + (f * (m2[14] - m1[14]));\n        result[15] = m1[15] + (f * (m2[15] - m1[15]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the area of an AABB.\n     *\n     * @private\n     */\n    getAABB3Area(aabb) {\n        const width = (aabb[3] - aabb[0]);\n        const height = (aabb[4] - aabb[1]);\n        const depth = (aabb[5] - aabb[2]);\n        return (width * height * depth);\n    },\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n        aabb[4] = math.MIN_DOUBLE;\n        aabb[5] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new Float32Array(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = math.MIN_DOUBLE;\n            let ymax = math.MIN_DOUBLE;\n            let zmax = math.MIN_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new Float32Array(3);\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Gets the 3D center of the given flat array of 3D positions.\n     *\n     * @private\n     */\n    getPositionsCenter(positions, center = math.vec3()) {\n        let xCenter = 0;\n        let yCenter = 0;\n        let zCenter = 0;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            xCenter += positions[i + 0];\n            yCenter += positions[i + 1];\n            zCenter += positions[i + 2];\n        }\n        const numPositions = positions.length / 3;\n        center[0] = xCenter / numPositions;\n        center[1] = yCenter / numPositions;\n        center[2] = zCenter / numPositions;\n        return center;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n     *\n     * @private\n     */\n    expandAABB3Points3(aabb, positions) {\n        var x;\n        var y;\n        var z;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            x = positions[i];\n            y = positions[i + 1];\n            z = positions[i + 2];\n            if (aabb[0] > x) {\n                aabb[0] = x;\n            }\n            if (aabb[1] > y) {\n                aabb[1] = y;\n            }\n            if (aabb[2] > z) {\n                aabb[2] = z;\n            }\n            if (aabb[3] < x) {\n                aabb[3] = x;\n            }\n            if (aabb[4] < y) {\n                aabb[4] = y;\n            }\n            if (aabb[5] < z) {\n                aabb[5] = z;\n            }\n        }\n        return aabb;\n    },\n\n    /**\n     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB2(aabb = math.AABB2()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MIN_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    point3AABB3Intersect(aabb, p) {\n        return aabb[0] > p[0] || aabb[3] < p[0] || aabb[1] > p[1] || aabb[4] < p[1] || aabb[2] > p[2] || aabb[5] < p[2];\n    },\n\n    /**\n     *\n     * @param dir\n     * @param constant\n     * @param aabb\n     * @returns {number}\n     */\n    planeAABB3Intersect(dir, constant, aabb) {\n        let min, max;\n        if (dir[0] > 0) {\n            min = dir[0] * aabb[0];\n            max = dir[0] * aabb[3];\n        } else {\n            min = dir[0] * aabb[3];\n            max = dir[0] * aabb[0];\n        }\n        if (dir[1] > 0) {\n            min += dir[1] * aabb[1];\n            max += dir[1] * aabb[4];\n        } else {\n            min += dir[1] * aabb[4];\n            max += dir[1] * aabb[1];\n        }\n        if (dir[2] > 0) {\n            min += dir[2] * aabb[2];\n            max += dir[2] * aabb[5];\n        } else {\n            min += dir[2] * aabb[5];\n            max += dir[2] * aabb[2];\n        }\n        const outside = (min <= -constant) && (max <= -constant);\n        if (outside) {\n            return -1;\n        }\n\n        const inside = (min >= -constant) && (max >= -constant);\n        if (inside) {\n            return 1;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToAABB2(points, aabb = math.AABB2()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let w;\n        let f;\n\n        for (let i = 0, len = points.length; i < len; i += 4) {\n\n            x = points[i + 0];\n            y = points[i + 1];\n            w = points[i + 3] || 1.0;\n\n            f = 1.0 / w;\n\n            x *= f;\n            y *= f;\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = xmax;\n        aabb[3] = ymax;\n\n        return aabb;\n    },\n\n    /**\n     * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB2(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] < aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 2D boundary to enclose the given point, if required.\n     *\n     * @private\n     */\n    expandAABB2Point2(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] < p[0]) {\n            aabb[2] = p[0];\n        }\n\n        if (aabb[3] < p[1]) {\n            aabb[3] = p[1];\n        }\n\n        return aabb;\n    },\n\n    AABB2ToCanvas(aabb, canvasWidth, canvasHeight, aabb2 = aabb) {\n        const xmin = (aabb[0] + 1.0) * 0.5;\n        const ymin = (aabb[1] + 1.0) * 0.5;\n        const xmax = (aabb[2] + 1.0) * 0.5;\n        const ymax = (aabb[3] + 1.0) * 0.5;\n\n        aabb2[0] = Math.floor(xmin * canvasWidth);\n        aabb2[1] = canvasHeight - Math.floor(ymax * canvasHeight);\n        aabb2[2] = Math.floor(xmax * canvasWidth);\n        aabb2[3] = canvasHeight - Math.floor(ymin * canvasHeight);\n\n        return aabb2;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Curves\n    //------------------------------------------------------------------------------------------------------------------\n\n    tangentQuadraticBezier(t, p0, p1, p2) {\n        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n    },\n\n    tangentQuadraticBezier3(t, p0, p1, p2, p3) {\n        return -3 * p0 * (1 - t) * (1 - t) +\n            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\n            6 * t * p2 * (1 - t) - 3 * t * t * p2 +\n            3 * t * t * p3;\n    },\n\n    tangentSpline(t) {\n        const h00 = 6 * t * t - 6 * t;\n        const h10 = 3 * t * t - 4 * t + 1;\n        const h01 = -6 * t * t + 6 * t;\n        const h11 = 3 * t * t - 2 * t;\n        return h00 + h10 + h01 + h11;\n    },\n\n    catmullRomInterpolate(p0, p1, p2, p3, t) {\n        const v0 = (p2 - p0) * 0.5;\n        const v1 = (p3 - p1) * 0.5;\n        const t2 = t * t;\n        const t3 = t * t2;\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    },\n\n// Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n// Quad Bezier Functions\n\n    b2p0(t, p) {\n        const k = 1 - t;\n        return k * k * p;\n\n    },\n\n    b2p1(t, p) {\n        return 2 * (1 - t) * t * p;\n    },\n\n    b2p2(t, p) {\n        return t * t * p;\n    },\n\n    b2(t, p0, p1, p2) {\n        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);\n    },\n\n// Cubic Bezier Functions\n\n    b3p0(t, p) {\n        const k = 1 - t;\n        return k * k * k * p;\n    },\n\n    b3p1(t, p) {\n        const k = 1 - t;\n        return 3 * k * k * t * p;\n    },\n\n    b3p2(t, p) {\n        const k = 1 - t;\n        return 3 * k * t * t * p;\n    },\n\n    b3p3(t, p) {\n        return t * t * t * p;\n    },\n\n    b3(t, p0, p1, p2, p3) {\n        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Geometry\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    },\n\n    /**\n     * Finds the intersection of a 3D ray with a 3D triangle.\n     *\n     * @private\n     */\n    rayTriangleIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            const EPSILON = 0.000001;\n\n            const edge1 = math.subVec3(b, a, tempVec3);\n            const edge2 = math.subVec3(c, a, tempVec3b);\n\n            const pvec = math.cross3Vec3(dir, edge2, tempVec3c);\n            const det = math.dotVec3(edge1, pvec);\n            if (det < EPSILON) {\n                return null;\n            }\n\n            const tvec = math.subVec3(origin, a, tempVec3d);\n            const u = math.dotVec3(tvec, pvec);\n            if (u < 0 || u > det) {\n                return null;\n            }\n\n            const qvec = math.cross3Vec3(tvec, edge1, tempVec3e);\n            const v = math.dotVec3(dir, qvec);\n            if (v < 0 || u + v > det) {\n                return null;\n            }\n\n            const t = math.dotVec3(edge2, qvec) / det;\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Finds the intersection of a 3D ray with a plane defined by 3 points.\n     *\n     * @private\n     */\n    rayPlaneIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            dir = math.normalizeVec3(dir, tempVec3);\n\n            const edge1 = math.subVec3(b, a, tempVec3b);\n            const edge2 = math.subVec3(c, a, tempVec3c);\n\n            const n = math.cross3Vec3(edge1, edge2, tempVec3d);\n            math.normalizeVec3(n, n);\n\n            const d = -math.dotVec3(a, n);\n\n            const t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);\n\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     *\n     * @private\n     */\n    cartesianToBarycentric: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n\n        return (cartesian, a, b, c, dest) => {\n\n            const v0 = math.subVec3(c, a, tempVec3);\n            const v1 = math.subVec3(b, a, tempVec3b);\n            const v2 = math.subVec3(cartesian, a, tempVec3c);\n\n            const dot00 = math.dotVec3(v0, v0);\n            const dot01 = math.dotVec3(v0, v1);\n            const dot02 = math.dotVec3(v0, v2);\n            const dot11 = math.dotVec3(v1, v1);\n            const dot12 = math.dotVec3(v1, v2);\n\n            const denom = (dot00 * dot11 - dot01 * dot01);\n\n            // Colinear or singular triangle\n\n            if (denom === 0) {\n\n                // Arbitrary location outside of triangle\n\n                return null;\n            }\n\n            const invDenom = 1 / denom;\n\n            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n            dest[0] = 1 - u - v;\n            dest[1] = v;\n            dest[2] = u;\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Returns true if the given barycentric coordinates are within their triangle.\n     *\n     * @private\n     */\n    barycentricInsideTriangle(bary) {\n\n        const v = bary[1];\n        const u = bary[2];\n\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    },\n\n    /**\n     * Gets cartesian coordinates from barycentric coordinates within a triangle.\n     *\n     * @private\n     */\n    barycentricToCartesian(bary, a, b, c, cartesian = math.vec3()) {\n        const u = bary[0];\n        const v = bary[1];\n        const w = bary[2];\n\n        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;\n        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;\n        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;\n\n        return cartesian;\n    },\n\n\n    /**\n     * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n     * modified arrays that have duplicate vertices removed.\n     *\n     * Note: does not work well when co-incident vertices have same positions but different normals and UVs.\n     *\n     * @param positions\n     * @param normals\n     * @param uv\n     * @param indices\n     * @returns {{positions: Array, indices: Array}}\n     * @private\n     */\n    mergeVertices(positions, normals, uv, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        const indicesLookup = [];\n        const uniquePositions = [];\n        const uniqueNormals = normals ? [] : null;\n        const uniqueUV = uv ? [] : null;\n        const indices2 = [];\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let i;\n        let len;\n        let uvi = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = uniquePositions.length / 3;\n                uniquePositions.push(vx);\n                uniquePositions.push(vy);\n                uniquePositions.push(vz);\n                if (normals) {\n                    uniqueNormals.push(normals[i]);\n                    uniqueNormals.push(normals[i + 1]);\n                    uniqueNormals.push(normals[i + 2]);\n                }\n                if (uv) {\n                    uniqueUV.push(uv[uvi]);\n                    uniqueUV.push(uv[uvi + 1]);\n                }\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n            uvi += 2;\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            indices2[i] = indicesLookup[indices[i]];\n        }\n        const result = {\n            positions: uniquePositions,\n            indices: indices2\n        };\n        if (uniqueNormals) {\n            result.normals = uniqueNormals;\n        }\n        if (uniqueUV) {\n            result.uv = uniqueUV;\n\n        }\n        return result;\n    },\n\n    /**\n     * Builds normal vectors from positions and indices.\n     *\n     * @private\n     */\n    buildNormals: ((() => {\n\n        const a = new Float32Array(3);\n        const b = new Float32Array(3);\n        const c = new Float32Array(3);\n        const ab = new Float32Array(3);\n        const ac = new Float32Array(3);\n        const crossVec = new Float32Array(3);\n\n        return (positions, indices, normals) => {\n\n            let i;\n            let len;\n            const nvecs = new Array(positions.length / 3);\n            let j0;\n            let j1;\n            let j2;\n\n            for (i = 0, len = indices.length; i < len; i += 3) {\n\n                j0 = indices[i];\n                j1 = indices[i + 1];\n                j2 = indices[i + 2];\n\n                a[0] = positions[j0 * 3];\n                a[1] = positions[j0 * 3 + 1];\n                a[2] = positions[j0 * 3 + 2];\n\n                b[0] = positions[j1 * 3];\n                b[1] = positions[j1 * 3 + 1];\n                b[2] = positions[j1 * 3 + 2];\n\n                c[0] = positions[j2 * 3];\n                c[1] = positions[j2 * 3 + 1];\n                c[2] = positions[j2 * 3 + 2];\n\n                math.subVec3(b, a, ab);\n                math.subVec3(c, a, ac);\n\n                const normVec = new Float32Array(3);\n\n                math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n                if (!nvecs[j0]) {\n                    nvecs[j0] = [];\n                }\n                if (!nvecs[j1]) {\n                    nvecs[j1] = [];\n                }\n                if (!nvecs[j2]) {\n                    nvecs[j2] = [];\n                }\n\n                nvecs[j0].push(normVec);\n                nvecs[j1].push(normVec);\n                nvecs[j2].push(normVec);\n            }\n\n            normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n            let count;\n            let x;\n            let y;\n            let z;\n\n            for (i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n                count = nvecs[i].length;\n\n                x = 0;\n                y = 0;\n                z = 0;\n\n                for (let j = 0; j < count; j++) {\n                    x += nvecs[i][j][0];\n                    y += nvecs[i][j][1];\n                    z += nvecs[i][j][2];\n                }\n\n                normals[i * 3] = (x / count);\n                normals[i * 3 + 1] = (y / count);\n                normals[i * 3 + 2] = (z / count);\n            }\n\n            return normals;\n        };\n    }))(),\n\n    /**\n     * Builds vertex tangent vectors from positions, UVs and indices.\n     *\n     * @private\n     */\n    buildTangents: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n        const tempVec3f = new Float32Array(3);\n        const tempVec3g = new Float32Array(3);\n\n        return (positions, indices, uv) => {\n\n            const tangents = new Float32Array(positions.length);\n\n            // The vertex arrays needs to be calculated\n            // before the calculation of the tangents\n\n            for (let location = 0; location < indices.length; location += 3) {\n\n                // Recontructing each vertex and UV coordinate into the respective vectors\n\n                let index = indices[location];\n\n                const v0 = positions.subarray(index * 3, index * 3 + 3);\n                const uv0 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 1];\n\n                const v1 = positions.subarray(index * 3, index * 3 + 3);\n                const uv1 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 2];\n\n                const v2 = positions.subarray(index * 3, index * 3 + 3);\n                const uv2 = uv.subarray(index * 2, index * 2 + 2);\n\n                const deltaPos1 = math.subVec3(v1, v0, tempVec3);\n                const deltaPos2 = math.subVec3(v2, v0, tempVec3b);\n\n                const deltaUV1 = math.subVec2(uv1, uv0, tempVec3c);\n                const deltaUV2 = math.subVec2(uv2, uv0, tempVec3d);\n\n                const r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));\n\n                const tangent = math.mulVec3Scalar(\n                    math.subVec3(\n                        math.mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),\n                        math.mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),\n                        tempVec3g\n                    ),\n                    r,\n                    tempVec3f\n                );\n\n                // Average the value of the vectors\n\n                let addTo;\n\n                for (let v = 0; v < 3; v++) {\n                    addTo = indices[location + v] * 3;\n                    tangents[addTo] += tangent[0];\n                    tangents[addTo + 1] += tangent[1];\n                    tangents[addTo + 2] += tangent[2];\n                }\n            }\n\n            return tangents;\n        };\n    }))(),\n\n    /**\n     * Builds vertex and index arrays needed by color-indexed triangle picking.\n     *\n     * @private\n     */\n    buildPickTriangles(positions, indices, compressGeometry) {\n\n        const numIndices = indices.length;\n        const pickPositions = compressGeometry ? new Uint16Array(numIndices * 9) : new Float32Array(numIndices * 9);\n        const pickColors = new Uint8Array(numIndices * 12);\n        let primIndex = 0;\n        let vi;// Positions array index\n        let pvi = 0;// Picking positions array index\n        let pci = 0; // Picking color array index\n\n        // Triangle indices\n        let i;\n        let r;\n        let g;\n        let b;\n        let a;\n\n        for (let location = 0; location < numIndices; location += 3) {\n\n            // Primitive-indexed triangle pick color\n\n            a = (primIndex >> 24 & 0xFF);\n            b = (primIndex >> 16 & 0xFF);\n            g = (primIndex >> 8 & 0xFF);\n            r = (primIndex & 0xFF);\n\n            // A\n\n            i = indices[location];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // B\n\n            i = indices[location + 1];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // C\n\n            i = indices[location + 2];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            primIndex++;\n        }\n\n        return {\n            positions: pickPositions,\n            colors: pickColors\n        };\n    },\n\n    /**\n     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n     * averaging their normal vectors.\n     *\n     * @returns {{positions: Array, normals: *}}\n     */\n    faceToVertexNormals(positions, normals, options = {}) {\n        const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n        const vertexMap = {};\n        const vertexNormals = [];\n        const vertexNormalAccum = {};\n        let acc;\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let posi;\n        let i;\n        let j;\n        let len;\n        let a;\n        let b;\n        let c;\n\n        for (i = 0, len = positions.length; i < len; i += 3) {\n\n            posi = i / 3;\n\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n            if (vertexMap[key] === undefined) {\n                vertexMap[key] = [posi];\n            } else {\n                vertexMap[key].push(posi);\n            }\n\n            const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n            vertexNormals[posi] = normal;\n\n            acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n            vertexNormalAccum[posi] = acc;\n        }\n\n        for (key in vertexMap) {\n\n            if (vertexMap.hasOwnProperty(key)) {\n\n                const vertices = vertexMap[key];\n                const numVerts = vertices.length;\n\n                for (i = 0; i < numVerts; i++) {\n\n                    const ii = vertices[i];\n\n                    acc = vertexNormalAccum[ii];\n\n                    for (j = 0; j < numVerts; j++) {\n\n                        if (i === j) {\n                            continue;\n                        }\n\n                        const jj = vertices[j];\n\n                        a = vertexNormals[ii];\n                        b = vertexNormals[jj];\n\n                        const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                        if (angle < smoothNormalsAngleThreshold) {\n\n                            acc[0] += b[0];\n                            acc[1] += b[1];\n                            acc[2] += b[2];\n                            acc[3] += 1.0;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0, len = normals.length; i < len; i += 3) {\n\n            acc = vertexNormalAccum[i / 3];\n\n            normals[i + 0] = acc[0] / acc[3];\n            normals[i + 1] = acc[1] / acc[3];\n            normals[i + 2] = acc[2] / acc[3];\n\n        }\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Ray casting\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.\n     @method canvasPosToWorldRay\n     @static\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     */\n    canvasPosToWorldRay: ((() => {\n\n        const tempMat4b = new Float32Array(16);\n        const tempMat4c = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n        const tempVec4c = new Float32Array(4);\n        const tempVec4d = new Float32Array(4);\n\n        return (canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir) => {\n\n            const pvMat = math.mulMat4(projMatrix, viewMatrix, tempMat4b);\n            const pvMatInverse = math.inverseMat4(pvMat, tempMat4c);\n\n            // Calculate clip space coordinates, which will be in range\n            // of x=[-1..1] and y=[-1..1], with y=(+1) at top\n\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n\n            const clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates\n            const clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);\n\n            tempVec4a[0] = clipX;\n            tempVec4a[1] = clipY;\n            tempVec4a[2] = -1;\n            tempVec4a[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4a, tempVec4b);\n            math.mulVec4Scalar(tempVec4b, 1 / tempVec4b[3]);\n\n            tempVec4c[0] = clipX;\n            tempVec4c[1] = clipY;\n            tempVec4c[2] = 1;\n            tempVec4c[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4c, tempVec4d);\n            math.mulVec4Scalar(tempVec4d, 1 / tempVec4d[3]);\n\n            worldRayOrigin[0] = tempVec4d[0];\n            worldRayOrigin[1] = tempVec4d[1];\n            worldRayOrigin[2] = tempVec4d[2];\n\n            math.subVec3(tempVec4d, tempVec4b, worldRayDir);\n\n            math.normalizeVec3(worldRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a Canvas-space position to a Mesh's Local-space coordinate system, in the context of a Camera.\n     @method canvasPosToLocalRay\n     @static\n     @param {Camera} camera The Camera.\n     @param {Mesh} mesh The Mesh.\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} worldMatrix Modeling matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    canvasPosToLocalRay: ((() => {\n\n        const worldRayOrigin = new Float32Array(3);\n        const worldRayDir = new Float32Array(3);\n\n        return (canvas, viewMatrix, projMatrix, worldMatrix, canvasPos, localRayOrigin, localRayDir) => {\n            math.canvasPosToWorldRay(canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir);\n            math.worldRayToLocalRay(worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a ray from World-space to a Mesh's Local-space coordinate system.\n     @method worldRayToLocalRay\n     @static\n     @param {Number[]} worldMatrix The World transform matrix\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    worldRayToLocalRay: ((() => {\n\n        const tempMat4 = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n\n        return (worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) => {\n\n            const modelMatInverse = math.inverseMat4(worldMatrix, tempMat4);\n\n            tempVec4a[0] = worldRayOrigin[0];\n            tempVec4a[1] = worldRayOrigin[1];\n            tempVec4a[2] = worldRayOrigin[2];\n            tempVec4a[3] = 1;\n\n            math.transformVec4(modelMatInverse, tempVec4a, tempVec4b);\n\n            localRayOrigin[0] = tempVec4b[0];\n            localRayOrigin[1] = tempVec4b[1];\n            localRayOrigin[2] = tempVec4b[2];\n\n            math.transformVec3(modelMatInverse, worldRayDir, localRayDir);\n        };\n    }))(),\n\n    buildKDTree: ((() => {\n\n        const KD_TREE_MAX_DEPTH = 10;\n        const KD_TREE_MIN_TRIANGLES = 20;\n\n        const dimLength = new Float32Array();\n\n        function buildNode(triangles, indices, positions, depth) {\n            const aabb = new Float32Array(6);\n\n            const node = {\n                triangles: null,\n                left: null,\n                right: null,\n                leaf: false,\n                splitDim: 0,\n                aabb\n            };\n\n            aabb[0] = aabb[1] = aabb[2] = Number.POSITIVE_INFINITY;\n            aabb[3] = aabb[4] = aabb[5] = Number.NEGATIVE_INFINITY;\n\n            let t;\n            let i;\n            let len;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n                var ii = triangles[t] * 3;\n                for (let j = 0; j < 3; ++j) {\n                    const pi = indices[ii + j] * 3;\n                    if (positions[pi] < aabb[0]) {\n                        aabb[0] = positions[pi]\n                    }\n                    if (positions[pi] > aabb[3]) {\n                        aabb[3] = positions[pi]\n                    }\n                    if (positions[pi + 1] < aabb[1]) {\n                        aabb[1] = positions[pi + 1]\n                    }\n                    if (positions[pi + 1] > aabb[4]) {\n                        aabb[4] = positions[pi + 1]\n                    }\n                    if (positions[pi + 2] < aabb[2]) {\n                        aabb[2] = positions[pi + 2]\n                    }\n                    if (positions[pi + 2] > aabb[5]) {\n                        aabb[5] = positions[pi + 2]\n                    }\n                }\n            }\n\n            if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {\n                node.triangles = triangles;\n                node.leaf = true;\n                return node;\n            }\n\n            dimLength[0] = aabb[3] - aabb[0];\n            dimLength[1] = aabb[4] - aabb[1];\n            dimLength[2] = aabb[5] - aabb[2];\n\n            let dim = 0;\n\n            if (dimLength[1] > dimLength[dim]) {\n                dim = 1;\n            }\n\n            if (dimLength[2] > dimLength[dim]) {\n                dim = 2;\n            }\n\n            node.splitDim = dim;\n\n            const mid = (aabb[dim] + aabb[dim + 3]) / 2;\n            const left = new Array(triangles.length);\n            let numLeft = 0;\n            const right = new Array(triangles.length);\n            let numRight = 0;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n\n                var ii = triangles[t] * 3;\n                const i0 = indices[ii];\n                const i1 = indices[ii + 1];\n                const i2 = indices[ii + 2];\n\n                const pi0 = i0 * 3;\n                const pi1 = i1 * 3;\n                const pi2 = i2 * 3;\n\n                if (positions[pi0 + dim] <= mid || positions[pi1 + dim] <= mid || positions[pi2 + dim] <= mid) {\n                    left[numLeft++] = triangles[t];\n                } else {\n                    right[numRight++] = triangles[t];\n                }\n            }\n\n            left.length = numLeft;\n            right.length = numRight;\n\n            node.left = buildNode(left, indices, positions, depth + 1);\n            node.right = buildNode(right, indices, positions, depth + 1);\n\n            return node;\n        }\n\n        return (indices, positions) => {\n            const numTris = indices.length / 3;\n            const triangles = new Array(numTris);\n            for (let i = 0; i < numTris; ++i) {\n                triangles[i] = i;\n            }\n            return buildNode(triangles, indices, positions, 0);\n        };\n    }))(),\n\n\n    decompressPosition(position, decodeMatrix, dest) {\n        dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];\n        dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];\n        dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];\n    },\n\n    decompressPositions(positions, decodeMatrix, dest = new Float32Array(positions.length)) {\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];\n            dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];\n            dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];\n        }\n        return dest;\n    },\n\n    decompressUV(uv, decodeMatrix, dest) {\n        dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];\n        dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];\n    },\n\n    decompressUVs(uvs, decodeMatrix, dest = new Float32Array(uvs.length)) {\n        for (let i = 0, len = uvs.length; i < len; i += 3) {\n            dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];\n            dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];\n        }\n        return dest;\n    },\n\n    octDecodeVec2(oct, result) {\n        let x = oct[0];\n        let y = oct[1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[0] = x / length;\n        result[1] = y / length;\n        result[2] = z / length;\n        return result;\n    },\n\n    octDecodeVec2s(octs, result) {\n        for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n            let x = octs[i + 0];\n            let y = octs[i + 1];\n            x = (2 * x + 1) / 255;\n            y = (2 * y + 1) / 255;\n            const z = 1 - Math.abs(x) - Math.abs(y);\n            if (z < 0) {\n                x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n                y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n            }\n            const length = Math.sqrt(x * x + y * y + z * z);\n            result[j + 0] = x / length;\n            result[j + 1] = y / length;\n            result[j + 2] = z / length;\n            j += 3;\n        }\n        return result;\n    }\n};\n\nmath.buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n    // TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + \",\" + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                dot = math.dotVec3(normal1, normal2);\n                if (dot > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvbWF0aC5qcz9iNWU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1GQUFtRixHQUFHLGVBQWUsRUFBRSxvQkFBb0IsR0FBRyw0QkFBNEIsRUFBRSxxQkFBcUIsR0FBRyxzQkFBc0IsRUFBRSxvQkFBb0IsR0FBRyxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCO0FBQzFYO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrRUFBK0Usb0JBQW9CO0FBQ25HO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsU0FBUzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0JBQWtCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxTQUFTLE9BQU87O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsMkJBQTJCOztBQUU3RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qix1QkFBdUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCOztBQUU1RztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjOztBQUV6Qzs7QUFFQTs7QUFFQSwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG9CQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tYXRoL21hdGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTb21lIHRlbXBvcmFyeSB2YXJzIHRvIGhlbHAgYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cbmNvbnN0IGRvdWJsZVByZWNpc2lvbiA9IHRydWU7XG5jb25zdCBGbG9hdEFycmF5VHlwZSA9IGRvdWJsZVByZWNpc2lvbiA/IEZsb2F0NjRBcnJheSA6IEZsb2F0MzJBcnJheTtcblxuY29uc3QgdGVtcE1hdDEgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcE1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcFZlYzQgPSBuZXcgRmxvYXRBcnJheVR5cGUoNCk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtYXRoID0ge1xuXG4gICAgTUlOX0RPVUJMRTogLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIE1BWF9ET1VCTEU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByYWRpaWFucyBpbiBhIGRlZ3JlZSAoMC4wMTc0NTMyOTI1KS5cbiAgICAgKiBAcHJvcGVydHkgREVHVE9SQURcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIERFR1RPUkFEOiAwLjAxNzQ1MzI5MjUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlZ3JlZXMgaW4gYSByYWRpYW4uXG4gICAgICogQHByb3BlcnR5IFJBRFRPREVHXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBSQURUT0RFRzogNTcuMjk1Nzc5NTEzLFxuXG4gICAgdW5nbG9iYWxpemVPYmplY3RJZChtb2RlbElkLCBnbG9iYWxJZCkge1xuICAgICAgICBjb25zdCBpZHggPSBnbG9iYWxJZC5pbmRleE9mKFwiI1wiKTtcbiAgICAgICAgcmV0dXJuIChpZHggPT09IG1vZGVsSWQubGVuZ3RoICYmIGdsb2JhbElkLnN0YXJ0c1dpdGgobW9kZWxJZCkpID8gZ2xvYmFsSWQuc3Vic3RyaW5nKGlkeCArIDEpIDogZ2xvYmFsSWQ7XG4gICAgfSxcblxuICAgIGdsb2JhbGl6ZU9iamVjdElkKG1vZGVsSWQsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiAobW9kZWxJZCArIFwiI1wiICsgb2JqZWN0SWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjMlxuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjM1xuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCB2ZWM0XG4gICAgICogQHBhcmFtIFt2YWx1ZXNdIEluaXRpYWwgdmFsdWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgdmVjNCh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgNCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM3gzIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDNcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzeDMgbWF0cml4IHRvIDR4NFxuICAgICAqIEBtZXRob2QgbWF0M1RvTWF0NFxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXguXG4gICAgICogQHBhcmFtIG1hdDQgNHg0IG1hdHJpeFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgbWF0M1RvTWF0NChtYXQzLCBtYXQ0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXQ0WzBdID0gbWF0M1swXTtcbiAgICAgICAgbWF0NFsxXSA9IG1hdDNbMV07XG4gICAgICAgIG1hdDRbMl0gPSBtYXQzWzJdO1xuICAgICAgICBtYXQ0WzNdID0gMDtcbiAgICAgICAgbWF0NFs0XSA9IG1hdDNbM107XG4gICAgICAgIG1hdDRbNV0gPSBtYXQzWzRdO1xuICAgICAgICBtYXQ0WzZdID0gbWF0M1s1XTtcbiAgICAgICAgbWF0NFs3XSA9IDA7XG4gICAgICAgIG1hdDRbOF0gPSBtYXQzWzZdO1xuICAgICAgICBtYXQ0WzldID0gbWF0M1s3XTtcbiAgICAgICAgbWF0NFsxMF0gPSBtYXQzWzhdO1xuICAgICAgICBtYXQ0WzExXSA9IDA7XG4gICAgICAgIG1hdDRbMTJdID0gMDtcbiAgICAgICAgbWF0NFsxM10gPSAwO1xuICAgICAgICBtYXQ0WzE0XSA9IDA7XG4gICAgICAgIG1hdDRbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG1hdDQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDRcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQ0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCAxNik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgNHg0IG1hdHJpeCB0byAzeDNcbiAgICAgKiBAbWV0aG9kIG1hdDRUb01hdDNcbiAgICAgKiBAcGFyYW0gbWF0NCA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIG1hdDRUb01hdDMobWF0NCwgbWF0MykgeyAvLyBUT0RPXG4gICAgICAgIC8vcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgOSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiBkb3VibGUtcHJlY2lzaW9uIHZhbHVlcyB0byBhIGxpc3Qgb2YgaGlnaC1wYXJ0IGZsb2F0cyBhbmQgYSBsaXN0IG9mIGxvdy1wYXJ0IGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gZG91YmxlVmFsc1xuICAgICAqIEBwYXJhbSBmbG9hdFZhbHNIaWdoXG4gICAgICogQHBhcmFtIGZsb2F0VmFsc0xvd1xuICAgICAqL1xuICAgIGRvdWJsZXNUb0Zsb2F0cyhkb3VibGVWYWxzLCBmbG9hdFZhbHNIaWdoLCBmbG9hdFZhbHNMb3cpIHtcbiAgICAgICAgY29uc3QgZmxvYXRQYWlyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRvdWJsZVZhbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGguc3BsaXREb3VibGUoZG91YmxlVmFsc1tpXSwgZmxvYXRQYWlyKTtcbiAgICAgICAgICAgIGZsb2F0VmFsc0hpZ2hbaV0gPSBmbG9hdFBhaXJbMF07XG4gICAgICAgICAgICBmbG9hdFZhbHNMb3dbaV0gPSBmbG9hdFBhaXJbMV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgZG91YmxlIHZhbHVlIGludG8gdHdvIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gZmxvYXRQYWlyXG4gICAgICovXG4gICAgc3BsaXREb3VibGUodmFsdWUsIGZsb2F0UGFpcikge1xuICAgICAgICBjb25zdCBoaSA9IEZsb2F0MzJBcnJheS5mcm9tKFt2YWx1ZV0pWzBdO1xuICAgICAgICBjb25zdCBsb3cgPSB2YWx1ZSAtIGhpO1xuICAgICAgICBmbG9hdFBhaXJbMF0gPSBoaTtcbiAgICAgICAgZmxvYXRQYWlyWzFdID0gbG93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFVVSUQuXG4gICAgICogQG1ldGhvZCBjcmVhdGVVVUlEXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4gc3RyaW5nIFRoZSBuZXcgVVVJRFxuICAgICAqL1xuICAgIGNyZWF0ZVVVSUQ6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxmID0ge307XG4gICAgICAgIGNvbnN0IGx1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBsdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgICAgICAgICAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICByZXR1cm4gYCR7bHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXX0tJHtsdXRbZDEgJiAweGZmXX0ke2x1dFtkMSA+PiA4ICYgMHhmZl19LSR7bHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdfSR7bHV0W2QxID4+IDI0ICYgMHhmZl19LSR7bHV0W2QyICYgMHgzZiB8IDB4ODBdfSR7bHV0W2QyID4+IDggJiAweGZmXX0tJHtsdXRbZDIgPj4gMTYgJiAweGZmXX0ke2x1dFtkMiA+PiAyNCAmIDB4ZmZdfSR7bHV0W2QzICYgMHhmZl19JHtsdXRbZDMgPj4gOCAmIDB4ZmZdfSR7bHV0W2QzID4+IDE2ICYgMHhmZl19JHtsdXRbZDMgPj4gMjQgJiAweGZmXX1gO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgdG8gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIExvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gQ2xhbXBlZCByZXN1bHQuXG4gICAgICovXG4gICAgY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmxvYXRpbmctcG9pbnQgbW9kdWx1c1xuICAgICAqIEBtZXRob2QgZm1vZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZm1vZChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIm1hdGguZm1vZCA6IEF0dGVtcHRpbmcgdG8gZmluZCBtb2R1bHVzIHdpdGhpbiBuZWdhdGl2ZSByYW5nZSAtIHdvdWxkIGJlIGluZmluaXRlIGxvb3AgLSBpZ25vcmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiIDw9IGEpIHtcbiAgICAgICAgICAgIGEgLT0gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gMy1lbGVtZW50IHZlY3RvcnMgYXJlIHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSB2MVxuICAgICAqIEBwYXJhbSB2MlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbXBhcmVWZWMzKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gKHYxWzBdID09PSB2MlswXSAmJiB2MVsxXSA9PT0gdjJbMV0gJiYgdjFbMl0gPT09IHYyWzJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbmVnYXRlVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVmVjdG9yIHRvIG5lZ2F0ZVxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBuZWdhdGVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gLXZbMF07XG4gICAgICAgIGRlc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IC12WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBuZWdhdGVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gbmVnYXRlXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG5lZ2F0ZVZlYzQodiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IC12WzFdO1xuICAgICAgICBkZXN0WzJdID0gLXZbMl07XG4gICAgICAgIGRlc3RbM10gPSAtdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgdG8gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICsgdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSArIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICsgdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzY2FsYXIgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICsgcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIHRvIGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBhZGRWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhZGRWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSArIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdICsgdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gKyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNjYWxhciB2YWx1ZSB0byBlYWNoIGVsZW1lbnQgb2YgYSB0aHJlZS1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzNTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgZnJvbSBhbm90aGVyLlxuICAgICAqIEBtZXRob2Qgc3ViVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFZlY3RvciB0byBzdWJ0cmFjdFxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdWJWZWM0KHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAtIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC0gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLSB2WzJdO1xuICAgICAgICBkZXN0WzNdID0gdVszXSAtIHZbM107XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMyh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC0gdlsyXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBvbmUgdHdvLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMih1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdlb21ldHJpYyBtZWFuIG9mIHRoZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZ2VvbWV0cmljTWVhblZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsuLi5BcnJheShOdW1iZXIpfSB2ZWN0b3JzIFZlYzIgdG8gbWVhblxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IFRoZSBnZW9tZXRyaWMgbWVhbiB2ZWMyXG4gICAgICovXG4gICAgZ2VvbWV0cmljTWVhblZlYzIoLi4udmVjdG9ycykge1xuICAgICAgICBjb25zdCBnZW9tZXRyaWNNZWFuID0gbmV3IEZsb2F0QXJyYXlUeXBlKHZlY3RvcnNbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMF0gKz0gdmVjdG9yc1tpXVswXTtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMV0gKz0gdmVjdG9yc1tpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyaWNNZWFuWzBdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICBnZW9tZXRyaWNNZWFuWzFdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cmljTWVhbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGEgc2NhbGFyIHZhbHVlIGZyb20gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN1YlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC0gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLSBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAtIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC0gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZWFjaCBlbGVtZW50IG9mIGEgNC1lbGVtZW50IHZlY3RvciB0byBhIHNjYWxhciB2YWx1ZSBtaW51cyB0aGUgdmFsdWUgb2YgdGhhdCBlbGVtZW50LlxuICAgICAqIEBtZXRob2Qgc3ViU2NhbGFyVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIFRoZSBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHYgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViU2NhbGFyVmVjNCh2LCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBvbmUgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICogdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKiB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSAqIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICogdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzM0Y2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMzU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gKiBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBlYWNoIGVsZW1lbnQgb2YgYSB0d28tZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMyU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMyU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgZm91ci1lbGVtZW50IHZlY3RvciBieSBhbm90aGVyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZGl2VmVjNCh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLyB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAvIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC8gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHVbM10gLyB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLCByZXR1cm5pbmcgYSBuZXcgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgZGl2U2NhbGFyVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZTY2FsYXJWZWMzKHMsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gcyAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSBzIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHMgLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjM1NjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAvIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdIC8gcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gLyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWM0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gcyBzY2FsYXJcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC8gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAvIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC8gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIGZvdXItZWxlbWVudCB2ZWN0b3IsIHJldHVybmluZyBhIG5ldyB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaXZTY2FsYXJWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSBzIHNjYWxhclxuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlNjYWxhclZlYzQocywgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBzIC8gdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHMgLyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gcyAvIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSBzIC8gdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBmb3VyLWVsZW1lbnQgdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBkb3RWZWM0KHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdICsgdVsyXSAqIHZbMl0gKyB1WzNdICogdlszXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIGZvdXItZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBjcm9zcyBwcm9kdWN0XG4gICAgICovXG4gICAgY3Jvc3MzVmVjNCh1LCB2KSB7XG4gICAgICAgIGNvbnN0IHUwID0gdVswXTtcbiAgICAgICAgY29uc3QgdTEgPSB1WzFdO1xuICAgICAgICBjb25zdCB1MiA9IHVbMl07XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB1MSAqIHYyIC0gdTIgKiB2MSxcbiAgICAgICAgICAgIHUyICogdjAgLSB1MCAqIHYyLFxuICAgICAgICAgICAgdTAgKiB2MSAtIHUxICogdjAsXG4gICAgICAgICAgICAwLjBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB0aHJlZS1lbGVtZW50IHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBjcm9zczNWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGNyb3NzIHByb2R1Y3RcbiAgICAgKi9cbiAgICBjcm9zczNWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gdVswXTtcbiAgICAgICAgY29uc3QgeSA9IHVbMV07XG4gICAgICAgIGNvbnN0IHogPSB1WzJdO1xuICAgICAgICBjb25zdCB4MiA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkyID0gdlsxXTtcbiAgICAgICAgY29uc3QgejIgPSB2WzJdO1xuICAgICAgICBkZXN0WzBdID0geSAqIHoyIC0geiAqIHkyO1xuICAgICAgICBkZXN0WzFdID0geiAqIHgyIC0geCAqIHoyO1xuICAgICAgICBkZXN0WzJdID0geCAqIHkyIC0geSAqIHgyO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG5cbiAgICBzcUxlblZlYzQodikgeyAvLyBUT0RPXG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzQodiwgdik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjNCh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzQodikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdGhyZWUtZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzModSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0gKyB1WzJdICogdlsyXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB0d28tZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzIodSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pO1xuICAgIH0sXG5cblxuICAgIHNxTGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzModiwgdik7XG4gICAgfSxcblxuXG4gICAgc3FMZW5WZWMyKHYpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguZG90VmVjMih2LCB2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzModikpO1xuICAgIH0sXG5cbiAgICBkaXN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh2LCB3KSA9PiBtYXRoLmxlblZlYzMobWF0aC5zdWJWZWMzKHYsIHcsIHZlYykpO1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbGVuVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGxlbmd0aFxuICAgICAqL1xuICAgIGxlblZlYzIodikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG1hdGguc3FMZW5WZWMyKHYpKTtcbiAgICB9LFxuXG4gICAgZGlzdFZlYzI6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ZWMgPSBuZXcgRmxvYXRBcnJheVR5cGUoMik7XG4gICAgICAgIHJldHVybiAodiwgdykgPT4gbWF0aC5sZW5WZWMyKG1hdGguc3ViVmVjMih2LCB3LCB2ZWMpKTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcmNwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKlxuICAgICAqL1xuICAgIHJjcFZlYzModiwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5kaXZTY2FsYXJWZWMzKDEuMCwgdiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yXG4gICAgICogQG1ldGhvZCBub3JtYWxpemVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqXG4gICAgICovXG4gICAgbm9ybWFsaXplVmVjNCh2LCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IGYgPSAxLjAgLyBtYXRoLmxlblZlYzQodik7XG4gICAgICAgIHJldHVybiBtYXRoLm11bFZlYzRTY2FsYXIodiwgZiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB0aHJlZS1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMyh2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjM1NjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhIHR3by1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMyKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMih2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjMlNjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAqIEBtZXRob2QgYW5nbGVWZWMzXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcGFyYW0gd1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYW5nbGVWZWMzKHYsIHcpIHtcbiAgICAgICAgbGV0IHRoZXRhID0gbWF0aC5kb3RWZWMzKHYsIHcpIC8gKE1hdGguc3FydChtYXRoLnNxTGVuVmVjMyh2KSAqIG1hdGguc3FMZW5WZWMzKHcpKSk7XG4gICAgICAgIHRoZXRhID0gdGhldGEgPCAtMSA/IC0xIDogKHRoZXRhID4gMSA/IDEgOiB0aGV0YSk7ICAvLyBDbGFtcCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3ModGhldGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgZnJvbSB0aGUgcm90YXRpb24gcGFydCBvZiBhIHNpeHRlZW4tZWxlbWVudCBtYXRyaXguXG4gICAgICogQHBhcmFtIG1cbiAgICAgKiBAcGFyYW0gZGVzdFxuICAgICAqL1xuICAgIHZlYzNGcm9tTWF0NFNjYWxlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcblxuICAgICAgICByZXR1cm4gKG0sIGRlc3QpID0+IHtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzBdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzJdO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzRdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzVdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzZdO1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzhdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzldO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzEwXTtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdGgubGVuVmVjMyh0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gbi1lbGVtZW50IHZlY3RvciB0byBhIEpTT04tc2VyaWFsaXphYmxlXG4gICAgICogYXJyYXkgd2l0aCB2YWx1ZXMgcm91bmRlZCB0byB0d28gZGVjaW1hbCBwbGFjZXMuXG4gICAgICovXG4gICAgdmVjVG9BcnJheTogKCgoKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYgKiAxMDAwMDApIC8gMTAwMDAwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdiA9PiB7XG4gICAgICAgICAgICB2ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZbaV0gPSB0cnVuYyh2W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzLWVsZW1lbnQgdmVjdG9yIGZyb20gYW4gYXJyYXkgdG8gYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGBgYGB7eDo5OTksIHk6OTk5LCB6Ojk5OX1gYGBgLlxuICAgICAqIEBwYXJhbSBhcnJcbiAgICAgKiBAcmV0dXJucyB7e3g6ICosIHk6ICosIHo6ICp9fVxuICAgICAqL1xuICAgIHh5ekFycmF5VG9PYmplY3QoYXJyKSB7XG4gICAgICAgIHJldHVybiB7XCJ4XCI6IGFyclswXSwgXCJ5XCI6IGFyclsxXSwgXCJ6XCI6IGFyclsyXX07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgMy1lbGVtZW50IHZlY3RvciBvYmplY3Qgb2YgdGhlIGZvcm0gYGBgYHt4Ojk5OSwgeTo5OTksIHo6OTk5fWBgYGAgdG8gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSAgW2FycnldXG4gICAgICogQHJldHVybnMgeypbXX1cbiAgICAgKi9cbiAgICB4eXpPYmplY3RUb0FycmF5KHh5eiwgYXJyeSkge1xuICAgICAgICBhcnJ5ID0gYXJyeSB8fCBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGFycnlbMF0gPSB4eXoueDtcbiAgICAgICAgYXJyeVsxXSA9IHh5ei55O1xuICAgICAgICBhcnJ5WzJdID0geHl6Lno7XG4gICAgICAgIHJldHVybiBhcnJ5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEdXBsaWNhdGVzIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGR1cE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZHVwTWF0NChtKSB7XG4gICAgICAgIHJldHVybiBtLnNsaWNlKDAsIDE2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYSAzeDMgbWF0cml4IGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgbWF0NFRvM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBtYXQ0VG8zKG0pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sXG4gICAgICAgICAgICBtWzRdLCBtWzVdLCBtWzZdLFxuICAgICAgICAgICAgbVs4XSwgbVs5XSwgbVsxMF1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUuXG4gICAgICogQG1ldGhvZCBtNHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbTRzKHMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHMsIHMsIHMsIHMsXG4gICAgICAgICAgICBzLCBzLCBzLCBzLFxuICAgICAgICAgICAgcywgcywgcywgcyxcbiAgICAgICAgICAgIHMsIHMsIHMsIHNcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHplcm8uXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9aZXJvZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvWmVyb2VzKCkge1xuICAgICAgICByZXR1cm4gbWF0aC5tNHMoMC4wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIDEuMC5cbiAgICAgKiBAbWV0aG9kIHNldE1hdDRUb09uZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvT25lcygpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubTRzKDEuMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZWFjaCBlbGVtZW50IHNldCB0byAxLjAuXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9PbmVzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHYodikge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKFtcbiAgICAgICAgICAgIHZbMF0sIDAuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgICAwLjAsIHZbMV0sIDAuMCwgMC4wLFxuICAgICAgICAgICAgMC4wLCAwLjAsIHZbMl0sIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIHZbM11cbiAgICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NGMoeCwgeSwgeiwgdykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDR2KFt4LCB5LCB6LCB3XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHMocykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDRjKHMsIHMsIHMsIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGlkZW50aXR5TWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpZGVudGl0eU1hdDQobWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuICAgICAgICBtYXRbM10gPSAwLjA7XG5cbiAgICAgICAgbWF0WzRdID0gMC4wO1xuICAgICAgICBtYXRbNV0gPSAxLjA7XG4gICAgICAgIG1hdFs2XSA9IDAuMDtcbiAgICAgICAgbWF0WzddID0gMC4wO1xuXG4gICAgICAgIG1hdFs4XSA9IDAuMDtcbiAgICAgICAgbWF0WzldID0gMC4wO1xuICAgICAgICBtYXRbMTBdID0gMS4wO1xuICAgICAgICBtYXRbMTFdID0gMC4wO1xuXG4gICAgICAgIG1hdFsxMl0gPSAwLjA7XG4gICAgICAgIG1hdFsxM10gPSAwLjA7XG4gICAgICAgIG1hdFsxNF0gPSAwLjA7XG4gICAgICAgIG1hdFsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG1hdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDN4MyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBpZGVudGl0eU1hdDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaWRlbnRpdHlNYXQzKG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuXG4gICAgICAgIG1hdFszXSA9IDAuMDtcbiAgICAgICAgbWF0WzRdID0gMS4wO1xuICAgICAgICBtYXRbNV0gPSAwLjA7XG5cbiAgICAgICAgbWF0WzZdID0gMC4wO1xuICAgICAgICBtYXRbN10gPSAwLjA7XG4gICAgICAgIG1hdFs4XSA9IDEuMDtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeCBpcyB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqIEBtZXRob2QgaXNJZGVudGl0eU1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNJZGVudGl0eU1hdDQobSkge1xuICAgICAgICBpZiAobVswXSAhPT0gMS4wIHx8IG1bMV0gIT09IDAuMCB8fCBtWzJdICE9PSAwLjAgfHwgbVszXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzRdICE9PSAwLjAgfHwgbVs1XSAhPT0gMS4wIHx8IG1bNl0gIT09IDAuMCB8fCBtWzddICE9PSAwLjAgfHxcbiAgICAgICAgICAgIG1bOF0gIT09IDAuMCB8fCBtWzldICE9PSAwLjAgfHwgbVsxMF0gIT09IDEuMCB8fCBtWzExXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzEyXSAhPT0gMC4wIHx8IG1bMTNdICE9PSAwLjAgfHwgbVsxNF0gIT09IDAuMCB8fCBtWzE1XSAhPT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBuZWdhdGVNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG5lZ2F0ZU1hdDQobSwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1tWzFdO1xuICAgICAgICBkZXN0WzJdID0gLW1bMl07XG4gICAgICAgIGRlc3RbM10gPSAtbVszXTtcbiAgICAgICAgZGVzdFs0XSA9IC1tWzRdO1xuICAgICAgICBkZXN0WzVdID0gLW1bNV07XG4gICAgICAgIGRlc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgZGVzdFs3XSA9IC1tWzddO1xuICAgICAgICBkZXN0WzhdID0gLW1bOF07XG4gICAgICAgIGRlc3RbOV0gPSAtbVs5XTtcbiAgICAgICAgZGVzdFsxMF0gPSAtbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gLW1bMTFdO1xuICAgICAgICBkZXN0WzEyXSA9IC1tWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSAtbVsxM107XG4gICAgICAgIGRlc3RbMTRdID0gLW1bMTRdO1xuICAgICAgICBkZXN0WzE1XSA9IC1tWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIDR4NCBtYXRyaWNlcyB0b2dldGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBkZXN0WzFdID0gYVsxXSArIGJbMV07XG4gICAgICAgIGRlc3RbMl0gPSBhWzJdICsgYlsyXTtcbiAgICAgICAgZGVzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICBkZXN0WzRdID0gYVs0XSArIGJbNF07XG4gICAgICAgIGRlc3RbNV0gPSBhWzVdICsgYls1XTtcbiAgICAgICAgZGVzdFs2XSA9IGFbNl0gKyBiWzZdO1xuICAgICAgICBkZXN0WzddID0gYVs3XSArIGJbN107XG4gICAgICAgIGRlc3RbOF0gPSBhWzhdICsgYls4XTtcbiAgICAgICAgZGVzdFs5XSA9IGFbOV0gKyBiWzldO1xuICAgICAgICBkZXN0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICAgICAgZGVzdFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gICAgICAgIGRlc3RbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICAgICAgZGVzdFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NFNjYWxhcihtLCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKyBzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSArIHM7XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdICsgcztcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKyBzO1xuICAgICAgICBkZXN0WzRdID0gbVs0XSArIHM7XG4gICAgICAgIGRlc3RbNV0gPSBtWzVdICsgcztcbiAgICAgICAgZGVzdFs2XSA9IG1bNl0gKyBzO1xuICAgICAgICBkZXN0WzddID0gbVs3XSArIHM7XG4gICAgICAgIGRlc3RbOF0gPSBtWzhdICsgcztcbiAgICAgICAgZGVzdFs5XSA9IG1bOV0gKyBzO1xuICAgICAgICBkZXN0WzEwXSA9IG1bMTBdICsgcztcbiAgICAgICAgZGVzdFsxMV0gPSBtWzExXSArIHM7XG4gICAgICAgIGRlc3RbMTJdID0gbVsxMl0gKyBzO1xuICAgICAgICBkZXN0WzEzXSA9IG1bMTNdICsgcztcbiAgICAgICAgZGVzdFsxNF0gPSBtWzE0XSArIHM7XG4gICAgICAgIGRlc3RbMTVdID0gbVsxNV0gKyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZFNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmFkZE1hdDRTY2FsYXIobSwgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgc2Vjb25kIDR4NCBtYXRyaXggZnJvbSB0aGUgZmlyc3QuXG4gICAgICogQG1ldGhvZCBzdWJNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN1Yk1hdDQoYSwgYiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGRlc3RbM10gPSBhWzNdIC0gYlszXTtcbiAgICAgICAgZGVzdFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgICAgICBkZXN0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgICAgIGRlc3RbNl0gPSBhWzZdIC0gYls2XTtcbiAgICAgICAgZGVzdFs3XSA9IGFbN10gLSBiWzddO1xuICAgICAgICBkZXN0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgICAgIGRlc3RbOV0gPSBhWzldIC0gYls5XTtcbiAgICAgICAgZGVzdFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICAgICAgICBkZXN0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICAgICAgICBkZXN0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gc2NhbGFyIGZyb20gZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc3ViTWF0NFNjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdWJNYXQ0U2NhbGFyKG0sIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gbVswXSAtIHM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdIC0gcztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gLSBzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAtIHM7XG4gICAgICAgIGRlc3RbNF0gPSBtWzRdIC0gcztcbiAgICAgICAgZGVzdFs1XSA9IG1bNV0gLSBzO1xuICAgICAgICBkZXN0WzZdID0gbVs2XSAtIHM7XG4gICAgICAgIGRlc3RbN10gPSBtWzddIC0gcztcbiAgICAgICAgZGVzdFs4XSA9IG1bOF0gLSBzO1xuICAgICAgICBkZXN0WzldID0gbVs5XSAtIHM7XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF0gLSBzO1xuICAgICAgICBkZXN0WzExXSA9IG1bMTFdIC0gcztcbiAgICAgICAgZGVzdFsxMl0gPSBtWzEyXSAtIHM7XG4gICAgICAgIGRlc3RbMTNdID0gbVsxM10gLSBzO1xuICAgICAgICBkZXN0WzE0XSA9IG1bMTRdIC0gcztcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XSAtIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHN1YlNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3ViU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSBtWzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gbVsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSBtWzNdO1xuICAgICAgICBkZXN0WzRdID0gcyAtIG1bNF07XG4gICAgICAgIGRlc3RbNV0gPSBzIC0gbVs1XTtcbiAgICAgICAgZGVzdFs2XSA9IHMgLSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gcyAtIG1bN107XG4gICAgICAgIGRlc3RbOF0gPSBzIC0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IHMgLSBtWzldO1xuICAgICAgICBkZXN0WzEwXSA9IHMgLSBtWzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBzIC0gbVsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gcyAtIG1bMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IHMgLSBtWzEzXTtcbiAgICAgICAgZGVzdFsxNF0gPSBzIC0gbVsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gcyAtIG1bMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgdHdvIGdpdmVuIDR4NCBtYXRyaXggYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gYVswXTtcblxuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzddO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzldO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdO1xuICAgICAgICBjb25zdCBiMDAgPSBiWzBdO1xuICAgICAgICBjb25zdCBiMDEgPSBiWzFdO1xuICAgICAgICBjb25zdCBiMDIgPSBiWzJdO1xuICAgICAgICBjb25zdCBiMDMgPSBiWzNdO1xuICAgICAgICBjb25zdCBiMTAgPSBiWzRdO1xuICAgICAgICBjb25zdCBiMTEgPSBiWzVdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzZdO1xuICAgICAgICBjb25zdCBiMTMgPSBiWzddO1xuICAgICAgICBjb25zdCBiMjAgPSBiWzhdO1xuICAgICAgICBjb25zdCBiMjEgPSBiWzldO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzEwXTtcbiAgICAgICAgY29uc3QgYjIzID0gYlsxMV07XG4gICAgICAgIGNvbnN0IGIzMCA9IGJbMTJdO1xuICAgICAgICBjb25zdCBiMzEgPSBiWzEzXTtcbiAgICAgICAgY29uc3QgYjMyID0gYlsxNF07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbMTVdO1xuXG4gICAgICAgIGRlc3RbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzA7XG4gICAgICAgIGRlc3RbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzE7XG4gICAgICAgIGRlc3RbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzI7XG4gICAgICAgIGRlc3RbM10gPSBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzM7XG4gICAgICAgIGRlc3RbNF0gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzA7XG4gICAgICAgIGRlc3RbNV0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzE7XG4gICAgICAgIGRlc3RbNl0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzI7XG4gICAgICAgIGRlc3RbN10gPSBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzM7XG4gICAgICAgIGRlc3RbOF0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzA7XG4gICAgICAgIGRlc3RbOV0gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzE7XG4gICAgICAgIGRlc3RbMTBdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyICsgYjIzICogYTMyO1xuICAgICAgICBkZXN0WzExXSA9IGIyMCAqIGEwMyArIGIyMSAqIGExMyArIGIyMiAqIGEyMyArIGIyMyAqIGEzMztcbiAgICAgICAgZGVzdFsxMl0gPSBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzA7XG4gICAgICAgIGRlc3RbMTNdID0gYjMwICogYTAxICsgYjMxICogYTExICsgYjMyICogYTIxICsgYjMzICogYTMxO1xuICAgICAgICBkZXN0WzE0XSA9IGIzMCAqIGEwMiArIGIzMSAqIGExMiArIGIzMiAqIGEyMiArIGIzMyAqIGEzMjtcbiAgICAgICAgZGVzdFsxNV0gPSBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIHR3byBnaXZlbiAzeDMgbWF0cmljZXMgYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0MyhhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGExMSA9IGFbMF07XG4gICAgICAgIGNvbnN0IGExMiA9IGFbM107XG4gICAgICAgIGNvbnN0IGExMyA9IGFbNl07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEyMiA9IGFbNF07XG4gICAgICAgIGNvbnN0IGEyMyA9IGFbN107XG4gICAgICAgIGNvbnN0IGEzMSA9IGFbMl07XG4gICAgICAgIGNvbnN0IGEzMiA9IGFbNV07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbOF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbMF07XG4gICAgICAgIGNvbnN0IGIxMiA9IGJbM107XG4gICAgICAgIGNvbnN0IGIxMyA9IGJbNl07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGIyMiA9IGJbNF07XG4gICAgICAgIGNvbnN0IGIyMyA9IGJbN107XG4gICAgICAgIGNvbnN0IGIzMSA9IGJbMl07XG4gICAgICAgIGNvbnN0IGIzMiA9IGJbNV07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbOF07XG5cbiAgICAgICAgZGVzdFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcbiAgICAgICAgZGVzdFszXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcbiAgICAgICAgZGVzdFs2XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMztcblxuICAgICAgICBkZXN0WzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xuICAgICAgICBkZXN0WzRdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuICAgICAgICBkZXN0WzddID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xuXG4gICAgICAgIGRlc3RbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG4gICAgICAgIGRlc3RbNV0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG4gICAgICAgIGRlc3RbOF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4IGJ5IHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG11bE1hdDRTY2FsYXIobSwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IG1bMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogcztcbiAgICAgICAgZGVzdFs0XSA9IG1bNF0gKiBzO1xuICAgICAgICBkZXN0WzVdID0gbVs1XSAqIHM7XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdICogcztcbiAgICAgICAgZGVzdFs3XSA9IG1bN10gKiBzO1xuICAgICAgICBkZXN0WzhdID0gbVs4XSAqIHM7XG4gICAgICAgIGRlc3RbOV0gPSBtWzldICogcztcbiAgICAgICAgZGVzdFsxMF0gPSBtWzEwXSAqIHM7XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV0gKiBzO1xuICAgICAgICBkZXN0WzEyXSA9IG1bMTJdICogcztcbiAgICAgICAgZGVzdFsxM10gPSBtWzEzXSAqIHM7XG4gICAgICAgIGRlc3RbMTRdID0gbVsxNF0gKiBzO1xuICAgICAgICBkZXN0WzE1XSA9IG1bMTVdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXggYnkgdGhlIGdpdmVuIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0djRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NHY0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogdjAgKyBtWzRdICogdjEgKyBtWzhdICogdjIgKyBtWzEyXSAqIHYzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHYwICsgbVs1XSAqIHYxICsgbVs5XSAqIHYyICsgbVsxM10gKiB2MztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gKiB2MCArIG1bNl0gKiB2MSArIG1bMTBdICogdjIgKyBtWzE0XSAqIHYzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAqIHYwICsgbVs3XSAqIHYxICsgbVsxMV0gKiB2MiArIG1bMTVdICogdjM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNwb3NlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc3Bvc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgICAgIGNvbnN0IG00ID0gbWF0WzRdO1xuXG4gICAgICAgIGNvbnN0IG0xNCA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IG04ID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbMTNdO1xuICAgICAgICBjb25zdCBtMTIgPSBtYXRbMTJdO1xuICAgICAgICBjb25zdCBtOSA9IG1hdFs5XTtcbiAgICAgICAgaWYgKCFkZXN0IHx8IG1hdCA9PT0gZGVzdCkge1xuICAgICAgICAgICAgY29uc3QgYTAxID0gbWF0WzFdO1xuICAgICAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICAgICAgY29uc3QgYTAzID0gbWF0WzNdO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gbWF0WzZdO1xuICAgICAgICAgICAgY29uc3QgYTEzID0gbWF0WzddO1xuICAgICAgICAgICAgY29uc3QgYTIzID0gbWF0WzExXTtcbiAgICAgICAgICAgIG1hdFsxXSA9IG00O1xuICAgICAgICAgICAgbWF0WzJdID0gbTg7XG4gICAgICAgICAgICBtYXRbM10gPSBtMTI7XG4gICAgICAgICAgICBtYXRbNF0gPSBhMDE7XG4gICAgICAgICAgICBtYXRbNl0gPSBtOTtcbiAgICAgICAgICAgIG1hdFs3XSA9IG0xMztcbiAgICAgICAgICAgIG1hdFs4XSA9IGEwMjtcbiAgICAgICAgICAgIG1hdFs5XSA9IGExMjtcbiAgICAgICAgICAgIG1hdFsxMV0gPSBtMTQ7XG4gICAgICAgICAgICBtYXRbMTJdID0gYTAzO1xuICAgICAgICAgICAgbWF0WzEzXSA9IGExMztcbiAgICAgICAgICAgIG1hdFsxNF0gPSBhMjM7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgIGRlc3RbMV0gPSBtNDtcbiAgICAgICAgZGVzdFsyXSA9IG04O1xuICAgICAgICBkZXN0WzNdID0gbTEyO1xuICAgICAgICBkZXN0WzRdID0gbWF0WzFdO1xuICAgICAgICBkZXN0WzVdID0gbWF0WzVdO1xuICAgICAgICBkZXN0WzZdID0gbTk7XG4gICAgICAgIGRlc3RbN10gPSBtMTM7XG4gICAgICAgIGRlc3RbOF0gPSBtYXRbMl07XG4gICAgICAgIGRlc3RbOV0gPSBtYXRbNl07XG4gICAgICAgIGRlc3RbMTBdID0gbWF0WzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBtMTQ7XG4gICAgICAgIGRlc3RbMTJdID0gbWF0WzNdO1xuICAgICAgICBkZXN0WzEzXSA9IG1hdFs3XTtcbiAgICAgICAgZGVzdFsxNF0gPSBtYXRbMTFdO1xuICAgICAgICBkZXN0WzE1XSA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiAzeDMgbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0cmFuc3Bvc2VNYXQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zcG9zZU1hdDMobWF0LCBkZXN0KSB7XG4gICAgICAgIGlmIChkZXN0ID09PSBtYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgICAgIGNvbnN0IGEwMiA9IG1hdFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IG1hdFs1XTtcbiAgICAgICAgICAgIGRlc3RbMV0gPSBtYXRbM107XG4gICAgICAgICAgICBkZXN0WzJdID0gbWF0WzZdO1xuICAgICAgICAgICAgZGVzdFszXSA9IGEwMTtcbiAgICAgICAgICAgIGRlc3RbNV0gPSBtYXRbN107XG4gICAgICAgICAgICBkZXN0WzZdID0gYTAyO1xuICAgICAgICAgICAgZGVzdFs3XSA9IGExMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0WzNdO1xuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdFs2XTtcbiAgICAgICAgICAgIGRlc3RbM10gPSBtYXRbMV07XG4gICAgICAgICAgICBkZXN0WzRdID0gbWF0WzRdO1xuICAgICAgICAgICAgZGVzdFs1XSA9IG1hdFs3XTtcbiAgICAgICAgICAgIGRlc3RbNl0gPSBtYXRbMl07XG4gICAgICAgICAgICBkZXN0WzddID0gbWF0WzVdO1xuICAgICAgICAgICAgZGVzdFs4XSA9IG1hdFs4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBkZXRlcm1pbmFudE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZGV0ZXJtaW5hbnRNYXQ0KG1hdCkge1xuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBhMzAgKiBhMjEgKiBhMTIgKiBhMDMgLSBhMjAgKiBhMzEgKiBhMTIgKiBhMDMgLSBhMzAgKiBhMTEgKiBhMjIgKiBhMDMgKyBhMTAgKiBhMzEgKiBhMjIgKiBhMDMgK1xuICAgICAgICAgICAgYTIwICogYTExICogYTMyICogYTAzIC0gYTEwICogYTIxICogYTMyICogYTAzIC0gYTMwICogYTIxICogYTAyICogYTEzICsgYTIwICogYTMxICogYTAyICogYTEzICtcbiAgICAgICAgICAgIGEzMCAqIGEwMSAqIGEyMiAqIGExMyAtIGEwMCAqIGEzMSAqIGEyMiAqIGExMyAtIGEyMCAqIGEwMSAqIGEzMiAqIGExMyArIGEwMCAqIGEyMSAqIGEzMiAqIGExMyArXG4gICAgICAgICAgICBhMzAgKiBhMTEgKiBhMDIgKiBhMjMgLSBhMTAgKiBhMzEgKiBhMDIgKiBhMjMgLSBhMzAgKiBhMDEgKiBhMTIgKiBhMjMgKyBhMDAgKiBhMzEgKiBhMTIgKiBhMjMgK1xuICAgICAgICAgICAgYTEwICogYTAxICogYTMyICogYTIzIC0gYTAwICogYTExICogYTMyICogYTIzIC0gYTIwICogYTExICogYTAyICogYTMzICsgYTEwICogYTIxICogYTAyICogYTMzICtcbiAgICAgICAgICAgIGEyMCAqIGEwMSAqIGExMiAqIGEzMyAtIGEwMCAqIGEyMSAqIGExMiAqIGEzMyAtIGExMCAqIGEwMSAqIGEyMiAqIGEzMyArIGEwMCAqIGExMSAqIGEyMiAqIGEzMztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGludmVyc2VNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGludmVyc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCAoaW5saW5lZCB0byBhdm9pZCBkb3VibGUtY2FjaGluZylcbiAgICAgICAgY29uc3QgaW52RGV0ID0gMSAvIChiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgICAgIGRlc3RbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxXSA9ICgtYTAxICogYjExICsgYTAyICogYjEwIC0gYTAzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzNdID0gKC1hMjEgKiBiMDUgKyBhMjIgKiBiMDQgLSBhMjMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzRdID0gKC1hMTAgKiBiMTEgKyBhMTIgKiBiMDggLSBhMTMgKiBiMDcpICogaW52RGV0O1xuICAgICAgICBkZXN0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbNl0gPSAoLWEzMCAqIGIwNSArIGEzMiAqIGIwMiAtIGEzMyAqIGIwMSkgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGludkRldDtcbiAgICAgICAgZGVzdFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzldID0gKC1hMDAgKiBiMTAgKyBhMDEgKiBiMDggLSBhMDMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzExXSA9ICgtYTIwICogYjA0ICsgYTIxICogYjAyIC0gYTIzICogYjAwKSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxMl0gPSAoLWExMCAqIGIwOSArIGExMSAqIGIwNyAtIGExMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTRdID0gKC1hMzAgKiBiMDMgKyBhMzEgKiBiMDEgLSBhMzIgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogaW52RGV0O1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFjZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYWNlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFjZU1hdDQobSkge1xuICAgICAgICByZXR1cm4gKG1bMF0gKyBtWzVdICsgbVsxMF0gKyBtWzE1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDR2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgbVsxMl0gPSB2WzBdO1xuICAgICAgICBtWzEzXSA9IHZbMV07XG4gICAgICAgIG1bMTRdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0M1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDN2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDMoKTtcbiAgICAgICAgbVs2XSA9IHZbMF07XG4gICAgICAgIG1bN10gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRpb25NYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDRjOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgeHl6ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICByZXR1cm4gKHgsIHksIHosIGRlc3QpID0+IHtcbiAgICAgICAgICAgIHh5elswXSA9IHg7XG4gICAgICAgICAgICB4eXpbMV0gPSB5O1xuICAgICAgICAgICAgeHl6WzJdID0gejtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNsYXRpb25NYXQ0cyhzLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NGMocywgcywgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWF0NHYoeHl6LCBtKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0ZU1hdDRjKHh5elswXSwgeHl6WzFdLCB4eXpbMl0sIG0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnRseSBwb3N0LWNvbmNhdGVuYXRlcyBhIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB6XG4gICAgICogQHBhcmFtIG1cbiAgICAgKi9cbiAgICBPTER0cmFuc2xhdGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIG1bMF0gKz0gbTEyICogeDtcbiAgICAgICAgbVs0XSArPSBtMTIgKiB5O1xuICAgICAgICBtWzhdICs9IG0xMiAqIHo7XG5cbiAgICAgICAgY29uc3QgbTEzID0gbVsxM107XG4gICAgICAgIG1bMV0gKz0gbTEzICogeDtcbiAgICAgICAgbVs1XSArPSBtMTMgKiB5O1xuICAgICAgICBtWzldICs9IG0xMyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIG1bMl0gKz0gbTE0ICogeDtcbiAgICAgICAgbVs2XSArPSBtMTQgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTQgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzNdICs9IG0xNSAqIHg7XG4gICAgICAgIG1bN10gKz0gbTE1ICogeTtcbiAgICAgICAgbVsxMV0gKz0gbTE1ICogejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlTWF0NGMoeCwgeSwgeiwgbSkge1xuXG4gICAgICAgIGNvbnN0IG0zID0gbVszXTtcbiAgICAgICAgbVswXSArPSBtMyAqIHg7XG4gICAgICAgIG1bMV0gKz0gbTMgKiB5O1xuICAgICAgICBtWzJdICs9IG0zICogejtcblxuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIG1bNF0gKz0gbTcgKiB4O1xuICAgICAgICBtWzVdICs9IG03ICogeTtcbiAgICAgICAgbVs2XSArPSBtNyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIG1bOF0gKz0gbTExICogeDtcbiAgICAgICAgbVs5XSArPSBtMTEgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTEgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzEyXSArPSBtMTUgKiB4O1xuICAgICAgICBtWzEzXSArPSBtMTUgKiB5O1xuICAgICAgICBtWzE0XSArPSBtMTUgKiB6O1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCB0aGF0IHJlcGxhY2VzIHRoZSB0cmFuc2xhdGlvbiBpbiB0aGUgcmlnaHRtb3N0IGNvbHVtbiBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBhZmZpbmUgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSBtXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIGRlc3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRNYXQ0VHJhbnNsYXRpb24obSwgdHJhbnNsYXRpb24sIGRlc3QpIHtcblxuICAgICAgICBkZXN0WzBdID0gbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdO1xuICAgICAgICBkZXN0WzNdID0gbVszXTtcblxuICAgICAgICBkZXN0WzRdID0gbVs0XTtcbiAgICAgICAgZGVzdFs1XSA9IG1bNV07XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gbVs3XTtcblxuICAgICAgICBkZXN0WzhdID0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IG1bOV07XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV07XG5cbiAgICAgICAgZGVzdFsxMl0gPSB0cmFuc2xhdGlvblswXTtcbiAgICAgICAgZGVzdFsxM10gPSB0cmFuc2xhdGlvblsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB0cmFuc2xhdGlvblsyXTtcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgcm90YXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgcm90YXRpb25NYXQ0dlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICByb3RhdGlvbk1hdDR2KGFuZ2xlcmFkLCBheGlzLCBtKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gbWF0aC5ub3JtYWxpemVWZWM0KFtheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdLCAwLjBdLCBbXSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IHEgPSAxLjAgLSBjO1xuXG4gICAgICAgIGNvbnN0IHggPSBheFswXTtcbiAgICAgICAgY29uc3QgeSA9IGF4WzFdO1xuICAgICAgICBjb25zdCB6ID0gYXhbMl07XG5cbiAgICAgICAgbGV0IHh5O1xuICAgICAgICBsZXQgeXo7XG4gICAgICAgIGxldCB6eDtcbiAgICAgICAgbGV0IHhzO1xuICAgICAgICBsZXQgeXM7XG4gICAgICAgIGxldCB6cztcblxuICAgICAgICAvL3h4ID0geCAqIHg7IHVzZWQgb25jZVxuICAgICAgICAvL3l5ID0geSAqIHk7IHVzZWQgb25jZVxuICAgICAgICAvL3p6ID0geiAqIHo7IHVzZWQgb25jZVxuICAgICAgICB4eSA9IHggKiB5O1xuICAgICAgICB5eiA9IHkgKiB6O1xuICAgICAgICB6eCA9IHogKiB4O1xuICAgICAgICB4cyA9IHggKiBzO1xuICAgICAgICB5cyA9IHkgKiBzO1xuICAgICAgICB6cyA9IHogKiBzO1xuXG4gICAgICAgIG0gPSBtIHx8IG1hdGgubWF0NCgpO1xuXG4gICAgICAgIG1bMF0gPSAocSAqIHggKiB4KSArIGM7XG4gICAgICAgIG1bMV0gPSAocSAqIHh5KSArIHpzO1xuICAgICAgICBtWzJdID0gKHEgKiB6eCkgLSB5cztcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gKHEgKiB4eSkgLSB6cztcbiAgICAgICAgbVs1XSA9IChxICogeSAqIHkpICsgYztcbiAgICAgICAgbVs2XSA9IChxICogeXopICsgeHM7XG4gICAgICAgIG1bN10gPSAwLjA7XG5cbiAgICAgICAgbVs4XSA9IChxICogengpICsgeXM7XG4gICAgICAgIG1bOV0gPSAocSAqIHl6KSAtIHhzO1xuICAgICAgICBtWzEwXSA9IChxICogeiAqIHopICsgYztcbiAgICAgICAgbVsxMV0gPSAwLjA7XG5cbiAgICAgICAgbVsxMl0gPSAwLjA7XG4gICAgICAgIG1bMTNdID0gMC4wO1xuICAgICAgICBtWzE0XSA9IDAuMDtcbiAgICAgICAgbVsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHJvdGF0aW9uTWF0NGNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcm90YXRpb25NYXQ0YyhhbmdsZXJhZCwgeCwgeSwgeiwgbWF0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnJvdGF0aW9uTWF0NHYoYW5nbGVyYWQsIFt4LCB5LCB6XSwgbWF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0dih2LCBtID0gbWF0aC5pZGVudGl0eU1hdDQoKSkge1xuICAgICAgICBtWzBdID0gdlswXTtcbiAgICAgICAgbVs1XSA9IHZbMV07XG4gICAgICAgIG1bMTBdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHNjYWxlIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHNjYWxpbmdNYXQzdlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzY2FsaW5nTWF0M3YodiwgbSA9IG1hdGguaWRlbnRpdHlNYXQzKCkpIHtcbiAgICAgICAgbVswXSA9IHZbMF07XG4gICAgICAgIG1bNF0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0YzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHh5eiA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh4LCB5LCB6LCBkZXN0KSA9PiB7XG4gICAgICAgICAgICB4eXpbMF0gPSB4O1xuICAgICAgICAgICAgeHl6WzFdID0geTtcbiAgICAgICAgICAgIHh5elsyXSA9IHo7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsaW5nTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgc2NhbGluZyB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGVNYXQ0Y1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gelxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgbVswXSAqPSB4O1xuICAgICAgICBtWzRdICo9IHk7XG4gICAgICAgIG1bOF0gKj0gejtcblxuICAgICAgICBtWzFdICo9IHg7XG4gICAgICAgIG1bNV0gKj0geTtcbiAgICAgICAgbVs5XSAqPSB6O1xuXG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuXG4gICAgICAgIG1bM10gKj0geDtcbiAgICAgICAgbVs3XSAqPSB5O1xuICAgICAgICBtWzExXSAqPSB6O1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRWZmaWNpZW50bHkgcG9zdC1jb25jYXRlbmF0ZXMgYSBzY2FsaW5nIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBzY2FsZU1hdDRjXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0dih4eXosIG0pIHtcblxuICAgICAgICBjb25zdCB4ID0geHl6WzBdO1xuICAgICAgICBjb25zdCB5ID0geHl6WzFdO1xuICAgICAgICBjb25zdCB6ID0geHl6WzJdO1xuXG4gICAgICAgIG1bMF0gKj0geDtcbiAgICAgICAgbVs0XSAqPSB5O1xuICAgICAgICBtWzhdICo9IHo7XG4gICAgICAgIG1bMV0gKj0geDtcbiAgICAgICAgbVs1XSAqPSB5O1xuICAgICAgICBtWzldICo9IHo7XG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuICAgICAgICBtWzNdICo9IHg7XG4gICAgICAgIG1bN10gKj0geTtcbiAgICAgICAgbVsxMV0gKj0gejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0cyhzKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjYWxpbmdNYXQ0YyhzLCBzLCBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgRGVzdGluYXRpb24gbWF0cml4XG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICovXG4gICAgcm90YXRpb25UcmFuc2xhdGlvbk1hdDQocSwgdiwgZGVzdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIGNvbnN0IHggPSBxWzBdO1xuICAgICAgICBjb25zdCB5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcgPSBxWzNdO1xuXG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICAgICAgY29uc3QgeHogPSB4ICogejI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG5cbiAgICAgICAgZGVzdFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgICAgIGRlc3RbMV0gPSB4eSArIHd6O1xuICAgICAgICBkZXN0WzJdID0geHogLSB3eTtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSB4eSAtIHd6O1xuICAgICAgICBkZXN0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICAgICAgZGVzdFs2XSA9IHl6ICsgd3g7XG4gICAgICAgIGRlc3RbN10gPSAwO1xuICAgICAgICBkZXN0WzhdID0geHogKyB3eTtcbiAgICAgICAgZGVzdFs5XSA9IHl6IC0gd3g7XG4gICAgICAgIGRlc3RbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICAgICAgZGVzdFsxMV0gPSAwO1xuICAgICAgICBkZXN0WzEyXSA9IHZbMF07XG4gICAgICAgIGRlc3RbMTNdID0gdlsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB2WzJdO1xuICAgICAgICBkZXN0WzE1XSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgRXVsZXIgYW5nbGVzIGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0IFRoZSA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBEZXNpcmVkIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gRXVsZXIgYW5nbGVzLCBjcmVhdGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgRXVsZXIgYW5nbGVzLlxuICAgICAqL1xuICAgIG1hdDRUb0V1bGVyKG1hdCwgb3JkZXIsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBjbGFtcCA9IG1hdGguY2xhbXA7XG5cbiAgICAgICAgLy8gQXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICBjb25zdCBtMTEgPSBtYXRbMF07XG5cbiAgICAgICAgY29uc3QgbTEyID0gbWF0WzRdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBtMjMgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1hdFsyXTtcbiAgICAgICAgY29uc3QgbTMyID0gbWF0WzZdO1xuICAgICAgICBjb25zdCBtMzMgPSBtYXRbMTBdO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMTMpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIoLW0xMiwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1lYWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMihtMTMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIobTIxLCBtMjIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmFzaW4oY2xhbXAobTMyLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMzMpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMzEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzJdID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1laWCcpIHtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0yMik7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmFzaW4oLWNsYW1wKG0xMiwgLTEsIDEpKTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb21wb3NlTWF0NChwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUsIG1hdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIG1hdGgucXVhdGVybmlvblRvUm90YXRpb25NYXQ0KHF1YXRlcm5pb24sIG1hdCk7XG4gICAgICAgIG1hdGguc2NhbGVNYXQ0dihzY2FsZSwgbWF0KTtcbiAgICAgICAgbWF0aC50cmFuc2xhdGVNYXQ0dihwb3NpdGlvbiwgbWF0KTtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICBkZWNvbXBvc2VNYXQ0OiAoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKG1hdCwgcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlKSB7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFswXTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFsxXTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFsyXTtcblxuICAgICAgICAgICAgbGV0IHN4ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFs0XTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFs1XTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFs2XTtcblxuICAgICAgICAgICAgY29uc3Qgc3kgPSBtYXRoLmxlblZlYzModmVjKTtcblxuICAgICAgICAgICAgdmVjWzhdID0gbWF0WzhdO1xuICAgICAgICAgICAgdmVjWzldID0gbWF0WzldO1xuICAgICAgICAgICAgdmVjWzEwXSA9IG1hdFsxMF07XG5cbiAgICAgICAgICAgIGNvbnN0IHN6ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRldGVybWluYW50TWF0NChtYXQpO1xuXG4gICAgICAgICAgICBpZiAoZGV0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvblswXSA9IG1hdFsxMl07XG4gICAgICAgICAgICBwb3NpdGlvblsxXSA9IG1hdFsxM107XG4gICAgICAgICAgICBwb3NpdGlvblsyXSA9IG1hdFsxNF07XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgICAgICAgICBtYXRyaXguc2V0KG1hdCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xuICAgICAgICAgICAgY29uc3QgaW52U1kgPSAxIC8gc3k7XG4gICAgICAgICAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgICAgICAgICAgbWF0cml4WzBdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzFdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzJdICo9IGludlNYO1xuXG4gICAgICAgICAgICBtYXRyaXhbNF0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNV0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNl0gKj0gaW52U1k7XG5cbiAgICAgICAgICAgIG1hdHJpeFs4XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFs5XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFsxMF0gKj0gaW52U1o7XG5cbiAgICAgICAgICAgIG1hdGgubWF0NFRvUXVhdGVybmlvbihtYXRyaXgsIHF1YXRlcm5pb24pO1xuXG4gICAgICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgICAgIHNjYWxlWzJdID0gc3o7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KSgpLFxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZ2V0Q29sTWF0NChtYXQsIGMpIHtcbiAgICAgICAgY29uc3QgaSA9IGMgKiA0O1xuICAgICAgICByZXR1cm4gW21hdFtpXSwgbWF0W2kgKyAxXSwgbWF0W2kgKyAyXSwgbWF0W2kgKyAzXV07XG4gICAgfSxcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHNldFJvd01hdDQobWF0LCByLCB2KSB7XG4gICAgICAgIG1hdFtyXSA9IHZbMF07XG4gICAgICAgIG1hdFtyICsgNF0gPSB2WzFdO1xuICAgICAgICBtYXRbciArIDhdID0gdlsyXTtcbiAgICAgICAgbWF0W3IgKyAxMl0gPSB2WzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0ICdsb29rYXQnIHZpZXdpbmcgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGxvb2tBdE1hdDR2XG4gICAgICogQHBhcmFtIHBvcyB2ZWMzIHBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHZlYzMgcG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gICAgICogQHBhcmFtIHVwIHZlYzMgcG9pbnRpbmcgXCJ1cFwiXG4gICAgICogQHBhcmFtIGRlc3QgbWF0NCBPcHRpb25hbCwgbWF0NCBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21hdDR9IGRlc3QgaWYgc3BlY2lmaWVkLCBhIG5ldyBtYXQ0IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGxvb2tBdE1hdDR2KHBvcywgdGFyZ2V0LCB1cCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXRoLm1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc3ggPSBwb3NbMF07XG4gICAgICAgIGNvbnN0IHBvc3kgPSBwb3NbMV07XG4gICAgICAgIGNvbnN0IHBvc3ogPSBwb3NbMl07XG4gICAgICAgIGNvbnN0IHVweCA9IHVwWzBdO1xuICAgICAgICBjb25zdCB1cHkgPSB1cFsxXTtcbiAgICAgICAgY29uc3QgdXB6ID0gdXBbMl07XG4gICAgICAgIGNvbnN0IHRhcmdldHggPSB0YXJnZXRbMF07XG4gICAgICAgIGNvbnN0IHRhcmdldHkgPSB0YXJnZXRbMV07XG4gICAgICAgIGNvbnN0IHRhcmdldHogPSB0YXJnZXRbMl07XG5cbiAgICAgICAgaWYgKHBvc3ggPT09IHRhcmdldHggJiYgcG9zeSA9PT0gdGFyZ2V0eSAmJiBwb3N6ID09PSB0YXJnZXR6KSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB6MDtcbiAgICAgICAgbGV0IHoxO1xuICAgICAgICBsZXQgejI7XG4gICAgICAgIGxldCB4MDtcbiAgICAgICAgbGV0IHgxO1xuICAgICAgICBsZXQgeDI7XG4gICAgICAgIGxldCB5MDtcbiAgICAgICAgbGV0IHkxO1xuICAgICAgICBsZXQgeTI7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgLy92ZWMzLmRpcmVjdGlvbihleWUsIGNlbnRlciwgeik7XG4gICAgICAgIHowID0gcG9zeCAtIHRhcmdldHg7XG4gICAgICAgIHoxID0gcG9zeSAtIHRhcmdldHk7XG4gICAgICAgIHoyID0gcG9zeiAtIHRhcmdldHo7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIChubyBjaGVjayBuZWVkZWQgZm9yIDAgYmVjYXVzZSBvZiBlYXJseSByZXR1cm4pXG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICAgICAgejAgKj0gbGVuO1xuICAgICAgICB6MSAqPSBsZW47XG4gICAgICAgIHoyICo9IGxlbjtcblxuICAgICAgICAvL3ZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHosIHgpKTtcbiAgICAgICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICB4MCA9IDA7XG4gICAgICAgICAgICB4MSA9IDA7XG4gICAgICAgICAgICB4MiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICAgICAgeDIgKj0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy92ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHosIHgsIHkpKTtcbiAgICAgICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICAgICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICAgICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHkwID0gMDtcbiAgICAgICAgICAgIHkxID0gMDtcbiAgICAgICAgICAgIHkyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgICAgICB5MiAqPSBsZW47XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzBdID0geDA7XG4gICAgICAgIGRlc3RbMV0gPSB5MDtcbiAgICAgICAgZGVzdFsyXSA9IHowO1xuICAgICAgICBkZXN0WzNdID0gMDtcbiAgICAgICAgZGVzdFs0XSA9IHgxO1xuICAgICAgICBkZXN0WzVdID0geTE7XG4gICAgICAgIGRlc3RbNl0gPSB6MTtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSB4MjtcbiAgICAgICAgZGVzdFs5XSA9IHkyO1xuICAgICAgICBkZXN0WzEwXSA9IHoyO1xuICAgICAgICBkZXN0WzExXSA9IDA7XG4gICAgICAgIGRlc3RbMTJdID0gLSh4MCAqIHBvc3ggKyB4MSAqIHBvc3kgKyB4MiAqIHBvc3opO1xuICAgICAgICBkZXN0WzEzXSA9IC0oeTAgKiBwb3N4ICsgeTEgKiBwb3N5ICsgeTIgKiBwb3N6KTtcbiAgICAgICAgZGVzdFsxNF0gPSAtKHowICogcG9zeCArIHoxICogcG9zeSArIHoyICogcG9zeik7XG4gICAgICAgIGRlc3RbMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCAnbG9va2F0JyB2aWV3aW5nIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBsb29rQXRNYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsb29rQXRNYXQ0Yyhwb3N4LCBwb3N5LCBwb3N6LCB0YXJnZXR4LCB0YXJnZXR5LCB0YXJnZXR6LCB1cHgsIHVweSwgdXB6KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmxvb2tBdE1hdDR2KFtwb3N4LCBwb3N5LCBwb3N6XSwgW3RhcmdldHgsIHRhcmdldHksIHRhcmdldHpdLCBbdXB4LCB1cHksIHVwel0sIFtdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBvcnRob01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG9ydGhvTWF0NGMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG5cbiAgICAgICAgZGVzdFswXSA9IDIuMCAvIHJsO1xuICAgICAgICBkZXN0WzFdID0gMC4wO1xuICAgICAgICBkZXN0WzJdID0gMC4wO1xuICAgICAgICBkZXN0WzNdID0gMC4wO1xuXG4gICAgICAgIGRlc3RbNF0gPSAwLjA7XG4gICAgICAgIGRlc3RbNV0gPSAyLjAgLyB0YjtcbiAgICAgICAgZGVzdFs2XSA9IDAuMDtcbiAgICAgICAgZGVzdFs3XSA9IDAuMDtcblxuICAgICAgICBkZXN0WzhdID0gMC4wO1xuICAgICAgICBkZXN0WzldID0gMC4wO1xuICAgICAgICBkZXN0WzEwXSA9IC0yLjAgLyBmbjtcbiAgICAgICAgZGVzdFsxMV0gPSAwLjA7XG5cbiAgICAgICAgZGVzdFsxMl0gPSAtKGxlZnQgKyByaWdodCkgLyBybDtcbiAgICAgICAgZGVzdFsxM10gPSAtKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxNF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMS4wO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgZnJ1c3R1bU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGZydXN0dW1NYXQ0dihmbWluLCBmbWF4LCBtKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IG1hdGgubWF0NCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm1pbjQgPSBbZm1pblswXSwgZm1pblsxXSwgZm1pblsyXSwgMC4wXTtcbiAgICAgICAgY29uc3QgZm1heDQgPSBbZm1heFswXSwgZm1heFsxXSwgZm1heFsyXSwgMC4wXTtcblxuICAgICAgICBtYXRoLmFkZFZlYzQoZm1heDQsIGZtaW40LCB0ZW1wTWF0MSk7XG4gICAgICAgIG1hdGguc3ViVmVjNChmbWF4NCwgZm1pbjQsIHRlbXBNYXQyKTtcblxuICAgICAgICBjb25zdCB0ID0gMi4wICogZm1pbjRbMl07XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDIwID0gdGVtcE1hdDJbMF07XG4gICAgICAgIGNvbnN0IHRlbXBNYXQyMSA9IHRlbXBNYXQyWzFdO1xuICAgICAgICBjb25zdCB0ZW1wTWF0MjIgPSB0ZW1wTWF0MlsyXTtcblxuICAgICAgICBtWzBdID0gdCAvIHRlbXBNYXQyMDtcbiAgICAgICAgbVsxXSA9IDAuMDtcbiAgICAgICAgbVsyXSA9IDAuMDtcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gMC4wO1xuICAgICAgICBtWzVdID0gdCAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVs2XSA9IDAuMDtcbiAgICAgICAgbVs3XSA9IDAuMDtcblxuICAgICAgICBtWzhdID0gdGVtcE1hdDFbMF0gLyB0ZW1wTWF0MjA7XG4gICAgICAgIG1bOV0gPSB0ZW1wTWF0MVsxXSAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVsxMF0gPSAtdGVtcE1hdDFbMl0gLyB0ZW1wTWF0MjI7XG4gICAgICAgIG1bMTFdID0gLTEuMDtcblxuICAgICAgICBtWzEyXSA9IDAuMDtcbiAgICAgICAgbVsxM10gPSAwLjA7XG4gICAgICAgIG1bMTRdID0gLXQgKiBmbWF4NFsyXSAvIHRlbXBNYXQyMjtcbiAgICAgICAgbVsxNV0gPSAwLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBmcnVzdHVtTWF0NHZcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZnJ1c3R1bU1hdDQobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG4gICAgICAgIGRlc3RbMF0gPSAobmVhciAqIDIpIC8gcmw7XG4gICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICBkZXN0WzJdID0gMDtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSAwO1xuICAgICAgICBkZXN0WzVdID0gKG5lYXIgKiAyKSAvIHRiO1xuICAgICAgICBkZXN0WzZdID0gMDtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSAocmlnaHQgKyBsZWZ0KSAvIHJsO1xuICAgICAgICBkZXN0WzldID0gKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxMF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTFdID0gLTE7XG4gICAgICAgIGRlc3RbMTJdID0gMDtcbiAgICAgICAgZGVzdFsxM10gPSAwO1xuICAgICAgICBkZXN0WzE0XSA9IC0oZmFyICogbmVhciAqIDIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBwZXJzcGVjdGl2ZU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHBlcnNwZWN0aXZlTWF0NChmb3Z5cmFkLCBhc3BlY3RyYXRpbywgem5lYXIsIHpmYXIsIG0pIHtcbiAgICAgICAgY29uc3QgcG1pbiA9IFtdO1xuICAgICAgICBjb25zdCBwbWF4ID0gW107XG5cbiAgICAgICAgcG1pblsyXSA9IHpuZWFyO1xuICAgICAgICBwbWF4WzJdID0gemZhcjtcblxuICAgICAgICBwbWF4WzFdID0gcG1pblsyXSAqIE1hdGgudGFuKGZvdnlyYWQgLyAyLjApO1xuICAgICAgICBwbWluWzFdID0gLXBtYXhbMV07XG5cbiAgICAgICAgcG1heFswXSA9IHBtYXhbMV0gKiBhc3BlY3RyYXRpbztcbiAgICAgICAgcG1pblswXSA9IC1wbWF4WzBdO1xuXG4gICAgICAgIHJldHVybiBtYXRoLmZydXN0dW1NYXQ0dihwbWluLCBwbWF4LCBtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gNHg0IG1hdHJpY2VzIGFyZSB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gbTFcbiAgICAgKiBAcGFyYW0gbTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wYXJlTWF0NChtMSwgbTIpIHtcbiAgICAgICAgcmV0dXJuIG0xWzBdID09PSBtMlswXSAmJlxuICAgICAgICAgICAgbTFbMV0gPT09IG0yWzFdICYmXG4gICAgICAgICAgICBtMVsyXSA9PT0gbTJbMl0gJiZcbiAgICAgICAgICAgIG0xWzNdID09PSBtMlszXSAmJlxuICAgICAgICAgICAgbTFbNF0gPT09IG0yWzRdICYmXG4gICAgICAgICAgICBtMVs1XSA9PT0gbTJbNV0gJiZcbiAgICAgICAgICAgIG0xWzZdID09PSBtMls2XSAmJlxuICAgICAgICAgICAgbTFbN10gPT09IG0yWzddICYmXG4gICAgICAgICAgICBtMVs4XSA9PT0gbTJbOF0gJiZcbiAgICAgICAgICAgIG0xWzldID09PSBtMls5XSAmJlxuICAgICAgICAgICAgbTFbMTBdID09PSBtMlsxMF0gJiZcbiAgICAgICAgICAgIG0xWzExXSA9PT0gbTJbMTFdICYmXG4gICAgICAgICAgICBtMVsxMl0gPT09IG0yWzEyXSAmJlxuICAgICAgICAgICAgbTFbMTNdID09PSBtMlsxM10gJiZcbiAgICAgICAgICAgIG0xWzE0XSA9PT0gbTJbMTRdICYmXG4gICAgICAgICAgICBtMVsxNV0gPT09IG0yWzE1XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIHRocmVlLWVsZW1lbnQgcG9zaXRpb24gYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9pbnQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50MyhtLCBwLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcblxuICAgICAgICBjb25zdCB4ID0gcFswXTtcbiAgICAgICAgY29uc3QgeSA9IHBbMV07XG4gICAgICAgIGNvbnN0IHogPSBwWzJdO1xuXG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHgpICsgKG1bNF0gKiB5KSArIChtWzhdICogeikgKyBtWzEyXTtcbiAgICAgICAgZGVzdFsxXSA9IChtWzFdICogeCkgKyAobVs1XSAqIHkpICsgKG1bOV0gKiB6KSArIG1bMTNdO1xuICAgICAgICBkZXN0WzJdID0gKG1bMl0gKiB4KSArIChtWzZdICogeSkgKyAobVsxMF0gKiB6KSArIG1bMTRdO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgaG9tb2dlbmVvdXMgY29vcmRpbmF0ZSBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBkZXN0WzBdID0gbVswXSAqIHZbMF0gKyBtWzRdICogdlsxXSArIG1bOF0gKiB2WzJdICsgbVsxMl0gKiB2WzNdO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHZbMF0gKyBtWzVdICogdlsxXSArIG1bOV0gKiB2WzJdICsgbVsxM10gKiB2WzNdO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHZbMF0gKyBtWzZdICogdlsxXSArIG1bMTBdICogdlsyXSArIG1bMTRdICogdlszXTtcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzExXSAqIHZbMl0gKyBtWzE1XSAqIHZbM107XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiB0aHJlZS1lbGVtZW50IHBvc2l0aW9ucyBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludHMzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50czMobSwgcG9pbnRzLCBwb2ludHMyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBvaW50czIgfHwgW107XG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCBwMDtcbiAgICAgICAgbGV0IHAxO1xuICAgICAgICBsZXQgcDI7XG4gICAgICAgIGxldCBwaTtcblxuICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuXG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgbGV0IHI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgICAgIHBpID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBwMCA9IHBpWzBdO1xuICAgICAgICAgICAgcDEgPSBwaVsxXTtcbiAgICAgICAgICAgIHAyID0gcGlbMl07XG5cbiAgICAgICAgICAgIHIgPSByZXN1bHRbaV0gfHwgKHJlc3VsdFtpXSA9IFswLCAwLCAwXSk7XG5cbiAgICAgICAgICAgIHJbMF0gPSAobTAgKiBwMCkgKyAobTQgKiBwMSkgKyAobTggKiBwMikgKyBtMTI7XG4gICAgICAgICAgICByWzFdID0gKG0xICogcDApICsgKG01ICogcDEpICsgKG05ICogcDIpICsgbTEzO1xuICAgICAgICAgICAgclsyXSA9IChtMiAqIHAwKSArIChtNiAqIHAxKSArIChtMTAgKiBwMikgKyBtMTQ7XG4gICAgICAgICAgICByWzNdID0gKG0zICogcDApICsgKG03ICogcDEpICsgKG0xMSAqIHAyKSArIG0xNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW47XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9zaXRpb25zM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1Qb3NpdGlvbnMzKG0sIHAsIHAyID0gcCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgbGVuID0gcC5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgejtcblxuICAgICAgICBjb25zdCBtMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHggPSBwW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBwW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwW2kgKyAyXTtcblxuICAgICAgICAgICAgcDJbaSArIDBdID0gKG0wICogeCkgKyAobTQgKiB5KSArIChtOCAqIHopICsgbTEyO1xuICAgICAgICAgICAgcDJbaSArIDFdID0gKG0xICogeCkgKyAobTUgKiB5KSArIChtOSAqIHopICsgbTEzO1xuICAgICAgICAgICAgcDJbaSArIDJdID0gKG0yICogeCkgKyAobTYgKiB5KSArIChtMTAgKiB6KSArIG0xNDtcbiAgICAgICAgICAgIHAyW2kgKyAzXSA9IChtMyAqIHgpICsgKG03ICogeSkgKyAobTExICogeikgKyBtMTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgcG9zaXRpb25zIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zZm9ybVBvc2l0aW9uczRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9zaXRpb25zNChtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWMzKG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgZGVzdCA9IGRlc3QgfHwgdGhpcy52ZWMzKCk7XG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHYwKSArIChtWzRdICogdjEpICsgKG1bOF0gKiB2Mik7XG4gICAgICAgIGRlc3RbMV0gPSAobVsxXSAqIHYwKSArIChtWzVdICogdjEpICsgKG1bOV0gKiB2Mik7XG4gICAgICAgIGRlc3RbMl0gPSAobVsyXSAqIHYwKSArIChtWzZdICogdjEpICsgKG1bMTBdICogdjIpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWM0KG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICBkZXN0ID0gZGVzdCB8fCBtYXRoLnZlYzQoKTtcbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKiB2MCArIG1bNF0gKiB2MSArIG1bOF0gKiB2MiArIG1bMTJdICogdjM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdICogdjAgKyBtWzVdICogdjEgKyBtWzldICogdjIgKyBtWzEzXSAqIHYzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHYwICsgbVs2XSAqIHYxICsgbVsxMF0gKiB2MiArIG1bMTRdICogdjM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogdjAgKyBtWzddICogdjEgKyBtWzExXSAqIHYyICsgbVsxNV0gKiB2MztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNYKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXTtcbiAgICAgICAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhjKSAtIHBbMl0gKiBNYXRoLnNpbihjKTtcbiAgICAgICAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihjKSArIHBbMl0gKiBNYXRoLmNvcyhjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNZKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFsyXSAqIE1hdGguc2luKGMpICsgcFswXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzFdID0gcFsxXTtcbiAgICAgICAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhjKSAtIHBbMF0gKiBNYXRoLnNpbihjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNaKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXSAqIE1hdGguY29zKGMpIC0gcFsxXSAqIE1hdGguc2luKGMpO1xuICAgICAgICByWzFdID0gcFswXSAqIE1hdGguc2luKGMpICsgcFsxXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzJdID0gcFsyXTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yIGJ5IGEgNHg0IHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcm9qZWN0VmVjNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHAgM0QgVmlldy1zcGFjZSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcSAyRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gMkQgUHJvamVjdGVkIGNvb3JkaW5hdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcHJvamVjdFZlYzQocCwgcSkge1xuICAgICAgICBjb25zdCBmID0gMS4wIC8gcFszXTtcbiAgICAgICAgcSA9IHEgfHwgbWF0aC52ZWMyKCk7XG4gICAgICAgIHFbMF0gPSBwWzBdICogZjtcbiAgICAgICAgcVsxXSA9IHBbMV0gKiBmO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5wcm9qZWN0cyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnByb2plY3RWZWMzXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcCAzRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXQgVmlldyBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IHByb2pNYXQgUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdW5wcm9qZWN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSgxNik7XG4gICAgICAgIGNvbnN0IG1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuICAgICAgICBjb25zdCBtYXQzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwLCB2aWV3TWF0LCBwcm9qTWF0LCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1WZWMzKHRoaXMubXVsTWF0NCh0aGlzLmludmVyc2VNYXQ0KHZpZXdNYXQsIG1hdCksIHRoaXMuaW52ZXJzZU1hdDQocHJvak1hdCwgbWF0MiksIG1hdDMpLCBwLCBxKVxuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIDNEIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBsZXJwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwVmVjMyh0LCB0MSwgdDIsIHAxLCBwMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgudmVjMygpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IHAxWzBdICsgKGYgKiAocDJbMF0gLSBwMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBwMVsxXSArIChmICogKHAyWzFdIC0gcDFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gcDFbMl0gKyAoZiAqIChwMlsyXSAtIHAxWzJdKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHR3byA0eDQgbWF0cmljZXMuXG4gICAgICogQG1ldGhvZCBsZXJwTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwTWF0NCh0LCB0MSwgdDIsIG0xLCBtMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgubWF0NCgpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IG0xWzBdICsgKGYgKiAobTJbMF0gLSBtMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBtMVsxXSArIChmICogKG0yWzFdIC0gbTFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gbTFbMl0gKyAoZiAqIChtMlsyXSAtIG0xWzJdKSk7XG4gICAgICAgIHJlc3VsdFszXSA9IG0xWzNdICsgKGYgKiAobTJbM10gLSBtMVszXSkpO1xuICAgICAgICByZXN1bHRbNF0gPSBtMVs0XSArIChmICogKG0yWzRdIC0gbTFbNF0pKTtcbiAgICAgICAgcmVzdWx0WzVdID0gbTFbNV0gKyAoZiAqIChtMls1XSAtIG0xWzVdKSk7XG4gICAgICAgIHJlc3VsdFs2XSA9IG0xWzZdICsgKGYgKiAobTJbNl0gLSBtMVs2XSkpO1xuICAgICAgICByZXN1bHRbN10gPSBtMVs3XSArIChmICogKG0yWzddIC0gbTFbN10pKTtcbiAgICAgICAgcmVzdWx0WzhdID0gbTFbOF0gKyAoZiAqIChtMls4XSAtIG0xWzhdKSk7XG4gICAgICAgIHJlc3VsdFs5XSA9IG0xWzldICsgKGYgKiAobTJbOV0gLSBtMVs5XSkpO1xuICAgICAgICByZXN1bHRbMTBdID0gbTFbMTBdICsgKGYgKiAobTJbMTBdIC0gbTFbMTBdKSk7XG4gICAgICAgIHJlc3VsdFsxMV0gPSBtMVsxMV0gKyAoZiAqIChtMlsxMV0gLSBtMVsxMV0pKTtcbiAgICAgICAgcmVzdWx0WzEyXSA9IG0xWzEyXSArIChmICogKG0yWzEyXSAtIG0xWzEyXSkpO1xuICAgICAgICByZXN1bHRbMTNdID0gbTFbMTNdICsgKGYgKiAobTJbMTNdIC0gbTFbMTNdKSk7XG4gICAgICAgIHJlc3VsdFsxNF0gPSBtMVsxNF0gKyAoZiAqIChtMlsxNF0gLSBtMVsxNF0pKTtcbiAgICAgICAgcmVzdWx0WzE1XSA9IG0xWzE1XSArIChmICogKG0yWzE1XSAtIG0xWzE1XSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGludG8gYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZsYXR0ZW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheSBvZiBBcnJheXN9IGEgQSAyRCBhcnJheVxuICAgICAqIEByZXR1cm5zIEZsYXR0ZW5lZCAxRCBhcnJheVxuICAgICAqL1xuICAgIGZsYXR0ZW4oYSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW5qO1xuICAgICAgICBsZXQgaXRlbTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5pID0gYS5sZW5ndGg7IGkgPCBsZW5pOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuaiA9IGl0ZW0ubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIGlkZW50aXR5UXVhdGVybmlvbihkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgZGVzdFswXSA9IDAuMDtcbiAgICAgICAgZGVzdFsxXSA9IDAuMDtcbiAgICAgICAgZGVzdFsyXSA9IDAuMDtcbiAgICAgICAgZGVzdFszXSA9IDEuMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgcXVhdGVybmlvbiBmcm9tIEV1bGVyIGFuZ2xlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGV1bGVyIFRoZSBFdWxlciBhbmdsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gcXVhdGVybmlvbiwgY3JlYXRlZCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgZXVsZXJUb1F1YXRlcm5pb24oZXVsZXIsIG9yZGVyLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgICAgICAvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuICAgICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICAgICAgY29uc3QgYSA9IChldWxlclswXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYiA9IChldWxlclsxXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYyA9IChldWxlclsyXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcblxuICAgICAgICBjb25zdCBjMSA9IE1hdGguY29zKGEpO1xuICAgICAgICBjb25zdCBjMiA9IE1hdGguY29zKGIpO1xuICAgICAgICBjb25zdCBjMyA9IE1hdGguY29zKGMpO1xuICAgICAgICBjb25zdCBzMSA9IE1hdGguc2luKGEpO1xuICAgICAgICBjb25zdCBzMiA9IE1hdGguc2luKGIpO1xuICAgICAgICBjb25zdCBzMyA9IE1hdGguc2luKGMpO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgbWF0NFRvUXVhdGVybmlvbihtLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgICAgICAvLyBBc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMTBdO1xuICAgICAgICBsZXQgcztcblxuICAgICAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuICAgICAgICBpZiAodHJhY2UgPiAwKSB7XG5cbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuXG4gICAgICAgICAgICBkZXN0WzNdID0gMC4yNSAvIHM7XG4gICAgICAgICAgICBkZXN0WzBdID0gKG0zMiAtIG0yMykgKiBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IChtMTMgLSBtMzEpICogcztcbiAgICAgICAgICAgIGRlc3RbMl0gPSAobTIxIC0gbTEyKSAqIHM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTExIC0gbTIyIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMzIgLSBtMjMpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAwLjI1ICogcztcbiAgICAgICAgICAgIGRlc3RbMV0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0xMyArIG0zMSkgLyBzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobTIyID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMTMgLSBtMzEpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0yMyArIG0zMikgLyBzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEzICsgbTMxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gKG0yMyArIG0zMikgLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IDAuMjUgKiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNQYWlyVG9RdWF0ZXJuaW9uKHUsIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBub3JtX3Vfbm9ybV92ID0gTWF0aC5zcXJ0KG1hdGguZG90VmVjMyh1LCB1KSAqIG1hdGguZG90VmVjMyh2LCB2KSk7XG4gICAgICAgIGxldCByZWFsX3BhcnQgPSBub3JtX3Vfbm9ybV92ICsgbWF0aC5kb3RWZWMzKHUsIHYpO1xuXG4gICAgICAgIGlmIChyZWFsX3BhcnQgPCAwLjAwMDAwMDAxICogbm9ybV91X25vcm1fdikge1xuXG4gICAgICAgICAgICAvLyBJZiB1IGFuZCB2IGFyZSBleGFjdGx5IG9wcG9zaXRlLCByb3RhdGUgMTgwIGRlZ3JlZXNcbiAgICAgICAgICAgIC8vIGFyb3VuZCBhbiBhcmJpdHJhcnkgb3J0aG9nb25hbCBheGlzLiBBeGlzIG5vcm1hbGlzYXRpb25cbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gbGF0ZXIsIHdoZW4gd2Ugbm9ybWFsaXNlIHRoZSBxdWF0ZXJuaW9uLlxuXG4gICAgICAgICAgICByZWFsX3BhcnQgPSAwLjA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh1WzBdKSA+IE1hdGguYWJzKHVbMl0pKSB7XG5cbiAgICAgICAgICAgICAgICBkZXN0WzBdID0gLXVbMV07XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IHVbMF07XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IDA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IC11WzJdO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSB1WzFdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBxdWF0ZXJuaW9uIHRoZSBzdGFuZGFyZCB3YXkuXG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzModSwgdiwgZGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzNdID0gcmVhbF9wYXJ0O1xuXG4gICAgICAgIHJldHVybiBtYXRoLm5vcm1hbGl6ZVF1YXRlcm5pb24oZGVzdCk7XG4gICAgfSxcblxuICAgIGFuZ2xlQXhpc1RvUXVhdGVybmlvbihhbmdsZUF4aXMsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUF4aXNbM10gLyAyLjA7XG4gICAgICAgIGNvbnN0IGZzaW4gPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBkZXN0WzBdID0gZnNpbiAqIGFuZ2xlQXhpc1swXTtcbiAgICAgICAgZGVzdFsxXSA9IGZzaW4gKiBhbmdsZUF4aXNbMV07XG4gICAgICAgIGRlc3RbMl0gPSBmc2luICogYW5nbGVBeGlzWzJdO1xuICAgICAgICBkZXN0WzNdID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0V1bGVyOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIChxLCBvcmRlciwgZGVzdCkgPT4ge1xuICAgICAgICAgICAgZGVzdCA9IGRlc3QgfHwgbWF0aC52ZWMzKCk7XG4gICAgICAgICAgICBtYXRoLnF1YXRlcm5pb25Ub1JvdGF0aW9uTWF0NChxLCBtYXQpO1xuICAgICAgICAgICAgbWF0aC5tYXQ0VG9FdWxlcihtYXQsIG9yZGVyLCBkZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgbXVsUXVhdGVybmlvbnMocCwgcSwgZGVzdCA9IG1hdGgudmVjNCgpKSB7XG4gICAgICAgIGNvbnN0IHAwID0gcFswXTtcbiAgICAgICAgY29uc3QgcDEgPSBwWzFdO1xuICAgICAgICBjb25zdCBwMiA9IHBbMl07XG4gICAgICAgIGNvbnN0IHAzID0gcFszXTtcbiAgICAgICAgY29uc3QgcTAgPSBxWzBdO1xuICAgICAgICBjb25zdCBxMSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBkZXN0WzBdID0gcDMgKiBxMCArIHAwICogcTMgKyBwMSAqIHEyIC0gcDIgKiBxMTtcbiAgICAgICAgZGVzdFsxXSA9IHAzICogcTEgKyBwMSAqIHEzICsgcDIgKiBxMCAtIHAwICogcTI7XG4gICAgICAgIGRlc3RbMl0gPSBwMyAqIHEyICsgcDIgKiBxMyArIHAwICogcTEgLSBwMSAqIHEwO1xuICAgICAgICBkZXN0WzNdID0gcDMgKiBxMyAtIHAwICogcTAgLSBwMSAqIHExIC0gcDIgKiBxMjtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNBcHBseVF1YXRlcm5pb24ocSwgdmVjLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgeCA9IHZlY1swXTtcbiAgICAgICAgY29uc3QgeSA9IHZlY1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHZlY1syXTtcblxuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gICAgICAgIGRlc3RbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgICBkZXN0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICAgICAgZGVzdFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub01hdDQocSwgZGVzdCkge1xuXG4gICAgICAgIGRlc3QgPSBtYXRoLmlkZW50aXR5TWF0NChkZXN0KTtcblxuICAgICAgICBjb25zdCBxMCA9IHFbMF07ICAvL3hcbiAgICAgICAgY29uc3QgcTEgPSBxWzFdOyAgLy95XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTsgIC8velxuICAgICAgICBjb25zdCBxMyA9IHFbM107ICAvL3dcblxuICAgICAgICBjb25zdCB0eCA9IDIuMCAqIHEwO1xuICAgICAgICBjb25zdCB0eSA9IDIuMCAqIHExO1xuICAgICAgICBjb25zdCB0eiA9IDIuMCAqIHEyO1xuXG4gICAgICAgIGNvbnN0IHR3eCA9IHR4ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eSA9IHR5ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eiA9IHR6ICogcTM7XG5cbiAgICAgICAgY29uc3QgdHh4ID0gdHggKiBxMDtcbiAgICAgICAgY29uc3QgdHh5ID0gdHkgKiBxMDtcbiAgICAgICAgY29uc3QgdHh6ID0gdHogKiBxMDtcblxuICAgICAgICBjb25zdCB0eXkgPSB0eSAqIHExO1xuICAgICAgICBjb25zdCB0eXogPSB0eiAqIHExO1xuICAgICAgICBjb25zdCB0enogPSB0eiAqIHEyO1xuXG4gICAgICAgIGRlc3RbMF0gPSAxLjAgLSAodHl5ICsgdHp6KTtcbiAgICAgICAgZGVzdFsxXSA9IHR4eSArIHR3ejtcbiAgICAgICAgZGVzdFsyXSA9IHR4eiAtIHR3eTtcblxuICAgICAgICBkZXN0WzRdID0gdHh5IC0gdHd6O1xuICAgICAgICBkZXN0WzVdID0gMS4wIC0gKHR4eCArIHR6eik7XG4gICAgICAgIGRlc3RbNl0gPSB0eXogKyB0d3g7XG5cbiAgICAgICAgZGVzdFs4XSA9IHR4eiArIHR3eTtcbiAgICAgICAgZGVzdFs5XSA9IHR5eiAtIHR3eDtcblxuICAgICAgICBkZXN0WzEwXSA9IDEuMCAtICh0eHggKyB0eXkpO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBxdWF0ZXJuaW9uVG9Sb3RhdGlvbk1hdDQocSwgbSkge1xuICAgICAgICBjb25zdCB4ID0gcVswXTtcbiAgICAgICAgY29uc3QgeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHogPSBxWzJdO1xuICAgICAgICBjb25zdCB3ID0gcVszXTtcblxuICAgICAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgICAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICAgICAgY29uc3QgeHkgPSB4ICogeTI7XG4gICAgICAgIGNvbnN0IHh6ID0geCAqIHoyO1xuICAgICAgICBjb25zdCB5eSA9IHkgKiB5MjtcbiAgICAgICAgY29uc3QgeXogPSB5ICogejI7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xuICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xuXG4gICAgICAgIG1bMF0gPSAxIC0gKHl5ICsgenopO1xuICAgICAgICBtWzRdID0geHkgLSB3ejtcbiAgICAgICAgbVs4XSA9IHh6ICsgd3k7XG5cbiAgICAgICAgbVsxXSA9IHh5ICsgd3o7XG4gICAgICAgIG1bNV0gPSAxIC0gKHh4ICsgenopO1xuICAgICAgICBtWzldID0geXogLSB3eDtcblxuICAgICAgICBtWzJdID0geHogLSB3eTtcbiAgICAgICAgbVs2XSA9IHl6ICsgd3g7XG4gICAgICAgIG1bMTBdID0gMSAtICh4eCArIHl5KTtcblxuICAgICAgICAvLyBsYXN0IGNvbHVtblxuICAgICAgICBtWzNdID0gMDtcbiAgICAgICAgbVs3XSA9IDA7XG4gICAgICAgIG1bMTFdID0gMDtcblxuICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgIG1bMTJdID0gMDtcbiAgICAgICAgbVsxM10gPSAwO1xuICAgICAgICBtWzE0XSA9IDA7XG4gICAgICAgIG1bMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplUXVhdGVybmlvbihxLCBkZXN0ID0gcSkge1xuICAgICAgICBjb25zdCBsZW4gPSBtYXRoLmxlblZlYzQoW3FbMF0sIHFbMV0sIHFbMl0sIHFbM11dKTtcbiAgICAgICAgZGVzdFswXSA9IHFbMF0gLyBsZW47XG4gICAgICAgIGRlc3RbMV0gPSBxWzFdIC8gbGVuO1xuICAgICAgICBkZXN0WzJdID0gcVsyXSAvIGxlbjtcbiAgICAgICAgZGVzdFszXSA9IHFbM10gLyBsZW47XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb25qdWdhdGVRdWF0ZXJuaW9uKHEsIGRlc3QgPSBxKSB7XG4gICAgICAgIGRlc3RbMF0gPSAtcVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1xWzFdO1xuICAgICAgICBkZXN0WzJdID0gLXFbMl07XG4gICAgICAgIGRlc3RbM10gPSBxWzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgaW52ZXJzZVF1YXRlcm5pb24ocSwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKG1hdGguY29uanVnYXRlUXVhdGVybmlvbihxLCBkZXN0KSk7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0FuZ2xlQXhpcyhxLCBhbmdsZUF4aXMgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBxID0gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKHEsIHRlbXBWZWM0KTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3MocTMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KDEgLSBxMyAqIHEzKTtcbiAgICAgICAgaWYgKHMgPCAwLjAwMSkgeyAvLyB0ZXN0IHRvIGF2b2lkIGRpdmlkZSBieSB6ZXJvLCBzIGlzIGFsd2F5cyBwb3NpdGl2ZSBkdWUgdG8gc3FydFxuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXTtcbiAgICAgICAgICAgIGFuZ2xlQXhpc1sxXSA9IHFbMV07XG4gICAgICAgICAgICBhbmdsZUF4aXNbMl0gPSBxWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXSAvIHM7XG4gICAgICAgICAgICBhbmdsZUF4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgICAgIGFuZ2xlQXhpc1syXSA9IHFbMl0gLyBzO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlQXhpc1szXSA9IGFuZ2xlOyAvLyAqIDU3LjI5NTc3OTU3OTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlQXhpcztcbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb3VuZGFyaWVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM0QgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQUFCQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIDJEIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEFBQkIyKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAzRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAyRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDE2KTtcbiAgICB9LFxuXG4gICAgLyoqIFJldHVybnMgYSBuZXcgM0QgYm91bmRpbmcgc3BoZXJlICovXG4gICAgU3BoZXJlMyh4LCB5LCB6LCByKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUoW3gsIHksIHosIHJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBPQkIzIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJhbnNmb3JtT0JCMyhtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBBQUJCIGNvbnRhaW5zIHRoZSBzZWNvbmQgQUFCQi5cbiAgICAgKiBAcGFyYW0gYWFiYjFcbiAgICAgKiBAcGFyYW0gYWFiYjJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc0FBQkIzOiBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChcbiAgICAgICAgICAgIGFhYmIxWzBdIDw9IGFhYmIyWzBdICYmIGFhYmIyWzNdIDw9IGFhYmIxWzNdICYmXG4gICAgICAgICAgICBhYWJiMVsxXSA8PSBhYWJiMlsxXSAmJiBhYWJiMls0XSA8PSBhYWJiMVs0XSAmJlxuICAgICAgICAgICAgYWFiYjFbMl0gPD0gYWFiYjJbMl0gJiYgYWFiYjJbNV0gPD0gYWFiYjFbNV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpYWdvbmFsIHNpemUgb2YgYW4gQUFCQjMgZ2l2ZW4gYXMgbWluaW1hIGFuZCBtYXhpbWEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzRGlhZzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiBhYWJiID0+IHtcblxuICAgICAgICAgICAgbWluWzBdID0gYWFiYlswXTtcbiAgICAgICAgICAgIG1pblsxXSA9IGFhYmJbMV07XG4gICAgICAgICAgICBtaW5bMl0gPSBhYWJiWzJdO1xuXG4gICAgICAgICAgICBtYXhbMF0gPSBhYWJiWzNdO1xuICAgICAgICAgICAgbWF4WzFdID0gYWFiYls0XTtcbiAgICAgICAgICAgIG1heFsyXSA9IGFhYmJbNV07XG5cbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF0aC5sZW5WZWMzKHRlbXBWZWMzKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkaWFnb25hbCBib3VuZGFyeSBzaXplIHRoYXQgaXMgc3ltbWV0cmljYWwgYWJvdXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCM0RpYWdQb2ludDogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiAoYWFiYiwgcCkgPT4ge1xuXG4gICAgICAgICAgICBtaW5bMF0gPSBhYWJiWzBdO1xuICAgICAgICAgICAgbWluWzFdID0gYWFiYlsxXTtcbiAgICAgICAgICAgIG1pblsyXSA9IGFhYmJbMl07XG5cbiAgICAgICAgICAgIG1heFswXSA9IGFhYmJbM107XG4gICAgICAgICAgICBtYXhbMV0gPSBhYWJiWzRdO1xuICAgICAgICAgICAgbWF4WzJdID0gYWFiYls1XTtcblxuICAgICAgICAgICAgY29uc3QgZGlhZ1ZlYyA9IG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICBjb25zdCB4bmVnID0gcFswXSAtIGFhYmJbMF07XG4gICAgICAgICAgICBjb25zdCB4cG9zID0gYWFiYlszXSAtIHBbMF07XG4gICAgICAgICAgICBjb25zdCB5bmVnID0gcFsxXSAtIGFhYmJbMV07XG4gICAgICAgICAgICBjb25zdCB5cG9zID0gYWFiYls0XSAtIHBbMV07XG4gICAgICAgICAgICBjb25zdCB6bmVnID0gcFsyXSAtIGFhYmJbMl07XG4gICAgICAgICAgICBjb25zdCB6cG9zID0gYWFiYls1XSAtIHBbMl07XG5cbiAgICAgICAgICAgIGRpYWdWZWNbMF0gKz0gKHhuZWcgPiB4cG9zKSA/IHhuZWcgOiB4cG9zO1xuICAgICAgICAgICAgZGlhZ1ZlY1sxXSArPSAoeW5lZyA+IHlwb3MpID8geW5lZyA6IHlwb3M7XG4gICAgICAgICAgICBkaWFnVmVjWzJdICs9ICh6bmVnID4genBvcykgPyB6bmVnIDogenBvcztcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1hdGgubGVuVmVjMyhkaWFnVmVjKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmVhIG9mIGFuIEFBQkIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzQXJlYShhYWJiKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKGFhYmJbM10gLSBhYWJiWzBdKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGFhYmJbNF0gLSBhYWJiWzFdKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSAoYWFiYls1XSAtIGFhYmJbMl0pO1xuICAgICAgICByZXR1cm4gKHdpZHRoICogaGVpZ2h0ICogZGVwdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYW4gQUFCQi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QUFCQjNDZW50ZXIoYWFiYiwgZGVzdCkge1xuICAgICAgICBjb25zdCByID0gZGVzdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICByWzBdID0gKGFhYmJbMF0gKyBhYWJiWzNdKSAvIDI7XG4gICAgICAgIHJbMV0gPSAoYWFiYlsxXSArIGFhYmJbNF0pIC8gMjtcbiAgICAgICAgclsyXSA9IChhYWJiWzJdICsgYWFiYls1XSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSAyRCBBQUJCLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCMkNlbnRlcihhYWJiLCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IHIgPSBkZXN0IHx8IG1hdGgudmVjMigpO1xuXG4gICAgICAgIHJbMF0gPSAoYWFiYlsyXSArIGFhYmJbMF0pIC8gMjtcbiAgICAgICAgclsxXSA9IChhYWJiWzNdICsgYWFiYlsxXSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAzRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgM0QgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMyhhYWJiID0gbWF0aC5BQUJCMygpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNF0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNV0gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBpbnRvIGFuIG9yaWVudGVkIGJvdW5kYXJ5IGNvbnNpc3Rpbmcgb2ZcbiAgICAgKiBhbiBhcnJheSBvZiBlaWdodCAzRCBwb3NpdGlvbnMsIG9uZSBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGJvdW5kYXJ5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBBQUJCM1RvT0JCMyhhYWJiLCBvYmIgPSBtYXRoLk9CQjMoKSkge1xuICAgICAgICBvYmJbMF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMV0gPSBhYWJiWzFdO1xuICAgICAgICBvYmJbMl0gPSBhYWJiWzJdO1xuICAgICAgICBvYmJbM10gPSAxO1xuXG4gICAgICAgIG9iYls0XSA9IGFhYmJbM107XG4gICAgICAgIG9iYls1XSA9IGFhYmJbMV07XG4gICAgICAgIG9iYls2XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYls3XSA9IDE7XG5cbiAgICAgICAgb2JiWzhdID0gYWFiYlszXTtcbiAgICAgICAgb2JiWzldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzEwXSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxMV0gPSAxO1xuXG4gICAgICAgIG9iYlsxMl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTNdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzE0XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxNV0gPSAxO1xuXG4gICAgICAgIG9iYlsxNl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTddID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzE4XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsxOV0gPSAxO1xuXG4gICAgICAgIG9iYlsyMF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjFdID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzIyXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyM10gPSAxO1xuXG4gICAgICAgIG9iYlsyNF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjVdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzI2XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyN10gPSAxO1xuXG4gICAgICAgIG9iYlsyOF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMjldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzMwXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlszMV0gPSAxO1xuXG4gICAgICAgIHJldHVybiBvYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvc2l0aW9uczNUb0FBQkIzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBwID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgYWFiYiwgcG9zaXRpb25zRGVjb2RlTWF0cml4KSA9PiB7XG4gICAgICAgICAgICBhYWJiID0gYWFiYiB8fCBtYXRoLkFBQkIzKCk7XG5cbiAgICAgICAgICAgIGxldCB4bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCB6O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHBvc2l0aW9uc1tpICsgMF07XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gcG9zaXRpb25zW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICBtYXRoLmRlY29tcHJlc3NQb3NpdGlvbihwLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHBbMl07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcG9zaXRpb25zW2kgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgeW1pbiA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHptaW4gPSB6O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgICAgICB4bWF4ID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHptYXggPSB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgICAgICBhYWJiWzFdID0geW1pbjtcbiAgICAgICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICAgICAgYWFiYlszXSA9IHhtYXg7XG4gICAgICAgICAgICBhYWJiWzRdID0geW1heDtcbiAgICAgICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgICAgICByZXR1cm4gYWFiYjtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIzKG9iYiwgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9iYi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gb2JiW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBvYmJbaSArIDFdO1xuICAgICAgICAgICAgeiA9IG9iYltpICsgMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb0FBQkIzKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICB4ID0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpXVsxXTtcbiAgICAgICAgICAgIHogPSBwb2ludHNbaV1bMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvaW50cywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHkgKz0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9pbnRzW2ldWzJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzMocG9pbnRzW2ldLCBzcGhlcmUsIHRlbXBWZWMzKSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gZGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwaGVyZVszXSA9IHJhZGl1cztcblxuICAgICAgICAgICAgcmV0dXJuIHNwaGVyZTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGJvdW5kYXJ5IHNwaGVyZSBlbmNsb3NpbmcgdGhlIGdpdmVuIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcG9zaXRpb25zM1RvU3BoZXJlMzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcFZlYzNhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGxlblBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgeCArPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgeSArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbnVtUG9zaXRpb25zID0gbGVuUG9zaXRpb25zIC8gMztcblxuICAgICAgICAgICAgc3BoZXJlWzBdID0geCAvIG51bVBvc2l0aW9ucztcbiAgICAgICAgICAgIHNwaGVyZVsxXSA9IHkgLyBudW1Qb3NpdGlvbnM7XG4gICAgICAgICAgICBzcGhlcmVbMl0gPSB6IC8gbnVtUG9zaXRpb25zO1xuXG4gICAgICAgICAgICBsZXQgZGlzdDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdGVtcFZlYzNhWzFdID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMl0gPSBwb3NpdGlvbnNbaSArIDJdO1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzModGVtcFZlYzNhLCBzcGhlcmUsIHRlbXBWZWMzYikpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9pbnRzLCBzcGhlcmUpID0+IHtcblxuICAgICAgICAgICAgc3BoZXJlID0gc3BoZXJlIHx8IG1hdGgudmVjNCgpO1xuXG4gICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBsZXQgeiA9IDA7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgbGVuUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IGxlblBvaW50cyAvIDQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICB5ICs9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgeiArPSBwb2ludHNbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuXG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludFsyXSA9IHBvaW50c1tpICsgMl07XG5cbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMobWF0aC5sZW5WZWMzKG1hdGguc3ViVmVjMyhwb2ludCwgc3BoZXJlLCB0ZW1wVmVjMykpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSBib3VuZGluZyBzcGhlcmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNwaGVyZTNDZW50ZXIoc3BoZXJlLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgZGVzdFswXSA9IHNwaGVyZVswXTtcbiAgICAgICAgZGVzdFsxXSA9IHNwaGVyZVsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHNwaGVyZVsyXTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgM0QgY2VudGVyIG9mIHRoZSBnaXZlbiBmbGF0IGFycmF5IG9mIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25zQ2VudGVyKHBvc2l0aW9ucywgY2VudGVyID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgbGV0IHhDZW50ZXIgPSAwO1xuICAgICAgICBsZXQgeUNlbnRlciA9IDA7XG4gICAgICAgIGxldCB6Q2VudGVyID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgeENlbnRlciArPSBwb3NpdGlvbnNbaSArIDBdO1xuICAgICAgICAgICAgeUNlbnRlciArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgekNlbnRlciArPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuICAgICAgICBjZW50ZXJbMF0gPSB4Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMV0gPSB5Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMl0gPSB6Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBmaXJzdCBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgc2Vjb25kLCBpZiByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhwYW5kQUFCQjMoYWFiYjEsIGFhYmIyKSB7XG5cbiAgICAgICAgaWYgKGFhYmIxWzBdID4gYWFiYjJbMF0pIHtcbiAgICAgICAgICAgIGFhYmIxWzBdID0gYWFiYjJbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbMV0gPiBhYWJiMlsxXSkge1xuICAgICAgICAgICAgYWFiYjFbMV0gPSBhYWJiMlsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsyXSA+IGFhYmIyWzJdKSB7XG4gICAgICAgICAgICBhYWJiMVsyXSA9IGFhYmIyWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzNdIDwgYWFiYjJbM10pIHtcbiAgICAgICAgICAgIGFhYmIxWzNdID0gYWFiYjJbM107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbNF0gPCBhYWJiMls0XSkge1xuICAgICAgICAgICAgYWFiYjFbNF0gPSBhYWJiMls0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVs1XSA8IGFhYmIyWzVdKSB7XG4gICAgICAgICAgICBhYWJiMVs1XSA9IGFhYmIyWzVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmIxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBnaXZlbiBwb2ludCwgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50MyhhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA+IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzRdIDwgcFsxXSkge1xuICAgICAgICAgICAgYWFiYls0XSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYls1XSA8IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbNV0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYW4gYXhpcy1hbGlnbmVkIDNEIGJvdW5kYXJ5IHRvIGVuY2xvc2UgdGhlIGdpdmVuIHBvaW50cywgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50czMoYWFiYiwgcG9zaXRpb25zKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgaWYgKGFhYmJbMF0gPiB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlswXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYlsxXSA+IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzJdID4geikge1xuICAgICAgICAgICAgICAgIGFhYmJbMl0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhYmJbM10gPCB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlszXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYls0XSA8IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzRdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzVdIDwgeikge1xuICAgICAgICAgICAgICAgIGFhYmJbNV0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAyRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgMkQgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMihhYWJiID0gbWF0aC5BQUJCMigpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIHBvaW50M0FBQkIzSW50ZXJzZWN0KGFhYmIsIHApIHtcbiAgICAgICAgcmV0dXJuIGFhYmJbMF0gPiBwWzBdIHx8IGFhYmJbM10gPCBwWzBdIHx8IGFhYmJbMV0gPiBwWzFdIHx8IGFhYmJbNF0gPCBwWzFdIHx8IGFhYmJbMl0gPiBwWzJdIHx8IGFhYmJbNV0gPCBwWzJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXJcbiAgICAgKiBAcGFyYW0gY29uc3RhbnRcbiAgICAgKiBAcGFyYW0gYWFiYlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGxhbmVBQUJCM0ludGVyc2VjdChkaXIsIGNvbnN0YW50LCBhYWJiKSB7XG4gICAgICAgIGxldCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRpclswXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgICAgICBtYXggPSBkaXJbMF0gKiBhYWJiWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluID0gZGlyWzBdICogYWFiYlszXTtcbiAgICAgICAgICAgIG1heCA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclsxXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICAgICAgbWF4ICs9IGRpclsxXSAqIGFhYmJbNF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzFdICogYWFiYls0XTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJbMl0gPiAwKSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMl0gKiBhYWJiWzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluICs9IGRpclsyXSAqIGFhYmJbNV07XG4gICAgICAgICAgICBtYXggKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRzaWRlID0gKG1pbiA8PSAtY29uc3RhbnQpICYmIChtYXggPD0gLWNvbnN0YW50KTtcbiAgICAgICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluc2lkZSA9IChtaW4gPj0gLWNvbnN0YW50KSAmJiAobWF4ID49IC1jb25zdGFudCk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIDJEIHByb2plY3RlZCBheGlzLWFsaWduZWQgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIyKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjIoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICBsZXQgeW1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCB3O1xuICAgICAgICBsZXQgZjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgICAgIHggPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB3ID0gcG9pbnRzW2kgKyAzXSB8fCAxLjA7XG5cbiAgICAgICAgICAgIGYgPSAxLjAgLyB3O1xuXG4gICAgICAgICAgICB4ICo9IGY7XG4gICAgICAgICAgICB5ICo9IGY7XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPiB4bWF4KSB7XG4gICAgICAgICAgICAgICAgeG1heCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5ID4geW1heCkge1xuICAgICAgICAgICAgICAgIHltYXggPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgIGFhYmJbMV0gPSB5bWluO1xuICAgICAgICBhYWJiWzJdID0geG1heDtcbiAgICAgICAgYWFiYlszXSA9IHltYXg7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIGZpcnN0IGF4aXMtYWxpZ25lZCAyRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBzZWNvbmQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMihhYWJiMSwgYWFiYjIpIHtcblxuICAgICAgICBpZiAoYWFiYjFbMF0gPiBhYWJiMlswXSkge1xuICAgICAgICAgICAgYWFiYjFbMF0gPSBhYWJiMlswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsxXSA+IGFhYmIyWzFdKSB7XG4gICAgICAgICAgICBhYWJiMVsxXSA9IGFhYmIyWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzJdIDwgYWFiYjJbMl0pIHtcbiAgICAgICAgICAgIGFhYmIxWzJdID0gYWFiYjJbMl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbM10gPCBhYWJiMlszXSkge1xuICAgICAgICAgICAgYWFiYjFbM10gPSBhYWJiMlszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbiBheGlzLWFsaWduZWQgMkQgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgZ2l2ZW4gcG9pbnQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMlBvaW50MihhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA8IHBbMF0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzFdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICBBQUJCMlRvQ2FudmFzKGFhYmIsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIGFhYmIyID0gYWFiYikge1xuICAgICAgICBjb25zdCB4bWluID0gKGFhYmJbMF0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWluID0gKGFhYmJbMV0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB4bWF4ID0gKGFhYmJbMl0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWF4ID0gKGFhYmJbM10gKyAxLjApICogMC41O1xuXG4gICAgICAgIGFhYmIyWzBdID0gTWF0aC5mbG9vcih4bWluICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlsxXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1heCAqIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGFhYmIyWzJdID0gTWF0aC5mbG9vcih4bWF4ICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlszXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1pbiAqIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIGFhYmIyO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEN1cnZlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyKHQsIHAwLCBwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogKHAxIC0gcDApICsgMiAqIHQgKiAocDIgLSBwMSk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgK1xuICAgICAgICAgICAgMyAqIHAxICogKDEgLSB0KSAqICgxIC0gdCkgLSA2ICogdCAqIHAxICogKDEgLSB0KSArXG4gICAgICAgICAgICA2ICogdCAqIHAyICogKDEgLSB0KSAtIDMgKiB0ICogdCAqIHAyICtcbiAgICAgICAgICAgIDMgKiB0ICogdCAqIHAzO1xuICAgIH0sXG5cbiAgICB0YW5nZW50U3BsaW5lKHQpIHtcbiAgICAgICAgY29uc3QgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7XG4gICAgICAgIGNvbnN0IGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTtcbiAgICAgICAgY29uc3QgaDAxID0gLTYgKiB0ICogdCArIDYgKiB0O1xuICAgICAgICBjb25zdCBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcbiAgICAgICAgcmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcbiAgICB9LFxuXG4gICAgY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIGNvbnN0IHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICBjb25zdCB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICAgICAgY29uc3QgdDMgPSB0ICogdDI7XG4gICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICB9LFxuXG4vLyBCZXppZXIgQ3VydmUgZm9ybXVsaWkgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cbi8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjJwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogcDtcblxuICAgIH0sXG5cbiAgICBiMnAxKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIycDIodCwgcCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiMih0LCBwMCwgcDEsIHAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIycDAodCwgcDApICsgdGhpcy5iMnAxKHQsIHAxKSArIHRoaXMuYjJwMih0LCBwMik7XG4gICAgfSxcblxuLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjNwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG4gICAgfSxcblxuICAgIGIzcDEodCwgcCkge1xuICAgICAgICBjb25zdCBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcbiAgICB9LFxuXG4gICAgYjNwMih0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiM3AzKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIzcDAodCwgcDApICsgdGhpcy5iM3AxKHQsIHAxKSArIHRoaXMuYjNwMih0LCBwMikgKyB0aGlzLmIzcDModCwgcDMpO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdlb21ldHJ5XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbCB2ZWN0b3Igb2YgYSB0cmlhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJpYW5nbGVOb3JtYWwoYSwgYiwgYywgbm9ybWFsID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgcDF4ID0gYlswXSAtIGFbMF07XG4gICAgICAgIGNvbnN0IHAxeSA9IGJbMV0gLSBhWzFdO1xuICAgICAgICBjb25zdCBwMXogPSBiWzJdIC0gYVsyXTtcblxuICAgICAgICBjb25zdCBwMnggPSBjWzBdIC0gYVswXTtcbiAgICAgICAgY29uc3QgcDJ5ID0gY1sxXSAtIGFbMV07XG4gICAgICAgIGNvbnN0IHAyeiA9IGNbMl0gLSBhWzJdO1xuXG4gICAgICAgIGNvbnN0IHAzeCA9IHAxeSAqIHAyeiAtIHAxeiAqIHAyeTtcbiAgICAgICAgY29uc3QgcDN5ID0gcDF6ICogcDJ4IC0gcDF4ICogcDJ6O1xuICAgICAgICBjb25zdCBwM3ogPSBwMXggKiBwMnkgLSBwMXkgKiBwMng7XG5cbiAgICAgICAgY29uc3QgbWFnID0gTWF0aC5zcXJ0KHAzeCAqIHAzeCArIHAzeSAqIHAzeSArIHAzeiAqIHAzeik7XG4gICAgICAgIGlmIChtYWcgPT09IDApIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IDA7XG4gICAgICAgICAgICBub3JtYWxbMV0gPSAwO1xuICAgICAgICAgICAgbm9ybWFsWzJdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IHAzeCAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsxXSA9IHAzeSAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsyXSA9IHAzeiAvIG1hZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgM0QgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJheVRyaWFuZ2xlSW50ZXJzZWN0OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChvcmlnaW4sIGRpciwgYSwgYiwgYywgaXNlY3QpID0+IHtcblxuICAgICAgICAgICAgaXNlY3QgPSBpc2VjdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICAgICAgY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG4gICAgICAgICAgICBjb25zdCBlZGdlMSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2IpO1xuXG4gICAgICAgICAgICBjb25zdCBwdmVjID0gbWF0aC5jcm9zczNWZWMzKGRpciwgZWRnZTIsIHRlbXBWZWMzYyk7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRvdFZlYzMoZWRnZTEsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKGRldCA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHZlYyA9IG1hdGguc3ViVmVjMyhvcmlnaW4sIGEsIHRlbXBWZWMzZCk7XG4gICAgICAgICAgICBjb25zdCB1ID0gbWF0aC5kb3RWZWMzKHR2ZWMsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKHUgPCAwIHx8IHUgPiBkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcXZlYyA9IG1hdGguY3Jvc3MzVmVjMyh0dmVjLCBlZGdlMSwgdGVtcFZlYzNlKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtYXRoLmRvdFZlYzMoZGlyLCBxdmVjKTtcbiAgICAgICAgICAgIGlmICh2IDwgMCB8fCB1ICsgdiA+IGRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ID0gbWF0aC5kb3RWZWMzKGVkZ2UyLCBxdmVjKSAvIGRldDtcbiAgICAgICAgICAgIGlzZWN0WzBdID0gb3JpZ2luWzBdICsgdCAqIGRpclswXTtcbiAgICAgICAgICAgIGlzZWN0WzFdID0gb3JpZ2luWzFdICsgdCAqIGRpclsxXTtcbiAgICAgICAgICAgIGlzZWN0WzJdID0gb3JpZ2luWzJdICsgdCAqIGRpclsyXTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzZWN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSAzIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmF5UGxhbmVJbnRlcnNlY3Q6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNkID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKG9yaWdpbiwgZGlyLCBhLCBiLCBjLCBpc2VjdCkgPT4ge1xuXG4gICAgICAgICAgICBpc2VjdCA9IGlzZWN0IHx8IG1hdGgudmVjMygpO1xuXG4gICAgICAgICAgICBkaXIgPSBtYXRoLm5vcm1hbGl6ZVZlYzMoZGlyLCB0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVkZ2UxID0gbWF0aC5zdWJWZWMzKGIsIGEsIHRlbXBWZWMzYik7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBuID0gbWF0aC5jcm9zczNWZWMzKGVkZ2UxLCBlZGdlMiwgdGVtcFZlYzNkKTtcbiAgICAgICAgICAgIG1hdGgubm9ybWFsaXplVmVjMyhuLCBuKTtcblxuICAgICAgICAgICAgY29uc3QgZCA9IC1tYXRoLmRvdFZlYzMoYSwgbik7XG5cbiAgICAgICAgICAgIGNvbnN0IHQgPSAtKG1hdGguZG90VmVjMyhvcmlnaW4sIG4pICsgZCkgLyBtYXRoLmRvdFZlYzMoZGlyLCBuKTtcblxuICAgICAgICAgICAgaXNlY3RbMF0gPSBvcmlnaW5bMF0gKyB0ICogZGlyWzBdO1xuICAgICAgICAgICAgaXNlY3RbMV0gPSBvcmlnaW5bMV0gKyB0ICogZGlyWzFdO1xuICAgICAgICAgICAgaXNlY3RbMl0gPSBvcmlnaW5bMl0gKyB0ICogZGlyWzJdO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNlY3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGZyb20gY2FydGVzaWFuIGNvb3JkaW5hdGVzIHdpdGhpbiBhIHRyaWFuZ2xlLlxuICAgICAqIEdldHMgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgZnJvbSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhcnRlc2lhblRvQmFyeWNlbnRyaWM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhcnRlc2lhbiwgYSwgYiwgYywgZGVzdCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB2MCA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCB2MSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjM2IpO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBtYXRoLnN1YlZlYzMoY2FydGVzaWFuLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBkb3QwMCA9IG1hdGguZG90VmVjMyh2MCwgdjApO1xuICAgICAgICAgICAgY29uc3QgZG90MDEgPSBtYXRoLmRvdFZlYzModjAsIHYxKTtcbiAgICAgICAgICAgIGNvbnN0IGRvdDAyID0gbWF0aC5kb3RWZWMzKHYwLCB2Mik7XG4gICAgICAgICAgICBjb25zdCBkb3QxMSA9IG1hdGguZG90VmVjMyh2MSwgdjEpO1xuICAgICAgICAgICAgY29uc3QgZG90MTIgPSBtYXRoLmRvdFZlYzModjEsIHYyKTtcblxuICAgICAgICAgICAgY29uc3QgZGVub20gPSAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuXG4gICAgICAgICAgICAvLyBDb2xpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXG4gICAgICAgICAgICBpZiAoZGVub20gPT09IDApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cbiAgICAgICAgICAgIGNvbnN0IHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgICAgICBjb25zdCB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gMSAtIHUgLSB2O1xuICAgICAgICAgICAgZGVzdFsxXSA9IHY7XG4gICAgICAgICAgICBkZXN0WzJdID0gdTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlaXIgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljSW5zaWRlVHJpYW5nbGUoYmFyeSkge1xuXG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB1ID0gYmFyeVsyXTtcblxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FydGVzaWFuIGNvb3JkaW5hdGVzIGZyb20gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljVG9DYXJ0ZXNpYW4oYmFyeSwgYSwgYiwgYywgY2FydGVzaWFuID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgdSA9IGJhcnlbMF07XG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB3ID0gYmFyeVsyXTtcblxuICAgICAgICBjYXJ0ZXNpYW5bMF0gPSBhWzBdICogdSArIGJbMF0gKiB2ICsgY1swXSAqIHc7XG4gICAgICAgIGNhcnRlc2lhblsxXSA9IGFbMV0gKiB1ICsgYlsxXSAqIHYgKyBjWzFdICogdztcbiAgICAgICAgY2FydGVzaWFuWzJdID0gYVsyXSAqIHUgKyBiWzJdICogdiArIGNbMl0gKiB3O1xuXG4gICAgICAgIHJldHVybiBjYXJ0ZXNpYW47XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gZ2VvbWV0cnkgZGVmaW5lZCBhcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMsIG9wdGlvbmFsIG5vcm1hbHMsIG9wdGlvbiB1diBhbmQgYW4gYXJyYXkgb2YgaW5kaWNlcywgcmV0dXJuc1xuICAgICAqIG1vZGlmaWVkIGFycmF5cyB0aGF0IGhhdmUgZHVwbGljYXRlIHZlcnRpY2VzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBkb2VzIG5vdCB3b3JrIHdlbGwgd2hlbiBjby1pbmNpZGVudCB2ZXJ0aWNlcyBoYXZlIHNhbWUgcG9zaXRpb25zIGJ1dCBkaWZmZXJlbnQgbm9ybWFscyBhbmQgVVZzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSBub3JtYWxzXG4gICAgICogQHBhcmFtIHV2XG4gICAgICogQHBhcmFtIGluZGljZXNcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIGluZGljZXM6IEFycmF5fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1lcmdlVmVydGljZXMocG9zaXRpb25zLCBub3JtYWxzLCB1diwgaW5kaWNlcykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICAgICAgY29uc3QgaW5kaWNlc0xvb2t1cCA9IFtdO1xuICAgICAgICBjb25zdCB1bmlxdWVQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5pcXVlTm9ybWFscyA9IG5vcm1hbHMgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVVWID0gdXYgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGluZGljZXMyID0gW107XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgdXZpID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zTWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc01hcFtrZXldID0gdW5pcXVlUG9zaXRpb25zLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zLnB1c2godngpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9ucy5wdXNoKHZ5KTtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnMucHVzaCh2eik7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlTm9ybWFscy5wdXNoKG5vcm1hbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmldKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmkgKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgICAgIHV2aSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGluZGljZXMyW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHVuaXF1ZVBvc2l0aW9ucyxcbiAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMyXG4gICAgICAgIH07XG4gICAgICAgIGlmICh1bmlxdWVOb3JtYWxzKSB7XG4gICAgICAgICAgICByZXN1bHQubm9ybWFscyA9IHVuaXF1ZU5vcm1hbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXF1ZVVWKSB7XG4gICAgICAgICAgICByZXN1bHQudXYgPSB1bmlxdWVVVjtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBub3JtYWwgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucyBhbmQgaW5kaWNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGROb3JtYWxzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBjb25zdCBhYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgY3Jvc3NWZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9zaXRpb25zLCBpbmRpY2VzLCBub3JtYWxzKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgICAgIGNvbnN0IG52ZWNzID0gbmV3IEFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzKTtcbiAgICAgICAgICAgIGxldCBqMDtcbiAgICAgICAgICAgIGxldCBqMTtcbiAgICAgICAgICAgIGxldCBqMjtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuXG4gICAgICAgICAgICAgICAgajAgPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGoxID0gaW5kaWNlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgajIgPSBpbmRpY2VzW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgIGFbMF0gPSBwb3NpdGlvbnNbajAgKiAzXTtcbiAgICAgICAgICAgICAgICBhWzFdID0gcG9zaXRpb25zW2owICogMyArIDFdO1xuICAgICAgICAgICAgICAgIGFbMl0gPSBwb3NpdGlvbnNbajAgKiAzICsgMl07XG5cbiAgICAgICAgICAgICAgICBiWzBdID0gcG9zaXRpb25zW2oxICogM107XG4gICAgICAgICAgICAgICAgYlsxXSA9IHBvc2l0aW9uc1tqMSAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICBiWzJdID0gcG9zaXRpb25zW2oxICogMyArIDJdO1xuXG4gICAgICAgICAgICAgICAgY1swXSA9IHBvc2l0aW9uc1tqMiAqIDNdO1xuICAgICAgICAgICAgICAgIGNbMV0gPSBwb3NpdGlvbnNbajIgKiAzICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHBvc2l0aW9uc1tqMiAqIDMgKyAyXTtcblxuICAgICAgICAgICAgICAgIG1hdGguc3ViVmVjMyhiLCBhLCBhYik7XG4gICAgICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGEsIGFjKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1WZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKG1hdGguY3Jvc3MzVmVjMyhhYiwgYWMsIGNyb3NzVmVjKSwgbm9ybVZlYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW52ZWNzW2owXSkge1xuICAgICAgICAgICAgICAgICAgICBudmVjc1tqMF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFudmVjc1tqMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnZlY3NbajFdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbnZlY3NbajJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG52ZWNzW2oyXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG52ZWNzW2owXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oxXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oyXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3JtYWxzID0gKG5vcm1hbHMgJiYgbm9ybWFscy5sZW5ndGggPT09IHBvc2l0aW9ucy5sZW5ndGgpID8gbm9ybWFscyA6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGxldCBjb3VudDtcbiAgICAgICAgICAgIGxldCB4O1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgejtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbnZlY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgIC8vIE5vdyBnbyB0aHJvdWdoIGFuZCBhdmVyYWdlIG91dCBldmVyeXRoaW5nXG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IG52ZWNzW2ldLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIHogPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbnZlY3NbaV1bal1bMF07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbnZlY3NbaV1bal1bMV07XG4gICAgICAgICAgICAgICAgICAgIHogKz0gbnZlY3NbaV1bal1bMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9ybWFsc1tpICogM10gPSAoeCAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMV0gPSAoeSAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMl0gPSAoeiAvIGNvdW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IHRhbmdlbnQgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucywgVVZzIGFuZCBpbmRpY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFRhbmdlbnRzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbnMsIGluZGljZXMsIHV2KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gVGhlIHZlcnRleCBhcnJheXMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgdGFuZ2VudHNcblxuICAgICAgICAgICAgZm9yIChsZXQgbG9jYXRpb24gPSAwOyBsb2NhdGlvbiA8IGluZGljZXMubGVuZ3RoOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWNvbnRydWN0aW5nIGVhY2ggdmVydGV4IGFuZCBVViBjb29yZGluYXRlIGludG8gdGhlIHJlc3BlY3RpdmUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHBvc2l0aW9ucy5zdWJhcnJheShpbmRleCAqIDMsIGluZGV4ICogMyArIDMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHV2MCA9IHV2LnN1YmFycmF5KGluZGV4ICogMiwgaW5kZXggKiAyICsgMik7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gcG9zaXRpb25zLnN1YmFycmF5KGluZGV4ICogMywgaW5kZXggKiAzICsgMyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXYxID0gdXYuc3ViYXJyYXkoaW5kZXggKiAyLCBpbmRleCAqIDIgKyAyKTtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbiArIDJdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdjIgPSBwb3NpdGlvbnMuc3ViYXJyYXkoaW5kZXggKiAzLCBpbmRleCAqIDMgKyAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1djIgPSB1di5zdWJhcnJheShpbmRleCAqIDIsIGluZGV4ICogMiArIDIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFQb3MxID0gbWF0aC5zdWJWZWMzKHYxLCB2MCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhUG9zMiA9IG1hdGguc3ViVmVjMyh2MiwgdjAsIHRlbXBWZWMzYik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMSA9IG1hdGguc3ViVmVjMih1djEsIHV2MCwgdGVtcFZlYzNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMiA9IG1hdGguc3ViVmVjMih1djIsIHV2MCwgdGVtcFZlYzNkKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAxIC8gKChkZWx0YVVWMVswXSAqIGRlbHRhVVYyWzFdKSAtIChkZWx0YVVWMVsxXSAqIGRlbHRhVVYyWzBdKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gbWF0aC5tdWxWZWMzU2NhbGFyKFxuICAgICAgICAgICAgICAgICAgICBtYXRoLnN1YlZlYzMoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm11bFZlYzNTY2FsYXIoZGVsdGFQb3MxLCBkZWx0YVVWMlsxXSwgdGVtcFZlYzNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubXVsVmVjM1NjYWxhcihkZWx0YVBvczIsIGRlbHRhVVYxWzFdLCB0ZW1wVmVjM2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFZlYzNnXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZWMzZlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBdmVyYWdlIHRoZSB2YWx1ZSBvZiB0aGUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGFkZFRvO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCAzOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG8gPSBpbmRpY2VzW2xvY2F0aW9uICsgdl0gKiAzO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUb10gKz0gdGFuZ2VudFswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudHNbYWRkVG8gKyAxXSArPSB0YW5nZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUbyArIDJdICs9IHRhbmdlbnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFuZ2VudHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IGFuZCBpbmRleCBhcnJheXMgbmVlZGVkIGJ5IGNvbG9yLWluZGV4ZWQgdHJpYW5nbGUgcGlja2luZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRQaWNrVHJpYW5nbGVzKHBvc2l0aW9ucywgaW5kaWNlcywgY29tcHJlc3NHZW9tZXRyeSkge1xuXG4gICAgICAgIGNvbnN0IG51bUluZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGlja1Bvc2l0aW9ucyA9IGNvbXByZXNzR2VvbWV0cnkgPyBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcyAqIDkpIDogbmV3IEZsb2F0MzJBcnJheShudW1JbmRpY2VzICogOSk7XG4gICAgICAgIGNvbnN0IHBpY2tDb2xvcnMgPSBuZXcgVWludDhBcnJheShudW1JbmRpY2VzICogMTIpO1xuICAgICAgICBsZXQgcHJpbUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHZpOy8vIFBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcHZpID0gMDsvLyBQaWNraW5nIHBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcGNpID0gMDsgLy8gUGlja2luZyBjb2xvciBhcnJheSBpbmRleFxuXG4gICAgICAgIC8vIFRyaWFuZ2xlIGluZGljZXNcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCByO1xuICAgICAgICBsZXQgZztcbiAgICAgICAgbGV0IGI7XG4gICAgICAgIGxldCBhO1xuXG4gICAgICAgIGZvciAobGV0IGxvY2F0aW9uID0gMDsgbG9jYXRpb24gPCBudW1JbmRpY2VzOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZS1pbmRleGVkIHRyaWFuZ2xlIHBpY2sgY29sb3JcblxuICAgICAgICAgICAgYSA9IChwcmltSW5kZXggPj4gMjQgJiAweEZGKTtcbiAgICAgICAgICAgIGIgPSAocHJpbUluZGV4ID4+IDE2ICYgMHhGRik7XG4gICAgICAgICAgICBnID0gKHByaW1JbmRleCA+PiA4ICYgMHhGRik7XG4gICAgICAgICAgICByID0gKHByaW1JbmRleCAmIDB4RkYpO1xuXG4gICAgICAgICAgICAvLyBBXG5cbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2xvY2F0aW9uXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIEJcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIENcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAyXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIHByaW1JbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogcGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGNvbG9yczogcGlja0NvbG9yc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBzdXJmYWNlLXBlcnBlbmRpY3VsYXIgZmFjZSBub3JtYWxzIHRvIHZlcnRleCBub3JtYWxzLiBBc3N1bWVzIHRoYXQgdGhlIG1lc2ggY29udGFpbnMgZGlzam9pbnQgdHJpYW5nbGVzXG4gICAgICogdGhhdCBkb24ndCBzaGFyZSB2ZXJ0ZXggYXJyYXkgZWxlbWVudHMuIFdvcmtzIGJ5IGZpbmRpbmcgZ3JvdXBzIG9mIHZlcnRpY2VzIHRoYXQgaGF2ZSB0aGUgc2FtZSBsb2NhdGlvbiBhbmRcbiAgICAgKiBhdmVyYWdpbmcgdGhlaXIgbm9ybWFsIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIG5vcm1hbHM6ICp9fVxuICAgICAqL1xuICAgIGZhY2VUb1ZlcnRleE5vcm1hbHMocG9zaXRpb25zLCBub3JtYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc21vb3RoTm9ybWFsc0FuZ2xlVGhyZXNob2xkID0gb3B0aW9ucy5zbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQgfHwgMjA7XG4gICAgICAgIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJ0ZXhOb3JtYWxzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnRleE5vcm1hbEFjY3VtID0ge307XG4gICAgICAgIGxldCBhY2M7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBwb3NpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW47XG4gICAgICAgIGxldCBhO1xuICAgICAgICBsZXQgYjtcbiAgICAgICAgbGV0IGM7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHBvc2kgPSBpIC8gMztcblxuICAgICAgICAgICAgdnggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB2eSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICB2eiA9IHBvc2l0aW9uc1tpICsgMl07XG5cbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4TWFwW2tleV0gPSBbcG9zaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRleE1hcFtrZXldLnB1c2gocG9zaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IG1hdGgubm9ybWFsaXplVmVjMyhbbm9ybWFsc1tpXSwgbm9ybWFsc1tpICsgMV0sIG5vcm1hbHNbaSArIDJdXSk7XG5cbiAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbcG9zaV0gPSBub3JtYWw7XG5cbiAgICAgICAgICAgIGFjYyA9IG1hdGgudmVjNChbbm9ybWFsWzBdLCBub3JtYWxbMV0sIG5vcm1hbFsyXSwgMV0pO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxBY2N1bVtwb3NpXSA9IGFjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHZlcnRleE1hcCkge1xuXG4gICAgICAgICAgICBpZiAodmVydGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdmVydGV4TWFwW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtVmVydHMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlpID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgYWNjID0gdmVydGV4Tm9ybWFsQWNjdW1baWldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1WZXJ0czsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpqID0gdmVydGljZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB2ZXJ0ZXhOb3JtYWxzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB2ZXJ0ZXhOb3JtYWxzW2pqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhtYXRoLmFuZ2xlVmVjMyhhLCBiKSAvIG1hdGguREVHVE9SQUQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCBzbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1swXSArPSBiWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1sxXSArPSBiWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1syXSArPSBiWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1szXSArPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub3JtYWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIGFjYyA9IHZlcnRleE5vcm1hbEFjY3VtW2kgLyAzXTtcblxuICAgICAgICAgICAgbm9ybWFsc1tpICsgMF0gPSBhY2NbMF0gLyBhY2NbM107XG4gICAgICAgICAgICBub3JtYWxzW2kgKyAxXSA9IGFjY1sxXSAvIGFjY1szXTtcbiAgICAgICAgICAgIG5vcm1hbHNbaSArIDJdID0gYWNjWzJdIC8gYWNjWzNdO1xuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSYXkgY2FzdGluZ1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgVHJhbnNmb3JtcyBhIENhbnZhcy1zcGFjZSBwb3NpdGlvbiBpbnRvIGEgV29ybGQtc3BhY2UgcmF5LCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb1dvcmxkUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gdmlld01hdHJpeCBWaWV3IG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSBwcm9qTWF0cml4IFByb2plY3Rpb24gbWF0cml4XG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGNhbnZhc1BvcyBUaGUgQ2FudmFzLXNwYWNlIHBvc2l0aW9uLlxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgY2FudmFzUG9zVG9Xb3JsZFJheTogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDRiID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0YyA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGIgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGMgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIHJldHVybiAoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBwdk1hdCA9IG1hdGgubXVsTWF0NChwcm9qTWF0cml4LCB2aWV3TWF0cml4LCB0ZW1wTWF0NGIpO1xuICAgICAgICAgICAgY29uc3QgcHZNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NChwdk1hdCwgdGVtcE1hdDRjKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNsaXAgc3BhY2UgY29vcmRpbmF0ZXMsIHdoaWNoIHdpbGwgYmUgaW4gcmFuZ2VcbiAgICAgICAgICAgIC8vIG9mIHg9Wy0xLi4xXSBhbmQgeT1bLTEuLjFdLCB3aXRoIHk9KCsxKSBhdCB0b3BcblxuICAgICAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCBjbGlwWCA9IChjYW52YXNQb3NbMF0gLSBjYW52YXNXaWR0aCAvIDIpIC8gKGNhbnZhc1dpZHRoIC8gMik7ICAvLyBDYWxjdWxhdGUgY2xpcCBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29uc3QgY2xpcFkgPSAtKGNhbnZhc1Bvc1sxXSAtIGNhbnZhc0hlaWdodCAvIDIpIC8gKGNhbnZhc0hlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSBjbGlwWDtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IGNsaXBZO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gLTE7XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRiLCAxIC8gdGVtcFZlYzRiWzNdKTtcblxuICAgICAgICAgICAgdGVtcFZlYzRjWzBdID0gY2xpcFg7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbMV0gPSBjbGlwWTtcbiAgICAgICAgICAgIHRlbXBWZWM0Y1syXSA9IDE7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGMsIHRlbXBWZWM0ZCk7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRkLCAxIC8gdGVtcFZlYzRkWzNdKTtcblxuICAgICAgICAgICAgd29ybGRSYXlPcmlnaW5bMF0gPSB0ZW1wVmVjNGRbMF07XG4gICAgICAgICAgICB3b3JsZFJheU9yaWdpblsxXSA9IHRlbXBWZWM0ZFsxXTtcbiAgICAgICAgICAgIHdvcmxkUmF5T3JpZ2luWzJdID0gdGVtcFZlYzRkWzJdO1xuXG4gICAgICAgICAgICBtYXRoLnN1YlZlYzModGVtcFZlYzRkLCB0ZW1wVmVjNGIsIHdvcmxkUmF5RGlyKTtcblxuICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKHdvcmxkUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICBUcmFuc2Zvcm1zIGEgQ2FudmFzLXNwYWNlIHBvc2l0aW9uIHRvIGEgTWVzaCdzIExvY2FsLXNwYWNlIGNvb3JkaW5hdGUgc3lzdGVtLCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb0xvY2FsUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBUaGUgQ2FtZXJhLlxuICAgICBAcGFyYW0ge01lc2h9IG1lc2ggVGhlIE1lc2guXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXRyaXggVmlldyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gcHJvak1hdHJpeCBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBNb2RlbGluZyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gY2FudmFzUG9zIFRoZSBDYW52YXMtc3BhY2UgcG9zaXRpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBjYW52YXNQb3NUb0xvY2FsUmF5OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB3b3JsZFJheU9yaWdpbiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHdvcmxkUmF5RGlyID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhbnZhcywgdmlld01hdHJpeCwgcHJvak1hdHJpeCwgd29ybGRNYXRyaXgsIGNhbnZhc1BvcywgbG9jYWxSYXlPcmlnaW4sIGxvY2FsUmF5RGlyKSA9PiB7XG4gICAgICAgICAgICBtYXRoLmNhbnZhc1Bvc1RvV29ybGRSYXkoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcik7XG4gICAgICAgICAgICBtYXRoLndvcmxkUmF5VG9Mb2NhbFJheSh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgIFRyYW5zZm9ybXMgYSByYXkgZnJvbSBXb3JsZC1zcGFjZSB0byBhIE1lc2gncyBMb2NhbC1zcGFjZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgQG1ldGhvZCB3b3JsZFJheVRvTG9jYWxSYXlcbiAgICAgQHN0YXRpY1xuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBUaGUgV29ybGQgdHJhbnNmb3JtIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB3b3JsZFJheVRvTG9jYWxSYXk6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAgICAgcmV0dXJuICh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NCh3b3JsZE1hdHJpeCwgdGVtcE1hdDQpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSB3b3JsZFJheU9yaWdpblswXTtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IHdvcmxkUmF5T3JpZ2luWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gd29ybGRSYXlPcmlnaW5bMl07XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQobW9kZWxNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG5cbiAgICAgICAgICAgIGxvY2FsUmF5T3JpZ2luWzBdID0gdGVtcFZlYzRiWzBdO1xuICAgICAgICAgICAgbG9jYWxSYXlPcmlnaW5bMV0gPSB0ZW1wVmVjNGJbMV07XG4gICAgICAgICAgICBsb2NhbFJheU9yaWdpblsyXSA9IHRlbXBWZWM0YlsyXTtcblxuICAgICAgICAgICAgbWF0aC50cmFuc2Zvcm1WZWMzKG1vZGVsTWF0SW52ZXJzZSwgd29ybGRSYXlEaXIsIGxvY2FsUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIGJ1aWxkS0RUcmVlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBLRF9UUkVFX01BWF9ERVBUSCA9IDEwO1xuICAgICAgICBjb25zdCBLRF9UUkVFX01JTl9UUklBTkdMRVMgPSAyMDtcblxuICAgICAgICBjb25zdCBkaW1MZW5ndGggPSBuZXcgRmxvYXQzMkFycmF5KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGROb2RlKHRyaWFuZ2xlcywgaW5kaWNlcywgcG9zaXRpb25zLCBkZXB0aCkge1xuICAgICAgICAgICAgY29uc3QgYWFiYiA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGVhZjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3BsaXREaW06IDAsXG4gICAgICAgICAgICAgICAgYWFiYlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWFiYlswXSA9IGFhYmJbMV0gPSBhYWJiWzJdID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgYWFiYlszXSA9IGFhYmJbNF0gPSBhYWJiWzVdID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlpID0gdHJpYW5nbGVzW3RdICogMztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGluZGljZXNbaWkgKyBqXSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGldIDwgYWFiYlswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlswXSA9IHBvc2l0aW9uc1twaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW3BpXSA+IGFhYmJbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhYmJbM10gPSBwb3NpdGlvbnNbcGldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdIDwgYWFiYlsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsxXSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdID4gYWFiYls0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls0XSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdIDwgYWFiYlsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsyXSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdID4gYWFiYls1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls1XSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmlhbmdsZXMubGVuZ3RoIDwgS0RfVFJFRV9NSU5fVFJJQU5HTEVTIHx8IGRlcHRoID4gS0RfVFJFRV9NQVhfREVQVEgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcbiAgICAgICAgICAgICAgICBub2RlLmxlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaW1MZW5ndGhbMF0gPSBhYWJiWzNdIC0gYWFiYlswXTtcbiAgICAgICAgICAgIGRpbUxlbmd0aFsxXSA9IGFhYmJbNF0gLSBhYWJiWzFdO1xuICAgICAgICAgICAgZGltTGVuZ3RoWzJdID0gYWFiYls1XSAtIGFhYmJbMl07XG5cbiAgICAgICAgICAgIGxldCBkaW0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzFdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzJdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLnNwbGl0RGltID0gZGltO1xuXG4gICAgICAgICAgICBjb25zdCBtaWQgPSAoYWFiYltkaW1dICsgYWFiYltkaW0gKyAzXSkgLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG5ldyBBcnJheSh0cmlhbmdsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBudW1MZWZ0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbmV3IEFycmF5KHRyaWFuZ2xlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IG51bVJpZ2h0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWkgPSB0cmlhbmdsZXNbdF0gKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkwID0gaW5kaWNlc1tpaV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTEgPSBpbmRpY2VzW2lpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTIgPSBpbmRpY2VzW2lpICsgMl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwaTAgPSBpMCAqIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGkxID0gaTEgKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpMiA9IGkyICogMztcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGkwICsgZGltXSA8PSBtaWQgfHwgcG9zaXRpb25zW3BpMSArIGRpbV0gPD0gbWlkIHx8IHBvc2l0aW9uc1twaTIgKyBkaW1dIDw9IG1pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0W251bUxlZnQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRbbnVtUmlnaHQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0Lmxlbmd0aCA9IG51bUxlZnQ7XG4gICAgICAgICAgICByaWdodC5sZW5ndGggPSBudW1SaWdodDtcblxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gYnVpbGROb2RlKGxlZnQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSBidWlsZE5vZGUocmlnaHQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGluZGljZXMsIHBvc2l0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbnVtVHJpcyA9IGluZGljZXMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IG5ldyBBcnJheShudW1UcmlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJpczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZE5vZGUodHJpYW5nbGVzLCBpbmRpY2VzLCBwb3NpdGlvbnMsIDApO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG5cbiAgICBkZWNvbXByZXNzUG9zaXRpb24ocG9zaXRpb24sIGRlY29kZU1hdHJpeCwgZGVzdCkge1xuICAgICAgICBkZXN0WzBdID0gcG9zaXRpb25bMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbMTJdO1xuICAgICAgICBkZXN0WzFdID0gcG9zaXRpb25bMV0gKiBkZWNvZGVNYXRyaXhbNV0gKyBkZWNvZGVNYXRyaXhbMTNdO1xuICAgICAgICBkZXN0WzJdID0gcG9zaXRpb25bMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1Bvc2l0aW9ucyhwb3NpdGlvbnMsIGRlY29kZU1hdHJpeCwgZGVzdCA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgZGVzdFtpICsgMF0gPSBwb3NpdGlvbnNbaSArIDBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzEyXTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gcG9zaXRpb25zW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs1XSArIGRlY29kZU1hdHJpeFsxM107XG4gICAgICAgICAgICBkZXN0W2kgKyAyXSA9IHBvc2l0aW9uc1tpICsgMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1VWKHV2LCBkZWNvZGVNYXRyaXgsIGRlc3QpIHtcbiAgICAgICAgZGVzdFswXSA9IHV2WzBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzZdO1xuICAgICAgICBkZXN0WzFdID0gdXZbMV0gKiBkZWNvZGVNYXRyaXhbNF0gKyBkZWNvZGVNYXRyaXhbN107XG4gICAgfSxcblxuICAgIGRlY29tcHJlc3NVVnModXZzLCBkZWNvZGVNYXRyaXgsIGRlc3QgPSBuZXcgRmxvYXQzMkFycmF5KHV2cy5sZW5ndGgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB1dnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGRlc3RbaSArIDBdID0gdXZzW2kgKyAwXSAqIGRlY29kZU1hdHJpeFswXSArIGRlY29kZU1hdHJpeFs2XTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gdXZzW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs0XSArIGRlY29kZU1hdHJpeFs3XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMihvY3QsIHJlc3VsdCkge1xuICAgICAgICBsZXQgeCA9IG9jdFswXTtcbiAgICAgICAgbGV0IHkgPSBvY3RbMV07XG4gICAgICAgIHggPSAoMiAqIHggKyAxKSAvIDI1NTtcbiAgICAgICAgeSA9ICgyICogeSArIDEpIC8gMjU1O1xuICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgeCA9ICgxIC0gTWF0aC5hYnMoeSkpICogKHggPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgcmVzdWx0WzBdID0geCAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzJdID0geiAvIGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMnMob2N0cywgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbGVuID0gb2N0cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHggPSBvY3RzW2kgKyAwXTtcbiAgICAgICAgICAgIGxldCB5ID0gb2N0c1tpICsgMV07XG4gICAgICAgICAgICB4ID0gKDIgKiB4ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICB5ID0gKDIgKiB5ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gKDEgLSBNYXRoLmFicyh5KSkgKiAoeCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICAgICAgcmVzdWx0W2ogKyAwXSA9IHggLyBsZW5ndGg7XG4gICAgICAgICAgICByZXN1bHRbaiArIDFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdFtqICsgMl0gPSB6IC8gbGVuZ3RoO1xuICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubWF0aC5idWlsZEVkZ2VJbmRpY2VzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHVuaXF1ZVBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXNMb29rdXAgPSBbXTtcbiAgICBjb25zdCBpbmRpY2VzUmV2ZXJzZUxvb2t1cCA9IFtdO1xuICAgIGNvbnN0IHdlbGRlZEluZGljZXMgPSBbXTtcblxuICAgIC8vIFRPRE86IE9wdGltaXplIHdpdGggY2FjaGluZywgYnV0IG5lZWQgdG8gY2F0ZXIgdG8gYm90aCBjb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgcG9zaXRpb25zXG5cbiAgICBjb25zdCBmYWNlcyA9IFtdO1xuICAgIGxldCBudW1GYWNlcyA9IDA7XG4gICAgY29uc3QgY29tcGEgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGIgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGMgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgYSA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBjID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgY2IgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBhYiA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGNyb3NzID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3Qgbm9ybWFsID0gbWF0aC52ZWMzKCk7XG5cbiAgICBmdW5jdGlvbiB3ZWxkVmVydGljZXMocG9zaXRpb25zLCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuICAgICAgICBsZXQgdng7XG4gICAgICAgIGxldCB2eTtcbiAgICAgICAgbGV0IHZ6O1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBjb25zdCBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvblBvaW50cyk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgbGVuVW5pcXVlUG9zaXRpb25zID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IE1hdGgucm91bmQodnggKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2eSAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZ6ICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbnNNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zTWFwW2tleV0gPSBsZW5VbmlxdWVQb3NpdGlvbnMgLyAzO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9uc1tsZW5VbmlxdWVQb3NpdGlvbnMrK10gPSB2eDtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnNbbGVuVW5pcXVlUG9zaXRpb25zKytdID0gdnk7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zW2xlblVuaXF1ZVBvc2l0aW9ucysrXSA9IHZ6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB3ZWxkZWRJbmRpY2VzW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgICAgIGluZGljZXNSZXZlcnNlTG9va3VwW3dlbGRlZEluZGljZXNbaV1dID0gaW5kaWNlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmFjZXMobnVtSW5kaWNlcywgcG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgIG51bUZhY2VzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG51bUluZGljZXM7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgaWEgPSAoKHdlbGRlZEluZGljZXNbaV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYiA9ICgod2VsZGVkSW5kaWNlc1tpICsgMV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYyA9ICgod2VsZGVkSW5kaWNlc1tpICsgMl0pICogMyk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgY29tcGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGNvbXBhWzFdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMV07XG4gICAgICAgICAgICAgICAgY29tcGFbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAyXTtcbiAgICAgICAgICAgICAgICBjb21wYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgY29tcGJbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb21wYlsyXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDJdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjb21wY1sxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDFdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzJdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMl07XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlXG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGEsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYSk7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGIsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYik7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGMsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGFbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAxXTtcbiAgICAgICAgICAgICAgICBhWzJdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMl07XG4gICAgICAgICAgICAgICAgYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgYlsxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDFdO1xuICAgICAgICAgICAgICAgIGJbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAyXTtcbiAgICAgICAgICAgICAgICBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjWzFdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGIsIGNiKTtcbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhhLCBiLCBhYik7XG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzMoY2IsIGFiLCBjcm9zcyk7XG4gICAgICAgICAgICBtYXRoLm5vcm1hbGl6ZVZlYzMoY3Jvc3MsIG5vcm1hbCk7XG4gICAgICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbbnVtRmFjZXNdIHx8IChmYWNlc1tudW1GYWNlc10gPSB7bm9ybWFsOiBtYXRoLnZlYzMoKX0pO1xuICAgICAgICAgICAgZmFjZS5ub3JtYWxbMF0gPSBub3JtYWxbMF07XG4gICAgICAgICAgICBmYWNlLm5vcm1hbFsxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICAgIGZhY2Uubm9ybWFsWzJdID0gbm9ybWFsWzJdO1xuICAgICAgICAgICAgbnVtRmFjZXMrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocG9zaXRpb25zLCBpbmRpY2VzLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGVkZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgd2VsZFZlcnRpY2VzKHBvc2l0aW9ucywgaW5kaWNlcyk7XG4gICAgICAgIGJ1aWxkRmFjZXMoaW5kaWNlcy5sZW5ndGgsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgIGNvbnN0IGVkZ2VJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKG1hdGguREVHVE9SQUQgKiBlZGdlVGhyZXNob2xkKTtcbiAgICAgICAgY29uc3QgZWRnZXMgPSB7fTtcbiAgICAgICAgbGV0IGVkZ2UxO1xuICAgICAgICBsZXQgZWRnZTI7XG4gICAgICAgIGxldCBpbmRleDE7XG4gICAgICAgIGxldCBpbmRleDI7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCBsYXJnZUluZGV4ID0gZmFsc2U7XG4gICAgICAgIGxldCBlZGdlO1xuICAgICAgICBsZXQgbm9ybWFsMTtcbiAgICAgICAgbGV0IG5vcm1hbDI7XG4gICAgICAgIGxldCBkb3Q7XG4gICAgICAgIGxldCBpYTtcbiAgICAgICAgbGV0IGliO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgZmFjZUluZGV4ID0gaSAvIDM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgIGVkZ2UxID0gd2VsZGVkSW5kaWNlc1tpICsgal07XG4gICAgICAgICAgICAgICAgZWRnZTIgPSB3ZWxkZWRJbmRpY2VzW2kgKyAoKGogKyAxKSAlIDMpXTtcbiAgICAgICAgICAgICAgICBpbmRleDEgPSBNYXRoLm1pbihlZGdlMSwgZWRnZTIpO1xuICAgICAgICAgICAgICAgIGluZGV4MiA9IE1hdGgubWF4KGVkZ2UxLCBlZGdlMik7XG4gICAgICAgICAgICAgICAga2V5ID0gaW5kZXgxICsgXCIsXCIgKyBpbmRleDI7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxOiBpbmRleDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDI6IGluZGV4MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UxOiBmYWNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlMjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNba2V5XS5mYWNlMiA9IGZhY2VJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gZWRnZXMpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1trZXldO1xuICAgICAgICAgICAgLy8gYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXG4gICAgICAgICAgICBpZiAoZWRnZS5mYWNlMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsMSA9IGZhY2VzW2VkZ2UuZmFjZTFdLm5vcm1hbDtcbiAgICAgICAgICAgICAgICBub3JtYWwyID0gZmFjZXNbZWRnZS5mYWNlMl0ubm9ybWFsO1xuICAgICAgICAgICAgICAgIGRvdCA9IG1hdGguZG90VmVjMyhub3JtYWwxLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gdGhyZXNob2xkRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlhID0gaW5kaWNlc1JldmVyc2VMb29rdXBbZWRnZS5pbmRleDFdO1xuICAgICAgICAgICAgaWIgPSBpbmRpY2VzUmV2ZXJzZUxvb2t1cFtlZGdlLmluZGV4Ml07XG4gICAgICAgICAgICBpZiAoIWxhcmdlSW5kZXggJiYgaWEgPiA2NTUzNSB8fCBpYiA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgbGFyZ2VJbmRleCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGdlSW5kaWNlcy5wdXNoKGlhKTtcbiAgICAgICAgICAgIGVkZ2VJbmRpY2VzLnB1c2goaWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGFyZ2VJbmRleCkgPyBuZXcgVWludDMyQXJyYXkoZWRnZUluZGljZXMpIDogbmV3IFVpbnQxNkFycmF5KGVkZ2VJbmRpY2VzKTtcbiAgICB9O1xufSkoKTtcblxuXG5leHBvcnQge21hdGh9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js ***!
  \*******************************************************************/
/*! exports provided: stats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stats\", function() { return stats; });\n/**\n * xeokit runtime statistics.\n * @private\n * @type {{components: {models: number, objects: number, scenes: number, meshes: number}, memory: {indices: number, uvs: number, textures: number, materials: number, transforms: number, positions: number, programs: number, normals: number, meshes: number, colors: number}, build: {version: string}, client: {browser: string}, frame: {frameCount: number, useProgram: number, bindTexture: number, drawElements: number, bindArray: number, tasksRun: number, fps: number, drawArrays: number, tasksScheduled: number}}}\n */\nconst stats = {\n    build: {\n        version: \"0.8\"\n    },\n    client: {\n        browser: (navigator && navigator.userAgent) ? navigator.userAgent : \"n/a\"\n    },\n\n    components: {\n        scenes: 0,\n        models: 0,\n        meshes: 0,\n        objects: 0\n    },\n    memory: {\n        meshes: 0,\n        positions: 0,\n        colors: 0,\n        normals: 0,\n        uvs: 0,\n        indices: 0,\n        textures: 0,\n        transforms: 0,\n        materials: 0,\n        programs: 0\n    },\n    frame: {\n        frameCount: 0,\n        fps: 0,\n        useProgram: 0,\n        bindTexture: 0,\n        bindArray: 0,\n        drawElements: 0,\n        drawArrays: 0,\n        tasksRun: 0,\n        tasksScheduled: 0\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzPzg0NDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxnRUFBZ0UsV0FBVyw0S0FBNEssVUFBVSxnQkFBZ0IsV0FBVyxnQkFBZ0IsVUFBVTtBQUM5VTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB4ZW9raXQgcnVudGltZSBzdGF0aXN0aWNzLlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHt7Y29tcG9uZW50czoge21vZGVsczogbnVtYmVyLCBvYmplY3RzOiBudW1iZXIsIHNjZW5lczogbnVtYmVyLCBtZXNoZXM6IG51bWJlcn0sIG1lbW9yeToge2luZGljZXM6IG51bWJlciwgdXZzOiBudW1iZXIsIHRleHR1cmVzOiBudW1iZXIsIG1hdGVyaWFsczogbnVtYmVyLCB0cmFuc2Zvcm1zOiBudW1iZXIsIHBvc2l0aW9uczogbnVtYmVyLCBwcm9ncmFtczogbnVtYmVyLCBub3JtYWxzOiBudW1iZXIsIG1lc2hlczogbnVtYmVyLCBjb2xvcnM6IG51bWJlcn0sIGJ1aWxkOiB7dmVyc2lvbjogc3RyaW5nfSwgY2xpZW50OiB7YnJvd3Nlcjogc3RyaW5nfSwgZnJhbWU6IHtmcmFtZUNvdW50OiBudW1iZXIsIHVzZVByb2dyYW06IG51bWJlciwgYmluZFRleHR1cmU6IG51bWJlciwgZHJhd0VsZW1lbnRzOiBudW1iZXIsIGJpbmRBcnJheTogbnVtYmVyLCB0YXNrc1J1bjogbnVtYmVyLCBmcHM6IG51bWJlciwgZHJhd0FycmF5czogbnVtYmVyLCB0YXNrc1NjaGVkdWxlZDogbnVtYmVyfX19XG4gKi9cbmNvbnN0IHN0YXRzID0ge1xuICAgIGJ1aWxkOiB7XG4gICAgICAgIHZlcnNpb246IFwiMC44XCJcbiAgICB9LFxuICAgIGNsaWVudDoge1xuICAgICAgICBicm93c2VyOiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IFwibi9hXCJcbiAgICB9LFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBzY2VuZXM6IDAsXG4gICAgICAgIG1vZGVsczogMCxcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBvYmplY3RzOiAwXG4gICAgfSxcbiAgICBtZW1vcnk6IHtcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBwb3NpdGlvbnM6IDAsXG4gICAgICAgIGNvbG9yczogMCxcbiAgICAgICAgbm9ybWFsczogMCxcbiAgICAgICAgdXZzOiAwLFxuICAgICAgICBpbmRpY2VzOiAwLFxuICAgICAgICB0ZXh0dXJlczogMCxcbiAgICAgICAgdHJhbnNmb3JtczogMCxcbiAgICAgICAgbWF0ZXJpYWxzOiAwLFxuICAgICAgICBwcm9ncmFtczogMFxuICAgIH0sXG4gICAgZnJhbWU6IHtcbiAgICAgICAgZnJhbWVDb3VudDogMCxcbiAgICAgICAgZnBzOiAwLFxuICAgICAgICB1c2VQcm9ncmFtOiAwLFxuICAgICAgICBiaW5kVGV4dHVyZTogMCxcbiAgICAgICAgYmluZEFycmF5OiAwLFxuICAgICAgICBkcmF3RWxlbWVudHM6IDAsXG4gICAgICAgIGRyYXdBcnJheXM6IDAsXG4gICAgICAgIHRhc2tzUnVuOiAwLFxuICAgICAgICB0YXNrc1NjaGVkdWxlZDogMFxuICAgIH1cbn07XG5cbmV4cG9ydCB7c3RhdHN9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js ***!
  \*******************************************************************/
/*! exports provided: utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n/**\n * @private\n */\nfunction xmlToJson(node, attributeRenamer) {\n    if (node.nodeType === node.TEXT_NODE) {\n        var v = node.nodeValue;\n        if (v.match(/^\\s+$/) === null) {\n            return v;\n        }\n    } else if (node.nodeType === node.ELEMENT_NODE ||\n        node.nodeType === node.DOCUMENT_NODE) {\n        var json = {type: node.nodeName, children: []};\n\n        if (node.nodeType === node.ELEMENT_NODE) {\n            for (var j = 0; j < node.attributes.length; j++) {\n                var attribute = node.attributes[j];\n                var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;\n                json[nm] = attribute.nodeValue;\n            }\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n            var item = node.childNodes[i];\n            var j = xmlToJson(item, attributeRenamer);\n            if (j) json.children.push(j);\n        }\n\n        return json;\n    }\n}\n\n/**\n * @private\n */\nfunction clone(ob) {\n    return JSON.parse(JSON.stringify(ob));\n}\n\n/**\n * @private\n */\nvar guidChars = [[\"0\", 10], [\"A\", 26], [\"a\", 26], [\"_\", 1], [\"$\", 1]].map(function (a) {\n    var li = [];\n    var st = a[0].charCodeAt(0);\n    var en = st + a[1];\n    for (var i = st; i < en; ++i) {\n        li.push(i);\n    }\n    return String.fromCharCode.apply(null, li);\n}).join(\"\");\n\n/**\n * @private\n */\nfunction b64(v, len) {\n    var r = (!len || len === 4) ? [0, 6, 12, 18] : [0, 6];\n    return r.map(function (i) {\n        return guidChars.substr(parseInt(v / (1 << i)) % 64, 1)\n    }).reverse().join(\"\");\n}\n\n/**\n * @private\n */\nfunction compressGuid(g) {\n    var bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function (i) {\n        return parseInt(g.substr(i, 2), 16);\n    });\n    return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function (i) {\n        return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2]);\n    }).join(\"\");\n}\n\n/**\n * @private\n */\nfunction findNodeOfType(m, t) {\n    var li = [];\n    var _ = function (n) {\n        if (n.type === t) li.push(n);\n        (n.children || []).forEach(function (c) {\n            _(c);\n        });\n    };\n    _(m);\n    return li;\n}\n\n/**\n * @private\n */\nfunction timeout(dt) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(resolve, dt);\n    });\n}\n\n/**\n * @private\n */\nfunction httpRequest(args) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(args.method || \"GET\", args.url, true);\n        xhr.onload = function (e) {\n            console.log(args.url, xhr.readyState, xhr.status);\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.responseXML);\n                } else {\n                    reject(xhr.statusText);\n                }\n            }\n        };\n        xhr.send(null);\n    });\n}\n\n/**\n * @private\n */\nconst queryString = function () {\n    // This function is anonymous, is executed immediately and\n    // the return value is assigned to QueryString!\n    var query_string = {};\n    var query = window.location.search.substring(1);\n    var vars = query.split(\"&\");\n    for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        // If first entry with this name\n        if (typeof query_string[pair[0]] === \"undefined\") {\n            query_string[pair[0]] = decodeURIComponent(pair[1]);\n            // If second entry with this name\n        } else if (typeof query_string[pair[0]] === \"string\") {\n            var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];\n            query_string[pair[0]] = arr;\n            // If third or later entry with this name\n        } else {\n            query_string[pair[0]].push(decodeURIComponent(pair[1]));\n        }\n    }\n    return query_string;\n}();\n\n/**\n * @private\n */\nfunction loadJSON(url, ok, err) {\n    // Avoid checking ok and err on each use.\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n\n    var request = new XMLHttpRequest();\n    request.overrideMimeType(\"application/json\");\n    request.open('GET', url, true);\n    request.addEventListener('load', function (event) {\n        var response = event.target.response;\n        if (this.status === 200) {\n            var json;\n            try {\n                json = JSON.parse(response);\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n            ok(json);\n        } else if (this.status === 0) {\n            // Some browsers return HTTP Status 0 when using non-http protocol\n            // e.g. 'file://' or 'data://'. Handle as success.\n            console.warn('loadFile: HTTP Status 0 received.');\n            try {\n                ok(JSON.parse(response));\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n        } else {\n            err(event);\n        }\n    }, false);\n\n    request.addEventListener('error', function (event) {\n        err(event);\n    }, false);\n    request.send(null);\n}\n\n/**\n * @private\n */\nfunction loadArraybuffer(url, ok, err) {\n    // Check for data: URI\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n        const isBase64 = !!dataUriRegexResult[2];\n        var data = dataUriRegexResult[3];\n        data = window.decodeURIComponent(data);\n        if (isBase64) {\n            data = window.atob(data);\n        }\n        try {\n            const buffer = new ArrayBuffer(data.length);\n            const view = new Uint8Array(buffer);\n            for (var i = 0; i < data.length; i++) {\n                view[i] = data.charCodeAt(i);\n            }\n            window.setTimeout(function () {\n                ok(buffer);\n            }, 0);\n        } catch (error) {\n            window.setTimeout(function () {\n                err(error);\n            }, 0);\n        }\n    } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.responseType = 'arraybuffer';\n        request.onreadystatechange = function () {\n            if (request.readyState === 4) {\n                if (request.status === 200) {\n                    ok(request.response);\n                } else {\n                    err('loadArrayBuffer error : ' + request.response);\n                }\n            }\n        };\n        request.send(null);\n    }\n}\n\n/**\n Tests if the given object is an array\n @private\n */\nfunction isArray(value) {\n    return value && !(value.propertyIsEnumerable('length')) && typeof value === 'object' && typeof value.length === 'number';\n}\n\n/**\n Tests if the given value is a string\n @param value\n @returns {boolean}\n @private\n */\nfunction isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n Tests if the given value is a number\n @param value\n @returns {boolean}\n @private\n */\nfunction isNumeric(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/**\n Tests if the given value is an ID\n @param value\n @returns {boolean}\n @private\n */\nfunction isID(value) {\n    return utils.isString(value) || utils.isNumeric(value);\n}\n\n/**\n Tests if the given components are the same, where the components can be either IDs or instances.\n @param c1\n @param c2\n @returns {boolean}\n @private\n */\nfunction isSameComponent(c1, c2) {\n    if (!c1 || !c2) {\n        return false;\n    }\n    const id1 = (utils.isNumeric(c1) || utils.isString(c1)) ? `${c1}` : c1.id;\n    const id2 = (utils.isNumeric(c2) || utils.isString(c2)) ? `${c2}` : c2.id;\n    return id1 === id2;\n}\n\n/**\n Tests if the given value is a function\n @param value\n @returns {boolean}\n @private\n */\nfunction isFunction(value) {\n    return (typeof value === \"function\");\n}\n\n/**\n Tests if the given value is a JavaScript JSON object, eg, ````{ foo: \"bar\" }````.\n @param value\n @returns {boolean}\n @private\n */\nfunction isObject(value) {\n    const objectConstructor = {}.constructor;\n    return (!!value && value.constructor === objectConstructor);\n}\n\n/** Returns a shallow copy\n */\nfunction copy(o) {\n    return utils.apply(o, {});\n}\n\n/** Add properties of o to o2, overwriting them on o2 if already there\n */\nfunction apply(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            o2[name] = o[name];\n        }\n    }\n    return o2;\n}\n\n/**\n Add non-null/defined properties of o to o2\n @private\n */\nfunction apply2(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o[name] !== undefined && o[name] !== null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Add properties of o to o2 where undefined or null on o2\n @private\n */\nfunction applyIf(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o2[name] === undefined || o2[name] === null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Returns true if the given map is empty.\n @param obj\n @returns {boolean}\n @private\n */\nfunction isEmptyObject(obj) {\n    for (const name in obj) {\n        if (obj.hasOwnProperty(name)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n Returns the given ID as a string, in quotes if the ID was a string to begin with.\n\n This is useful for logging IDs.\n\n @param {Number| String} id The ID\n @returns {String}\n @private\n */\nfunction inQuotes(id) {\n    return utils.isNumeric(id) ? (`${id}`) : (`'${id}'`);\n}\n\n/**\n Returns the concatenation of two typed arrays.\n @param a\n @param b\n @returns {*|a}\n @private\n */\nfunction concat(a, b) {\n    const c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n}\n\nfunction flattenParentChildHierarchy(root) {\n    var list = [];\n\n    function visit(node) {\n        node.id = node.uuid;\n        delete node.oid;\n        list.push(node);\n        var children = node.children;\n\n        if (children) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                child.parent = node.id;\n                visit(children[i]);\n            }\n        }\n        node.children = [];\n    }\n\n    visit(root);\n    return list;\n}\n\n/**\n * @private\n */\nconst utils = {\n    xmlToJson: xmlToJson,\n    clone: clone,\n    compressGuid: compressGuid,\n    findNodeOfType: findNodeOfType,\n    timeout: timeout,\n    httpRequest: httpRequest,\n    loadJSON: loadJSON,\n    loadArraybuffer: loadArraybuffer,\n    queryString: queryString,\n    isArray: isArray,\n    isString: isString,\n    isNumeric: isNumeric,\n    isID: isID,\n    isSameComponent: isSameComponent,\n    isFunction: isFunction,\n    isObject: isObject,\n    copy: copy,\n    apply: apply,\n    apply2: apply2,\n    applyIf: applyIf,\n    isEmptyObject: isEmptyObject,\n    inQuotes: inQuotes,\n    concat: concat,\n    flattenParentChildHierarchy: flattenParentChildHierarchy\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzLmpzP2NkYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlFQUF5RSxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5RUFBeUUsRUFBRTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsZUFBZTtBQUN4QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsVUFBVSxHQUFHO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHhtbFRvSnNvbihub2RlLCBhdHRyaWJ1dGVSZW5hbWVyKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIHZhciB2ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGlmICh2Lm1hdGNoKC9eXFxzKyQvKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFIHx8XG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIganNvbiA9IHt0eXBlOiBub2RlLm5vZGVOYW1lLCBjaGlsZHJlbjogW119O1xuXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBubSA9IGF0dHJpYnV0ZVJlbmFtZXJbYXR0cmlidXRlLm5vZGVOYW1lXSB8fCBhdHRyaWJ1dGUubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAganNvbltubV0gPSBhdHRyaWJ1dGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSB4bWxUb0pzb24oaXRlbSwgYXR0cmlidXRlUmVuYW1lcik7XG4gICAgICAgICAgICBpZiAoaikganNvbi5jaGlsZHJlbi5wdXNoKGopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2IpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ3VpZENoYXJzID0gW1tcIjBcIiwgMTBdLCBbXCJBXCIsIDI2XSwgW1wiYVwiLCAyNl0sIFtcIl9cIiwgMV0sIFtcIiRcIiwgMV1dLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBzdCA9IGFbMF0uY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZW4gPSBzdCArIGFbMV07XG4gICAgZm9yICh2YXIgaSA9IHN0OyBpIDwgZW47ICsraSkge1xuICAgICAgICBsaS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBsaSk7XG59KS5qb2luKFwiXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGI2NCh2LCBsZW4pIHtcbiAgICB2YXIgciA9ICghbGVuIHx8IGxlbiA9PT0gNCkgPyBbMCwgNiwgMTIsIDE4XSA6IFswLCA2XTtcbiAgICByZXR1cm4gci5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGd1aWRDaGFycy5zdWJzdHIocGFyc2VJbnQodiAvICgxIDw8IGkpKSAlIDY0LCAxKVxuICAgIH0pLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzR3VpZChnKSB7XG4gICAgdmFyIGJzID0gWzAsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE2LCAxOCwgMjAsIDIyLCAyNCwgMjYsIDI4LCAzMF0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChnLnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiBiNjQoYnNbMF0sIDIpICsgWzEsIDQsIDcsIDEwLCAxM10ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBiNjQoKGJzW2ldIDw8IDE2KSArIChic1tpICsgMV0gPDwgOCkgKyBic1tpICsgMl0pO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmluZE5vZGVPZlR5cGUobSwgdCkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBfID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4udHlwZSA9PT0gdCkgbGkucHVzaChuKTtcbiAgICAgICAgKG4uY2hpbGRyZW4gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF8oYyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXyhtKTtcbiAgICByZXR1cm4gbGk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKGFyZ3MubWV0aG9kIHx8IFwiR0VUXCIsIGFyZ3MudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLnVybCwgeGhyLnJlYWR5U3RhdGUsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZVhNTCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHhoci5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYW5vbnltb3VzLCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBhbmRcbiAgICAvLyB0aGUgcmV0dXJuIHZhbHVlIGlzIGFzc2lnbmVkIHRvIFF1ZXJ5U3RyaW5nIVxuICAgIHZhciBxdWVyeV9zdHJpbmcgPSB7fTtcbiAgICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgLy8gSWYgZmlyc3QgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgICAgIC8vIElmIHNlY29uZCBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbcXVlcnlfc3RyaW5nW3BhaXJbMF1dLCBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSldO1xuICAgICAgICAgICAgcXVlcnlfc3RyaW5nW3BhaXJbMF1dID0gYXJyO1xuICAgICAgICAgICAgLy8gSWYgdGhpcmQgb3IgbGF0ZXIgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXS5wdXNoKGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5X3N0cmluZztcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkSlNPTih1cmwsIG9rLCBlcnIpIHtcbiAgICAvLyBBdm9pZCBjaGVja2luZyBvayBhbmQgZXJyIG9uIGVhY2ggdXNlLlxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGV2ZW50LnRhcmdldC5yZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBqc29uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9rKGpzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcbiAgICAgICAgICAgIC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2xvYWRGaWxlOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvayhKU09OLnBhcnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycihldmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVycihldmVudCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkQXJyYXlidWZmZXIodXJsLCBvaywgZXJyKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KTtcbiAgICBpZiAoZGF0YVVyaVJlZ2V4UmVzdWx0KSB7IC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgZGF0YSBVUklzIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgY29uc3QgaXNCYXNlNjQgPSAhIWRhdGFVcmlSZWdleFJlc3VsdFsyXTtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhVXJpUmVnZXhSZXN1bHRbM107XG4gICAgICAgIGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB3aW5kb3cuYXRvYihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlld1tpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvayhidWZmZXIpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXJyKGVycm9yKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2socmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyKCdsb2FkQXJyYXlCdWZmZXIgZXJyb3IgOiAnICsgcmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgfVxufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGFycmF5XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhKHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gVGVzdHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXJcbiBAcGFyYW0gdmFsdWVcbiBAcmV0dXJucyB7Ym9vbGVhbn1cbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJRFxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSUQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNTdHJpbmcodmFsdWUpIHx8IHV0aWxzLmlzTnVtZXJpYyh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiBjb21wb25lbnRzIGFyZSB0aGUgc2FtZSwgd2hlcmUgdGhlIGNvbXBvbmVudHMgY2FuIGJlIGVpdGhlciBJRHMgb3IgaW5zdGFuY2VzLlxuIEBwYXJhbSBjMVxuIEBwYXJhbSBjMlxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZUNvbXBvbmVudChjMSwgYzIpIHtcbiAgICBpZiAoIWMxIHx8ICFjMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlkMSA9ICh1dGlscy5pc051bWVyaWMoYzEpIHx8IHV0aWxzLmlzU3RyaW5nKGMxKSkgPyBgJHtjMX1gIDogYzEuaWQ7XG4gICAgY29uc3QgaWQyID0gKHV0aWxzLmlzTnVtZXJpYyhjMikgfHwgdXRpbHMuaXNTdHJpbmcoYzIpKSA/IGAke2MyfWAgOiBjMi5pZDtcbiAgICByZXR1cm4gaWQxID09PSBpZDI7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKYXZhU2NyaXB0IEpTT04gb2JqZWN0LCBlZywgYGBgYHsgZm9vOiBcImJhclwiIH1gYGBgLlxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqZWN0Q29uc3RydWN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gKCEhdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IG9iamVjdENvbnN0cnVjdG9yKTtcbn1cblxuLyoqIFJldHVybnMgYSBzaGFsbG93IGNvcHlcbiAqL1xuZnVuY3Rpb24gY29weShvKSB7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5KG8sIHt9KTtcbn1cblxuLyoqIEFkZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzIsIG92ZXJ3cml0aW5nIHRoZW0gb24gbzIgaWYgYWxyZWFkeSB0aGVyZVxuICovXG5mdW5jdGlvbiBhcHBseShvLCBvMikge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBBZGQgbm9uLW51bGwvZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzJcbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcHBseTIobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG9bbmFtZV0gIT09IHVuZGVmaW5lZCAmJiBvW25hbWVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbzJbbmFtZV0gPSBvW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvMjtcbn1cblxuLyoqXG4gQWRkIHByb3BlcnRpZXMgb2YgbyB0byBvMiB3aGVyZSB1bmRlZmluZWQgb3IgbnVsbCBvbiBvMlxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SWYobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG8yW25hbWVdID09PSB1bmRlZmluZWQgfHwgbzJbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1hcCBpcyBlbXB0eS5cbiBAcGFyYW0gb2JqXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgZ2l2ZW4gSUQgYXMgYSBzdHJpbmcsIGluIHF1b3RlcyBpZiB0aGUgSUQgd2FzIGEgc3RyaW5nIHRvIGJlZ2luIHdpdGguXG5cbiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9nZ2luZyBJRHMuXG5cbiBAcGFyYW0ge051bWJlcnwgU3RyaW5nfSBpZCBUaGUgSURcbiBAcmV0dXJucyB7U3RyaW5nfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluUXVvdGVzKGlkKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzTnVtZXJpYyhpZCkgPyAoYCR7aWR9YCkgOiAoYCcke2lkfSdgKTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gdHlwZWQgYXJyYXlzLlxuIEBwYXJhbSBhXG4gQHBhcmFtIGJcbiBAcmV0dXJucyB7KnxhfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgYyA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5KHJvb3QpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgICAgICBub2RlLmlkID0gbm9kZS51dWlkO1xuICAgICAgICBkZWxldGUgbm9kZS5vaWQ7XG4gICAgICAgIGxpc3QucHVzaChub2RlKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgICAgICAgICB2aXNpdChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cblxuICAgIHZpc2l0KHJvb3QpO1xuICAgIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHV0aWxzID0ge1xuICAgIHhtbFRvSnNvbjogeG1sVG9Kc29uLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBjb21wcmVzc0d1aWQ6IGNvbXByZXNzR3VpZCxcbiAgICBmaW5kTm9kZU9mVHlwZTogZmluZE5vZGVPZlR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBodHRwUmVxdWVzdDogaHR0cFJlcXVlc3QsXG4gICAgbG9hZEpTT046IGxvYWRKU09OLFxuICAgIGxvYWRBcnJheWJ1ZmZlcjogbG9hZEFycmF5YnVmZmVyLFxuICAgIHF1ZXJ5U3RyaW5nOiBxdWVyeVN0cmluZyxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc051bWVyaWM6IGlzTnVtZXJpYyxcbiAgICBpc0lEOiBpc0lELFxuICAgIGlzU2FtZUNvbXBvbmVudDogaXNTYW1lQ29tcG9uZW50LFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGNvcHk6IGNvcHksXG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIGFwcGx5MjogYXBwbHkyLFxuICAgIGFwcGx5SWY6IGFwcGx5SWYsXG4gICAgaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcbiAgICBpblF1b3RlczogaW5RdW90ZXMsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5OiBmbGF0dGVuUGFyZW50Q2hpbGRIaWVyYXJjaHlcbn07XG5cbmV4cG9ydCB7dXRpbHN9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js ***!
  \***********************************************************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return Map; });\n/** @private */\nclass Map {\n\n    constructor(items, baseId) {\n        this.items = items || [];\n        this._lastUniqueId = (baseId || 0) + 1;\n    }\n\n    /**\n     * Usage:\n     *\n     * id = myMap.addItem(\"foo\") // ID internally generated\n     * id = myMap.addItem(\"foo\", \"bar\") // ID is \"foo\"\n     */\n    addItem() {\n        let item;\n        if (arguments.length === 2) {\n            const id = arguments[0];\n            item = arguments[1];\n            if (this.items[id]) { // Won't happen if given ID is string\n                throw \"ID clash: '\" + id + \"'\";\n            }\n            this.items[id] = item;\n            return id;\n\n        } else {\n            item = arguments[0] || {};\n            while (true) {\n                const findId = this._lastUniqueId++;\n                if (!this.items[findId]) {\n                    this.items[findId] = item;\n                    return findId;\n                }\n            }\n        }\n    }\n\n    removeItem(id) {\n        const item = this.items[id];\n        delete this.items[id];\n        return item;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL01hcC5qcz84ZDZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS91dGlscy9NYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmNsYXNzIE1hcCB7XG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgYmFzZUlkKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5fbGFzdFVuaXF1ZUlkID0gKGJhc2VJZCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIikgLy8gSUQgaW50ZXJuYWxseSBnZW5lcmF0ZWRcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIiwgXCJiYXJcIikgLy8gSUQgaXMgXCJmb29cIlxuICAgICAqL1xuICAgIGFkZEl0ZW0oKSB7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaWRdKSB7IC8vIFdvbid0IGhhcHBlbiBpZiBnaXZlbiBJRCBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aHJvdyBcIklEIGNsYXNoOiAnXCIgKyBpZCArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kSWQgPSB0aGlzLl9sYXN0VW5pcXVlSWQrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXNbZmluZElkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ZpbmRJZF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oaWQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1tpZF07XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js ***!
  \*************************************************************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Queue\", function() { return Queue; });\n// Fast queue that avoids using potentially inefficient array .shift() calls\n// Based on https://github.com/creationix/fastqueue\n\n/** @private */\nclass Queue {\n\n    constructor() {\n\n        this._head = [];\n        this._headLength = 0;\n        this._tail = [];\n        this._index = 0;\n        this._length = 0;\n    }\n\n    get length() {\n        return this._length;\n    }\n\n    shift() {\n        if (this._index >= this._headLength) {\n            const t = this._head;\n            t.length = 0;\n            this._head = this._tail;\n            this._tail = t;\n            this._index = 0;\n            this._headLength = this._head.length;\n            if (!this._headLength) {\n                return;\n            }\n        }\n        const value = this._head[this._index];\n        if (this._index < 0) {\n            delete this._head[this._index++];\n        }\n        else {\n            this._head[this._index++] = undefined;\n        }\n        this._length--;\n        return value;\n    }\n\n    push(item) {\n        this._length++;\n        this._tail.push(item);\n        return this;\n    };\n\n    unshift(item) {\n        this._head[--this._index] = item;\n        this._length++;\n        return this;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzP2Y5YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRmFzdCBxdWV1ZSB0aGF0IGF2b2lkcyB1c2luZyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCBhcnJheSAuc2hpZnQoKSBjYWxsc1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NyZWF0aW9uaXgvZmFzdHF1ZXVlXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgUXVldWUge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5faGVhZCA9IFtdO1xuICAgICAgICB0aGlzLl9oZWFkTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IFtdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX2hlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRMZW5ndGggPSB0aGlzLl9oZWFkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGVhZExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2hlYWRbdGhpcy5faW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZFt0aGlzLl9pbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRbdGhpcy5faW5kZXgrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHRoaXMuX3RhaWwucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHVuc2hpZnQoaXRlbSkge1xuICAgICAgICB0aGlzLl9oZWFkWy0tdGhpcy5faW5kZXhdID0gaXRlbTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHtRdWV1ZX07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js ***!
  \*******************************************************************************/
/*! exports provided: RenderState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderState\", function() { return RenderState; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\n/**\n * @desc Represents a chunk of state changes applied by the {@link Scene}'s renderer while it renders a frame.\n *\n * * Contains properties that represent the state changes.\n * * Has a unique automatically-generated numeric ID, which the renderer can use to sort these, in order to avoid applying redundant state changes for each frame.\n * * Initialize your own properties on a RenderState via its constructor.\n *\n * @private\n */\nclass RenderState {\n\n    constructor(cfg) {\n\n        /**\n         The RenderState's ID, unique within the renderer.\n         @property id\n         @type {Number}\n         @final\n         */\n        this.id = ids.addItem({});\n        for (const key in cfg) {\n            if (cfg.hasOwnProperty(key)) {\n                this[key] = cfg[key];\n            }\n        }\n    }\n\n    /**\n     Destroys this RenderState.\n     */\n    destroy() {\n        ids.removeItem(this.id);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1JlbmRlclN0YXRlLmpzP2I1MWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW9DOztBQUVwQyxnQkFBZ0IsaURBQUcsR0FBRzs7QUFFdEI7QUFDQSw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS93ZWJnbC9SZW5kZXJTdGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWFwfSBmcm9tIFwiLi4vdXRpbHMvTWFwLmpzXCI7XG5cbmNvbnN0IGlkcyA9IG5ldyBNYXAoe30pO1xuXG4vKipcbiAqIEBkZXNjIFJlcHJlc2VudHMgYSBjaHVuayBvZiBzdGF0ZSBjaGFuZ2VzIGFwcGxpZWQgYnkgdGhlIHtAbGluayBTY2VuZX0ncyByZW5kZXJlciB3aGlsZSBpdCByZW5kZXJzIGEgZnJhbWUuXG4gKlxuICogKiBDb250YWlucyBwcm9wZXJ0aWVzIHRoYXQgcmVwcmVzZW50IHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICogKiBIYXMgYSB1bmlxdWUgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgbnVtZXJpYyBJRCwgd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiB1c2UgdG8gc29ydCB0aGVzZSwgaW4gb3JkZXIgdG8gYXZvaWQgYXBwbHlpbmcgcmVkdW5kYW50IHN0YXRlIGNoYW5nZXMgZm9yIGVhY2ggZnJhbWUuXG4gKiAqIEluaXRpYWxpemUgeW91ciBvd24gcHJvcGVydGllcyBvbiBhIFJlbmRlclN0YXRlIHZpYSBpdHMgY29uc3RydWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmVuZGVyU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoY2ZnKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBUaGUgUmVuZGVyU3RhdGUncyBJRCwgdW5pcXVlIHdpdGhpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgICBAcHJvcGVydHkgaWRcbiAgICAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBpZHMuYWRkSXRlbSh7fSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNmZykge1xuICAgICAgICAgICAgaWYgKGNmZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gY2ZnW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgRGVzdHJveXMgdGhpcyBSZW5kZXJTdGF0ZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZHMucmVtb3ZlSXRlbSh0aGlzLmlkKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7UmVuZGVyU3RhdGV9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js\n");

/***/ })

}]);