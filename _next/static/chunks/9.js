(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[9],{

/***/ "./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/Annotation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/Annotation.js ***!
  \*************************************************************************************/
/*! exports provided: Annotation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Annotation\", function() { return Annotation; });\n/* harmony import */ var _viewer_scene_marker_Marker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../viewer/scene/marker/Marker.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/marker/Marker.js\");\n/* harmony import */ var _viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../viewer/scene/utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n\n\n\n/**\n * A {@link Marker} with an HTML label attached to it, managed by an {@link AnnotationsPlugin}.\n *\n * See {@link AnnotationsPlugin} for more info.\n */\nclass Annotation extends _viewer_scene_marker_Marker_js__WEBPACK_IMPORTED_MODULE_0__[\"Marker\"] {\n\n    /**\n     * @private\n     */\n    constructor(owner, cfg) {\n\n        super(owner, cfg);\n\n        /**\n         * The {@link AnnotationsPlugin} this Annotation was created by.\n         * @type {AnnotationsPlugin}\n         */\n        this.plugin = cfg.plugin;\n\n        this._container = cfg.container;\n        if (!this._container) {\n            throw \"config missing: container\";\n        }\n\n        if ((!cfg.markerElement) && (!cfg.markerHTML)) {\n            throw \"config missing: need either markerElement or markerHTML\";\n        }\n        if ((!cfg.labelElement) && (!cfg.labelHTML)) {\n            throw \"config missing: need either labelElement or labelHTML\";\n        }\n\n        this._htmlDirty = false;\n\n        if (cfg.markerElement) {\n            this._marker = cfg.markerElement;\n            this._marker.addEventListener(\"click\", this._onMouseClickedExternalMarker = () => {\n                this.plugin.fire(\"markerClicked\", this);\n            });\n            this._marker.addEventListener(\"mouseenter\", this._onMouseEnterExternalMarker = () => {\n                this.plugin.fire(\"markerMouseEnter\", this);\n            });\n            this._marker.addEventListener(\"mouseleave\", this._onMouseLeaveExternalMarker = () => {\n                this.plugin.fire(\"markerMouseLeave\", this);\n            });\n            this._markerExternal = true; // Don't destroy marker when destroying Annotation\n        } else {\n            this._markerHTML = cfg.markerHTML;\n            this._htmlDirty = true;\n            this._markerExternal = false;\n        }\n\n        if (cfg.labelElement) {\n            this._label = cfg.labelElement;\n            this._labelExternal = true; // Don't destroy marker when destroying Annotation\n        } else {\n            this._labelHTML = cfg.labelHTML;\n            this._htmlDirty = true;\n            this._labelExternal = false;\n        }\n\n        this._markerShown = !!cfg.markerShown;\n        this._labelShown = !!cfg.labelShown;\n        this._values = cfg.values || {};\n        this._layoutDirty = true;\n        this._visibilityDirty = true;\n\n        this._buildHTML();\n\n        this._onTick = this.scene.on(\"tick\", () => {\n            if (this._htmlDirty) {\n                this._buildHTML();\n                this._htmlDirty = false;\n                this._layoutDirty = true;\n                this._visibilityDirty = true;\n            }\n            if (this._layoutDirty || this._visibilityDirty) {\n                if (this._markerShown || this._labelShown) {\n                    this._updatePosition();\n                    this._layoutDirty = false;\n                }\n            }\n            if (this._visibilityDirty) {\n                this._marker.style.visibility = (this.visible && this._markerShown) ? \"visible\" : \"hidden\";\n                this._label.style.visibility = (this.visible && this._markerShown && this._labelShown) ? \"visible\" : \"hidden\";\n                this._visibilityDirty = false;\n            }\n        });\n\n        this.on(\"canvasPos\", () => {\n            this._layoutDirty = true;\n        });\n\n        this.on(\"visible\", () => {\n            this._visibilityDirty = true;\n        });\n\n        this.setMarkerShown(cfg.markerShown !== false);\n        this.setLabelShown(cfg.labelShown);\n\n        /**\n         * Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.\n         *\n         * Undefined by default.\n         *\n         * @type {Number[]} Eye position.\n         */\n        this.eye = cfg.eye ? cfg.eye.slice() : null;\n\n        /**\n         * Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.\n         *\n         * Undefined by default.\n         *\n         * @type {Number[]} The \"look\" vector.\n         */\n        this.look = cfg.look ? cfg.look.slice() : null;\n\n        /**\n         * Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.\n         *\n         * Undefined by default.\n         *\n         * @type {Number[]} The \"up\" vector.\n         */\n        this.up = cfg.up ? cfg.up.slice() : null;\n\n        /**\n         * Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.\n         *\n         * Undefined by default.\n         *\n         * @type {String} The projection type - \"perspective\" or \"ortho\"..\n         */\n        this.projection = cfg.projection;\n    }\n\n    /**\n     * @private\n     */\n    _buildHTML() {\n        if (!this._markerExternal) {\n            if (this._marker) {\n                this._container.removeChild(this._marker);\n                this._marker = null;\n            }\n            let markerHTML = this._markerHTML || \"<p></p>\"; // Make marker\n            if (_viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isArray(markerHTML)) {\n                markerHTML = markerHTML.join(\"\");\n            }\n            markerHTML = this._renderTemplate(markerHTML);\n            const markerFragment = document.createRange().createContextualFragment(markerHTML);\n            this._marker = markerFragment.firstChild;\n            this._container.appendChild(this._marker);\n            this._marker.style.visibility = this._markerShown ? \"visible\" : \"hidden\";\n            this._marker.addEventListener(\"click\", () => {\n                this.plugin.fire(\"markerClicked\", this);\n            });\n            this._marker.addEventListener(\"mouseenter\", () => {\n                this.plugin.fire(\"markerMouseEnter\", this);\n            });\n            this._marker.addEventListener(\"mouseleave\", () => {\n                this.plugin.fire(\"markerMouseLeave\", this);\n            });\n        }\n        if (!this._labelExternal) {\n            if (this._label) {\n                this._container.removeChild(this._label);\n                this._label = null;\n            }\n            let labelHTML = this._labelHTML || \"<p></p>\"; // Make label\n            if (_viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isArray(labelHTML)) {\n                labelHTML = labelHTML.join(\"\");\n            }\n            labelHTML = this._renderTemplate(labelHTML);\n            const labelFragment = document.createRange().createContextualFragment(labelHTML);\n            this._label = labelFragment.firstChild;\n            this._container.appendChild(this._label);\n            this._label.style.visibility = (this._markerShown && this._labelShown) ? \"visible\" : \"hidden\";\n        }\n    }\n\n    /**\n     * @private\n     */\n    _updatePosition() {\n        const boundary = this.scene.canvas.boundary;\n        const left = boundary[0];\n        const top = boundary[1];\n        const canvasPos = this.canvasPos;\n        this._marker.style.left = (Math.floor(left + canvasPos[0]) - 12) + \"px\";\n        this._marker.style.top = (Math.floor(top + canvasPos[1]) - 12) + \"px\";\n        this._marker.style[\"z-index\"] = 90005 + Math.floor(this._viewPos[2]) + 1;\n        const offsetX = 20;\n        const offsetY = -17;\n        this._label.style.left = 20 + Math.floor(left + canvasPos[0] + offsetX) + \"px\";\n        this._label.style.top = Math.floor(top + canvasPos[1] + offsetY) + \"px\";\n        this._label.style[\"z-index\"] = 90005 + Math.floor(this._viewPos[2]) + 1;\n    }\n\n    /**\n     * @private\n     */\n    _renderTemplate(template) {\n        for (var key in this._values) {\n            if (this._values.hasOwnProperty(key)) {\n                const value = this._values[key];\n                template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);\n            }\n        }\n        return template;\n    }\n\n    /**\n     * Sets whether or not to show this Annotation's marker.\n     *\n     * The marker shows the Annotation's position.\n     *\n     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @param {Boolean} shown Whether to show the marker.\n     */\n    setMarkerShown(shown) {\n        shown = !!shown;\n        if (this._markerShown === shown) {\n            return;\n        }\n        this._markerShown = shown;\n        this._visibilityDirty = true;\n    }\n\n    /**\n     * Gets whether or not to show this Annotation's marker.\n     *\n     * The marker shows the Annotation's position.\n     *\n     * The marker is only visible when both this property and {@link Annotation#visible} are ````true````.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @returns {Boolean} Whether to show the marker.\n     */\n    getMarkerShown() {\n        return this._markerShown;\n    }\n\n    /**\n     * Sets whether or not to show this Annotation's label.\n     *\n     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @param {Boolean} shown Whether to show the label.\n     */\n    setLabelShown(shown) {\n        shown = !!shown;\n        if (this._labelShown === shown) {\n            return;\n        }\n        this._labelShown = shown;\n        this._visibilityDirty = true;\n    }\n\n    /**\n     * Gets whether or not to show this Annotation's label.\n     *\n     * The label is only visible when both this property and {@link Annotation#visible} are ````true````.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @returns {Boolean} Whether to show the label.\n     */\n    getLabelShown() {\n        return this._labelShown;\n    }\n\n    /**\n     * Sets the value of a field within the HTML templates for either the Annotation's marker or label.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @param {String} key Identifies the field.\n     * @param {String} value The field's value.\n     */\n    setField(key, value) {\n        this._values[key] = value || \"\";\n        this._htmlDirty = true;\n    }\n\n    /**\n     * Gets the value of a field within the HTML templates for either the Annotation's marker or label.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @param {String} key Identifies the field.\n     * @returns {String} The field's value.\n     */\n    getField(key) {\n        return this._values[key];\n    }\n\n    /**\n     * Sets values for multiple placeholders within the Annotation's HTML templates for marker and label.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @param {{String:(String|Number)}} values Map of field values.\n     */\n    setValues(values) {\n        for (var key in values) {\n            if (values.hasOwnProperty(key)) {\n                const value = values[key];\n                this.setField(key, value);\n            }\n        }\n    }\n\n    /**\n     * Gets the values that were set for the placeholders within this Annotation's HTML marker and label templates.\n     *\n     * See {@link AnnotationsPlugin} for more info.\n     *\n     * @RETURNS {{String:(String|Number)}} Map of field values.\n     */\n    getValues() {\n        return this._values;\n    }\n\n    /**\n     * Destroys this Annotation.\n     *\n     * You can also call {@link AnnotationsPlugin#destroyAnnotation}.\n     */\n    destroy() {\n        if (this._marker) {\n            if (!this._markerExternal) {\n                this._marker.parentNode.removeChild(this._marker);\n            } else {\n                this._marker.removeEventListener(\"click\", this._onMouseClickedExternalMarker);\n                this._marker.removeEventListener(\"mouseenter\", this._onMouseEnterExternalMarker);\n                this._marker.removeEventListener(\"mouseleave\", this._onMouseLeaveExternalMarker);\n                this._marker = null;\n            }\n        }\n        if (this._label) {\n            if (!this._labelExternal) {\n                this._label.parentNode.removeChild(this._label);\n            }\n            this._label = null;\n        }\n        this.scene.off(this._onTick);\n        super.destroy();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9Bbm5vdGF0aW9uc1BsdWdpbi9Bbm5vdGF0aW9uLmpzP2M0ZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkQ7QUFDVDs7QUFFbEQ7QUFDQSxNQUFNLGFBQWEsbURBQW1ELHdCQUF3QjtBQUM5RjtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0EseUJBQXlCLHFFQUFNOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEMsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYix3Q0FBd0M7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGlCQUFpQixrREFBa0QsYUFBYTtBQUM5SDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGtCQUFrQixrREFBa0QsYUFBYTtBQUMvSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGdCQUFnQixrREFBa0QsYUFBYTtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHdCQUF3QixrREFBa0QsYUFBYTtBQUNoSTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGdCQUFnQiw0REFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxnQkFBZ0IsNERBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QjtBQUN4RjtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QjtBQUN4RjtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlCQUF5QjtBQUN2RjtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUJBQXlCO0FBQ3ZGO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy9wbHVnaW5zL0Fubm90YXRpb25zUGx1Z2luL0Fubm90YXRpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcmtlcn0gZnJvbSBcIi4uLy4uL3ZpZXdlci9zY2VuZS9tYXJrZXIvTWFya2VyLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiLi4vLi4vdmlld2VyL3NjZW5lL3V0aWxzLmpzXCI7XG5cbi8qKlxuICogQSB7QGxpbmsgTWFya2VyfSB3aXRoIGFuIEhUTUwgbGFiZWwgYXR0YWNoZWQgdG8gaXQsIG1hbmFnZWQgYnkgYW4ge0BsaW5rIEFubm90YXRpb25zUGx1Z2lufS5cbiAqXG4gKiBTZWUge0BsaW5rIEFubm90YXRpb25zUGx1Z2lufSBmb3IgbW9yZSBpbmZvLlxuICovXG5jbGFzcyBBbm5vdGF0aW9uIGV4dGVuZHMgTWFya2VyIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXIsIGNmZykge1xuXG4gICAgICAgIHN1cGVyKG93bmVyLCBjZmcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUge0BsaW5rIEFubm90YXRpb25zUGx1Z2lufSB0aGlzIEFubm90YXRpb24gd2FzIGNyZWF0ZWQgYnkuXG4gICAgICAgICAqIEB0eXBlIHtBbm5vdGF0aW9uc1BsdWdpbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2luID0gY2ZnLnBsdWdpbjtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjZmcuY29udGFpbmVyO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgXCJjb25maWcgbWlzc2luZzogY29udGFpbmVyXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCFjZmcubWFya2VyRWxlbWVudCkgJiYgKCFjZmcubWFya2VySFRNTCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiY29uZmlnIG1pc3Npbmc6IG5lZWQgZWl0aGVyIG1hcmtlckVsZW1lbnQgb3IgbWFya2VySFRNTFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIWNmZy5sYWJlbEVsZW1lbnQpICYmICghY2ZnLmxhYmVsSFRNTCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiY29uZmlnIG1pc3Npbmc6IG5lZWQgZWl0aGVyIGxhYmVsRWxlbWVudCBvciBsYWJlbEhUTUxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2h0bWxEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjZmcubWFya2VyRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyID0gY2ZnLm1hcmtlckVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uTW91c2VDbGlja2VkRXh0ZXJuYWxNYXJrZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uZmlyZShcIm1hcmtlckNsaWNrZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLl9vbk1vdXNlRW50ZXJFeHRlcm5hbE1hcmtlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5maXJlKFwibWFya2VyTW91c2VFbnRlclwiLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX29uTW91c2VMZWF2ZUV4dGVybmFsTWFya2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmZpcmUoXCJtYXJrZXJNb3VzZUxlYXZlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJFeHRlcm5hbCA9IHRydWU7IC8vIERvbid0IGRlc3Ryb3kgbWFya2VyIHdoZW4gZGVzdHJveWluZyBBbm5vdGF0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJIVE1MID0gY2ZnLm1hcmtlckhUTUw7XG4gICAgICAgICAgICB0aGlzLl9odG1sRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyRXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZmcubGFiZWxFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IGNmZy5sYWJlbEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEV4dGVybmFsID0gdHJ1ZTsgLy8gRG9uJ3QgZGVzdHJveSBtYXJrZXIgd2hlbiBkZXN0cm95aW5nIEFubm90YXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSFRNTCA9IGNmZy5sYWJlbEhUTUw7XG4gICAgICAgICAgICB0aGlzLl9odG1sRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxFeHRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFya2VyU2hvd24gPSAhIWNmZy5tYXJrZXJTaG93bjtcbiAgICAgICAgdGhpcy5fbGFiZWxTaG93biA9ICEhY2ZnLmxhYmVsU2hvd247XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IGNmZy52YWx1ZXMgfHwge307XG4gICAgICAgIHRoaXMuX2xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eURpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9idWlsZEhUTUwoKTtcblxuICAgICAgICB0aGlzLl9vblRpY2sgPSB0aGlzLnNjZW5lLm9uKFwidGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faHRtbERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVpbGRIVE1MKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faHRtbERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2liaWxpdHlEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5b3V0RGlydHkgfHwgdGhpcy5fdmlzaWJpbGl0eURpcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hcmtlclNob3duIHx8IHRoaXMuX2xhYmVsU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJpbGl0eURpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyLnN0eWxlLnZpc2liaWxpdHkgPSAodGhpcy52aXNpYmxlICYmIHRoaXMuX21hcmtlclNob3duKSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS52aXNpYmlsaXR5ID0gKHRoaXMudmlzaWJsZSAmJiB0aGlzLl9tYXJrZXJTaG93biAmJiB0aGlzLl9sYWJlbFNob3duKSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmlsaXR5RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbihcImNhbnZhc1Bvc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub24oXCJ2aXNpYmxlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2liaWxpdHlEaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2V0TWFya2VyU2hvd24oY2ZnLm1hcmtlclNob3duICE9PSBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0TGFiZWxTaG93bihjZmcubGFiZWxTaG93bik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIFdvcmxkLXNwYWNlIHBvc2l0aW9uIGZvciB7QGxpbmsgQ2FtZXJhI2V5ZX0sIHVzZWQgd2hlbiB0aGlzIEFubm90YXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoIGEge0BsaW5rIENhbWVyYX0gcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVuZGVmaW5lZCBieSBkZWZhdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyW119IEV5ZSBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXllID0gY2ZnLmV5ZSA/IGNmZy5leWUuc2xpY2UoKSA6IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIFdvcmxkLXNwYWNlIHBvc2l0aW9uIGZvciB7QGxpbmsgQ2FtZXJhI2xvb2t9LCB1c2VkIHdoZW4gdGhpcyBBbm5vdGF0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHtAbGluayBDYW1lcmF9IHBvc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmRlZmluZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcltdfSBUaGUgXCJsb29rXCIgdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb29rID0gY2ZnLmxvb2sgPyBjZmcubG9vay5zbGljZSgpIDogbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgV29ybGQtc3BhY2UgcG9zaXRpb24gZm9yIHtAbGluayBDYW1lcmEjdXB9LCB1c2VkIHdoZW4gdGhpcyBBbm5vdGF0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHtAbGluayBDYW1lcmF9IHBvc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmRlZmluZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcltdfSBUaGUgXCJ1cFwiIHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXAgPSBjZmcudXAgPyBjZmcudXAuc2xpY2UoKSA6IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIHByb2plY3Rpb24gdHlwZSBmb3Ige0BsaW5rIENhbWVyYSNwcm9qZWN0aW9ufSwgdXNlZCB3aGVuIHRoaXMgQW5ub3RhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgQ2FtZXJhfSBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVW5kZWZpbmVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9IFRoZSBwcm9qZWN0aW9uIHR5cGUgLSBcInBlcnNwZWN0aXZlXCIgb3IgXCJvcnRob1wiLi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IGNmZy5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2J1aWxkSFRNTCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXJrZXJFeHRlcm5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9tYXJrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWFya2VySFRNTCA9IHRoaXMuX21hcmtlckhUTUwgfHwgXCI8cD48L3A+XCI7IC8vIE1ha2UgbWFya2VyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNBcnJheShtYXJrZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgIG1hcmtlckhUTUwgPSBtYXJrZXJIVE1MLmpvaW4oXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXJIVE1MID0gdGhpcy5fcmVuZGVyVGVtcGxhdGUobWFya2VySFRNTCk7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KG1hcmtlckhUTUwpO1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyID0gbWFya2VyRnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9tYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLl9tYXJrZXJTaG93biA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmZpcmUoXCJtYXJrZXJDbGlja2VkXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmZpcmUoXCJtYXJrZXJNb3VzZUVudGVyXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmZpcmUoXCJtYXJrZXJNb3VzZUxlYXZlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbEV4dGVybmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fbGFiZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYWJlbEhUTUwgPSB0aGlzLl9sYWJlbEhUTUwgfHwgXCI8cD48L3A+XCI7IC8vIE1ha2UgbGFiZWxcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0FycmF5KGxhYmVsSFRNTCkpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEhUTUwgPSBsYWJlbEhUTUwuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYmVsSFRNTCA9IHRoaXMuX3JlbmRlclRlbXBsYXRlKGxhYmVsSFRNTCk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbEZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQobGFiZWxIVE1MKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWxGcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xhYmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLnZpc2liaWxpdHkgPSAodGhpcy5fbWFya2VyU2hvd24gJiYgdGhpcy5fbGFiZWxTaG93bikgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSB0aGlzLnNjZW5lLmNhbnZhcy5ib3VuZGFyeTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGJvdW5kYXJ5WzBdO1xuICAgICAgICBjb25zdCB0b3AgPSBib3VuZGFyeVsxXTtcbiAgICAgICAgY29uc3QgY2FudmFzUG9zID0gdGhpcy5jYW52YXNQb3M7XG4gICAgICAgIHRoaXMuX21hcmtlci5zdHlsZS5sZWZ0ID0gKE1hdGguZmxvb3IobGVmdCArIGNhbnZhc1Bvc1swXSkgLSAxMikgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuX21hcmtlci5zdHlsZS50b3AgPSAoTWF0aC5mbG9vcih0b3AgKyBjYW52YXNQb3NbMV0pIC0gMTIpICsgXCJweFwiO1xuICAgICAgICB0aGlzLl9tYXJrZXIuc3R5bGVbXCJ6LWluZGV4XCJdID0gOTAwMDUgKyBNYXRoLmZsb29yKHRoaXMuX3ZpZXdQb3NbMl0pICsgMTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IDIwO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gLTE3O1xuICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS5sZWZ0ID0gMjAgKyBNYXRoLmZsb29yKGxlZnQgKyBjYW52YXNQb3NbMF0gKyBvZmZzZXRYKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUudG9wID0gTWF0aC5mbG9vcih0b3AgKyBjYW52YXNQb3NbMV0gKyBvZmZzZXRZKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGVbXCJ6LWluZGV4XCJdID0gOTAwMDUgKyBNYXRoLmZsb29yKHRoaXMuX3ZpZXdQb3NbMl0pICsgMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShuZXcgUmVnRXhwKCd7eycgKyBrZXkgKyAnfX0nLCAnZycpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGlzIEFubm90YXRpb24ncyBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbWFya2VyIHNob3dzIHRoZSBBbm5vdGF0aW9uJ3MgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgbWFya2VyIGlzIG9ubHkgdmlzaWJsZSB3aGVuIGJvdGggdGhpcyBwcm9wZXJ0eSBhbmQge0BsaW5rIEFubm90YXRpb24jdmlzaWJsZX0gYXJlIGBgYGB0cnVlYGBgYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3duIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWFya2VyLlxuICAgICAqL1xuICAgIHNldE1hcmtlclNob3duKHNob3duKSB7XG4gICAgICAgIHNob3duID0gISFzaG93bjtcbiAgICAgICAgaWYgKHRoaXMuX21hcmtlclNob3duID09PSBzaG93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcmtlclNob3duID0gc2hvd247XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoaXMgQW5ub3RhdGlvbidzIG1hcmtlci5cbiAgICAgKlxuICAgICAqIFRoZSBtYXJrZXIgc2hvd3MgdGhlIEFubm90YXRpb24ncyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBtYXJrZXIgaXMgb25seSB2aXNpYmxlIHdoZW4gYm90aCB0aGlzIHByb3BlcnR5IGFuZCB7QGxpbmsgQW5ub3RhdGlvbiN2aXNpYmxlfSBhcmUgYGBgYHRydWVgYGBgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBBbm5vdGF0aW9uc1BsdWdpbn0gZm9yIG1vcmUgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRvIHNob3cgdGhlIG1hcmtlci5cbiAgICAgKi9cbiAgICBnZXRNYXJrZXJTaG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGlzIEFubm90YXRpb24ncyBsYWJlbC5cbiAgICAgKlxuICAgICAqIFRoZSBsYWJlbCBpcyBvbmx5IHZpc2libGUgd2hlbiBib3RoIHRoaXMgcHJvcGVydHkgYW5kIHtAbGluayBBbm5vdGF0aW9uI3Zpc2libGV9IGFyZSBgYGBgdHJ1ZWBgYGAuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIEFubm90YXRpb25zUGx1Z2lufSBmb3IgbW9yZSBpbmZvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG93biBXaGV0aGVyIHRvIHNob3cgdGhlIGxhYmVsLlxuICAgICAqL1xuICAgIHNldExhYmVsU2hvd24oc2hvd24pIHtcbiAgICAgICAgc2hvd24gPSAhIXNob3duO1xuICAgICAgICBpZiAodGhpcy5fbGFiZWxTaG93biA9PT0gc2hvd24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYWJlbFNob3duID0gc2hvd247XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoaXMgQW5ub3RhdGlvbidzIGxhYmVsLlxuICAgICAqXG4gICAgICogVGhlIGxhYmVsIGlzIG9ubHkgdmlzaWJsZSB3aGVuIGJvdGggdGhpcyBwcm9wZXJ0eSBhbmQge0BsaW5rIEFubm90YXRpb24jdmlzaWJsZX0gYXJlIGBgYGB0cnVlYGBgYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0byBzaG93IHRoZSBsYWJlbC5cbiAgICAgKi9cbiAgICBnZXRMYWJlbFNob3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWxTaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGZpZWxkIHdpdGhpbiB0aGUgSFRNTCB0ZW1wbGF0ZXMgZm9yIGVpdGhlciB0aGUgQW5ub3RhdGlvbidzIG1hcmtlciBvciBsYWJlbC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IElkZW50aWZpZXMgdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgZmllbGQncyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRGaWVsZChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5faHRtbERpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIGZpZWxkIHdpdGhpbiB0aGUgSFRNTCB0ZW1wbGF0ZXMgZm9yIGVpdGhlciB0aGUgQW5ub3RhdGlvbidzIG1hcmtlciBvciBsYWJlbC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IElkZW50aWZpZXMgdGhlIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBmaWVsZCdzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldEZpZWxkKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2YWx1ZXMgZm9yIG11bHRpcGxlIHBsYWNlaG9sZGVycyB3aXRoaW4gdGhlIEFubm90YXRpb24ncyBIVE1MIHRlbXBsYXRlcyBmb3IgbWFya2VyIGFuZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tTdHJpbmc6KFN0cmluZ3xOdW1iZXIpfX0gdmFsdWVzIE1hcCBvZiBmaWVsZCB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0VmFsdWVzKHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmllbGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZXMgdGhhdCB3ZXJlIHNldCBmb3IgdGhlIHBsYWNlaG9sZGVycyB3aXRoaW4gdGhpcyBBbm5vdGF0aW9uJ3MgSFRNTCBtYXJrZXIgYW5kIGxhYmVsIHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW59IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAUkVUVVJOUyB7e1N0cmluZzooU3RyaW5nfE51bWJlcil9fSBNYXAgb2YgZmllbGQgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIEFubm90YXRpb24uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gY2FsbCB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW4jZGVzdHJveUFubm90YXRpb259LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXJrZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFya2VyRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9tYXJrZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uTW91c2VDbGlja2VkRXh0ZXJuYWxNYXJrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLl9vbk1vdXNlRW50ZXJFeHRlcm5hbE1hcmtlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuX29uTW91c2VMZWF2ZUV4dGVybmFsTWFya2VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9sYWJlbEV4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2VuZS5vZmYodGhpcy5fb25UaWNrKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtBbm5vdGF0aW9ufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/Annotation.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/AnnotationsPlugin.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/AnnotationsPlugin.js ***!
  \********************************************************************************************/
/*! exports provided: AnnotationsPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnnotationsPlugin\", function() { return AnnotationsPlugin; });\n/* harmony import */ var _viewer_Plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../viewer/Plugin.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js\");\n/* harmony import */ var _Annotation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Annotation.js */ \"./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/Annotation.js\");\n/* harmony import */ var _viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../viewer/scene/utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n/* harmony import */ var _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../viewer/scene/math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n\n\n\n\n\nconst tempVec3a = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].vec3();\nconst tempVec3b = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].vec3();\nconst tempVec3c = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].vec3();\n\n/**\n * {@link Viewer} plugin that creates {@link Annotation}s.\n *\n * [<img src=\"https://user-images.githubusercontent.com/83100/58403089-26589280-8062-11e9-8652-aed61a4e8c64.gif\">](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)\n *\n * * [[Example 1: Create annotations with mouse](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]\n * * [[Example 2: Click annotations to toggle labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]\n * * [[Example 3: Hover annotations to show labels](https://xeokit.github.io/xeokit-sdk/examples/#annotations_hoverShowLabels)]\n * * [[Example 4: Click annotations to fly to viewpoint](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickFlyToPosition)]\n * * [[Example 5: Create Annotations with externally-created elements](https://xeokit.github.io/xeokit-sdk/examples/#annotations_externalElements)]\n *\n * ## Overview\n *\n * * An {@link Annotation} is a 3D position with a label attached.\n * * Annotations render themselves with HTML elements that float over the canvas; customize the appearance of\n * individual Annotations using HTML template; configure default appearance by setting templates on the AnnotationsPlugin.\n * * Dynamically insert data values into each Annotation's HTML templates; configure default values on the AnnotationsPlugin.\n * * Optionally configure Annotation with externally-created DOM elements for markers and labels; these override templates and data values.\n * * Optionally configure Annotations to hide themselves whenever occluded by {@link Entity}s.\n * * Optionally configure each Annotation with a position we can jump or fly the {@link Camera} to.\n *\n * ## Example 1: Loading a model and creating an annotation\n *\n * In the example below, we'll use a {@link GLTFLoaderPlugin} to load a model, and an AnnotationsPlugin\n * to create an {@link Annotation} on it.\n *\n * We'll configure the AnnotationsPlugin with default HTML templates for each Annotation's position (its \"marker\") and\n * label, along with some default data values to insert into them.\n *\n * When we create our Annotation, we'll give it some specific data values to insert into the templates, overriding some of\n * the defaults we configured on the plugin. Note the correspondence between the placeholders in the templates\n * and the keys in the values map.\n *\n * We'll also configure the Annotation to hide itself whenever it's position is occluded by any {@link Entity}s (this is default behavior). The\n * {@link Scene} periodically occlusion-tests all Annotations on every 20th \"tick\" (which represents a rendered frame). We\n * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.\n *\n * Finally, we'll query the Annotation's position occlusion/visibility status, and subscribe to change events on those properties.\n *\n * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_clickShowLabels)]\n *\n * ````JavaScript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {GLTFLoaderPlugin} from \"../src/plugins/GLTFLoaderPlugin/GLTFLoaderPlugin.js\";\n * import {AnnotationsPlugin} from \"../src/plugins/AnnotationsPlugin/AnnotationsPlugin.js\";\n *\n * const viewer = new Viewer({\n *     canvasId: \"myCanvas\",\n *     transparent: true\n * });\n *\n * viewer.scene.camera.eye = [-2.37, 18.97, -26.12];\n * viewer.scene.camera.look = [10.97, 5.82, -11.22];\n * viewer.scene.camera.up = [0.36, 0.83, 0.40];\n *\n * const gltfLoader = new GLTFLoaderPlugin(viewer);\n *\n * const annotations = new AnnotationsPlugin(viewer, {\n *\n *      // Default HTML template for marker position\n *      markerHTML: \"<div class='annotation-marker' style='background-color: {{markerBGColor}};'>{{glyph}}</div>\",\n *\n *      // Default HTML template for label\n *      labelHTML: \"<div class='annotation-label' style='background-color: {{labelBGColor}};'>\" +\n *      \"<div class='annotation-title'>{{title}}</div><div class='annotation-desc'>{{description}}</div></div>\",\n *\n *      // Default values to insert into the marker and label templates\n *      values: {\n *          markerBGColor: \"red\",\n *          labelBGColor: \"red\",\n *          glyph: \"X\",\n *          title: \"Untitled\",\n *          description: \"No description\"\n *      }\n * });\n *\n * const model = gltfLoader.load({\n *      src: \"./models/gltf/duplex/scene.gltf\"\n * });\n *\n * model.on(\"loaded\", () => {\n *\n *      const entity = viewer.scene.meshes[\"\"];\n *\n *      // Create an annotation\n *      const myAnnotation1 = annotations.createAnnotation({\n *\n *          id: \"myAnnotation\",\n *\n *          entity: viewer.scene.objects[\"2O2Fr$t4X7Zf8NOew3FLOH\"], // Optional, associate with an Entity\n *\n *          worldPos: [0, 0, 0],        // 3D World-space position\n *\n *          occludable: true,           // Optional, default, makes Annotation invisible when occluded by Entities\n *          markerShown: true,          // Optional, default is true, makes position visible (when not occluded)\n *          labelShown: true            // Optional, default is false, makes label visible (when not occluded)\n *\n *          values: {                   // Optional, overrides AnnotationPlugin's defaults\n *              glyph: \"A\",\n *              title: \"My Annotation\",\n *              description: \"This is my annotation.\"\n *          }\n *      });\n *\n *      // Listen for change of the Annotation's 3D World-space position\n *\n *      myAnnotation1.on(\"worldPos\", function(worldPos) {\n *          //...\n *      });\n *\n *      // Listen for change of the Annotation's 3D View-space position, which happens\n *      // when either worldPos was updated or the Camera was moved\n *\n *      myAnnotation1.on(\"viewPos\", function(viewPos) {\n *          //...\n *      });\n *\n *      // Listen for change of the Annotation's 2D Canvas-space position, which happens\n *      // when worldPos or viewPos was updated, or Camera's projection was updated\n *\n *      myAnnotation1.on(\"canvasPos\", function(canvasPos) {\n *          //...\n *      });\n *\n *      // Listen for change of Annotation visibility. The Annotation becomes invisible when it falls outside the canvas,\n *      // or its position is occluded by some Entity. Note that, when not occluded, the position is only\n *      // shown when Annotation#markerShown is true, and the label is only shown when Annotation#labelShown is true.\n *\n *      myAnnotation1.on(\"visible\", function(visible) { // Marker visibility has changed\n *          if (visible) {\n *              this.log(\"Annotation is visible\");\n *          } else {\n *              this.log(\"Annotation is invisible\");\n *          }\n *      });\n *\n *      // Listen for destruction of the Annotation\n *\n *      myAnnotation1.on(\"destroyed\", () => {\n *          //...\n *      });\n * });\n * ````\n *\n * Let's query our {@link Annotation}'s current position in the World, View and Canvas coordinate systems:\n *\n * ````javascript\n * const worldPos  = myAnnotation.worldPos;  // [x,y,z]\n * const viewPos   = myAnnotation.viewPos;   // [x,y,z]\n * const canvasPos = myAnnotation.canvasPos; // [x,y]\n * ````\n *\n * We can query it's current visibility, which is ````false```` when its position is occluded by some {@link Entity}:\n *\n * ````\n * const visible = myAnnotation1.visible;\n * ````\n *\n * To listen for change events on our Annotation's position and visibility:\n *\n * ````javascript\n * // World-space position changes when we assign a new value to Annotation#worldPos\n * myAnnotation1.on(\"worldPos\", (worldPos) => {\n *     //...\n * });\n *\n * // View-space position changes when either worldPos was updated or the Camera was moved\n * myAnnotation1.on(\"viewPos\", (viewPos) => {\n *     //...\n * });\n *\n * // Canvas-space position changes when worldPos or viewPos was updated, or Camera's projection was updated\n * myAnnotation1.on(\"canvasPos\", (canvasPos) => {\n *     //...\n * });\n *\n * // Annotation is invisible when its position falls off the canvas or is occluded by some Entity\n * myAnnotation1.on(\"visible\", (visible) => {\n *     //...\n * });\n * ````\n *\n * Finally, let's dynamically update the values for a couple of placeholders in our Annotation's label:\n *\n * ```` javascript\n * myAnnotation1.setValues({\n *      title: \"Here's a new title\",\n *      description: \"Here's a new description\"\n * });\n * ````\n *\n *\n * ## Example 2: Creating an Annotation with a unique appearance\n *\n * Now let's create a second {@link Annotation}, this time with its own custom HTML label template, which includes\n * an image. In the Annotation's values, we'll also provide a new title and description, custom colors for the marker\n * and label, plus a URL for the image in the label template. To render its marker, the Annotation will fall back\n * on the AnnotationPlugin's default marker template.\n *\n * ````javascript\n * const myAnnotation2 = annotations.createAnnotation({\n *\n *      id: \"myAnnotation2\",\n *\n *      worldPos: [-0.163, 1.810, 7.977],\n *\n *      occludable: true,\n *      markerShown: true,\n *      labelShown: true,\n *\n *      // Custom label template is the same as the Annotation's, with the addition of an image element\n *      labelHTML: \"<div class='annotation-label' style='background-color: {{labelBGColor}};'>\\\n *          <div class='annotation-title'>{{title}}</div>\\\n *          <div class='annotation-desc'>{{description}}</div>\\\n *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\\\n *          </div>\",\n *\n *      // Custom template values override all the AnnotationPlugin's defaults, and includes an additional value\n *      // for the image element's URL\n *      values: {\n *          glyph: \"A3\",\n *          title: \"The West wall\",\n *          description: \"Annotations can contain<br>custom HTML like this<br>image:\",\n *          markerBGColor: \"green\",\n *          labelBGColor: \"green\",\n *          imageSrc: \"https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png\"\n *      }\n * });\n * ````\n *\n * ## Example 3: Creating an Annotation with a camera position\n *\n * We can optionally configure each {@link Annotation} with a position to fly or jump the {@link Camera} to.\n *\n * Let's create another Annotation, this time providing it with ````eye````, ````look```` and ````up```` properties\n * indicating a viewpoint on whatever it's annotating:\n *\n * ````javascript\n * const myAnnotation3 = annotations.createAnnotation({\n *\n *      id: \"myAnnotation3\",\n *\n *      worldPos: [-0.163, 3.810, 7.977],\n *\n *      eye: [0,0,-10],\n *      look: [-0.163, 3.810, 7.977],\n *      up: [0,1,0];\n *\n *      occludable: true,\n *      markerShown: true,\n *      labelShown: true,\n *\n *      labelHTML: \"<div class='annotation-label' style='background-color: {{labelBGColor}};'>\\\n *          <div class='annotation-title'>{{title}}</div>\\\n *          <div class='annotation-desc'>{{description}}</div>\\\n *          <br><img alt='myImage' width='150px' height='100px' src='{{imageSrc}}'>\\\n *          </div>\",\n *\n *      values: {\n *          glyph: \"A3\",\n *          title: \"The West wall\",\n *          description: \"Annotations can contain<br>custom HTML like this<br>image:\",\n *          markerBGColor: \"green\",\n *          labelBGColor: \"green\",\n *          imageSrc: \"https://xeokit.io/img/docs/BIMServerLoaderPlugin/schependomlaan.png\"\n *      }\n * });\n * ````\n *\n * Now we can fly the {@link Camera} to the Annotation's viewpoint, like this:\n *\n * ````javascript\n * viewer.cameraFlight.flyTo(myAnnotation3);\n * ````\n *\n * Or jump the Camera, like this:\n *\n * ````javascript\n * viewer.cameraFlight.jumpTo(myAnnotation3);\n * ````\n *\n * ## Example 4: Creating an Annotation using externally-created DOM elements\n *\n * Now let's create another {@link Annotation}, this time providing it with pre-existing DOM elements for its marker\n * and label. Note that AnnotationsPlugin will ignore any ````markerHTML````, ````labelHTML````\n * or ````values```` properties when provide  ````markerElementId```` or ````labelElementId````.\n *\n * ````javascript\n * const myAnnotation2 = annotations.createAnnotation({\n *\n *      id: \"myAnnotation2\",\n *\n *      worldPos: [-0.163, 1.810, 7.977],\n *\n *      occludable: true,\n *      markerShown: true,\n *      labelShown: true,\n *\n *      markerElementId: \"myMarkerElement\",\n *      labelElementId: \"myLabelElement\"\n * });\n * ````\n *\n * ## Example 5: Creating annotations by clicking on objects\n *\n * AnnotationsPlugin makes it easy to create {@link Annotation}s on the surfaces of {@link Entity}s as we click on them.\n *\n * The {@link AnnotationsPlugin#createAnnotation} method can accept a {@link PickResult} returned\n * by {@link Scene#pick}, from which it initializes the {@link Annotation}'s {@link Annotation#worldPos} and\n * {@link Annotation#entity}. Note that this only works when {@link Scene#pick} was configured to perform a 3D\n * surface-intersection pick (see {@link Scene#pick} for more info).\n *\n * Let's now extend our example to create an Annotation wherever we click on the surface of of our model:\n *\n * [[Run example](https://xeokit.github.io/xeokit-sdk/examples/#annotations_createWithMouse)]\n *\n * ````javascript\n * var i = 1; // Used to create unique Annotation IDs\n *\n * viewer.scene.input.on(\"mouseclicked\", (coords) => {\n *\n *     var pickRecord = viewer.scene.pick({\n *         canvasPos: coords,\n *         pickSurface: true  // <<------ This causes picking to find the intersection point on the entity\n *     });\n *\n *     if (pickRecord) {\n *\n *         const annotation = annotations.createAnnotation({\n *              id: \"myAnnotationOnClick\" + i,\n *              pickRecord: pickRecord,\n *              occludable: true,           // Optional, default is true\n *              markerShown: true,          // Optional, default is true\n *              labelShown: true,           // Optional, default is true\n *              values: {                   // HTML template values\n *                  glyph: \"A\" + i,\n *                  title: \"My annotation \" + i,\n *                  description: \"My description \" + i\n *              },\n           });\n *\n *         i++;\n *      }\n * });\n * ````\n *\n * Note that when the Annotation is occludable, there is potential for the {@link Annotation#worldPos} to become\n * visually embedded within the surface of its Entity when viewed from a distance. This happens as a result of limited\n * GPU accuracy GPU accuracy, especially when the near and far view-space clipping planes, specified by {@link Perspective#near}\n * and {@link Perspective#far}, or {@link Ortho#near} and {@link Perspective#far}, are far away from each other.\n *\n * To prevent this, we can offset Annotations from their Entity surfaces by an amount that we set\n * on {@link AnnotationsPlugin#surfaceOffset}:\n *\n * ````javascript\n * annotations.surfaceOffset = 0.3; // Default value\n * ````\n *\n * Annotations subsequently created with {@link AnnotationsPlugin#createAnnotation} using a {@link PickResult} will then\n * be offset by that amount.\n *\n * Another thing we can do to prevent this unwanted occlusion is keep the distance between the view-space clipping\n * planes to a minimum, which improves the accuracy of the Annotation occlusion test. In general, a good default\n * value for ````Perspective#far```` and ````Ortho#far```` is around ````2.000````.\n */\nclass AnnotationsPlugin extends _viewer_Plugin_js__WEBPACK_IMPORTED_MODULE_0__[\"Plugin\"] {\n\n    /**\n     * @constructor\n     * @param {Viewer} viewer The Viewer.\n     * @param {Object} cfg  Plugin configuration.\n     * @param {String} [cfg.id=\"Annotations\"] Optional ID for this plugin, so that we can find it within {@link Viewer#plugins}.\n     * @param {String} [cfg.markerHTML] HTML text template for Annotation markers. Defaults to ````<div></div>````. Ignored on {@link Annotation}s configured with a ````markerElementId````.\n     * @param {String} [cfg.labelHTML] HTML text template for Annotation labels. Defaults to ````<div></div>````.  Ignored on {@link Annotation}s configured with a ````labelElementId````.\n     * @param {HTMLElement} [cfg.container] Container DOM element for markers and labels. Defaults to ````document.body````.\n     * @param {{String:(String|Number)}} [cfg.values={}] Map of default values to insert into the HTML templates for the marker and label.\n     * @param {Number}  [cfg.surfaceOffset=0.3] The amount by which each {@link Annotation} is offset from the surface of\n     * its {@link Entity} when we create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.\n     */\n    constructor(viewer, cfg) {\n\n        super(\"Annotations\", viewer);\n\n        this._labelHTML = cfg.labelHTML || \"<div></div>\";\n        this._markerHTML = cfg.markerHTML || \"<div></div>\";\n        this._container = cfg.container || document.body;\n        this._values = cfg.values || {};\n\n        /**\n         * The {@link Annotation}s created by {@link AnnotationsPlugin#createAnnotation}, each mapped to its {@link Annotation#id}.\n         * @type {{String:Annotation}}\n         */\n        this.annotations = {};\n\n        this.surfaceOffset = cfg.surfaceOffset;\n    }\n\n    /**\n     * @private\n     */\n    send(name, value) {\n        switch (name) {\n            case \"clearAnnotations\":\n                this.clear();\n                break;\n        }\n    }\n\n    /**\n     * Sets the amount by which each {@link Annotation} is offset from the surface of its {@link Entity}, when we\n     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.\n     *\n     * See the class comments for more info.\n     *\n     * This is ````0.3```` by default.\n     *\n     * @param {Number} surfaceOffset The surface offset.\n     */\n    set surfaceOffset(surfaceOffset) {\n        if (surfaceOffset === undefined || surfaceOffset === null) {\n            surfaceOffset = 0.3;\n        }\n        this._surfaceOffset = surfaceOffset;\n    }\n\n    /**\n     * Gets the amount by which an {@link Annotation} is offset from the surface of its {@link Entity} when\n     * created by {@link AnnotationsPlugin#createAnnotation}, when we\n     * create the Annotation by supplying a {@link PickResult} to {@link AnnotationsPlugin#createAnnotation}.\n     *\n     * This is ````0.3```` by default.\n     *\n     * @returns {Number} The surface offset.\n     */\n    get surfaceOffset() {\n        return this._surfaceOffset;\n    }\n\n    /**\n     * Creates an {@link Annotation}.\n     *\n     * The Annotation is then registered by {@link Annotation#id} in {@link AnnotationsPlugin#annotations}.\n     *\n     * @param {Object} params Annotation configuration.\n     * @param {String} params.id Unique ID to assign to {@link Annotation#id}. The Annotation will be registered by this in {@link AnnotationsPlugin#annotations} and {@link Scene.components}. Must be unique among all components in the {@link Viewer}.\n     * @param {String} [params.markerElementId] ID of pre-existing DOM element to render the marker. This overrides ````markerHTML```` and does not support ````values```` (data is baked into the label DOM element).\n     * @param {String} [params.labelElementId] ID of pre-existing DOM element to render the label. This overrides ````labelHTML```` and does not support ````values```` (data is baked into the label DOM element).\n     * @param {String} [params.markerHTML] HTML text template for the Annotation marker. Defaults to the marker HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````markerElementId````.\n     * @param {String} [params.labelHTML] HTML text template for the Annotation label. Defaults to the label HTML given to the AnnotationsPlugin constructor. Ignored if you provide ````labelElementId````.\n     * @param {Number[]} [params.worldPos=[0,0,0]] World-space position of the Annotation marker, assigned to {@link Annotation#worldPos}.\n     * @param {Entity} [params.entity] Optional {@link Entity} to associate the Annotation with. Causes {@link Annotation#visible} to be ````false```` whenever {@link Entity#visible} is also ````false````.\n     * @param {PickResult} [params.pickResult] Sets the Annotation's World-space position and direction vector from the given {@link PickResult}'s {@link PickResult#worldPos} and {@link PickResult#worldNormal}, and the Annotation's Entity from {@link PickResult#entity}. Causes ````worldPos```` and ````entity```` parameters to be ignored, if they are also given.\n     * @param {Boolean} [params.occludable=false] Indicates whether or not the {@link Annotation} marker and label are hidden whenever the marker occluded by {@link Entity}s in the {@link Scene}. The\n     * {@link Scene} periodically occlusion-tests all Annotations on every 20th \"tick\" (which represents a rendered frame). We can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.\n     * @param  {{String:(String|Number)}} [params.values={}] Map of values to insert into the HTML templates for the marker and label. These will be inserted in addition to any values given to the AnnotationsPlugin constructor.\n     * @param {Boolean} [params.markerShown=true] Whether to initially show the {@link Annotation} marker.\n     * @param {Boolean} [params.labelShown=false] Whether to initially show the {@link Annotation} label.\n     * @param {Number[]} [params.eye] Optional World-space position for {@link Camera#eye}, used when this Annotation is associated with a {@link Camera} position.\n     * @param {Number[]} [params.look] Optional World-space position for {@link Camera#look}, used when this Annotation is associated with a {@link Camera} position.\n     * @param {Number[]} [params.up] Optional World-space position for {@link Camera#up}, used when this Annotation is associated with a {@link Camera} position.\n     * @param {String} [params.projection] Optional projection type for {@link Camera#projection}, used when this Annotation is associated with a {@link Camera} position.\n     * @returns {Annotation} The new {@link Annotation}.\n     */\n    createAnnotation(params) {\n        if (this.viewer.scene.components[params.id]) {\n            this.error(\"Viewer component with this ID already exists: \" + params.id);\n            delete params.id;\n        }\n        var worldPos;\n        var entity;\n        params.pickResult = params.pickResult || params.pickRecord;\n        if (params.pickResult) {\n            const pickResult = params.pickResult;\n            if (!pickResult.worldPos || !pickResult.worldNormal) {\n                this.error(\"Param 'pickResult' does not have both worldPos and worldNormal\");\n            } else {\n                const normalizedWorldNormal = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].normalizeVec3(pickResult.worldNormal, tempVec3a);\n                const offsetVec = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].mulVec3Scalar(normalizedWorldNormal, this._surfaceOffset, tempVec3b);\n                const offsetWorldPos = _viewer_scene_math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].addVec3(pickResult.worldPos, offsetVec, tempVec3c);\n                worldPos = offsetWorldPos;\n                entity = pickResult.entity;\n            }\n        } else {\n            worldPos = params.worldPos;\n            entity = params.entity;\n        }\n\n        var markerElement = null;\n        if (params.markerElementId) {\n            markerElement = document.getElementById(params.markerElementId);\n            if (!markerElement) {\n                this.error(\"Can't find DOM element for 'markerElementId' value '\" + params.markerElementId + \"' - defaulting to internally-generated empty DIV\");\n            }\n        }\n\n        var labelElement = null;\n        if (params.labelElementId) {\n            labelElement = document.getElementById(params.labelElementId);\n            if (!labelElement) {\n                this.error(\"Can't find DOM element for 'labelElementId' value '\" + params.labelElementId + \"' - defaulting to internally-generated empty DIV\");\n            }\n        }\n\n        const annotation = new _Annotation_js__WEBPACK_IMPORTED_MODULE_1__[\"Annotation\"](this.viewer.scene, {\n            id: params.id,\n            plugin: this,\n            entity: entity,\n            worldPos: worldPos,\n            container: this._container,\n            markerElement: markerElement,\n            labelElement: labelElement,\n            markerHTML: params.markerHTML || this._markerHTML,\n            labelHTML: params.labelHTML || this._labelHTML,\n            occludable: params.occludable,\n            values: _viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"utils\"].apply(params.values, _viewer_scene_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"utils\"].apply(this._values, {})),\n            markerShown: params.markerShown,\n            labelShown: params.labelShown,\n            eye: params.eye,\n            look: params.look,\n            up: params.up,\n            projection: params.projection,\n            visible: (params.visible !== false)\n        });\n        this.annotations[annotation.id] = annotation;\n        annotation.on(\"destroyed\", () => {\n            delete this.annotations[annotation.id];\n            this.fire(\"annotationDestroyed\", annotation.id);\n        });\n        this.fire(\"annotationCreated\", annotation.id);\n        return annotation;\n    }\n\n    /**\n     * Destroys an {@link Annotation}.\n     *\n     * @param {String} id ID of Annotation to destroy.\n     */\n    destroyAnnotation(id) {\n        var annotation = this.annotations[id];\n        if (!annotation) {\n            this.log(\"Annotation not found: \" + id);\n            return;\n        }\n        annotation.destroy();\n    }\n\n    /**\n     * Destroys all {@link Annotation}s.\n     */\n    clear() {\n        const ids = Object.keys(this.annotations);\n        for (var i = 0, len = ids.length; i < len; i++) {\n            this.destroyAnnotation(ids[i]);\n        }\n    }\n\n    /**\n     * Destroys this AnnotationsPlugin.\n     *\n     * Destroys all {@link Annotation}s first.\n     */\n    destroy() {\n        this.clear();\n        super.destroy();\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9Bbm5vdGF0aW9uc1BsdWdpbi9Bbm5vdGF0aW9uc1BsdWdpbi5qcz82MTlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE4QztBQUNIO0FBQ087QUFDRzs7QUFFckQsa0JBQWtCLCtEQUFJO0FBQ3RCLGtCQUFrQiwrREFBSTtBQUN0QixrQkFBa0IsK0RBQUk7O0FBRXRCO0FBQ0EsSUFBSSxhQUFhLHNCQUFzQixpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCLGlGQUFpRjtBQUNqRiw4Q0FBOEM7QUFDOUMsMEVBQTBFO0FBQzFFLGlHQUFpRztBQUNqRywrRUFBK0UsYUFBYTtBQUM1RixrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdELGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHLElBQUksWUFBWTtBQUNoQiwyQ0FBMkMsa0NBQWtDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0IsSUFBSSxPQUFPO0FBQzFHO0FBQ0E7QUFDQSw2RUFBNkUsZUFBZTtBQUM1Rix5Q0FBeUMsT0FBTyxxQ0FBcUMsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSx1R0FBdUcsYUFBYTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsZUFBZTtBQUM1Riw0Q0FBNEMsT0FBTztBQUNuRCwyQ0FBMkMsYUFBYTtBQUN4RCx1RUFBdUUsVUFBVTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCLHFDQUFxQyxhQUFhO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUYsNENBQTRDLE9BQU87QUFDbkQsMkNBQTJDLGFBQWE7QUFDeEQsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUIsc0JBQXNCLGFBQWE7QUFDbEc7QUFDQSxRQUFRLHlDQUF5QyxzQkFBc0IsaUJBQWlCO0FBQ3hGLE9BQU8saUJBQWlCLGlDQUFpQyxpQkFBaUIsSUFBSSwwQkFBMEI7QUFDeEcsSUFBSSx3QkFBd0Isa0NBQWtDLGlCQUFpQjtBQUMvRSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0RUFBNEUsMEJBQTBCO0FBQ3RHO0FBQ0EseUdBQXlHO0FBQ3pHLFFBQVEsc0JBQXNCLE1BQU0saUJBQWlCLE1BQU0sc0JBQXNCO0FBQ2pGO0FBQ0E7QUFDQSxPQUFPLHNDQUFzQztBQUM3QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQXlDLFVBQVUsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3REFBTTs7QUFFdEM7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLG9GQUFvRixxQkFBcUI7QUFDL0gsZUFBZSxPQUFPLDBHQUEwRyxpQkFBaUI7QUFDakosZUFBZSxPQUFPLHlHQUF5RyxpQkFBaUI7QUFDaEosZUFBZSxZQUFZO0FBQzNCLGdCQUFnQix3QkFBd0IsZUFBZTtBQUN2RCxlQUFlLE9BQU8sb0RBQW9ELGlCQUFpQjtBQUMzRixZQUFZLGFBQWEsK0NBQStDLGlCQUFpQixLQUFLLHlDQUF5QztBQUN2STtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQixjQUFjLHlDQUF5QyxzQkFBc0Isb0JBQW9CO0FBQ2xJLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsaUJBQWlCLG9DQUFvQyxhQUFhO0FBQ3hHLDZDQUE2QyxpQkFBaUIsS0FBSyx5Q0FBeUM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxpQkFBaUIsb0NBQW9DLGFBQWE7QUFDdEcsbUJBQW1CLHlDQUF5QztBQUM1RCw2Q0FBNkMsaUJBQWlCLEtBQUsseUNBQXlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLDZDQUE2QyxvQkFBb0IsS0FBSyxvQ0FBb0M7QUFDMUc7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLG1DQUFtQyxvQkFBb0IsZ0RBQWdELG9DQUFvQyxNQUFNLHVCQUF1Qiw4Q0FBOEMsYUFBYTtBQUN6UCxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTLHVGQUF1RiwwQkFBMEI7QUFDekksZUFBZSxPQUFPLDJCQUEyQixhQUFhLDJDQUEyQyx5QkFBeUIsK0JBQStCLHFCQUFxQjtBQUN0TCxlQUFlLFdBQVcscUdBQXFHLGlCQUFpQixJQUFJLDBCQUEwQixNQUFNLDZCQUE2QixvQ0FBb0Msd0JBQXdCO0FBQzdRLGVBQWUsUUFBUSx5REFBeUQsaUJBQWlCLDhEQUE4RCxhQUFhLFVBQVUsWUFBWTtBQUNsTSxRQUFRLFlBQVksbUpBQW1KLGtDQUFrQztBQUN6TSxpQkFBaUIsd0JBQXdCLGtCQUFrQjtBQUMzRCxlQUFlLFFBQVEsMERBQTBELGlCQUFpQjtBQUNsRyxlQUFlLFFBQVEsMERBQTBELGlCQUFpQjtBQUNsRyxlQUFlLFNBQVMsaURBQWlELGlCQUFpQixrREFBa0QsYUFBYTtBQUN6SixlQUFlLFNBQVMsa0RBQWtELGtCQUFrQixrREFBa0QsYUFBYTtBQUMzSixlQUFlLFNBQVMsZ0RBQWdELGdCQUFnQixrREFBa0QsYUFBYTtBQUN2SixlQUFlLE9BQU8sbURBQW1ELHdCQUF3QixrREFBa0QsYUFBYTtBQUNoSyxpQkFBaUIsV0FBVyxVQUFVLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw4Q0FBOEMsK0RBQUk7QUFDbEQsa0NBQWtDLCtEQUFJO0FBQ3RDLHVDQUF1QywrREFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQix5REFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0REFBSyxzQkFBc0IsNERBQUssdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9Bbm5vdGF0aW9uc1BsdWdpbi9Bbm5vdGF0aW9uc1BsdWdpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UGx1Z2lufSBmcm9tIFwiLi4vLi4vdmlld2VyL1BsdWdpbi5qc1wiO1xuaW1wb3J0IHtBbm5vdGF0aW9ufSBmcm9tIFwiLi9Bbm5vdGF0aW9uLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiLi4vLi4vdmlld2VyL3NjZW5lL3V0aWxzLmpzXCI7XG5pbXBvcnQge21hdGh9IGZyb20gXCIuLi8uLi92aWV3ZXIvc2NlbmUvbWF0aC9tYXRoLmpzXCI7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuY29uc3QgdGVtcFZlYzNiID0gbWF0aC52ZWMzKCk7XG5jb25zdCB0ZW1wVmVjM2MgPSBtYXRoLnZlYzMoKTtcblxuLyoqXG4gKiB7QGxpbmsgVmlld2VyfSBwbHVnaW4gdGhhdCBjcmVhdGVzIHtAbGluayBBbm5vdGF0aW9ufXMuXG4gKlxuICogWzxpbWcgc3JjPVwiaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vODMxMDAvNTg0MDMwODktMjY1ODkyODAtODA2Mi0xMWU5LTg2NTItYWVkNjFhNGU4YzY0LmdpZlwiPl0oaHR0cHM6Ly94ZW9raXQuZ2l0aHViLmlvL3hlb2tpdC1zZGsvZXhhbXBsZXMvI2Fubm90YXRpb25zX2NsaWNrRmx5VG9Qb3NpdGlvbilcbiAqXG4gKiAqIFtbRXhhbXBsZSAxOiBDcmVhdGUgYW5ub3RhdGlvbnMgd2l0aCBtb3VzZV0oaHR0cHM6Ly94ZW9raXQuZ2l0aHViLmlvL3hlb2tpdC1zZGsvZXhhbXBsZXMvI2Fubm90YXRpb25zX2NyZWF0ZVdpdGhNb3VzZSldXG4gKiAqIFtbRXhhbXBsZSAyOiBDbGljayBhbm5vdGF0aW9ucyB0byB0b2dnbGUgbGFiZWxzXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jYW5ub3RhdGlvbnNfY2xpY2tTaG93TGFiZWxzKV1cbiAqICogW1tFeGFtcGxlIDM6IEhvdmVyIGFubm90YXRpb25zIHRvIHNob3cgbGFiZWxzXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jYW5ub3RhdGlvbnNfaG92ZXJTaG93TGFiZWxzKV1cbiAqICogW1tFeGFtcGxlIDQ6IENsaWNrIGFubm90YXRpb25zIHRvIGZseSB0byB2aWV3cG9pbnRdKGh0dHBzOi8veGVva2l0LmdpdGh1Yi5pby94ZW9raXQtc2RrL2V4YW1wbGVzLyNhbm5vdGF0aW9uc19jbGlja0ZseVRvUG9zaXRpb24pXVxuICogKiBbW0V4YW1wbGUgNTogQ3JlYXRlIEFubm90YXRpb25zIHdpdGggZXh0ZXJuYWxseS1jcmVhdGVkIGVsZW1lbnRzXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jYW5ub3RhdGlvbnNfZXh0ZXJuYWxFbGVtZW50cyldXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiAqIEFuIHtAbGluayBBbm5vdGF0aW9ufSBpcyBhIDNEIHBvc2l0aW9uIHdpdGggYSBsYWJlbCBhdHRhY2hlZC5cbiAqICogQW5ub3RhdGlvbnMgcmVuZGVyIHRoZW1zZWx2ZXMgd2l0aCBIVE1MIGVsZW1lbnRzIHRoYXQgZmxvYXQgb3ZlciB0aGUgY2FudmFzOyBjdXN0b21pemUgdGhlIGFwcGVhcmFuY2Ugb2ZcbiAqIGluZGl2aWR1YWwgQW5ub3RhdGlvbnMgdXNpbmcgSFRNTCB0ZW1wbGF0ZTsgY29uZmlndXJlIGRlZmF1bHQgYXBwZWFyYW5jZSBieSBzZXR0aW5nIHRlbXBsYXRlcyBvbiB0aGUgQW5ub3RhdGlvbnNQbHVnaW4uXG4gKiAqIER5bmFtaWNhbGx5IGluc2VydCBkYXRhIHZhbHVlcyBpbnRvIGVhY2ggQW5ub3RhdGlvbidzIEhUTUwgdGVtcGxhdGVzOyBjb25maWd1cmUgZGVmYXVsdCB2YWx1ZXMgb24gdGhlIEFubm90YXRpb25zUGx1Z2luLlxuICogKiBPcHRpb25hbGx5IGNvbmZpZ3VyZSBBbm5vdGF0aW9uIHdpdGggZXh0ZXJuYWxseS1jcmVhdGVkIERPTSBlbGVtZW50cyBmb3IgbWFya2VycyBhbmQgbGFiZWxzOyB0aGVzZSBvdmVycmlkZSB0ZW1wbGF0ZXMgYW5kIGRhdGEgdmFsdWVzLlxuICogKiBPcHRpb25hbGx5IGNvbmZpZ3VyZSBBbm5vdGF0aW9ucyB0byBoaWRlIHRoZW1zZWx2ZXMgd2hlbmV2ZXIgb2NjbHVkZWQgYnkge0BsaW5rIEVudGl0eX1zLlxuICogKiBPcHRpb25hbGx5IGNvbmZpZ3VyZSBlYWNoIEFubm90YXRpb24gd2l0aCBhIHBvc2l0aW9uIHdlIGNhbiBqdW1wIG9yIGZseSB0aGUge0BsaW5rIENhbWVyYX0gdG8uXG4gKlxuICogIyMgRXhhbXBsZSAxOiBMb2FkaW5nIGEgbW9kZWwgYW5kIGNyZWF0aW5nIGFuIGFubm90YXRpb25cbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgd2UnbGwgdXNlIGEge0BsaW5rIEdMVEZMb2FkZXJQbHVnaW59IHRvIGxvYWQgYSBtb2RlbCwgYW5kIGFuIEFubm90YXRpb25zUGx1Z2luXG4gKiB0byBjcmVhdGUgYW4ge0BsaW5rIEFubm90YXRpb259IG9uIGl0LlxuICpcbiAqIFdlJ2xsIGNvbmZpZ3VyZSB0aGUgQW5ub3RhdGlvbnNQbHVnaW4gd2l0aCBkZWZhdWx0IEhUTUwgdGVtcGxhdGVzIGZvciBlYWNoIEFubm90YXRpb24ncyBwb3NpdGlvbiAoaXRzIFwibWFya2VyXCIpIGFuZFxuICogbGFiZWwsIGFsb25nIHdpdGggc29tZSBkZWZhdWx0IGRhdGEgdmFsdWVzIHRvIGluc2VydCBpbnRvIHRoZW0uXG4gKlxuICogV2hlbiB3ZSBjcmVhdGUgb3VyIEFubm90YXRpb24sIHdlJ2xsIGdpdmUgaXQgc29tZSBzcGVjaWZpYyBkYXRhIHZhbHVlcyB0byBpbnNlcnQgaW50byB0aGUgdGVtcGxhdGVzLCBvdmVycmlkaW5nIHNvbWUgb2ZcbiAqIHRoZSBkZWZhdWx0cyB3ZSBjb25maWd1cmVkIG9uIHRoZSBwbHVnaW4uIE5vdGUgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gdGhlIHBsYWNlaG9sZGVycyBpbiB0aGUgdGVtcGxhdGVzXG4gKiBhbmQgdGhlIGtleXMgaW4gdGhlIHZhbHVlcyBtYXAuXG4gKlxuICogV2UnbGwgYWxzbyBjb25maWd1cmUgdGhlIEFubm90YXRpb24gdG8gaGlkZSBpdHNlbGYgd2hlbmV2ZXIgaXQncyBwb3NpdGlvbiBpcyBvY2NsdWRlZCBieSBhbnkge0BsaW5rIEVudGl0eX1zICh0aGlzIGlzIGRlZmF1bHQgYmVoYXZpb3IpLiBUaGVcbiAqIHtAbGluayBTY2VuZX0gcGVyaW9kaWNhbGx5IG9jY2x1c2lvbi10ZXN0cyBhbGwgQW5ub3RhdGlvbnMgb24gZXZlcnkgMjB0aCBcInRpY2tcIiAod2hpY2ggcmVwcmVzZW50cyBhIHJlbmRlcmVkIGZyYW1lKS4gV2VcbiAqIGNhbiBhZGp1c3QgdGhhdCBmcmVxdWVuY3kgdmlhIHByb3BlcnR5IHtAbGluayBTY2VuZSN0aWNrc1Blck9jY2x1c2lvblRlc3R9LlxuICpcbiAqIEZpbmFsbHksIHdlJ2xsIHF1ZXJ5IHRoZSBBbm5vdGF0aW9uJ3MgcG9zaXRpb24gb2NjbHVzaW9uL3Zpc2liaWxpdHkgc3RhdHVzLCBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZSBldmVudHMgb24gdGhvc2UgcHJvcGVydGllcy5cbiAqXG4gKiBbW1J1biBleGFtcGxlXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jYW5ub3RhdGlvbnNfY2xpY2tTaG93TGFiZWxzKV1cbiAqXG4gKiBgYGBgSmF2YVNjcmlwdFxuICogaW1wb3J0IHtWaWV3ZXJ9IGZyb20gXCIuLi9zcmMvdmlld2VyL1ZpZXdlci5qc1wiO1xuICogaW1wb3J0IHtHTFRGTG9hZGVyUGx1Z2lufSBmcm9tIFwiLi4vc3JjL3BsdWdpbnMvR0xURkxvYWRlclBsdWdpbi9HTFRGTG9hZGVyUGx1Z2luLmpzXCI7XG4gKiBpbXBvcnQge0Fubm90YXRpb25zUGx1Z2lufSBmcm9tIFwiLi4vc3JjL3BsdWdpbnMvQW5ub3RhdGlvbnNQbHVnaW4vQW5ub3RhdGlvbnNQbHVnaW4uanNcIjtcbiAqXG4gKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlld2VyKHtcbiAqICAgICBjYW52YXNJZDogXCJteUNhbnZhc1wiLFxuICogICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gKiB9KTtcbiAqXG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmV5ZSA9IFstMi4zNywgMTguOTcsIC0yNi4xMl07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmxvb2sgPSBbMTAuOTcsIDUuODIsIC0xMS4yMl07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLnVwID0gWzAuMzYsIDAuODMsIDAuNDBdO1xuICpcbiAqIGNvbnN0IGdsdGZMb2FkZXIgPSBuZXcgR0xURkxvYWRlclBsdWdpbih2aWV3ZXIpO1xuICpcbiAqIGNvbnN0IGFubm90YXRpb25zID0gbmV3IEFubm90YXRpb25zUGx1Z2luKHZpZXdlciwge1xuICpcbiAqICAgICAgLy8gRGVmYXVsdCBIVE1MIHRlbXBsYXRlIGZvciBtYXJrZXIgcG9zaXRpb25cbiAqICAgICAgbWFya2VySFRNTDogXCI8ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLW1hcmtlcicgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IHt7bWFya2VyQkdDb2xvcn19Oyc+e3tnbHlwaH19PC9kaXY+XCIsXG4gKlxuICogICAgICAvLyBEZWZhdWx0IEhUTUwgdGVtcGxhdGUgZm9yIGxhYmVsXG4gKiAgICAgIGxhYmVsSFRNTDogXCI8ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLWxhYmVsJyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjoge3tsYWJlbEJHQ29sb3J9fTsnPlwiICtcbiAqICAgICAgXCI8ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLXRpdGxlJz57e3RpdGxlfX08L2Rpdj48ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLWRlc2MnPnt7ZGVzY3JpcHRpb259fTwvZGl2PjwvZGl2PlwiLFxuICpcbiAqICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgdG8gaW5zZXJ0IGludG8gdGhlIG1hcmtlciBhbmQgbGFiZWwgdGVtcGxhdGVzXG4gKiAgICAgIHZhbHVlczoge1xuICogICAgICAgICAgbWFya2VyQkdDb2xvcjogXCJyZWRcIixcbiAqICAgICAgICAgIGxhYmVsQkdDb2xvcjogXCJyZWRcIixcbiAqICAgICAgICAgIGdseXBoOiBcIlhcIixcbiAqICAgICAgICAgIHRpdGxlOiBcIlVudGl0bGVkXCIsXG4gKiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJObyBkZXNjcmlwdGlvblwiXG4gKiAgICAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1vZGVsID0gZ2x0ZkxvYWRlci5sb2FkKHtcbiAqICAgICAgc3JjOiBcIi4vbW9kZWxzL2dsdGYvZHVwbGV4L3NjZW5lLmdsdGZcIlxuICogfSk7XG4gKlxuICogbW9kZWwub24oXCJsb2FkZWRcIiwgKCkgPT4ge1xuICpcbiAqICAgICAgY29uc3QgZW50aXR5ID0gdmlld2VyLnNjZW5lLm1lc2hlc1tcIlwiXTtcbiAqXG4gKiAgICAgIC8vIENyZWF0ZSBhbiBhbm5vdGF0aW9uXG4gKiAgICAgIGNvbnN0IG15QW5ub3RhdGlvbjEgPSBhbm5vdGF0aW9ucy5jcmVhdGVBbm5vdGF0aW9uKHtcbiAqXG4gKiAgICAgICAgICBpZDogXCJteUFubm90YXRpb25cIixcbiAqXG4gKiAgICAgICAgICBlbnRpdHk6IHZpZXdlci5zY2VuZS5vYmplY3RzW1wiMk8yRnIkdDRYN1pmOE5PZXczRkxPSFwiXSwgLy8gT3B0aW9uYWwsIGFzc29jaWF0ZSB3aXRoIGFuIEVudGl0eVxuICpcbiAqICAgICAgICAgIHdvcmxkUG9zOiBbMCwgMCwgMF0sICAgICAgICAvLyAzRCBXb3JsZC1zcGFjZSBwb3NpdGlvblxuICpcbiAqICAgICAgICAgIG9jY2x1ZGFibGU6IHRydWUsICAgICAgICAgICAvLyBPcHRpb25hbCwgZGVmYXVsdCwgbWFrZXMgQW5ub3RhdGlvbiBpbnZpc2libGUgd2hlbiBvY2NsdWRlZCBieSBFbnRpdGllc1xuICogICAgICAgICAgbWFya2VyU2hvd246IHRydWUsICAgICAgICAgIC8vIE9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWUsIG1ha2VzIHBvc2l0aW9uIHZpc2libGUgKHdoZW4gbm90IG9jY2x1ZGVkKVxuICogICAgICAgICAgbGFiZWxTaG93bjogdHJ1ZSAgICAgICAgICAgIC8vIE9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlLCBtYWtlcyBsYWJlbCB2aXNpYmxlICh3aGVuIG5vdCBvY2NsdWRlZClcbiAqXG4gKiAgICAgICAgICB2YWx1ZXM6IHsgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwsIG92ZXJyaWRlcyBBbm5vdGF0aW9uUGx1Z2luJ3MgZGVmYXVsdHNcbiAqICAgICAgICAgICAgICBnbHlwaDogXCJBXCIsXG4gKiAgICAgICAgICAgICAgdGl0bGU6IFwiTXkgQW5ub3RhdGlvblwiLFxuICogICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgaXMgbXkgYW5ub3RhdGlvbi5cIlxuICogICAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlIG9mIHRoZSBBbm5vdGF0aW9uJ3MgM0QgV29ybGQtc3BhY2UgcG9zaXRpb25cbiAqXG4gKiAgICAgIG15QW5ub3RhdGlvbjEub24oXCJ3b3JsZFBvc1wiLCBmdW5jdGlvbih3b3JsZFBvcykge1xuICogICAgICAgICAgLy8uLi5cbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZSBvZiB0aGUgQW5ub3RhdGlvbidzIDNEIFZpZXctc3BhY2UgcG9zaXRpb24sIHdoaWNoIGhhcHBlbnNcbiAqICAgICAgLy8gd2hlbiBlaXRoZXIgd29ybGRQb3Mgd2FzIHVwZGF0ZWQgb3IgdGhlIENhbWVyYSB3YXMgbW92ZWRcbiAqXG4gKiAgICAgIG15QW5ub3RhdGlvbjEub24oXCJ2aWV3UG9zXCIsIGZ1bmN0aW9uKHZpZXdQb3MpIHtcbiAqICAgICAgICAgIC8vLi4uXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2Ugb2YgdGhlIEFubm90YXRpb24ncyAyRCBDYW52YXMtc3BhY2UgcG9zaXRpb24sIHdoaWNoIGhhcHBlbnNcbiAqICAgICAgLy8gd2hlbiB3b3JsZFBvcyBvciB2aWV3UG9zIHdhcyB1cGRhdGVkLCBvciBDYW1lcmEncyBwcm9qZWN0aW9uIHdhcyB1cGRhdGVkXG4gKlxuICogICAgICBteUFubm90YXRpb24xLm9uKFwiY2FudmFzUG9zXCIsIGZ1bmN0aW9uKGNhbnZhc1Bvcykge1xuICogICAgICAgICAgLy8uLi5cbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZSBvZiBBbm5vdGF0aW9uIHZpc2liaWxpdHkuIFRoZSBBbm5vdGF0aW9uIGJlY29tZXMgaW52aXNpYmxlIHdoZW4gaXQgZmFsbHMgb3V0c2lkZSB0aGUgY2FudmFzLFxuICogICAgICAvLyBvciBpdHMgcG9zaXRpb24gaXMgb2NjbHVkZWQgYnkgc29tZSBFbnRpdHkuIE5vdGUgdGhhdCwgd2hlbiBub3Qgb2NjbHVkZWQsIHRoZSBwb3NpdGlvbiBpcyBvbmx5XG4gKiAgICAgIC8vIHNob3duIHdoZW4gQW5ub3RhdGlvbiNtYXJrZXJTaG93biBpcyB0cnVlLCBhbmQgdGhlIGxhYmVsIGlzIG9ubHkgc2hvd24gd2hlbiBBbm5vdGF0aW9uI2xhYmVsU2hvd24gaXMgdHJ1ZS5cbiAqXG4gKiAgICAgIG15QW5ub3RhdGlvbjEub24oXCJ2aXNpYmxlXCIsIGZ1bmN0aW9uKHZpc2libGUpIHsgLy8gTWFya2VyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWRcbiAqICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gKiAgICAgICAgICAgICAgdGhpcy5sb2coXCJBbm5vdGF0aW9uIGlzIHZpc2libGVcIik7XG4gKiAgICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgIHRoaXMubG9nKFwiQW5ub3RhdGlvbiBpcyBpbnZpc2libGVcIik7XG4gKiAgICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gTGlzdGVuIGZvciBkZXN0cnVjdGlvbiBvZiB0aGUgQW5ub3RhdGlvblxuICpcbiAqICAgICAgbXlBbm5vdGF0aW9uMS5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gKiAgICAgICAgICAvLy4uLlxuICogICAgICB9KTtcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqIExldCdzIHF1ZXJ5IG91ciB7QGxpbmsgQW5ub3RhdGlvbn0ncyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBXb3JsZCwgVmlldyBhbmQgQ2FudmFzIGNvb3JkaW5hdGUgc3lzdGVtczpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogY29uc3Qgd29ybGRQb3MgID0gbXlBbm5vdGF0aW9uLndvcmxkUG9zOyAgLy8gW3gseSx6XVxuICogY29uc3Qgdmlld1BvcyAgID0gbXlBbm5vdGF0aW9uLnZpZXdQb3M7ICAgLy8gW3gseSx6XVxuICogY29uc3QgY2FudmFzUG9zID0gbXlBbm5vdGF0aW9uLmNhbnZhc1BvczsgLy8gW3gseV1cbiAqIGBgYGBcbiAqXG4gKiBXZSBjYW4gcXVlcnkgaXQncyBjdXJyZW50IHZpc2liaWxpdHksIHdoaWNoIGlzIGBgYGBmYWxzZWBgYGAgd2hlbiBpdHMgcG9zaXRpb24gaXMgb2NjbHVkZWQgYnkgc29tZSB7QGxpbmsgRW50aXR5fTpcbiAqXG4gKiBgYGBgXG4gKiBjb25zdCB2aXNpYmxlID0gbXlBbm5vdGF0aW9uMS52aXNpYmxlO1xuICogYGBgYFxuICpcbiAqIFRvIGxpc3RlbiBmb3IgY2hhbmdlIGV2ZW50cyBvbiBvdXIgQW5ub3RhdGlvbidzIHBvc2l0aW9uIGFuZCB2aXNpYmlsaXR5OlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiAvLyBXb3JsZC1zcGFjZSBwb3NpdGlvbiBjaGFuZ2VzIHdoZW4gd2UgYXNzaWduIGEgbmV3IHZhbHVlIHRvIEFubm90YXRpb24jd29ybGRQb3NcbiAqIG15QW5ub3RhdGlvbjEub24oXCJ3b3JsZFBvc1wiLCAod29ybGRQb3MpID0+IHtcbiAqICAgICAvLy4uLlxuICogfSk7XG4gKlxuICogLy8gVmlldy1zcGFjZSBwb3NpdGlvbiBjaGFuZ2VzIHdoZW4gZWl0aGVyIHdvcmxkUG9zIHdhcyB1cGRhdGVkIG9yIHRoZSBDYW1lcmEgd2FzIG1vdmVkXG4gKiBteUFubm90YXRpb24xLm9uKFwidmlld1Bvc1wiLCAodmlld1BvcykgPT4ge1xuICogICAgIC8vLi4uXG4gKiB9KTtcbiAqXG4gKiAvLyBDYW52YXMtc3BhY2UgcG9zaXRpb24gY2hhbmdlcyB3aGVuIHdvcmxkUG9zIG9yIHZpZXdQb3Mgd2FzIHVwZGF0ZWQsIG9yIENhbWVyYSdzIHByb2plY3Rpb24gd2FzIHVwZGF0ZWRcbiAqIG15QW5ub3RhdGlvbjEub24oXCJjYW52YXNQb3NcIiwgKGNhbnZhc1BvcykgPT4ge1xuICogICAgIC8vLi4uXG4gKiB9KTtcbiAqXG4gKiAvLyBBbm5vdGF0aW9uIGlzIGludmlzaWJsZSB3aGVuIGl0cyBwb3NpdGlvbiBmYWxscyBvZmYgdGhlIGNhbnZhcyBvciBpcyBvY2NsdWRlZCBieSBzb21lIEVudGl0eVxuICogbXlBbm5vdGF0aW9uMS5vbihcInZpc2libGVcIiwgKHZpc2libGUpID0+IHtcbiAqICAgICAvLy4uLlxuICogfSk7XG4gKiBgYGBgXG4gKlxuICogRmluYWxseSwgbGV0J3MgZHluYW1pY2FsbHkgdXBkYXRlIHRoZSB2YWx1ZXMgZm9yIGEgY291cGxlIG9mIHBsYWNlaG9sZGVycyBpbiBvdXIgQW5ub3RhdGlvbidzIGxhYmVsOlxuICpcbiAqIGBgYGAgamF2YXNjcmlwdFxuICogbXlBbm5vdGF0aW9uMS5zZXRWYWx1ZXMoe1xuICogICAgICB0aXRsZTogXCJIZXJlJ3MgYSBuZXcgdGl0bGVcIixcbiAqICAgICAgZGVzY3JpcHRpb246IFwiSGVyZSdzIGEgbmV3IGRlc2NyaXB0aW9uXCJcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqXG4gKiAjIyBFeGFtcGxlIDI6IENyZWF0aW5nIGFuIEFubm90YXRpb24gd2l0aCBhIHVuaXF1ZSBhcHBlYXJhbmNlXG4gKlxuICogTm93IGxldCdzIGNyZWF0ZSBhIHNlY29uZCB7QGxpbmsgQW5ub3RhdGlvbn0sIHRoaXMgdGltZSB3aXRoIGl0cyBvd24gY3VzdG9tIEhUTUwgbGFiZWwgdGVtcGxhdGUsIHdoaWNoIGluY2x1ZGVzXG4gKiBhbiBpbWFnZS4gSW4gdGhlIEFubm90YXRpb24ncyB2YWx1ZXMsIHdlJ2xsIGFsc28gcHJvdmlkZSBhIG5ldyB0aXRsZSBhbmQgZGVzY3JpcHRpb24sIGN1c3RvbSBjb2xvcnMgZm9yIHRoZSBtYXJrZXJcbiAqIGFuZCBsYWJlbCwgcGx1cyBhIFVSTCBmb3IgdGhlIGltYWdlIGluIHRoZSBsYWJlbCB0ZW1wbGF0ZS4gVG8gcmVuZGVyIGl0cyBtYXJrZXIsIHRoZSBBbm5vdGF0aW9uIHdpbGwgZmFsbCBiYWNrXG4gKiBvbiB0aGUgQW5ub3RhdGlvblBsdWdpbidzIGRlZmF1bHQgbWFya2VyIHRlbXBsYXRlLlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBteUFubm90YXRpb24yID0gYW5ub3RhdGlvbnMuY3JlYXRlQW5ub3RhdGlvbih7XG4gKlxuICogICAgICBpZDogXCJteUFubm90YXRpb24yXCIsXG4gKlxuICogICAgICB3b3JsZFBvczogWy0wLjE2MywgMS44MTAsIDcuOTc3XSxcbiAqXG4gKiAgICAgIG9jY2x1ZGFibGU6IHRydWUsXG4gKiAgICAgIG1hcmtlclNob3duOiB0cnVlLFxuICogICAgICBsYWJlbFNob3duOiB0cnVlLFxuICpcbiAqICAgICAgLy8gQ3VzdG9tIGxhYmVsIHRlbXBsYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBBbm5vdGF0aW9uJ3MsIHdpdGggdGhlIGFkZGl0aW9uIG9mIGFuIGltYWdlIGVsZW1lbnRcbiAqICAgICAgbGFiZWxIVE1MOiBcIjxkaXYgY2xhc3M9J2Fubm90YXRpb24tbGFiZWwnIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiB7e2xhYmVsQkdDb2xvcn19Oyc+XFxcbiAqICAgICAgICAgIDxkaXYgY2xhc3M9J2Fubm90YXRpb24tdGl0bGUnPnt7dGl0bGV9fTwvZGl2PlxcXG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLWRlc2MnPnt7ZGVzY3JpcHRpb259fTwvZGl2PlxcXG4gKiAgICAgICAgICA8YnI+PGltZyBhbHQ9J215SW1hZ2UnIHdpZHRoPScxNTBweCcgaGVpZ2h0PScxMDBweCcgc3JjPSd7e2ltYWdlU3JjfX0nPlxcXG4gKiAgICAgICAgICA8L2Rpdj5cIixcbiAqXG4gKiAgICAgIC8vIEN1c3RvbSB0ZW1wbGF0ZSB2YWx1ZXMgb3ZlcnJpZGUgYWxsIHRoZSBBbm5vdGF0aW9uUGx1Z2luJ3MgZGVmYXVsdHMsIGFuZCBpbmNsdWRlcyBhbiBhZGRpdGlvbmFsIHZhbHVlXG4gKiAgICAgIC8vIGZvciB0aGUgaW1hZ2UgZWxlbWVudCdzIFVSTFxuICogICAgICB2YWx1ZXM6IHtcbiAqICAgICAgICAgIGdseXBoOiBcIkEzXCIsXG4gKiAgICAgICAgICB0aXRsZTogXCJUaGUgV2VzdCB3YWxsXCIsXG4gKiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBbm5vdGF0aW9ucyBjYW4gY29udGFpbjxicj5jdXN0b20gSFRNTCBsaWtlIHRoaXM8YnI+aW1hZ2U6XCIsXG4gKiAgICAgICAgICBtYXJrZXJCR0NvbG9yOiBcImdyZWVuXCIsXG4gKiAgICAgICAgICBsYWJlbEJHQ29sb3I6IFwiZ3JlZW5cIixcbiAqICAgICAgICAgIGltYWdlU3JjOiBcImh0dHBzOi8veGVva2l0LmlvL2ltZy9kb2NzL0JJTVNlcnZlckxvYWRlclBsdWdpbi9zY2hlcGVuZG9tbGFhbi5wbmdcIlxuICogICAgICB9XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiAjIyBFeGFtcGxlIDM6IENyZWF0aW5nIGFuIEFubm90YXRpb24gd2l0aCBhIGNhbWVyYSBwb3NpdGlvblxuICpcbiAqIFdlIGNhbiBvcHRpb25hbGx5IGNvbmZpZ3VyZSBlYWNoIHtAbGluayBBbm5vdGF0aW9ufSB3aXRoIGEgcG9zaXRpb24gdG8gZmx5IG9yIGp1bXAgdGhlIHtAbGluayBDYW1lcmF9IHRvLlxuICpcbiAqIExldCdzIGNyZWF0ZSBhbm90aGVyIEFubm90YXRpb24sIHRoaXMgdGltZSBwcm92aWRpbmcgaXQgd2l0aCBgYGBgZXllYGBgYCwgYGBgYGxvb2tgYGBgIGFuZCBgYGBgdXBgYGBgIHByb3BlcnRpZXNcbiAqIGluZGljYXRpbmcgYSB2aWV3cG9pbnQgb24gd2hhdGV2ZXIgaXQncyBhbm5vdGF0aW5nOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBteUFubm90YXRpb24zID0gYW5ub3RhdGlvbnMuY3JlYXRlQW5ub3RhdGlvbih7XG4gKlxuICogICAgICBpZDogXCJteUFubm90YXRpb24zXCIsXG4gKlxuICogICAgICB3b3JsZFBvczogWy0wLjE2MywgMy44MTAsIDcuOTc3XSxcbiAqXG4gKiAgICAgIGV5ZTogWzAsMCwtMTBdLFxuICogICAgICBsb29rOiBbLTAuMTYzLCAzLjgxMCwgNy45NzddLFxuICogICAgICB1cDogWzAsMSwwXTtcbiAqXG4gKiAgICAgIG9jY2x1ZGFibGU6IHRydWUsXG4gKiAgICAgIG1hcmtlclNob3duOiB0cnVlLFxuICogICAgICBsYWJlbFNob3duOiB0cnVlLFxuICpcbiAqICAgICAgbGFiZWxIVE1MOiBcIjxkaXYgY2xhc3M9J2Fubm90YXRpb24tbGFiZWwnIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiB7e2xhYmVsQkdDb2xvcn19Oyc+XFxcbiAqICAgICAgICAgIDxkaXYgY2xhc3M9J2Fubm90YXRpb24tdGl0bGUnPnt7dGl0bGV9fTwvZGl2PlxcXG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPSdhbm5vdGF0aW9uLWRlc2MnPnt7ZGVzY3JpcHRpb259fTwvZGl2PlxcXG4gKiAgICAgICAgICA8YnI+PGltZyBhbHQ9J215SW1hZ2UnIHdpZHRoPScxNTBweCcgaGVpZ2h0PScxMDBweCcgc3JjPSd7e2ltYWdlU3JjfX0nPlxcXG4gKiAgICAgICAgICA8L2Rpdj5cIixcbiAqXG4gKiAgICAgIHZhbHVlczoge1xuICogICAgICAgICAgZ2x5cGg6IFwiQTNcIixcbiAqICAgICAgICAgIHRpdGxlOiBcIlRoZSBXZXN0IHdhbGxcIixcbiAqICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFubm90YXRpb25zIGNhbiBjb250YWluPGJyPmN1c3RvbSBIVE1MIGxpa2UgdGhpczxicj5pbWFnZTpcIixcbiAqICAgICAgICAgIG1hcmtlckJHQ29sb3I6IFwiZ3JlZW5cIixcbiAqICAgICAgICAgIGxhYmVsQkdDb2xvcjogXCJncmVlblwiLFxuICogICAgICAgICAgaW1hZ2VTcmM6IFwiaHR0cHM6Ly94ZW9raXQuaW8vaW1nL2RvY3MvQklNU2VydmVyTG9hZGVyUGx1Z2luL3NjaGVwZW5kb21sYWFuLnBuZ1wiXG4gKiAgICAgIH1cbiAqIH0pO1xuICogYGBgYFxuICpcbiAqIE5vdyB3ZSBjYW4gZmx5IHRoZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGUgQW5ub3RhdGlvbidzIHZpZXdwb2ludCwgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiB2aWV3ZXIuY2FtZXJhRmxpZ2h0LmZseVRvKG15QW5ub3RhdGlvbjMpO1xuICogYGBgYFxuICpcbiAqIE9yIGp1bXAgdGhlIENhbWVyYSwgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiB2aWV3ZXIuY2FtZXJhRmxpZ2h0Lmp1bXBUbyhteUFubm90YXRpb24zKTtcbiAqIGBgYGBcbiAqXG4gKiAjIyBFeGFtcGxlIDQ6IENyZWF0aW5nIGFuIEFubm90YXRpb24gdXNpbmcgZXh0ZXJuYWxseS1jcmVhdGVkIERPTSBlbGVtZW50c1xuICpcbiAqIE5vdyBsZXQncyBjcmVhdGUgYW5vdGhlciB7QGxpbmsgQW5ub3RhdGlvbn0sIHRoaXMgdGltZSBwcm92aWRpbmcgaXQgd2l0aCBwcmUtZXhpc3RpbmcgRE9NIGVsZW1lbnRzIGZvciBpdHMgbWFya2VyXG4gKiBhbmQgbGFiZWwuIE5vdGUgdGhhdCBBbm5vdGF0aW9uc1BsdWdpbiB3aWxsIGlnbm9yZSBhbnkgYGBgYG1hcmtlckhUTUxgYGBgLCBgYGBgbGFiZWxIVE1MYGBgYFxuICogb3IgYGBgYHZhbHVlc2BgYGAgcHJvcGVydGllcyB3aGVuIHByb3ZpZGUgIGBgYGBtYXJrZXJFbGVtZW50SWRgYGBgIG9yIGBgYGBsYWJlbEVsZW1lbnRJZGBgYGAuXG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG15QW5ub3RhdGlvbjIgPSBhbm5vdGF0aW9ucy5jcmVhdGVBbm5vdGF0aW9uKHtcbiAqXG4gKiAgICAgIGlkOiBcIm15QW5ub3RhdGlvbjJcIixcbiAqXG4gKiAgICAgIHdvcmxkUG9zOiBbLTAuMTYzLCAxLjgxMCwgNy45NzddLFxuICpcbiAqICAgICAgb2NjbHVkYWJsZTogdHJ1ZSxcbiAqICAgICAgbWFya2VyU2hvd246IHRydWUsXG4gKiAgICAgIGxhYmVsU2hvd246IHRydWUsXG4gKlxuICogICAgICBtYXJrZXJFbGVtZW50SWQ6IFwibXlNYXJrZXJFbGVtZW50XCIsXG4gKiAgICAgIGxhYmVsRWxlbWVudElkOiBcIm15TGFiZWxFbGVtZW50XCJcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqICMjIEV4YW1wbGUgNTogQ3JlYXRpbmcgYW5ub3RhdGlvbnMgYnkgY2xpY2tpbmcgb24gb2JqZWN0c1xuICpcbiAqIEFubm90YXRpb25zUGx1Z2luIG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIHtAbGluayBBbm5vdGF0aW9ufXMgb24gdGhlIHN1cmZhY2VzIG9mIHtAbGluayBFbnRpdHl9cyBhcyB3ZSBjbGljayBvbiB0aGVtLlxuICpcbiAqIFRoZSB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW4jY3JlYXRlQW5ub3RhdGlvbn0gbWV0aG9kIGNhbiBhY2NlcHQgYSB7QGxpbmsgUGlja1Jlc3VsdH0gcmV0dXJuZWRcbiAqIGJ5IHtAbGluayBTY2VuZSNwaWNrfSwgZnJvbSB3aGljaCBpdCBpbml0aWFsaXplcyB0aGUge0BsaW5rIEFubm90YXRpb259J3Mge0BsaW5rIEFubm90YXRpb24jd29ybGRQb3N9IGFuZFxuICoge0BsaW5rIEFubm90YXRpb24jZW50aXR5fS4gTm90ZSB0aGF0IHRoaXMgb25seSB3b3JrcyB3aGVuIHtAbGluayBTY2VuZSNwaWNrfSB3YXMgY29uZmlndXJlZCB0byBwZXJmb3JtIGEgM0RcbiAqIHN1cmZhY2UtaW50ZXJzZWN0aW9uIHBpY2sgKHNlZSB7QGxpbmsgU2NlbmUjcGlja30gZm9yIG1vcmUgaW5mbykuXG4gKlxuICogTGV0J3Mgbm93IGV4dGVuZCBvdXIgZXhhbXBsZSB0byBjcmVhdGUgYW4gQW5ub3RhdGlvbiB3aGVyZXZlciB3ZSBjbGljayBvbiB0aGUgc3VyZmFjZSBvZiBvZiBvdXIgbW9kZWw6XG4gKlxuICogW1tSdW4gZXhhbXBsZV0oaHR0cHM6Ly94ZW9raXQuZ2l0aHViLmlvL3hlb2tpdC1zZGsvZXhhbXBsZXMvI2Fubm90YXRpb25zX2NyZWF0ZVdpdGhNb3VzZSldXG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIHZhciBpID0gMTsgLy8gVXNlZCB0byBjcmVhdGUgdW5pcXVlIEFubm90YXRpb24gSURzXG4gKlxuICogdmlld2VyLnNjZW5lLmlucHV0Lm9uKFwibW91c2VjbGlja2VkXCIsIChjb29yZHMpID0+IHtcbiAqXG4gKiAgICAgdmFyIHBpY2tSZWNvcmQgPSB2aWV3ZXIuc2NlbmUucGljayh7XG4gKiAgICAgICAgIGNhbnZhc1BvczogY29vcmRzLFxuICogICAgICAgICBwaWNrU3VyZmFjZTogdHJ1ZSAgLy8gPDwtLS0tLS0gVGhpcyBjYXVzZXMgcGlja2luZyB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIGVudGl0eVxuICogICAgIH0pO1xuICpcbiAqICAgICBpZiAocGlja1JlY29yZCkge1xuICpcbiAqICAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zLmNyZWF0ZUFubm90YXRpb24oe1xuICogICAgICAgICAgICAgIGlkOiBcIm15QW5ub3RhdGlvbk9uQ2xpY2tcIiArIGksXG4gKiAgICAgICAgICAgICAgcGlja1JlY29yZDogcGlja1JlY29yZCxcbiAqICAgICAgICAgICAgICBvY2NsdWRhYmxlOiB0cnVlLCAgICAgICAgICAgLy8gT3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICogICAgICAgICAgICAgIG1hcmtlclNob3duOiB0cnVlLCAgICAgICAgICAvLyBPcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gKiAgICAgICAgICAgICAgbGFiZWxTaG93bjogdHJ1ZSwgICAgICAgICAgIC8vIE9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAqICAgICAgICAgICAgICB2YWx1ZXM6IHsgICAgICAgICAgICAgICAgICAgLy8gSFRNTCB0ZW1wbGF0ZSB2YWx1ZXNcbiAqICAgICAgICAgICAgICAgICAgZ2x5cGg6IFwiQVwiICsgaSxcbiAqICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiTXkgYW5ub3RhdGlvbiBcIiArIGksXG4gKiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk15IGRlc2NyaXB0aW9uIFwiICsgaVxuICogICAgICAgICAgICAgIH0sXG4gICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgaSsrO1xuICogICAgICB9XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgd2hlbiB0aGUgQW5ub3RhdGlvbiBpcyBvY2NsdWRhYmxlLCB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIHRoZSB7QGxpbmsgQW5ub3RhdGlvbiN3b3JsZFBvc30gdG8gYmVjb21lXG4gKiB2aXN1YWxseSBlbWJlZGRlZCB3aXRoaW4gdGhlIHN1cmZhY2Ugb2YgaXRzIEVudGl0eSB3aGVuIHZpZXdlZCBmcm9tIGEgZGlzdGFuY2UuIFRoaXMgaGFwcGVucyBhcyBhIHJlc3VsdCBvZiBsaW1pdGVkXG4gKiBHUFUgYWNjdXJhY3kgR1BVIGFjY3VyYWN5LCBlc3BlY2lhbGx5IHdoZW4gdGhlIG5lYXIgYW5kIGZhciB2aWV3LXNwYWNlIGNsaXBwaW5nIHBsYW5lcywgc3BlY2lmaWVkIGJ5IHtAbGluayBQZXJzcGVjdGl2ZSNuZWFyfVxuICogYW5kIHtAbGluayBQZXJzcGVjdGl2ZSNmYXJ9LCBvciB7QGxpbmsgT3J0aG8jbmVhcn0gYW5kIHtAbGluayBQZXJzcGVjdGl2ZSNmYXJ9LCBhcmUgZmFyIGF3YXkgZnJvbSBlYWNoIG90aGVyLlxuICpcbiAqIFRvIHByZXZlbnQgdGhpcywgd2UgY2FuIG9mZnNldCBBbm5vdGF0aW9ucyBmcm9tIHRoZWlyIEVudGl0eSBzdXJmYWNlcyBieSBhbiBhbW91bnQgdGhhdCB3ZSBzZXRcbiAqIG9uIHtAbGluayBBbm5vdGF0aW9uc1BsdWdpbiNzdXJmYWNlT2Zmc2V0fTpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogYW5ub3RhdGlvbnMuc3VyZmFjZU9mZnNldCA9IDAuMzsgLy8gRGVmYXVsdCB2YWx1ZVxuICogYGBgYFxuICpcbiAqIEFubm90YXRpb25zIHN1YnNlcXVlbnRseSBjcmVhdGVkIHdpdGgge0BsaW5rIEFubm90YXRpb25zUGx1Z2luI2NyZWF0ZUFubm90YXRpb259IHVzaW5nIGEge0BsaW5rIFBpY2tSZXN1bHR9IHdpbGwgdGhlblxuICogYmUgb2Zmc2V0IGJ5IHRoYXQgYW1vdW50LlxuICpcbiAqIEFub3RoZXIgdGhpbmcgd2UgY2FuIGRvIHRvIHByZXZlbnQgdGhpcyB1bndhbnRlZCBvY2NsdXNpb24gaXMga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmlldy1zcGFjZSBjbGlwcGluZ1xuICogcGxhbmVzIHRvIGEgbWluaW11bSwgd2hpY2ggaW1wcm92ZXMgdGhlIGFjY3VyYWN5IG9mIHRoZSBBbm5vdGF0aW9uIG9jY2x1c2lvbiB0ZXN0LiBJbiBnZW5lcmFsLCBhIGdvb2QgZGVmYXVsdFxuICogdmFsdWUgZm9yIGBgYGBQZXJzcGVjdGl2ZSNmYXJgYGBgIGFuZCBgYGBgT3J0aG8jZmFyYGBgYCBpcyBhcm91bmQgYGBgYDIuMDAwYGBgYC5cbiAqL1xuY2xhc3MgQW5ub3RhdGlvbnNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtWaWV3ZXJ9IHZpZXdlciBUaGUgVmlld2VyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgIFBsdWdpbiBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2ZnLmlkPVwiQW5ub3RhdGlvbnNcIl0gT3B0aW9uYWwgSUQgZm9yIHRoaXMgcGx1Z2luLCBzbyB0aGF0IHdlIGNhbiBmaW5kIGl0IHdpdGhpbiB7QGxpbmsgVmlld2VyI3BsdWdpbnN9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2ZnLm1hcmtlckhUTUxdIEhUTUwgdGV4dCB0ZW1wbGF0ZSBmb3IgQW5ub3RhdGlvbiBtYXJrZXJzLiBEZWZhdWx0cyB0byBgYGBgPGRpdj48L2Rpdj5gYGBgLiBJZ25vcmVkIG9uIHtAbGluayBBbm5vdGF0aW9ufXMgY29uZmlndXJlZCB3aXRoIGEgYGBgYG1hcmtlckVsZW1lbnRJZGBgYGAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjZmcubGFiZWxIVE1MXSBIVE1MIHRleHQgdGVtcGxhdGUgZm9yIEFubm90YXRpb24gbGFiZWxzLiBEZWZhdWx0cyB0byBgYGBgPGRpdj48L2Rpdj5gYGBgLiAgSWdub3JlZCBvbiB7QGxpbmsgQW5ub3RhdGlvbn1zIGNvbmZpZ3VyZWQgd2l0aCBhIGBgYGBsYWJlbEVsZW1lbnRJZGBgYGAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NmZy5jb250YWluZXJdIENvbnRhaW5lciBET00gZWxlbWVudCBmb3IgbWFya2VycyBhbmQgbGFiZWxzLiBEZWZhdWx0cyB0byBgYGBgZG9jdW1lbnQuYm9keWBgYGAuXG4gICAgICogQHBhcmFtIHt7U3RyaW5nOihTdHJpbmd8TnVtYmVyKX19IFtjZmcudmFsdWVzPXt9XSBNYXAgb2YgZGVmYXVsdCB2YWx1ZXMgdG8gaW5zZXJ0IGludG8gdGhlIEhUTUwgdGVtcGxhdGVzIGZvciB0aGUgbWFya2VyIGFuZCBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIFtjZmcuc3VyZmFjZU9mZnNldD0wLjNdIFRoZSBhbW91bnQgYnkgd2hpY2ggZWFjaCB7QGxpbmsgQW5ub3RhdGlvbn0gaXMgb2Zmc2V0IGZyb20gdGhlIHN1cmZhY2Ugb2ZcbiAgICAgKiBpdHMge0BsaW5rIEVudGl0eX0gd2hlbiB3ZSBjcmVhdGUgdGhlIEFubm90YXRpb24gYnkgc3VwcGx5aW5nIGEge0BsaW5rIFBpY2tSZXN1bHR9IHRvIHtAbGluayBBbm5vdGF0aW9uc1BsdWdpbiNjcmVhdGVBbm5vdGF0aW9ufS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIGNmZykge1xuXG4gICAgICAgIHN1cGVyKFwiQW5ub3RhdGlvbnNcIiwgdmlld2VyKTtcblxuICAgICAgICB0aGlzLl9sYWJlbEhUTUwgPSBjZmcubGFiZWxIVE1MIHx8IFwiPGRpdj48L2Rpdj5cIjtcbiAgICAgICAgdGhpcy5fbWFya2VySFRNTCA9IGNmZy5tYXJrZXJIVE1MIHx8IFwiPGRpdj48L2Rpdj5cIjtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY2ZnLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBjZmcudmFsdWVzIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUge0BsaW5rIEFubm90YXRpb259cyBjcmVhdGVkIGJ5IHtAbGluayBBbm5vdGF0aW9uc1BsdWdpbiNjcmVhdGVBbm5vdGF0aW9ufSwgZWFjaCBtYXBwZWQgdG8gaXRzIHtAbGluayBBbm5vdGF0aW9uI2lkfS5cbiAgICAgICAgICogQHR5cGUge3tTdHJpbmc6QW5ub3RhdGlvbn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy5zdXJmYWNlT2Zmc2V0ID0gY2ZnLnN1cmZhY2VPZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImNsZWFyQW5ub3RhdGlvbnNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbW91bnQgYnkgd2hpY2ggZWFjaCB7QGxpbmsgQW5ub3RhdGlvbn0gaXMgb2Zmc2V0IGZyb20gdGhlIHN1cmZhY2Ugb2YgaXRzIHtAbGluayBFbnRpdHl9LCB3aGVuIHdlXG4gICAgICogY3JlYXRlIHRoZSBBbm5vdGF0aW9uIGJ5IHN1cHBseWluZyBhIHtAbGluayBQaWNrUmVzdWx0fSB0byB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW4jY3JlYXRlQW5ub3RhdGlvbn0uXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIGNsYXNzIGNvbW1lbnRzIGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGBgYGAwLjNgYGBgIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3VyZmFjZU9mZnNldCBUaGUgc3VyZmFjZSBvZmZzZXQuXG4gICAgICovXG4gICAgc2V0IHN1cmZhY2VPZmZzZXQoc3VyZmFjZU9mZnNldCkge1xuICAgICAgICBpZiAoc3VyZmFjZU9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IHN1cmZhY2VPZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1cmZhY2VPZmZzZXQgPSAwLjM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VyZmFjZU9mZnNldCA9IHN1cmZhY2VPZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW1vdW50IGJ5IHdoaWNoIGFuIHtAbGluayBBbm5vdGF0aW9ufSBpcyBvZmZzZXQgZnJvbSB0aGUgc3VyZmFjZSBvZiBpdHMge0BsaW5rIEVudGl0eX0gd2hlblxuICAgICAqIGNyZWF0ZWQgYnkge0BsaW5rIEFubm90YXRpb25zUGx1Z2luI2NyZWF0ZUFubm90YXRpb259LCB3aGVuIHdlXG4gICAgICogY3JlYXRlIHRoZSBBbm5vdGF0aW9uIGJ5IHN1cHBseWluZyBhIHtAbGluayBQaWNrUmVzdWx0fSB0byB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW4jY3JlYXRlQW5ub3RhdGlvbn0uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGBgYGAwLjNgYGBgIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3VyZmFjZSBvZmZzZXQuXG4gICAgICovXG4gICAgZ2V0IHN1cmZhY2VPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXJmYWNlT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIEFubm90YXRpb259LlxuICAgICAqXG4gICAgICogVGhlIEFubm90YXRpb24gaXMgdGhlbiByZWdpc3RlcmVkIGJ5IHtAbGluayBBbm5vdGF0aW9uI2lkfSBpbiB7QGxpbmsgQW5ub3RhdGlvbnNQbHVnaW4jYW5ub3RhdGlvbnN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBBbm5vdGF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5pZCBVbmlxdWUgSUQgdG8gYXNzaWduIHRvIHtAbGluayBBbm5vdGF0aW9uI2lkfS4gVGhlIEFubm90YXRpb24gd2lsbCBiZSByZWdpc3RlcmVkIGJ5IHRoaXMgaW4ge0BsaW5rIEFubm90YXRpb25zUGx1Z2luI2Fubm90YXRpb25zfSBhbmQge0BsaW5rIFNjZW5lLmNvbXBvbmVudHN9LiBNdXN0IGJlIHVuaXF1ZSBhbW9uZyBhbGwgY29tcG9uZW50cyBpbiB0aGUge0BsaW5rIFZpZXdlcn0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubWFya2VyRWxlbWVudElkXSBJRCBvZiBwcmUtZXhpc3RpbmcgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIHRoZSBtYXJrZXIuIFRoaXMgb3ZlcnJpZGVzIGBgYGBtYXJrZXJIVE1MYGBgYCBhbmQgZG9lcyBub3Qgc3VwcG9ydCBgYGBgdmFsdWVzYGBgYCAoZGF0YSBpcyBiYWtlZCBpbnRvIHRoZSBsYWJlbCBET00gZWxlbWVudCkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubGFiZWxFbGVtZW50SWRdIElEIG9mIHByZS1leGlzdGluZyBET00gZWxlbWVudCB0byByZW5kZXIgdGhlIGxhYmVsLiBUaGlzIG92ZXJyaWRlcyBgYGBgbGFiZWxIVE1MYGBgYCBhbmQgZG9lcyBub3Qgc3VwcG9ydCBgYGBgdmFsdWVzYGBgYCAoZGF0YSBpcyBiYWtlZCBpbnRvIHRoZSBsYWJlbCBET00gZWxlbWVudCkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubWFya2VySFRNTF0gSFRNTCB0ZXh0IHRlbXBsYXRlIGZvciB0aGUgQW5ub3RhdGlvbiBtYXJrZXIuIERlZmF1bHRzIHRvIHRoZSBtYXJrZXIgSFRNTCBnaXZlbiB0byB0aGUgQW5ub3RhdGlvbnNQbHVnaW4gY29uc3RydWN0b3IuIElnbm9yZWQgaWYgeW91IHByb3ZpZGUgYGBgYG1hcmtlckVsZW1lbnRJZGBgYGAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubGFiZWxIVE1MXSBIVE1MIHRleHQgdGVtcGxhdGUgZm9yIHRoZSBBbm5vdGF0aW9uIGxhYmVsLiBEZWZhdWx0cyB0byB0aGUgbGFiZWwgSFRNTCBnaXZlbiB0byB0aGUgQW5ub3RhdGlvbnNQbHVnaW4gY29uc3RydWN0b3IuIElnbm9yZWQgaWYgeW91IHByb3ZpZGUgYGBgYGxhYmVsRWxlbWVudElkYGBgYC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbcGFyYW1zLndvcmxkUG9zPVswLDAsMF1dIFdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSBBbm5vdGF0aW9uIG1hcmtlciwgYXNzaWduZWQgdG8ge0BsaW5rIEFubm90YXRpb24jd29ybGRQb3N9LlxuICAgICAqIEBwYXJhbSB7RW50aXR5fSBbcGFyYW1zLmVudGl0eV0gT3B0aW9uYWwge0BsaW5rIEVudGl0eX0gdG8gYXNzb2NpYXRlIHRoZSBBbm5vdGF0aW9uIHdpdGguIENhdXNlcyB7QGxpbmsgQW5ub3RhdGlvbiN2aXNpYmxlfSB0byBiZSBgYGBgZmFsc2VgYGBgIHdoZW5ldmVyIHtAbGluayBFbnRpdHkjdmlzaWJsZX0gaXMgYWxzbyBgYGBgZmFsc2VgYGBgLlxuICAgICAqIEBwYXJhbSB7UGlja1Jlc3VsdH0gW3BhcmFtcy5waWNrUmVzdWx0XSBTZXRzIHRoZSBBbm5vdGF0aW9uJ3MgV29ybGQtc3BhY2UgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiB2ZWN0b3IgZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIFBpY2tSZXN1bHR9J3Mge0BsaW5rIFBpY2tSZXN1bHQjd29ybGRQb3N9IGFuZCB7QGxpbmsgUGlja1Jlc3VsdCN3b3JsZE5vcm1hbH0sIGFuZCB0aGUgQW5ub3RhdGlvbidzIEVudGl0eSBmcm9tIHtAbGluayBQaWNrUmVzdWx0I2VudGl0eX0uIENhdXNlcyBgYGBgd29ybGRQb3NgYGBgIGFuZCBgYGBgZW50aXR5YGBgYCBwYXJhbWV0ZXJzIHRvIGJlIGlnbm9yZWQsIGlmIHRoZXkgYXJlIGFsc28gZ2l2ZW4uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLm9jY2x1ZGFibGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUge0BsaW5rIEFubm90YXRpb259IG1hcmtlciBhbmQgbGFiZWwgYXJlIGhpZGRlbiB3aGVuZXZlciB0aGUgbWFya2VyIG9jY2x1ZGVkIGJ5IHtAbGluayBFbnRpdHl9cyBpbiB0aGUge0BsaW5rIFNjZW5lfS4gVGhlXG4gICAgICoge0BsaW5rIFNjZW5lfSBwZXJpb2RpY2FsbHkgb2NjbHVzaW9uLXRlc3RzIGFsbCBBbm5vdGF0aW9ucyBvbiBldmVyeSAyMHRoIFwidGlja1wiICh3aGljaCByZXByZXNlbnRzIGEgcmVuZGVyZWQgZnJhbWUpLiBXZSBjYW4gYWRqdXN0IHRoYXQgZnJlcXVlbmN5IHZpYSBwcm9wZXJ0eSB7QGxpbmsgU2NlbmUjdGlja3NQZXJPY2NsdXNpb25UZXN0fS5cbiAgICAgKiBAcGFyYW0gIHt7U3RyaW5nOihTdHJpbmd8TnVtYmVyKX19IFtwYXJhbXMudmFsdWVzPXt9XSBNYXAgb2YgdmFsdWVzIHRvIGluc2VydCBpbnRvIHRoZSBIVE1MIHRlbXBsYXRlcyBmb3IgdGhlIG1hcmtlciBhbmQgbGFiZWwuIFRoZXNlIHdpbGwgYmUgaW5zZXJ0ZWQgaW4gYWRkaXRpb24gdG8gYW55IHZhbHVlcyBnaXZlbiB0byB0aGUgQW5ub3RhdGlvbnNQbHVnaW4gY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLm1hcmtlclNob3duPXRydWVdIFdoZXRoZXIgdG8gaW5pdGlhbGx5IHNob3cgdGhlIHtAbGluayBBbm5vdGF0aW9ufSBtYXJrZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmxhYmVsU2hvd249ZmFsc2VdIFdoZXRoZXIgdG8gaW5pdGlhbGx5IHNob3cgdGhlIHtAbGluayBBbm5vdGF0aW9ufSBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbcGFyYW1zLmV5ZV0gT3B0aW9uYWwgV29ybGQtc3BhY2UgcG9zaXRpb24gZm9yIHtAbGluayBDYW1lcmEjZXllfSwgdXNlZCB3aGVuIHRoaXMgQW5ub3RhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgQ2FtZXJhfSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbcGFyYW1zLmxvb2tdIE9wdGlvbmFsIFdvcmxkLXNwYWNlIHBvc2l0aW9uIGZvciB7QGxpbmsgQ2FtZXJhI2xvb2t9LCB1c2VkIHdoZW4gdGhpcyBBbm5vdGF0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHtAbGluayBDYW1lcmF9IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtwYXJhbXMudXBdIE9wdGlvbmFsIFdvcmxkLXNwYWNlIHBvc2l0aW9uIGZvciB7QGxpbmsgQ2FtZXJhI3VwfSwgdXNlZCB3aGVuIHRoaXMgQW5ub3RhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgQ2FtZXJhfSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5wcm9qZWN0aW9uXSBPcHRpb25hbCBwcm9qZWN0aW9uIHR5cGUgZm9yIHtAbGluayBDYW1lcmEjcHJvamVjdGlvbn0sIHVzZWQgd2hlbiB0aGlzIEFubm90YXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoIGEge0BsaW5rIENhbWVyYX0gcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0Fubm90YXRpb259IFRoZSBuZXcge0BsaW5rIEFubm90YXRpb259LlxuICAgICAqL1xuICAgIGNyZWF0ZUFubm90YXRpb24ocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdlci5zY2VuZS5jb21wb25lbnRzW3BhcmFtcy5pZF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJWaWV3ZXIgY29tcG9uZW50IHdpdGggdGhpcyBJRCBhbHJlYWR5IGV4aXN0czogXCIgKyBwYXJhbXMuaWQpO1xuICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5pZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd29ybGRQb3M7XG4gICAgICAgIHZhciBlbnRpdHk7XG4gICAgICAgIHBhcmFtcy5waWNrUmVzdWx0ID0gcGFyYW1zLnBpY2tSZXN1bHQgfHwgcGFyYW1zLnBpY2tSZWNvcmQ7XG4gICAgICAgIGlmIChwYXJhbXMucGlja1Jlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgcGlja1Jlc3VsdCA9IHBhcmFtcy5waWNrUmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFwaWNrUmVzdWx0LndvcmxkUG9zIHx8ICFwaWNrUmVzdWx0LndvcmxkTm9ybWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlBhcmFtICdwaWNrUmVzdWx0JyBkb2VzIG5vdCBoYXZlIGJvdGggd29ybGRQb3MgYW5kIHdvcmxkTm9ybWFsXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkV29ybGROb3JtYWwgPSBtYXRoLm5vcm1hbGl6ZVZlYzMocGlja1Jlc3VsdC53b3JsZE5vcm1hbCwgdGVtcFZlYzNhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRWZWMgPSBtYXRoLm11bFZlYzNTY2FsYXIobm9ybWFsaXplZFdvcmxkTm9ybWFsLCB0aGlzLl9zdXJmYWNlT2Zmc2V0LCB0ZW1wVmVjM2IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFdvcmxkUG9zID0gbWF0aC5hZGRWZWMzKHBpY2tSZXN1bHQud29ybGRQb3MsIG9mZnNldFZlYywgdGVtcFZlYzNjKTtcbiAgICAgICAgICAgICAgICB3b3JsZFBvcyA9IG9mZnNldFdvcmxkUG9zO1xuICAgICAgICAgICAgICAgIGVudGl0eSA9IHBpY2tSZXN1bHQuZW50aXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ybGRQb3MgPSBwYXJhbXMud29ybGRQb3M7XG4gICAgICAgICAgICBlbnRpdHkgPSBwYXJhbXMuZW50aXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcmtlckVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAocGFyYW1zLm1hcmtlckVsZW1lbnRJZCkge1xuICAgICAgICAgICAgbWFya2VyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtcy5tYXJrZXJFbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFtYXJrZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNhbid0IGZpbmQgRE9NIGVsZW1lbnQgZm9yICdtYXJrZXJFbGVtZW50SWQnIHZhbHVlICdcIiArIHBhcmFtcy5tYXJrZXJFbGVtZW50SWQgKyBcIicgLSBkZWZhdWx0aW5nIHRvIGludGVybmFsbHktZ2VuZXJhdGVkIGVtcHR5IERJVlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYWJlbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAocGFyYW1zLmxhYmVsRWxlbWVudElkKSB7XG4gICAgICAgICAgICBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJhbXMubGFiZWxFbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFsYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ2FuJ3QgZmluZCBET00gZWxlbWVudCBmb3IgJ2xhYmVsRWxlbWVudElkJyB2YWx1ZSAnXCIgKyBwYXJhbXMubGFiZWxFbGVtZW50SWQgKyBcIicgLSBkZWZhdWx0aW5nIHRvIGludGVybmFsbHktZ2VuZXJhdGVkIGVtcHR5IERJVlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbih0aGlzLnZpZXdlci5zY2VuZSwge1xuICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZCxcbiAgICAgICAgICAgIHBsdWdpbjogdGhpcyxcbiAgICAgICAgICAgIGVudGl0eTogZW50aXR5LFxuICAgICAgICAgICAgd29ybGRQb3M6IHdvcmxkUG9zLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICAgICAgICBtYXJrZXJFbGVtZW50OiBtYXJrZXJFbGVtZW50LFxuICAgICAgICAgICAgbGFiZWxFbGVtZW50OiBsYWJlbEVsZW1lbnQsXG4gICAgICAgICAgICBtYXJrZXJIVE1MOiBwYXJhbXMubWFya2VySFRNTCB8fCB0aGlzLl9tYXJrZXJIVE1MLFxuICAgICAgICAgICAgbGFiZWxIVE1MOiBwYXJhbXMubGFiZWxIVE1MIHx8IHRoaXMuX2xhYmVsSFRNTCxcbiAgICAgICAgICAgIG9jY2x1ZGFibGU6IHBhcmFtcy5vY2NsdWRhYmxlLFxuICAgICAgICAgICAgdmFsdWVzOiB1dGlscy5hcHBseShwYXJhbXMudmFsdWVzLCB1dGlscy5hcHBseSh0aGlzLl92YWx1ZXMsIHt9KSksXG4gICAgICAgICAgICBtYXJrZXJTaG93bjogcGFyYW1zLm1hcmtlclNob3duLFxuICAgICAgICAgICAgbGFiZWxTaG93bjogcGFyYW1zLmxhYmVsU2hvd24sXG4gICAgICAgICAgICBleWU6IHBhcmFtcy5leWUsXG4gICAgICAgICAgICBsb29rOiBwYXJhbXMubG9vayxcbiAgICAgICAgICAgIHVwOiBwYXJhbXMudXAsXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiBwYXJhbXMucHJvamVjdGlvbixcbiAgICAgICAgICAgIHZpc2libGU6IChwYXJhbXMudmlzaWJsZSAhPT0gZmFsc2UpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zW2Fubm90YXRpb24uaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgYW5ub3RhdGlvbi5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uc1thbm5vdGF0aW9uLmlkXTtcbiAgICAgICAgICAgIHRoaXMuZmlyZShcImFubm90YXRpb25EZXN0cm95ZWRcIiwgYW5ub3RhdGlvbi5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpcmUoXCJhbm5vdGF0aW9uQ3JlYXRlZFwiLCBhbm5vdGF0aW9uLmlkKTtcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4ge0BsaW5rIEFubm90YXRpb259LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIElEIG9mIEFubm90YXRpb24gdG8gZGVzdHJveS5cbiAgICAgKi9cbiAgICBkZXN0cm95QW5ub3RhdGlvbihpZCkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMuYW5ub3RhdGlvbnNbaWRdO1xuICAgICAgICBpZiAoIWFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiQW5ub3RhdGlvbiBub3QgZm91bmQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFubm90YXRpb24uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFsbCB7QGxpbmsgQW5ub3RhdGlvbn1zLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLmFubm90YXRpb25zKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95QW5ub3RhdGlvbihpZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBBbm5vdGF0aW9uc1BsdWdpbi5cbiAgICAgKlxuICAgICAqIERlc3Ryb3lzIGFsbCB7QGxpbmsgQW5ub3RhdGlvbn1zIGZpcnN0LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtBbm5vdGF0aW9uc1BsdWdpbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/plugins/AnnotationsPlugin/AnnotationsPlugin.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js ***!
  \**************************************************************/
/*! exports provided: Plugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugin\", function() { return Plugin; });\n/**\n @desc Base class for {@link Viewer} plugin classes.\n */\nclass Plugin {\n\n    /**\n     * Creates this Plugin and installs it into the given {@link Viewer}.\n     *\n     * @param {string} id ID for this plugin, unique among all plugins in the viewer.\n     * @param {Viewer} viewer The viewer.\n     * @param {Object} [cfg] Options\n     */\n    constructor(id, viewer, cfg) {\n\n        /**\n         * ID for this Plugin, unique within its {@link Viewer}.\n         *\n         * @type {string}\n         */\n        this.id = (cfg && cfg.id) ? cfg.id : id;\n\n        /**\n         * The Viewer that contains this Plugin.\n         *\n         * @type {Viewer}\n         */\n        this.viewer = viewer;\n\n        /**\n         * Subscriptions to events fired at this Plugin.\n         * @private\n         */\n        this._eventSubs = {};\n\n        viewer.addPlugin(this);\n    }\n\n    /**\n     Subscribes to an event fired at this Plugin.\n\n     @param {String} event The event\n     @param {Function} callback Callback fired on the event\n     */\n    on(event, callback) {\n        let subs = this._eventSubs[event];\n        if (!subs) {\n            subs = [];\n            this._eventSubs[event] = subs;\n        }\n        subs.push(callback);\n    }\n\n    /**\n     Fires an event at this Plugin.\n\n     @param {String} event The event type name\n     @param {Object} value The event parameters\n     */\n    fire(event, value) {\n        const subs = this._eventSubs[event];\n        if (subs) {\n            for (let i = 0, len = subs.length; i < len; i++) {\n                subs[i](value);\n            }\n        }\n    }\n\n    /**\n     * Logs a message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    log(msg) {\n        console.log(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Logs a warning message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    warn(msg) {\n        console.warn(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Logs an error message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    error(msg) {\n        console.error(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Sends a message to this Plugin.\n     *\n     * @private\n     */\n    send(name, value) {\n        //...\n    }\n\n    /**\n     * Destroys this Plugin and removes it from its {@link Viewer}.\n     */\n    destroy() {\n        this.viewer.removePlugin(this);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL1BsdWdpbi5qcz85Yzk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsS0FBSyxJQUFJO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEsS0FBSyxJQUFJO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsS0FBSyxJQUFJO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL1BsdWdpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuIEBkZXNjIEJhc2UgY2xhc3MgZm9yIHtAbGluayBWaWV3ZXJ9IHBsdWdpbiBjbGFzc2VzLlxuICovXG5jbGFzcyBQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIFBsdWdpbiBhbmQgaW5zdGFsbHMgaXQgaW50byB0aGUgZ2l2ZW4ge0BsaW5rIFZpZXdlcn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgZm9yIHRoaXMgcGx1Z2luLCB1bmlxdWUgYW1vbmcgYWxsIHBsdWdpbnMgaW4gdGhlIHZpZXdlci5cbiAgICAgKiBAcGFyYW0ge1ZpZXdlcn0gdmlld2VyIFRoZSB2aWV3ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjZmddIE9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCwgdmlld2VyLCBjZmcpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSUQgZm9yIHRoaXMgUGx1Z2luLCB1bmlxdWUgd2l0aGluIGl0cyB7QGxpbmsgVmlld2VyfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSAoY2ZnICYmIGNmZy5pZCkgPyBjZmcuaWQgOiBpZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFZpZXdlciB0aGF0IGNvbnRhaW5zIHRoaXMgUGx1Z2luLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Vmlld2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmlwdGlvbnMgdG8gZXZlbnRzIGZpcmVkIGF0IHRoaXMgUGx1Z2luLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG5cbiAgICAgICAgdmlld2VyLmFkZFBsdWdpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgU3Vic2NyaWJlcyB0byBhbiBldmVudCBmaXJlZCBhdCB0aGlzIFBsdWdpbi5cblxuICAgICBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50XG4gICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZpcmVkIG9uIHRoZSBldmVudFxuICAgICAqL1xuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgc3VicyA9IHRoaXMuX2V2ZW50U3Vic1tldmVudF07XG4gICAgICAgIGlmICghc3Vicykge1xuICAgICAgICAgICAgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzW2V2ZW50XSA9IHN1YnM7XG4gICAgICAgIH1cbiAgICAgICAgc3Vicy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgRmlyZXMgYW4gZXZlbnQgYXQgdGhpcyBQbHVnaW4uXG5cbiAgICAgQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0eXBlIG5hbWVcbiAgICAgQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuX2V2ZW50U3Vic1tldmVudF07XG4gICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNbaV0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgdG8gdGhlIEphdmFTY3JpcHQgZGV2ZWxvcGVyIGNvbnNvbGUsIHByZWZpeGVkIHdpdGggdGhlIElEIG9mIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGxvZyhtc2cpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt4ZW9raXQgcGx1Z2luICR7dGhpcy5pZH1dOiAke21zZ31gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgd2FybmluZyBtZXNzYWdlIHRvIHRoZSBKYXZhU2NyaXB0IGRldmVsb3BlciBjb25zb2xlLCBwcmVmaXhlZCB3aXRoIHRoZSBJRCBvZiB0aGlzIFBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB3YXJuKG1zZykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFt4ZW9raXQgcGx1Z2luICR7dGhpcy5pZH1dOiAke21zZ31gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIEphdmFTY3JpcHQgZGV2ZWxvcGVyIGNvbnNvbGUsIHByZWZpeGVkIHdpdGggdGhlIElEIG9mIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGVycm9yKG1zZykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbeGVva2l0IHBsdWdpbiAke3RoaXMuaWR9XTogJHttc2d9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vLi4uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBQbHVnaW4gYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMge0BsaW5rIFZpZXdlcn0uXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy52aWV3ZXIucmVtb3ZlUGx1Z2luKHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtQbHVnaW59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js ***!
  \***********************************************************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n\n\n\n\n/**\n * @desc Base class for all xeokit components.\n *\n * ## Component IDs\n *\n * Every Component has an ID that's unique within the parent {@link Scene}. xeokit generates\n * the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a\n * scene comprised of {@link Scene}, {@link Material}, {@link ReadableGeometry} and\n * {@link Mesh} components, while letting xeokit generate its own ID for\n * the {@link ReadableGeometry}:\n *\n *````JavaScript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {Mesh} from \"../src/scene/mesh/Mesh.js\";\n * import {buildTorusGeometry} from \"../src/scene/geometry/builders/buildTorusGeometry.js\";\n * import {ReadableGeometry} from \"../src/scene/geometry/ReadableGeometry.js\";\n * import {PhongMaterial} from \"../src/scene/materials/PhongMaterial.js\";\n * import {Texture} from \"../src/scene/materials/Texture.js\";\n * import {Fresnel} from \"../src/scene/materials/Fresnel.js\";\n *\n * const viewer = new Viewer({\n *        canvasId: \"myCanvas\"\n *    });\n *\n * viewer.scene.camera.eye = [0, 0, 5];\n * viewer.scene.camera.look = [0, 0, 0];\n * viewer.scene.camera.up = [0, 1, 0];\n *\n * new Mesh(viewer.scene, {\n *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({\n *          center: [0, 0, 0],\n *          radius: 1.5,\n *          tube: 0.5,\n *          radialSegments: 32,\n *          tubeSegments: 24,\n *          arc: Math.PI * 2.0\n *      }),\n *      material: new PhongMaterial(viewer.scene, {\n *          id: \"myMaterial\",\n *          ambient: [0.9, 0.3, 0.9],\n *          shininess: 30,\n *          diffuseMap: new Texture(viewer.scene, {\n *              src: \"textures/diffuse/uvGrid2.jpg\"\n *          }),\n *          specularFresnel: new Fresnel(viewer.scene, {\n *              leftColor: [1.0, 1.0, 1.0],\n *              rightColor: [0.0, 0.0, 0.0],\n *              power: 4\n *          })\n *     })\n * });\n *````\n *\n * We can then find those components like this:\n *\n * ````javascript\n * // Find the Material\n * var material = viewer.scene.components[\"myMaterial\"];\n *\n * // Find all PhongMaterials in the Scene\n * var phongMaterials = viewer.scene.types[\"PhongMaterial\"];\n *\n * // Find our Material within the PhongMaterials\n * var materialAgain = phongMaterials[\"myMaterial\"];\n * ````\n *\n * ## Restriction on IDs\n *\n * Auto-generated IDs are of the form ````\"__0\"````, ````\"__1\"````, ````\"__2\"```` ... and so on.\n *\n * Scene maintains a map of these IDs, along with a counter that it increments each time it generates a new ID.\n *\n * If Scene has created the IDs listed above, and we then destroy the ````Component```` with ID ````\"__1\"````,\n * Scene will mark that ID as available, and will reuse it for the next default ID.\n *\n * Therefore, two restrictions your on IDs:\n *\n * * don't use IDs that begin with two underscores, and\n * * don't reuse auto-generated IDs of destroyed Components.\n *\n * ## Logging\n *\n * Components have methods to log ID-prefixed messages to the JavaScript console:\n *\n * ````javascript\n * material.log(\"Everything is fine, situation normal.\");\n * material.warn(\"Wait, whats that red light?\");\n * material.error(\"Aw, snap!\");\n * ````\n *\n * The logged messages will look like this in the console:\n *\n * ````text\n * [LOG]   myMaterial: Everything is fine, situation normal.\n * [WARN]  myMaterial: Wait, whats that red light..\n * [ERROR] myMaterial: Aw, snap!\n * ````\n *\n * ## Destruction\n *\n * Get notification of destruction of Components:\n *\n * ````javascript\n * material.once(\"destroyed\", function() {\n *     this.log(\"Component was destroyed: \" + this.id);\n * });\n * ````\n *\n * Or get notification of destruction of any Component within its {@link Scene}:\n *\n * ````javascript\n * scene.on(\"componentDestroyed\", function(component) {\n *     this.log(\"Component was destroyed: \" + component.id);\n * });\n * ````\n *\n * Then destroy a component like this:\n *\n * ````javascript\n * material.destroy();\n * ````\n */\nclass Component {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"Component\";\n    }\n\n    /**\n     * @private\n     */\n    get isComponent() {\n        return true;\n    }\n\n    constructor(owner = null, cfg = {}) {\n\n        /**\n         * The parent {@link Scene} that contains this Component.\n         *\n         * @property scene\n         * @type {Scene}\n         * @final\n         */\n        this.scene = null;\n\n        if (this.type === \"Scene\") {\n            this.scene = this;\n            /**\n             * The viewer that contains this Scene.\n             * @property viewer\n             * @type {Viewer}\n             */\n            this.viewer = cfg.viewer;\n        } else {\n            if (owner.type === \"Scene\") {\n                this.scene = owner;\n            } else if (owner instanceof Component) {\n                this.scene = owner.scene;\n            } else {\n                throw \"Invalid param: owner must be a Component\"\n            }\n            this._owner = owner;\n            this._renderer = this.scene._renderer;\n        }\n\n        this._dontClear = !!cfg.dontClear; // Prevent Scene#clear from destroying this component\n\n        this._renderer = this.scene._renderer;\n\n        /**\n         Arbitrary, user-defined metadata on this component.\n\n         @property metadata\n         @type Object\n         */\n        this.meta = cfg.meta || {};\n\n\n        /**\n         * ID of this Component, unique within the {@link Scene}.\n         *\n         * Components are mapped by this ID in {@link Scene#components}.\n         *\n         * @property id\n         * @type {String|Number}\n         */\n        this.id = cfg.id; // Auto-generated by Scene by default\n\n        /**\n         True as soon as this Component has been destroyed\n\n         @property destroyed\n         @type {Boolean}\n         */\n        this.destroyed = false;\n\n        this._attached = {}; // Attached components with names.\n        this._attachments = null; // Attached components keyed to IDs - lazy-instantiated\n        this._subIdMap = null; // Subscription subId pool\n        this._subIdEvents = null; // Subscription subIds mapped to event names\n        this._eventSubs = null; // Event names mapped to subscribers\n        this._eventSubsNum = null;\n        this._events = null; // Maps names to events\n        this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events\n        this._ownedComponents = null; // // Components created with #create - lazy-instantiated\n\n        if (this !== this.scene) { // Don't add scene to itself\n            this.scene._addComponent(this); // Assigns this component an automatic ID if not yet assigned\n        }\n\n        this._updateScheduled = false; // True when #_update will be called on next tick\n\n        if (owner) {\n            owner._own(this);\n        }\n    }\n\n    // /**\n    //  * Unique ID for this Component within its {@link Scene}.\n    //  *\n    //  * @property\n    //  * @type {String}\n    //  */\n    // get id() {\n    //     return this._id;\n    // }\n\n    /**\n     Indicates that we need to redraw the scene.\n\n     This is called by certain subclasses after they have made some sort of state update that requires the\n     renderer to perform a redraw.\n\n     For example: a {@link Mesh} calls this on itself whenever you update its\n     {@link Mesh#layer} property, which manually controls its render order in\n     relation to other Meshes.\n\n     If this component has a ````castsShadow```` property that's set ````true````, then this will also indicate\n     that the renderer needs to redraw shadow map associated with this component. Components like\n     {@link DirLight} have that property set when they produce light that creates shadows, while\n     components like {@link Mesh\"}}layer{{/crossLink}} have that property set when they cast shadows.\n\n     @protected\n     */\n    glRedraw() {\n        this._renderer.imageDirty();\n        if (this.castsShadow) { // Light source or object\n            this._renderer.shadowsDirty();\n        }\n    }\n\n    /**\n     Indicates that we need to re-sort the renderer's state-ordered drawables list.\n\n     For efficiency, the renderer keeps its list of drawables ordered so that runs of the same state updates can be\n     combined.  This method is called by certain subclasses after they have made some sort of state update that would\n     require re-ordering of the drawables list.\n\n     For example: a {@link DirLight} calls this on itself whenever you update {@link DirLight#dir}.\n\n     @protected\n     */\n    glResort() {\n        this._renderer.needStateSort();\n    }\n\n    /**\n     * The {@link Component} that owns the lifecycle of this Component, if any.\n     *\n     * When that component is destroyed, this component will be automatically destroyed also.\n     *\n     * Will be null if this Component has no owner.\n     *\n     * @property owner\n     * @type {Component}\n     */\n    get owner() {\n        return this._owner;\n    }\n\n    /**\n     * Tests if this component is of the given type, or is a subclass of the given type.\n     * @type {Boolean}\n     */\n    isType(type) {\n        return this.type === type;\n    }\n\n    /**\n     * Fires an event on this component.\n     *\n     * Notifies existing subscribers to the event, optionally retains the event to give to\n     * any subsequent notifications on the event as they are made.\n     *\n     * @param {String} event The event type name\n     * @param {Object} value The event parameters\n     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers\n     */\n    fire(event, value, forget) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n            this._eventSubsNum = {};\n        }\n        if (forget !== true) {\n            this._events[event] = value || true; // Save notification\n        }\n        const subs = this._eventSubs[event];\n        let sub;\n        if (subs) { // Notify subscriptions\n            for (const subId in subs) {\n                if (subs.hasOwnProperty(subId)) {\n                    sub = subs[subId];\n                    this._eventCallDepth++;\n                    if (this._eventCallDepth < 300) {\n                        sub.callback.call(sub.scope, value);\n                    } else {\n                        this.error(\"fire: potential stack overflow from recursive event '\" + event + \"' - dropping this event\");\n                    }\n                    this._eventCallDepth--;\n                }\n            }\n        }\n    }\n\n    /**\n     * Subscribes to an event on this component.\n     *\n     * The callback is be called with this component as scope.\n     *\n     * @param {String} event The event\n     * @param {Function} callback Called fired on the event\n     * @param {Object} [scope=this] Scope for the callback\n     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.\n     */\n    on(event, callback, scope) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._subIdMap) {\n            this._subIdMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__[\"Map\"](); // Subscription subId pool\n        }\n        if (!this._subIdEvents) {\n            this._subIdEvents = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n        }\n        if (!this._eventSubsNum) {\n            this._eventSubsNum = {};\n        }\n        let subs = this._eventSubs[event];\n        if (!subs) {\n            subs = {};\n            this._eventSubs[event] = subs;\n            this._eventSubsNum[event] = 1;\n        } else {\n            this._eventSubsNum[event]++;\n        }\n        const subId = this._subIdMap.addItem(); // Create unique subId\n        subs[subId] = {\n            callback: callback,\n            scope: scope || this\n        };\n        this._subIdEvents[subId] = event;\n        const value = this._events[event];\n        if (value !== undefined) { // A publication exists, notify callback immediately\n            callback.call(scope || this, value);\n        }\n        return subId;\n    }\n\n    /**\n     * Cancels an event subscription that was previously made with {@link Component#on} or {@link Component#once}.\n     *\n     * @param {String} subId Subscription ID\n     */\n    off(subId) {\n        if (subId === undefined || subId === null) {\n            return;\n        }\n        if (!this._subIdEvents) {\n            return;\n        }\n        const event = this._subIdEvents[subId];\n        if (event) {\n            delete this._subIdEvents[subId];\n            const subs = this._eventSubs[event];\n            if (subs) {\n                delete subs[subId];\n                this._eventSubsNum[event]--;\n            }\n            this._subIdMap.removeItem(subId); // Release subId\n        }\n    }\n\n    /**\n     * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.\n     *\n     * This is equivalent to calling {@link Component#on}, and then calling {@link Component#off} inside the callback function.\n     *\n     * @param {String} event Data event to listen to\n     * @param {Function} callback Called when fresh data is available at the event\n     * @param {Object} [scope=this] Scope for the callback\n     */\n    once(event, callback, scope) {\n        const self = this;\n        const subId = this.on(event,\n            function (value) {\n                self.off(subId);\n                callback.call(scope || this, value);\n            },\n            scope);\n    }\n\n    /**\n     * Returns true if there are any subscribers to the given event on this component.\n     *\n     * @param {String} event The event\n     * @return {Boolean} True if there are any subscribers to the given event on this component.\n     */\n    hasSubs(event) {\n        return (this._eventSubsNum && (this._eventSubsNum[event] > 0));\n    }\n\n    /**\n     * Logs a console debugging message for this component.\n     *\n     * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*\n     *\n     * Also fires the message as a \"log\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    log(message) {\n        message = \"[LOG]\" + this._message(message);\n        window.console.log(message);\n        this.scene.fire(\"log\", message);\n    }\n\n    _message(message) {\n        return \" [\" + this.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(this.id) + \"]: \" + message;\n    }\n\n    /**\n     * Logs a warning for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as a \"warn\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    warn(message) {\n        message = \"[WARN]\" + this._message(message);\n        window.console.warn(message);\n        this.scene.fire(\"warn\", message);\n    }\n\n    /**\n     * Logs an error for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as an \"error\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    error(message) {\n        message = \"[ERROR]\" + this._message(message);\n        window.console.error(message);\n        this.scene.fire(\"error\", message);\n    }\n\n    /**\n     * Adds a child component to this.\n     *\n     * When component not given, attaches the scene's default instance for the given name (if any).\n     * Publishes the new child component on this component, keyed to the given name.\n     *\n     * @param {*} params\n     * @param {String} params.name component name\n     * @param {Component} [params.component] The component\n     * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will\n     * cause an exception if the given child is not the same type or a subtype of this.\n     * @param {Boolean} [params.sceneDefault=false]\n     * @param {Boolean} [params.sceneSingleton=false]\n     * @param {Function} [params.onAttached] Optional callback called when component attached\n     * @param {Function} [params.onAttached.callback] Callback function\n     * @param {Function} [params.onAttached.scope] Optional scope for callback\n     * @param {Function} [params.onDetached] Optional callback called when component is detached\n     * @param {Function} [params.onDetached.callback] Callback function\n     * @param {Function} [params.onDetached.scope] Optional scope for callback\n     * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component\n     * @param {Boolean} [params.recompiles=true] When true, fires \"dirty\" events on this component\n     * @private\n     */\n    _attach(params) {\n\n        const name = params.name;\n\n        if (!name) {\n            this.error(\"Component 'name' expected\");\n            return;\n        }\n\n        let component = params.component;\n        const sceneDefault = params.sceneDefault;\n        const sceneSingleton = params.sceneSingleton;\n        const type = params.type;\n        const on = params.on;\n        const recompiles = params.recompiles !== false;\n\n        // True when child given as config object, where parent manages its instantiation and destruction\n        let managingLifecycle = false;\n\n        if (component) {\n\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isNumeric(component) || _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isString(component)) {\n\n                // Component ID given\n                // Both numeric and string IDs are supported\n\n                const id = component;\n\n                component = this.scene.components[id];\n\n                if (!component) {\n\n                    // Quote string IDs in errors\n\n                    this.error(\"Component not found: \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(id));\n                    return;\n                }\n            }\n        }\n\n        if (!component) {\n\n            if (sceneSingleton === true) {\n\n                // Using the first instance of the component type we find\n\n                const instances = this.scene.types[type];\n                for (const id2 in instances) {\n                    if (instances.hasOwnProperty) {\n                        component = instances[id2];\n                        break;\n                    }\n                }\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n\n            } else if (sceneDefault === true) {\n\n                // Using a default scene component\n\n                component = this.scene[name];\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n            }\n        }\n\n        if (component) {\n\n            if (component.scene.id !== this.scene.id) {\n                this.error(\"Not in same scene: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                return;\n            }\n\n            if (type) {\n\n                if (!component.isType(type)) {\n                    this.error(\"Expected a \" + type + \" type or subtype: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                    return;\n                }\n            }\n        }\n\n        if (!this._attachments) {\n            this._attachments = {};\n        }\n\n        const oldComponent = this._attached[name];\n        let subs;\n        let i;\n        let len;\n\n        if (oldComponent) {\n\n            if (component && oldComponent.id === component.id) {\n\n                // Reject attempt to reattach same component\n                return;\n            }\n\n            const oldAttachment = this._attachments[oldComponent.id];\n\n            // Unsubscribe from events on old component\n\n            subs = oldAttachment.subs;\n\n            for (i = 0, len = subs.length; i < len; i++) {\n                oldComponent.off(subs[i]);\n            }\n\n            delete this._attached[name];\n            delete this._attachments[oldComponent.id];\n\n            const onDetached = oldAttachment.params.onDetached;\n            if (onDetached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onDetached)) {\n                    onDetached(oldComponent);\n                } else {\n                    onDetached.scope ? onDetached.callback.call(onDetached.scope, oldComponent) : onDetached.callback(oldComponent);\n                }\n            }\n\n            if (oldAttachment.managingLifecycle) {\n\n                // Note that we just unsubscribed from all events fired by the child\n                // component, so destroying it won't fire events back at us now.\n\n                oldComponent.destroy();\n            }\n        }\n\n        if (component) {\n\n            // Set and publish the new component on this component\n\n            const attachment = {\n                params: params,\n                component: component,\n                subs: [],\n                managingLifecycle: managingLifecycle\n            };\n\n            attachment.subs.push(\n                component.once(\"destroyed\",\n                    function () {\n                        attachment.params.component = null;\n                        this._attach(attachment.params);\n                    },\n                    this));\n\n            if (recompiles) {\n                attachment.subs.push(\n                    component.on(\"dirty\",\n                        function () {\n                            this.fire(\"dirty\", this);\n                        },\n                        this));\n            }\n\n            this._attached[name] = component;\n            this._attachments[component.id] = attachment;\n\n            // Bind destruct listener to new component to remove it\n            // from this component when destroyed\n\n            const onAttached = params.onAttached;\n            if (onAttached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onAttached)) {\n                    onAttached(component);\n                } else {\n                    onAttached.scope ? onAttached.callback.call(onAttached.scope, component) : onAttached.callback(component);\n                }\n            }\n\n            if (on) {\n\n                let event;\n                let subIdr;\n                let callback;\n                let scope;\n\n                for (event in on) {\n                    if (on.hasOwnProperty(event)) {\n\n                        subIdr = on[event];\n\n                        if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(subIdr)) {\n                            callback = subIdr;\n                            scope = null;\n                        } else {\n                            callback = subIdr.callback;\n                            scope = subIdr.scope;\n                        }\n\n                        if (!callback) {\n                            continue;\n                        }\n\n                        attachment.subs.push(component.on(event, callback, scope));\n                    }\n                }\n            }\n        }\n\n        if (recompiles) {\n            this.fire(\"dirty\", this); // FIXME: May trigger spurous mesh recompilations unless able to limit with param?\n        }\n\n        this.fire(name, component); // Component can be null\n\n        return component;\n    }\n\n    _checkComponent(expectedType, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (expectedType !== component.type) {\n            this.error(\"Expected a \" + expectedType + \" Component\");\n            return;\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        return component;\n    }\n\n    _checkComponent2(expectedTypes, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        for (var i = 0, len = expectedTypes.length; i < len; i++) {\n            if (expectedTypes[i] === component.type) {\n                return component;\n            }\n        }\n        this.error(\"Expected component types: \" + expectedTypes);\n        return null;\n    }\n\n    _own(component) {\n        if (!this._ownedComponents) {\n            this._ownedComponents = {};\n        }\n        if (!this._ownedComponents[component.id]) {\n            this._ownedComponents[component.id] = component;\n        }\n        component.once(\"destroyed\", () => {\n            delete this._ownedComponents[component.id];\n        }, this);\n    }\n\n    /**\n     * Protected method, called by sub-classes to queue a call to _update().\n     * @protected\n     * @param {Number} [priority=1]\n     */\n    _needUpdate(priority) {\n        if (!this._updateScheduled) {\n            this._updateScheduled = true;\n            if (priority === 0) {\n                this._doUpdate();\n            } else {\n                _core_js__WEBPACK_IMPORTED_MODULE_0__[\"core\"].scheduleTask(this._doUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    _doUpdate() {\n        if (this._updateScheduled) {\n            this._updateScheduled = false;\n            if (this._update) {\n                this._update();\n            }\n        }\n    }\n\n    /**\n     * Protected virtual template method, optionally implemented\n     * by sub-classes to perform a scheduled task.\n     *\n     * @protected\n     */\n    _update() {\n    }\n\n    /**\n     * Destroys all {@link Component}s that are owned by this. These are Components that were instantiated with\n     * this Component as their first constructor argument.\n     */\n    clear() {\n        if (this._ownedComponents) {\n            for (var id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    const component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n    }\n\n    /**\n     * Destroys this component.\n     */\n    destroy() {\n\n        if (this.destroyed) {\n            return;\n        }\n\n        /**\n         * Fired when this Component is destroyed.\n         * @event destroyed\n         */\n        this.fire(\"destroyed\", this.destroyed = true); // Must fire before we blow away subscription maps, below\n\n        // Unsubscribe from child components and destroy then\n\n        let id;\n        let attachment;\n        let component;\n        let subs;\n        let i;\n        let len;\n\n        if (this._attachments) {\n            for (id in this._attachments) {\n                if (this._attachments.hasOwnProperty(id)) {\n                    attachment = this._attachments[id];\n                    component = attachment.component;\n                    subs = attachment.subs;\n                    for (i = 0, len = subs.length; i < len; i++) {\n                        component.off(subs[i]);\n                    }\n                    if (attachment.managingLifecycle) {\n                        component.destroy();\n                    }\n                }\n            }\n        }\n\n        if (this._ownedComponents) {\n            for (id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n\n        this.scene._removeComponent(this);\n\n        // Memory leak avoidance\n        this._attached = {};\n        this._attachments = null;\n        this._subIdMap = null;\n        this._subIdEvents = null;\n        this._eventSubs = null;\n        this._events = null;\n        this._eventCallDepth = 0;\n        this._ownedComponents = null;\n        this._updateScheduled = false;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL0NvbXBvbmVudC5qcz9hMDM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFDRTtBQUNFOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSx1QkFBdUIsWUFBWSxHQUFHLGVBQWUsR0FBRyx1QkFBdUI7QUFDL0UsSUFBSSxXQUFXO0FBQ2YsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixRQUFRO0FBQ1IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMscUNBQXFDOztBQUVyQyxrQ0FBa0M7QUFDbEMsMkNBQTJDO0FBQzNDOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQyxNQUFNLGlCQUFpQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLHNCQUFzQixhQUFhLE9BQU8sWUFBWTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixlQUFlLDJDQUEyQyxtQkFBbUI7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTyxvRUFBb0UsV0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQUcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsbUJBQW1CLEtBQUsscUJBQXFCO0FBQ2pIO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQ2pHO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QywrQ0FBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPLGdFQUFnRTtBQUN0RjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQiwrQ0FBSyx5QkFBeUIsK0NBQUs7O0FBRW5EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlELCtDQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEVBQTBFLCtDQUFLO0FBQy9FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvR0FBb0csK0NBQUs7QUFDekc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBSztBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFLO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QiwrQ0FBSztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLDZDQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvQ29tcG9uZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjb3JlfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7TWFwfSBmcm9tIFwiLi91dGlscy9NYXAuanNcIjtcblxuLyoqXG4gKiBAZGVzYyBCYXNlIGNsYXNzIGZvciBhbGwgeGVva2l0IGNvbXBvbmVudHMuXG4gKlxuICogIyMgQ29tcG9uZW50IElEc1xuICpcbiAqIEV2ZXJ5IENvbXBvbmVudCBoYXMgYW4gSUQgdGhhdCdzIHVuaXF1ZSB3aXRoaW4gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LiB4ZW9raXQgZ2VuZXJhdGVzXG4gKiB0aGUgSURzIGF1dG9tYXRpY2FsbHkgYnkgZGVmYXVsdCwgaG93ZXZlciB5b3UgY2FuIGFsc28gc3BlY2lmeSB0aGVtIHlvdXJzZWxmLiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgd2UncmUgY3JlYXRpbmcgYVxuICogc2NlbmUgY29tcHJpc2VkIG9mIHtAbGluayBTY2VuZX0sIHtAbGluayBNYXRlcmlhbH0sIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fSBhbmRcbiAqIHtAbGluayBNZXNofSBjb21wb25lbnRzLCB3aGlsZSBsZXR0aW5nIHhlb2tpdCBnZW5lcmF0ZSBpdHMgb3duIElEIGZvclxuICogdGhlIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fTpcbiAqXG4gKmBgYGBKYXZhU2NyaXB0XG4gKiBpbXBvcnQge1ZpZXdlcn0gZnJvbSBcIi4uL3NyYy92aWV3ZXIvVmlld2VyLmpzXCI7XG4gKiBpbXBvcnQge01lc2h9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWVzaC9NZXNoLmpzXCI7XG4gKiBpbXBvcnQge2J1aWxkVG9ydXNHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9idWlsZGVycy9idWlsZFRvcnVzR2VvbWV0cnkuanNcIjtcbiAqIGltcG9ydCB7UmVhZGFibGVHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9SZWFkYWJsZUdlb21ldHJ5LmpzXCI7XG4gKiBpbXBvcnQge1Bob25nTWF0ZXJpYWx9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWF0ZXJpYWxzL1Bob25nTWF0ZXJpYWwuanNcIjtcbiAqIGltcG9ydCB7VGV4dHVyZX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvVGV4dHVyZS5qc1wiO1xuICogaW1wb3J0IHtGcmVzbmVsfSBmcm9tIFwiLi4vc3JjL3NjZW5lL21hdGVyaWFscy9GcmVzbmVsLmpzXCI7XG4gKlxuICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXdlcih7XG4gKiAgICAgICAgY2FudmFzSWQ6IFwibXlDYW52YXNcIlxuICogICAgfSk7XG4gKlxuICogdmlld2VyLnNjZW5lLmNhbWVyYS5leWUgPSBbMCwgMCwgNV07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmxvb2sgPSBbMCwgMCwgMF07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLnVwID0gWzAsIDEsIDBdO1xuICpcbiAqIG5ldyBNZXNoKHZpZXdlci5zY2VuZSwge1xuICogICAgICBnZW9tZXRyeTogbmV3IFJlYWRhYmxlR2VvbWV0cnkodmlld2VyLnNjZW5lLCBidWlsZFRvcnVzR2VvbWV0cnkoe1xuICogICAgICAgICAgY2VudGVyOiBbMCwgMCwgMF0sXG4gKiAgICAgICAgICByYWRpdXM6IDEuNSxcbiAqICAgICAgICAgIHR1YmU6IDAuNSxcbiAqICAgICAgICAgIHJhZGlhbFNlZ21lbnRzOiAzMixcbiAqICAgICAgICAgIHR1YmVTZWdtZW50czogMjQsXG4gKiAgICAgICAgICBhcmM6IE1hdGguUEkgKiAyLjBcbiAqICAgICAgfSksXG4gKiAgICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgIGlkOiBcIm15TWF0ZXJpYWxcIixcbiAqICAgICAgICAgIGFtYmllbnQ6IFswLjksIDAuMywgMC45XSxcbiAqICAgICAgICAgIHNoaW5pbmVzczogMzAsXG4gKiAgICAgICAgICBkaWZmdXNlTWFwOiBuZXcgVGV4dHVyZSh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgICAgICBzcmM6IFwidGV4dHVyZXMvZGlmZnVzZS91dkdyaWQyLmpwZ1wiXG4gKiAgICAgICAgICB9KSxcbiAqICAgICAgICAgIHNwZWN1bGFyRnJlc25lbDogbmV3IEZyZXNuZWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgbGVmdENvbG9yOiBbMS4wLCAxLjAsIDEuMF0sXG4gKiAgICAgICAgICAgICAgcmlnaHRDb2xvcjogWzAuMCwgMC4wLCAwLjBdLFxuICogICAgICAgICAgICAgIHBvd2VyOiA0XG4gKiAgICAgICAgICB9KVxuICogICAgIH0pXG4gKiB9KTtcbiAqYGBgYFxuICpcbiAqIFdlIGNhbiB0aGVuIGZpbmQgdGhvc2UgY29tcG9uZW50cyBsaWtlIHRoaXM6XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIC8vIEZpbmQgdGhlIE1hdGVyaWFsXG4gKiB2YXIgbWF0ZXJpYWwgPSB2aWV3ZXIuc2NlbmUuY29tcG9uZW50c1tcIm15TWF0ZXJpYWxcIl07XG4gKlxuICogLy8gRmluZCBhbGwgUGhvbmdNYXRlcmlhbHMgaW4gdGhlIFNjZW5lXG4gKiB2YXIgcGhvbmdNYXRlcmlhbHMgPSB2aWV3ZXIuc2NlbmUudHlwZXNbXCJQaG9uZ01hdGVyaWFsXCJdO1xuICpcbiAqIC8vIEZpbmQgb3VyIE1hdGVyaWFsIHdpdGhpbiB0aGUgUGhvbmdNYXRlcmlhbHNcbiAqIHZhciBtYXRlcmlhbEFnYWluID0gcGhvbmdNYXRlcmlhbHNbXCJteU1hdGVyaWFsXCJdO1xuICogYGBgYFxuICpcbiAqICMjIFJlc3RyaWN0aW9uIG9uIElEc1xuICpcbiAqIEF1dG8tZ2VuZXJhdGVkIElEcyBhcmUgb2YgdGhlIGZvcm0gYGBgYFwiX18wXCJgYGBgLCBgYGBgXCJfXzFcImBgYGAsIGBgYGBcIl9fMlwiYGBgYCAuLi4gYW5kIHNvIG9uLlxuICpcbiAqIFNjZW5lIG1haW50YWlucyBhIG1hcCBvZiB0aGVzZSBJRHMsIGFsb25nIHdpdGggYSBjb3VudGVyIHRoYXQgaXQgaW5jcmVtZW50cyBlYWNoIHRpbWUgaXQgZ2VuZXJhdGVzIGEgbmV3IElELlxuICpcbiAqIElmIFNjZW5lIGhhcyBjcmVhdGVkIHRoZSBJRHMgbGlzdGVkIGFib3ZlLCBhbmQgd2UgdGhlbiBkZXN0cm95IHRoZSBgYGBgQ29tcG9uZW50YGBgYCB3aXRoIElEIGBgYGBcIl9fMVwiYGBgYCxcbiAqIFNjZW5lIHdpbGwgbWFyayB0aGF0IElEIGFzIGF2YWlsYWJsZSwgYW5kIHdpbGwgcmV1c2UgaXQgZm9yIHRoZSBuZXh0IGRlZmF1bHQgSUQuXG4gKlxuICogVGhlcmVmb3JlLCB0d28gcmVzdHJpY3Rpb25zIHlvdXIgb24gSURzOlxuICpcbiAqICogZG9uJ3QgdXNlIElEcyB0aGF0IGJlZ2luIHdpdGggdHdvIHVuZGVyc2NvcmVzLCBhbmRcbiAqICogZG9uJ3QgcmV1c2UgYXV0by1nZW5lcmF0ZWQgSURzIG9mIGRlc3Ryb3llZCBDb21wb25lbnRzLlxuICpcbiAqICMjIExvZ2dpbmdcbiAqXG4gKiBDb21wb25lbnRzIGhhdmUgbWV0aG9kcyB0byBsb2cgSUQtcHJlZml4ZWQgbWVzc2FnZXMgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZTpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogbWF0ZXJpYWwubG9nKFwiRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlwiKTtcbiAqIG1hdGVyaWFsLndhcm4oXCJXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodD9cIik7XG4gKiBtYXRlcmlhbC5lcnJvcihcIkF3LCBzbmFwIVwiKTtcbiAqIGBgYGBcbiAqXG4gKiBUaGUgbG9nZ2VkIG1lc3NhZ2VzIHdpbGwgbG9vayBsaWtlIHRoaXMgaW4gdGhlIGNvbnNvbGU6XG4gKlxuICogYGBgYHRleHRcbiAqIFtMT0ddICAgbXlNYXRlcmlhbDogRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlxuICogW1dBUk5dICBteU1hdGVyaWFsOiBXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodC4uXG4gKiBbRVJST1JdIG15TWF0ZXJpYWw6IEF3LCBzbmFwIVxuICogYGBgYFxuICpcbiAqICMjIERlc3RydWN0aW9uXG4gKlxuICogR2V0IG5vdGlmaWNhdGlvbiBvZiBkZXN0cnVjdGlvbiBvZiBDb21wb25lbnRzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5vbmNlKFwiZGVzdHJveWVkXCIsIGZ1bmN0aW9uKCkge1xuICogICAgIHRoaXMubG9nKFwiQ29tcG9uZW50IHdhcyBkZXN0cm95ZWQ6IFwiICsgdGhpcy5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBPciBnZXQgbm90aWZpY2F0aW9uIG9mIGRlc3RydWN0aW9uIG9mIGFueSBDb21wb25lbnQgd2l0aGluIGl0cyB7QGxpbmsgU2NlbmV9OlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBzY2VuZS5vbihcImNvbXBvbmVudERlc3Ryb3llZFwiLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAqICAgICB0aGlzLmxvZyhcIkNvbXBvbmVudCB3YXMgZGVzdHJveWVkOiBcIiArIGNvbXBvbmVudC5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBUaGVuIGRlc3Ryb3kgYSBjb21wb25lbnQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5kZXN0cm95KCk7XG4gKiBgYGBgXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ29tcG9uZW50XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgaXNDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKG93bmVyID0gbnVsbCwgY2ZnID0ge30pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9IHRoYXQgY29udGFpbnMgdGhpcyBDb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzY2VuZVxuICAgICAgICAgKiBAdHlwZSB7U2NlbmV9XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gdGhpcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZpZXdlciB0aGF0IGNvbnRhaW5zIHRoaXMgU2NlbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Vmlld2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlciA9IGNmZy52aWV3ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3duZXIudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG93bmVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lciBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBvd25lci5zY2VuZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmFtOiBvd25lciBtdXN0IGJlIGEgQ29tcG9uZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuc2NlbmUuX3JlbmRlcmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9udENsZWFyID0gISFjZmcuZG9udENsZWFyOyAvLyBQcmV2ZW50IFNjZW5lI2NsZWFyIGZyb20gZGVzdHJveWluZyB0aGlzIGNvbXBvbmVudFxuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5zY2VuZS5fcmVuZGVyZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBBcmJpdHJhcnksIHVzZXItZGVmaW5lZCBtZXRhZGF0YSBvbiB0aGlzIGNvbXBvbmVudC5cblxuICAgICAgICAgQHByb3BlcnR5IG1ldGFkYXRhXG4gICAgICAgICBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0YSA9IGNmZy5tZXRhIHx8IHt9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoaXMgQ29tcG9uZW50LCB1bmlxdWUgd2l0aGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb21wb25lbnRzIGFyZSBtYXBwZWQgYnkgdGhpcyBJRCBpbiB7QGxpbmsgU2NlbmUjY29tcG9uZW50c30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfE51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBjZmcuaWQ7IC8vIEF1dG8tZ2VuZXJhdGVkIGJ5IFNjZW5lIGJ5IGRlZmF1bHRcblxuICAgICAgICAvKipcbiAgICAgICAgIFRydWUgYXMgc29vbiBhcyB0aGlzIENvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWRcblxuICAgICAgICAgQHByb3BlcnR5IGRlc3Ryb3llZFxuICAgICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkID0ge307IC8vIEF0dGFjaGVkIGNvbXBvbmVudHMgd2l0aCBuYW1lcy5cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMgPSBudWxsOyAvLyBBdHRhY2hlZCBjb21wb25lbnRzIGtleWVkIHRvIElEcyAtIGxhenktaW5zdGFudGlhdGVkXG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDsgLy8gU3Vic2NyaXB0aW9uIHN1YklkIHBvb2xcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsOyAvLyBTdWJzY3JpcHRpb24gc3ViSWRzIG1hcHBlZCB0byBldmVudCBuYW1lc1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsOyAvLyBFdmVudCBuYW1lcyBtYXBwZWQgdG8gc3Vic2NyaWJlcnNcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDsgLy8gTWFwcyBuYW1lcyB0byBldmVudHNcbiAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGggPSAwOyAvLyBIZWxwcyB1cyBjYXRjaCBzdGFjayBvdmVyZmxvd3MgZnJvbSByZWN1cnNpdmUgZXZlbnRzXG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7IC8vIC8vIENvbXBvbmVudHMgY3JlYXRlZCB3aXRoICNjcmVhdGUgLSBsYXp5LWluc3RhbnRpYXRlZFxuXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnNjZW5lKSB7IC8vIERvbid0IGFkZCBzY2VuZSB0byBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX2FkZENvbXBvbmVudCh0aGlzKTsgLy8gQXNzaWducyB0aGlzIGNvbXBvbmVudCBhbiBhdXRvbWF0aWMgSUQgaWYgbm90IHlldCBhc3NpZ25lZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7IC8vIFRydWUgd2hlbiAjX3VwZGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiBuZXh0IHRpY2tcblxuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICAgIG93bmVyLl9vd24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgQ29tcG9uZW50IHdpdGhpbiBpdHMge0BsaW5rIFNjZW5lfS5cbiAgICAvLyAgKlxuICAgIC8vICAqIEBwcm9wZXJ0eVxuICAgIC8vICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgLy8gICovXG4gICAgLy8gZ2V0IGlkKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmVkcmF3IHRoZSBzY2VuZS5cblxuICAgICBUaGlzIGlzIGNhbGxlZCBieSBjZXJ0YWluIHN1YmNsYXNzZXMgYWZ0ZXIgdGhleSBoYXZlIG1hZGUgc29tZSBzb3J0IG9mIHN0YXRlIHVwZGF0ZSB0aGF0IHJlcXVpcmVzIHRoZVxuICAgICByZW5kZXJlciB0byBwZXJmb3JtIGEgcmVkcmF3LlxuXG4gICAgIEZvciBleGFtcGxlOiBhIHtAbGluayBNZXNofSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIGl0c1xuICAgICB7QGxpbmsgTWVzaCNsYXllcn0gcHJvcGVydHksIHdoaWNoIG1hbnVhbGx5IGNvbnRyb2xzIGl0cyByZW5kZXIgb3JkZXIgaW5cbiAgICAgcmVsYXRpb24gdG8gb3RoZXIgTWVzaGVzLlxuXG4gICAgIElmIHRoaXMgY29tcG9uZW50IGhhcyBhIGBgYGBjYXN0c1NoYWRvd2BgYGAgcHJvcGVydHkgdGhhdCdzIHNldCBgYGBgdHJ1ZWBgYGAsIHRoZW4gdGhpcyB3aWxsIGFsc28gaW5kaWNhdGVcbiAgICAgdGhhdCB0aGUgcmVuZGVyZXIgbmVlZHMgdG8gcmVkcmF3IHNoYWRvdyBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LiBDb21wb25lbnRzIGxpa2VcbiAgICAge0BsaW5rIERpckxpZ2h0fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBwcm9kdWNlIGxpZ2h0IHRoYXQgY3JlYXRlcyBzaGFkb3dzLCB3aGlsZVxuICAgICBjb21wb25lbnRzIGxpa2Uge0BsaW5rIE1lc2hcIn19bGF5ZXJ7ey9jcm9zc0xpbmt9fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBjYXN0IHNoYWRvd3MuXG5cbiAgICAgQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdsUmVkcmF3KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbWFnZURpcnR5KCk7XG4gICAgICAgIGlmICh0aGlzLmNhc3RzU2hhZG93KSB7IC8vIExpZ2h0IHNvdXJjZSBvciBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNoYWRvd3NEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmUtc29ydCB0aGUgcmVuZGVyZXIncyBzdGF0ZS1vcmRlcmVkIGRyYXdhYmxlcyBsaXN0LlxuXG4gICAgIEZvciBlZmZpY2llbmN5LCB0aGUgcmVuZGVyZXIga2VlcHMgaXRzIGxpc3Qgb2YgZHJhd2FibGVzIG9yZGVyZWQgc28gdGhhdCBydW5zIG9mIHRoZSBzYW1lIHN0YXRlIHVwZGF0ZXMgY2FuIGJlXG4gICAgIGNvbWJpbmVkLiAgVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGNlcnRhaW4gc3ViY2xhc3NlcyBhZnRlciB0aGV5IGhhdmUgbWFkZSBzb21lIHNvcnQgb2Ygc3RhdGUgdXBkYXRlIHRoYXQgd291bGRcbiAgICAgcmVxdWlyZSByZS1vcmRlcmluZyBvZiB0aGUgZHJhd2FibGVzIGxpc3QuXG5cbiAgICAgRm9yIGV4YW1wbGU6IGEge0BsaW5rIERpckxpZ2h0fSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIHtAbGluayBEaXJMaWdodCNkaXJ9LlxuXG4gICAgIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnbFJlc29ydCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIubmVlZFN0YXRlU29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQ29tcG9uZW50fSB0aGF0IG93bnMgdGhlIGxpZmVjeWNsZSBvZiB0aGlzIENvbXBvbmVudCwgaWYgYW55LlxuICAgICAqXG4gICAgICogV2hlbiB0aGF0IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQsIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgYWxzby5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgbnVsbCBpZiB0aGlzIENvbXBvbmVudCBoYXMgbm8gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3duZXJcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBvd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX293bmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgY29tcG9uZW50IGlzIG9mIHRoZSBnaXZlbiB0eXBlLCBvciBpcyBhIHN1YmNsYXNzIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBOb3RpZmllcyBleGlzdGluZyBzdWJzY3JpYmVycyB0byB0aGUgZXZlbnQsIG9wdGlvbmFsbHkgcmV0YWlucyB0aGUgZXZlbnQgdG8gZ2l2ZSB0b1xuICAgICAqIGFueSBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMgb24gdGhlIGV2ZW50IGFzIHRoZXkgYXJlIG1hZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmdldD1mYWxzZV0gV2hlbiB0cnVlLCBkb2VzIG5vdCByZXRhaW4gZm9yIHN1YnNlcXVlbnQgc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50LCB2YWx1ZSwgZm9yZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNOdW0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yZ2V0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdmFsdWUgfHwgdHJ1ZTsgLy8gU2F2ZSBub3RpZmljYXRpb25cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgbGV0IHN1YjtcbiAgICAgICAgaWYgKHN1YnMpIHsgLy8gTm90aWZ5IHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViSWQgaW4gc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzLmhhc093blByb3BlcnR5KHN1YklkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWJzW3N1YklkXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbERlcHRoIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2suY2FsbChzdWIuc2NvcGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJmaXJlOiBwb3RlbnRpYWwgc3RhY2sgb3ZlcmZsb3cgZnJvbSByZWN1cnNpdmUgZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgLSBkcm9wcGluZyB0aGlzIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Q2FsbERlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBhbiBldmVudCBvbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBiZSBjYWxsZWQgd2l0aCB0aGlzIGNvbXBvbmVudCBhcyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgZmlyZWQgb24gdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBIYW5kbGUgdG8gdGhlIHN1YnNjcmlwdGlvbiwgd2hpY2ggbWF5IGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgd2l0aCB7QGxpbmsgI29mZn0uXG4gICAgICovXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZE1hcCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRNYXAgPSBuZXcgTWFwKCk7IC8vIFN1YnNjcmlwdGlvbiBzdWJJZCBwb29sXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudFN1YnNOdW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFzdWJzKSB7XG4gICAgICAgICAgICBzdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNbZXZlbnRdID0gc3VicztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRNYXAuYWRkSXRlbSgpOyAvLyBDcmVhdGUgdW5pcXVlIHN1YklkXG4gICAgICAgIHN1YnNbc3ViSWRdID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlIHx8IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgLy8gQSBwdWJsaWNhdGlvbiBleGlzdHMsIG5vdGlmeSBjYWxsYmFjayBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSB8fCB0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uIHRoYXQgd2FzIHByZXZpb3VzbHkgbWFkZSB3aXRoIHtAbGluayBDb21wb25lbnQjb259IG9yIHtAbGluayBDb21wb25lbnQjb25jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViSWQgU3Vic2NyaXB0aW9uIElEXG4gICAgICovXG4gICAgb2ZmKHN1YklkKSB7XG4gICAgICAgIGlmIChzdWJJZCA9PT0gdW5kZWZpbmVkIHx8IHN1YklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdO1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZEV2ZW50c1tzdWJJZF07XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNbc3ViSWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YklkTWFwLnJlbW92ZUl0ZW0oc3ViSWQpOyAvLyBSZWxlYXNlIHN1YklkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGV2ZW50LCB0aGVuIHVuLXN1YnNjcmliZXMgYXMgc29vbiBhcyB0aGUgZXZlbnQgaXMgc3ViSWRkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvbn0sIGFuZCB0aGVuIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvZmZ9IGluc2lkZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRGF0YSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBmcmVzaCBkYXRhIGlzIGF2YWlsYWJsZSBhdCB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlPXRoaXNdIFNjb3BlIGZvciB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvbmNlKGV2ZW50LCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5vbihldmVudCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub2ZmKHN1YklkKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlIHx8IHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY29wZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgc3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIGV2ZW50IG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIGFueSBzdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgaGFzU3VicyhldmVudCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2V2ZW50U3Vic051bSAmJiAodGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSA+IDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY29uc29sZSBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbTE9HXSBbPGNvbXBvbmVudCB0eXBlPiA8Y29tcG9uZW50IGlkPjogPG1lc3NhZ2U+YGBgYCpcbiAgICAgKlxuICAgICAqIEFsc28gZmlyZXMgdGhlIG1lc3NhZ2UgYXMgYSBcImxvZ1wiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIltMT0ddXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcImxvZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBfbWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBcIiBbXCIgKyB0aGlzLnR5cGUgKyBcIiBcIiArIHV0aWxzLmluUXVvdGVzKHRoaXMuaWQpICsgXCJdOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIHdhcm5pbmcgZm9yIHRoaXMgY29tcG9uZW50IHRvIHRoZSBKYXZhU2NyaXB0IGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbV0FSTl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhIFwid2FyblwiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbV0FSTl1cIiArIHRoaXMuX21lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcIndhcm5cIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcnJvciBmb3IgdGhpcyBjb21wb25lbnQgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZS5cbiAgICAgKlxuICAgICAqIFRoZSBjb25zb2xlIG1lc3NhZ2Ugd2lsbCBoYXZlIHRoaXMgZm9ybWF0OiAqYGBgYFtFUlJPUl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhbiBcImVycm9yXCIgZXZlbnQgb24gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbRVJST1JdXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zY2VuZS5maXJlKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGlzLlxuICAgICAqXG4gICAgICogV2hlbiBjb21wb25lbnQgbm90IGdpdmVuLCBhdHRhY2hlcyB0aGUgc2NlbmUncyBkZWZhdWx0IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbmFtZSAoaWYgYW55KS5cbiAgICAgKiBQdWJsaXNoZXMgdGhlIG5ldyBjaGlsZCBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnQsIGtleWVkIHRvIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gW3BhcmFtcy5jb21wb25lbnRdIFRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy50eXBlXSBPcHRpb25hbCBleHBlY3RlZCB0eXBlIG9mIGJhc2UgdHlwZSBvZiB0aGUgY2hpbGQ7IHdoZW4gc3VwcGxpZWQsIHdpbGxcbiAgICAgKiBjYXVzZSBhbiBleGNlcHRpb24gaWYgdGhlIGdpdmVuIGNoaWxkIGlzIG5vdCB0aGUgc2FtZSB0eXBlIG9yIGEgc3VidHlwZSBvZiB0aGlzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5zY2VuZURlZmF1bHQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNjZW5lU2luZ2xldG9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZF0gT3B0aW9uYWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gY29tcG9uZW50IGF0dGFjaGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkF0dGFjaGVkLmNhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZC5zY29wZV0gT3B0aW9uYWwgc2NvcGUgZm9yIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkXSBPcHRpb25hbCBjYWxsYmFjayBjYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgZGV0YWNoZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1zLm9uRGV0YWNoZWQuY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkLnNjb3BlXSBPcHRpb25hbCBzY29wZSBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3tTdHJpbmc6RnVuY3Rpb259fSBbcGFyYW1zLm9uXSBDYWxsYmFja3MgdG8gc3Vic2NyaWJlIHRvIHByb3BlcnRpZXMgb24gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnJlY29tcGlsZXM9dHJ1ZV0gV2hlbiB0cnVlLCBmaXJlcyBcImRpcnR5XCIgZXZlbnRzIG9uIHRoaXMgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoKHBhcmFtcykge1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcblxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgJ25hbWUnIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHBhcmFtcy5jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IHNjZW5lRGVmYXVsdCA9IHBhcmFtcy5zY2VuZURlZmF1bHQ7XG4gICAgICAgIGNvbnN0IHNjZW5lU2luZ2xldG9uID0gcGFyYW1zLnNjZW5lU2luZ2xldG9uO1xuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGNvbnN0IG9uID0gcGFyYW1zLm9uO1xuICAgICAgICBjb25zdCByZWNvbXBpbGVzID0gcGFyYW1zLnJlY29tcGlsZXMgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vIFRydWUgd2hlbiBjaGlsZCBnaXZlbiBhcyBjb25maWcgb2JqZWN0LCB3aGVyZSBwYXJlbnQgbWFuYWdlcyBpdHMgaW5zdGFudGlhdGlvbiBhbmQgZGVzdHJ1Y3Rpb25cbiAgICAgICAgbGV0IG1hbmFnaW5nTGlmZWN5Y2xlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1lcmljKGNvbXBvbmVudCkgfHwgdXRpbHMuaXNTdHJpbmcoY29tcG9uZW50KSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50IElEIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gQm90aCBudW1lcmljIGFuZCBzdHJpbmcgSURzIGFyZSBzdXBwb3J0ZWRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5zY2VuZS5jb21wb25lbnRzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUXVvdGUgc3RyaW5nIElEcyBpbiBlcnJvcnNcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29tcG9uZW50IG5vdCBmb3VuZDogXCIgKyB1dGlscy5pblF1b3RlcyhpZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKHNjZW5lU2luZ2xldG9uID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCB0eXBlIHdlIGZpbmRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuc2NlbmUudHlwZXNbdHlwZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZDIgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGluc3RhbmNlc1tpZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiU2NlbmUgaGFzIG5vIGRlZmF1bHQgY29tcG9uZW50IGZvciAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmVEZWZhdWx0ID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBhIGRlZmF1bHQgc2NlbmUgY29tcG9uZW50XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlNjZW5lIGhhcyBubyBkZWZhdWx0IGNvbXBvbmVudCBmb3IgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIk5vdCBpbiBzYW1lIHNjZW5lOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5pc1R5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgXCIgKyB0eXBlICsgXCIgdHlwZSBvciBzdWJ0eXBlOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRDb21wb25lbnQgPSB0aGlzLl9hdHRhY2hlZFtuYW1lXTtcbiAgICAgICAgbGV0IHN1YnM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmIChvbGRDb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBvbGRDb21wb25lbnQuaWQgPT09IGNvbXBvbmVudC5pZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGF0dGVtcHQgdG8gcmVhdHRhY2ggc2FtZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dGFjaG1lbnQgPSB0aGlzLl9hdHRhY2htZW50c1tvbGRDb21wb25lbnQuaWRdO1xuXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIGV2ZW50cyBvbiBvbGQgY29tcG9uZW50XG5cbiAgICAgICAgICAgIHN1YnMgPSBvbGRBdHRhY2htZW50LnN1YnM7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN1YnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQub2ZmKHN1YnNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNoZWRbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNobWVudHNbb2xkQ29tcG9uZW50LmlkXTtcblxuICAgICAgICAgICAgY29uc3Qgb25EZXRhY2hlZCA9IG9sZEF0dGFjaG1lbnQucGFyYW1zLm9uRGV0YWNoZWQ7XG4gICAgICAgICAgICBpZiAob25EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9uRGV0YWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGV0YWNoZWQob2xkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbkRldGFjaGVkLnNjb3BlID8gb25EZXRhY2hlZC5jYWxsYmFjay5jYWxsKG9uRGV0YWNoZWQuc2NvcGUsIG9sZENvbXBvbmVudCkgOiBvbkRldGFjaGVkLmNhbGxiYWNrKG9sZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2xkQXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGp1c3QgdW5zdWJzY3JpYmVkIGZyb20gYWxsIGV2ZW50cyBmaXJlZCBieSB0aGUgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQsIHNvIGRlc3Ryb3lpbmcgaXQgd29uJ3QgZmlyZSBldmVudHMgYmFjayBhdCB1cyBub3cuXG5cbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICAvLyBTZXQgYW5kIHB1Ymxpc2ggdGhlIG5ldyBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnRcblxuICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdWJzOiBbXSxcbiAgICAgICAgICAgICAgICBtYW5hZ2luZ0xpZmVjeWNsZTogbWFuYWdpbmdMaWZlY3ljbGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbmNlKFwiZGVzdHJveWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucGFyYW1zLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2goYXR0YWNobWVudC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzKSk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvbXBpbGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5zdWJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbihcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFtuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzW2NvbXBvbmVudC5pZF0gPSBhdHRhY2htZW50O1xuXG4gICAgICAgICAgICAvLyBCaW5kIGRlc3RydWN0IGxpc3RlbmVyIHRvIG5ldyBjb21wb25lbnQgdG8gcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBmcm9tIHRoaXMgY29tcG9uZW50IHdoZW4gZGVzdHJveWVkXG5cbiAgICAgICAgICAgIGNvbnN0IG9uQXR0YWNoZWQgPSBwYXJhbXMub25BdHRhY2hlZDtcbiAgICAgICAgICAgIGlmIChvbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob25BdHRhY2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25BdHRhY2hlZChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQXR0YWNoZWQuc2NvcGUgPyBvbkF0dGFjaGVkLmNhbGxiYWNrLmNhbGwob25BdHRhY2hlZC5zY29wZSwgY29tcG9uZW50KSA6IG9uQXR0YWNoZWQuY2FsbGJhY2soY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCBzdWJJZHI7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGxldCBzY29wZTtcblxuICAgICAgICAgICAgICAgIGZvciAoZXZlbnQgaW4gb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJJZHIgPSBvbltldmVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHN1YklkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHN1YklkcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc3ViSWRyLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc3ViSWRyLnNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKGNvbXBvbmVudC5vbihldmVudCwgY2FsbGJhY2ssIHNjb3BlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb21waWxlcykge1xuICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7IC8vIEZJWE1FOiBNYXkgdHJpZ2dlciBzcHVyb3VzIG1lc2ggcmVjb21waWxhdGlvbnMgdW5sZXNzIGFibGUgdG8gbGltaXQgd2l0aCBwYXJhbT9cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZShuYW1lLCBjb21wb25lbnQpOyAvLyBDb21wb25lbnQgY2FuIGJlIG51bGxcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIF9jaGVja0NvbXBvbmVudChleHBlY3RlZFR5cGUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzSUQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuc2NlbmUuY29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbXBvbmVudCBub3QgZm91bmQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBDb21wb25lbnQgb3IgSURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGNvbXBvbmVudC50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBcIiArIGV4cGVjdGVkVHlwZSArIFwiIENvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgX2NoZWNrQ29tcG9uZW50MihleHBlY3RlZFR5cGVzLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0lEKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lLmNvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgbm90IGZvdW5kOiBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgQ29tcG9uZW50IG9yIElEXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlc1tpXSA9PT0gY29tcG9uZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBjb21wb25lbnQgdHlwZXM6IFwiICsgZXhwZWN0ZWRUeXBlcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9vd24oY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX293bmVkQ29tcG9uZW50c1tjb21wb25lbnQuaWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHNbY29tcG9uZW50LmlkXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnQub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2NvbXBvbmVudC5pZF07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3RlY3RlZCBtZXRob2QsIGNhbGxlZCBieSBzdWItY2xhc3NlcyB0byBxdWV1ZSBhIGNhbGwgdG8gX3VwZGF0ZSgpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5PTFdXG4gICAgICovXG4gICAgX25lZWRVcGRhdGUocHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1VwZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3JlLnNjaGVkdWxlVGFzayh0aGlzLl9kb1VwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kb1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm90ZWN0ZWQgdmlydHVhbCB0ZW1wbGF0ZSBtZXRob2QsIG9wdGlvbmFsbHkgaW1wbGVtZW50ZWRcbiAgICAgKiBieSBzdWItY2xhc3NlcyB0byBwZXJmb3JtIGEgc2NoZWR1bGVkIHRhc2suXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbGwge0BsaW5rIENvbXBvbmVudH1zIHRoYXQgYXJlIG93bmVkIGJ5IHRoaXMuIFRoZXNlIGFyZSBDb21wb25lbnRzIHRoYXQgd2VyZSBpbnN0YW50aWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgQ29tcG9uZW50IGFzIHRoZWlyIGZpcnN0IGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9vd25lZENvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBDb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBAZXZlbnQgZGVzdHJveWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoXCJkZXN0cm95ZWRcIiwgdGhpcy5kZXN0cm95ZWQgPSB0cnVlKTsgLy8gTXVzdCBmaXJlIGJlZm9yZSB3ZSBibG93IGF3YXkgc3Vic2NyaXB0aW9uIG1hcHMsIGJlbG93XG5cbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBjaGlsZCBjb21wb25lbnRzIGFuZCBkZXN0cm95IHRoZW5cblxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGxldCBhdHRhY2htZW50O1xuICAgICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgICBsZXQgc3VicztcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5fYXR0YWNobWVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBhdHRhY2htZW50LmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgc3VicyA9IGF0dGFjaG1lbnQuc3VicztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm9mZihzdWJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoaWQgaW4gdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVkQ29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX293bmVkQ29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS5fcmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xuXG4gICAgICAgIC8vIE1lbW9yeSBsZWFrIGF2b2lkYW5jZVxuICAgICAgICB0aGlzLl9hdHRhY2hlZCA9IHt9O1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudENhbGxEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHtDb21wb25lbnR9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/ENTITY_FLAGS.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/ENTITY_FLAGS.js ***!
  \***********************************************************************************************/
/*! exports provided: ENTITY_FLAGS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ENTITY_FLAGS\", function() { return ENTITY_FLAGS; });\n/**\n * @private\n * @type {{PICKABLE: number, CLIPPABLE: number, BACKFACES: number, VISIBLE: number, SELECTED: number, OUTLINED: number, CULLED: number, RECEIVE_SHADOW: number, COLLIDABLE: number, XRAYED: number, CAST_SHADOW: number, EDGES: number, HIGHLIGHTED: number}}\n */\nconst ENTITY_FLAGS = {\n    VISIBLE: 1,\n    CULLED: 1 << 2,\n    PICKABLE: 1 << 3,\n    CLIPPABLE: 1 << 4,\n    COLLIDABLE: 1 << 5,\n    CAST_SHADOW: 1 << 6,\n    RECEIVE_SHADOW: 1 << 7,\n    XRAYED: 1 << 8,\n    HIGHLIGHTED: 1 << 9,\n    SELECTED: 1 << 10,\n    EDGES: 1 << 11,\n    BACKFACES: 1 << 12,\n    TRANSPARENT: 1 << 13\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL1BlcmZvcm1hbmNlTW9kZWwvbGliL0VOVElUWV9GTEFHUy5qcz8yMzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL1BlcmZvcm1hbmNlTW9kZWwvbGliL0VOVElUWV9GTEFHUy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHt7UElDS0FCTEU6IG51bWJlciwgQ0xJUFBBQkxFOiBudW1iZXIsIEJBQ0tGQUNFUzogbnVtYmVyLCBWSVNJQkxFOiBudW1iZXIsIFNFTEVDVEVEOiBudW1iZXIsIE9VVExJTkVEOiBudW1iZXIsIENVTExFRDogbnVtYmVyLCBSRUNFSVZFX1NIQURPVzogbnVtYmVyLCBDT0xMSURBQkxFOiBudW1iZXIsIFhSQVlFRDogbnVtYmVyLCBDQVNUX1NIQURPVzogbnVtYmVyLCBFREdFUzogbnVtYmVyLCBISUdITElHSFRFRDogbnVtYmVyfX1cbiAqL1xuY29uc3QgRU5USVRZX0ZMQUdTID0ge1xuICAgIFZJU0lCTEU6IDEsXG4gICAgQ1VMTEVEOiAxIDw8IDIsXG4gICAgUElDS0FCTEU6IDEgPDwgMyxcbiAgICBDTElQUEFCTEU6IDEgPDwgNCxcbiAgICBDT0xMSURBQkxFOiAxIDw8IDUsXG4gICAgQ0FTVF9TSEFET1c6IDEgPDwgNixcbiAgICBSRUNFSVZFX1NIQURPVzogMSA8PCA3LFxuICAgIFhSQVlFRDogMSA8PCA4LFxuICAgIEhJR0hMSUdIVEVEOiAxIDw8IDksXG4gICAgU0VMRUNURUQ6IDEgPDwgMTAsXG4gICAgRURHRVM6IDEgPDwgMTEsXG4gICAgQkFDS0ZBQ0VTOiAxIDw8IDEyLFxuICAgIFRSQU5TUEFSRU5UOiAxIDw8IDEzXG59O1xuXG5leHBvcnQge0VOVElUWV9GTEFHU307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/ENTITY_FLAGS.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/PerformanceNode.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/PerformanceNode.js ***!
  \**************************************************************************************************/
/*! exports provided: PerformanceNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerformanceNode\", function() { return PerformanceNode; });\n/* harmony import */ var _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ENTITY_FLAGS.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/ENTITY_FLAGS.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n\n\n\nconst tempFloatRGB = new Float32Array([0, 0, 0]);\nconst tempIntRGB = new Uint16Array([0, 0, 0]);\n\n/**\n * @private\n */\nclass PerformanceNode {\n\n    /**\n     * @private\n     */\n    constructor(model, isObject, id, meshes, flags, aabb) {\n\n        this._isObject = isObject;\n\n        /**\n         * The {@link Scene} that contains this PerformanceNode.\n         *\n         * @property scene\n         * @type {Scene}\n         * @final\n         */\n        this.scene = model.scene;\n\n        /**\n         * The PerformanceModel that contains this PerformanceNode.\n         * @property model\n         * @type {PerformanceModel}\n         * @final\n         */\n        this.model = model;\n\n        /**\n         * The PerformanceModelMesh instances contained by this PerformanceNode\n         * @property meshes\n         * @type {{Array of PerformanceModelMesh}}\n         * @final\n         */\n        this.meshes = meshes;\n\n        this._numTriangles = 0;\n\n        for (var i = 0, len = this.meshes.length; i < len; i++) {  // TODO: tidier way? Refactor?\n            const mesh = this.meshes[i];\n            mesh.parent = this;\n            this._numTriangles += mesh.numTriangles;\n        }\n\n        /**\n         * ID of this PerformanceNode, unique within the {@link Scene}.\n         * @property id\n         * @type {String|Number}\n         * @final\n         */\n        this.id = id;\n\n        /**\n         * ID of the corresponding object within the originating system.\n         *\n         * @type {String}\n         * @abstract\n         */\n        this.originalSystemId = _math_math_js__WEBPACK_IMPORTED_MODULE_1__[\"math\"].unglobalizeObjectId(model.id, id);\n\n        this._flags = flags;\n        this._aabb = aabb;\n        this._offsetAABB = _math_math_js__WEBPACK_IMPORTED_MODULE_1__[\"math\"].AABB3(aabb);\n\n        this._offset = _math_math_js__WEBPACK_IMPORTED_MODULE_1__[\"math\"].vec3();\n\n        if (this._isObject) {\n            model.scene._registerObject(this);\n        }\n    }\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Entity members\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns true to indicate that PerformanceNode is an {@link Entity}.\n     * @type {Boolean}\n     */\n    get isEntity() {\n        return true;\n    }\n\n    /**\n     * Always returns ````false```` because a PerformanceNode can never represent a model.\n     *\n     * @type {Boolean}\n     */\n    get isModel() {\n        return false;\n    }\n\n    /**\n     * Returns ````true```` if this PerformanceNode represents an object.\n     *\n     * When ````true```` the PerformanceNode will be registered by {@link PerformanceNode#id} in\n     * {@link Scene#objects} and may also have a {@link MetaObject} with matching {@link MetaObject#id}.\n     *\n     * @type {Boolean}\n     */\n    get isObject() {\n        return this._isObject;\n    }\n\n    /**\n     * World-space 3D axis-aligned bounding box (AABB) of this PerformanceNode.\n     *\n     * Represented by a six-element Float64Array containing the min/max extents of the\n     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.\n     *\n     * @type {Float64Array}\n     */\n    get aabb() {\n        return this._offsetAABB;\n    }\n\n    /**\n     * The approximate number of triangles in this PerformanceNode.\n     *\n     * @type {Number}\n     */\n    get numTriangles() {\n        return this._numTriangles;\n    }\n\n    /**\n     * Sets if this PerformanceNode is visible.\n     *\n     * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#visible} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#visibleObjects}.\n     *\n     * @type {Boolean}\n     */\n    set visible(visible) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].VISIBLE) === visible) {\n            return; // Redundant update\n        }\n        if (visible) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].VISIBLE;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].VISIBLE;\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setVisible(this._flags);\n        }\n        if (this._isObject) {\n            this.model.scene._objectVisibilityUpdated(this);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode is visible.\n     *\n     * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#visible} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#visibleObjects}.\n     *\n     * @type {Boolean}\n     */\n    get visible() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].VISIBLE);\n    }\n\n    _getFlag(flag) {\n        return !!(this._flags & flag);\n    }\n\n    /**\n     * Sets if this PerformanceNode is highlighted.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#highlighted} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#highlightedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set highlighted(highlighted) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].HIGHLIGHTED) === highlighted) {\n            return; // Redundant update\n        }\n        if (highlighted) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].HIGHLIGHTED;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].HIGHLIGHTED;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setHighlighted(this._flags);\n        }\n        if (this._isObject) {\n            this.model.scene._objectHighlightedUpdated(this);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode is highlighted.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#highlighted} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#highlightedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get highlighted() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].HIGHLIGHTED);\n    }\n\n    /**\n     * Sets if this PerformanceNode is xrayed.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#xrayed} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#xrayedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set xrayed(xrayed) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].XRAYED) === xrayed) {\n            return; // Redundant update\n        }\n        if (xrayed) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].XRAYED;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].XRAYED;\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setXRayed(this._flags);\n        }\n        if (this._isObject) {\n            this.model.scene._objectXRayedUpdated(this);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode is xrayed.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#xrayed} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#xrayedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get xrayed() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].XRAYED);\n    }\n\n    /**\n     * Gets if this PerformanceNode is selected.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#selected} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#selectedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set selected(selected) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].SELECTED) === selected) {\n            return; // Redundant update\n        }\n        if (selected) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].SELECTED;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].SELECTED;\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setSelected(this._flags);\n        }\n        if (this._isObject) {\n            this.model.scene._objectSelectedUpdated(this);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Sets if this PerformanceNode is selected.\n     *\n     * When both {@link PerformanceNode#isObject} and {@link PerformanceNode#selected} are ````true```` the PerformanceNode will be\n     * registered by {@link PerformanceNode#id} in {@link Scene#selectedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get selected() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].SELECTED);\n    }\n\n    /**\n     * Sets if this PerformanceNode's edges are enhanced.\n     *\n     * @type {Boolean}\n     */\n    set edges(edges) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].EDGES) === edges) {\n            return; // Redundant update\n        }\n        if (edges) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].EDGES;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].EDGES;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setEdges(this._flags);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode's edges are enhanced.\n     *\n     * @type {Boolean}\n     */\n    get edges() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].EDGES);\n    }\n\n    /**\n     * Sets if this PerformanceNode is culled.\n     *\n     * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.\n     *\n     * @type {Boolean}\n     */\n    set culled(culled) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CULLED) === culled) {\n            return; // Redundant update\n        }\n        if (culled) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CULLED;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CULLED;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setCulled(this._flags);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode is culled.\n     *\n     * Only rendered when {@link PerformanceNode#visible} is ````true```` and {@link PerformanceNode#culled} is ````false````.\n     *\n     * @type {Boolean}\n     */\n    get culled() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CULLED);\n    }\n\n    /**\n     * Sets if this PerformanceNode is clippable.\n     *\n     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.\n     *\n     * @type {Boolean}\n     */\n    set clippable(clippable) {\n        if ((!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CLIPPABLE)) === clippable) {\n            return; // Redundant update\n        }\n        if (clippable) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CLIPPABLE;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CLIPPABLE;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setClippable(this._flags);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets if this PerformanceNode is clippable.\n     *\n     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.\n     *\n     * @type {Boolean}\n     */\n    get clippable() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].CLIPPABLE);\n    }\n\n    /**\n     * Sets if this PerformanceNode is included in boundary calculations.\n     *\n     * @type {Boolean}\n     */\n    set collidable(collidable) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].COLLIDABLE) === collidable) {\n            return; // Redundant update\n        }\n        if (collidable) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].COLLIDABLE;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].COLLIDABLE;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setCollidable(this._flags);\n        }\n    }\n\n    /**\n     * Gets if this PerformanceNode is included in boundary calculations.\n     *\n     * @type {Boolean}\n     */\n    get collidable() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].COLLIDABLE);\n    }\n\n    /**\n     * Sets if this PerformanceNode is pickable.\n     *\n     * Picking is done via calls to {@link Scene#pick}.\n     *\n     * @type {Boolean}\n     */\n    set pickable(pickable) {\n        if (!!(this._flags & _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].PICKABLE) === pickable) {\n            return; // Redundant update\n        }\n        if (pickable) {\n            this._flags = this._flags | _ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].PICKABLE;\n        } else {\n            this._flags = this._flags & ~_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].PICKABLE;\n        }\n        for (var i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setPickable(this._flags);\n        }\n    }\n\n    /**\n     * Gets if this PerformanceNode is pickable.\n     *\n     * Picking is done via calls to {@link Scene#pick}.\n     *\n     * @type {Boolean}\n     */\n    get pickable() {\n        return this._getFlag(_ENTITY_FLAGS_js__WEBPACK_IMPORTED_MODULE_0__[\"ENTITY_FLAGS\"].PICKABLE);\n    }\n\n    /**\n     * Sets the PerformanceNode's RGB colorize color.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     *\n     * @type {Number[]}\n     */\n    set colorize(color) { // [0..1, 0..1, 0..1]\n        if (color) {\n            tempIntRGB[0] = Math.floor(color[0] * 255.0); // Quantize\n            tempIntRGB[1] = Math.floor(color[1] * 255.0);\n            tempIntRGB[2] = Math.floor(color[2] * 255.0);\n            for (let i = 0, len = this.meshes.length; i < len; i++) {\n                this.meshes[i]._setColorize(tempIntRGB);\n            }\n        } else {\n            for (let i = 0, len = this.meshes.length; i < len; i++) {\n                this.meshes[i]._setColorize(null);\n            }\n        }\n        if (this._isObject) {\n            const colorized = (!!color);\n            this.scene._objectColorizeUpdated(this, colorized);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets the PerformanceNode's RGB colorize color.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     *\n     * @type {Number[]}\n     */\n    get colorize() { // [0..1, 0..1, 0..1]\n        if (this.meshes.length === 0) {\n            return null;\n        }\n        const colorize = this.meshes[0]._colorize;\n        tempFloatRGB[0] = colorize[0] / 255.0; // Unquantize\n        tempFloatRGB[1] = colorize[1] / 255.0;\n        tempFloatRGB[2] = colorize[2] / 255.0;\n        return tempFloatRGB;\n    }\n\n    /**\n     * Sets the PerformanceNode's opacity factor, multiplies by the PerformanceNode's rendered fragment alphas.\n     *\n     * This is a factor in range ````[0..1]````.\n     *\n     * @type {Number}\n     */\n    set opacity(opacity) {\n        if (this.meshes.length === 0) {\n            return;\n        }\n        const opacityUpdated = (opacity !== null && opacity !== undefined);\n        const lastOpacityQuantized = this.meshes[0]._colorize[3];\n        let opacityQuantized = 255;\n        if (opacityUpdated) {\n            if (opacity < 0) {\n                opacity = 0;\n            } else if (opacity > 1) {\n                opacity = 1;\n            }\n            opacityQuantized = Math.floor(opacity * 255.0); // Quantize\n            if (lastOpacityQuantized === opacityQuantized) {\n                return;\n            }\n        } else {\n            opacityQuantized = 255.0;\n            if (lastOpacityQuantized === opacityQuantized) {\n                return;\n            }\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setOpacity(opacityQuantized, this._flags);\n        }\n        if (this._isObject) {\n            this.scene._objectOpacityUpdated(this, opacityUpdated);\n        }\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets the PerformanceNode's opacity factor.\n     *\n     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.\n     *\n     * @type {Number}\n     */\n    get opacity() {\n        if (this.meshes.length > 0) {\n            return (this.meshes[0]._colorize[3] / 255.0);\n        } else {\n            return 1.0;\n        }\n    }\n\n    /**\n     * Sets the PerformanceNode's 3D World-space offset.\n     *\n     * The offset dynamically translates the PerformanceNode in World-space.\n     *\n     * Default value is ````[0, 0, 0]````.\n     *\n     * Provide a null or undefined value to reset to the default value.\n     *\n     * @type {Number[]}\n     */\n    set offset(offset) {\n        if (offset) {\n            this._offset[0] = offset[0];\n            this._offset[1] = offset[1];\n            this._offset[2] = offset[2];\n        } else {\n            this._offset[0] = 0;\n            this._offset[1] = 0;\n            this._offset[2] = 0;\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._setOffset(this._offset);\n        }\n        this._offsetAABB[0] = this._aabb[0] + this._offset[0];\n        this._offsetAABB[1] = this._aabb[1] + this._offset[1];\n        this._offsetAABB[2] = this._aabb[2] + this._offset[2];\n        this._offsetAABB[3] = this._aabb[3] + this._offset[0];\n        this._offsetAABB[4] = this._aabb[4] + this._offset[1];\n        this._offsetAABB[5] = this._aabb[5] + this._offset[2];\n        this.scene._aabbDirty = true;\n        this.scene._objectOffsetUpdated(this, offset);\n        this.model._aabbDirty = true;\n        this.model.glRedraw();\n    }\n\n    /**\n     * Gets the PerformanceNode's 3D World-space offset.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    get offset() {\n        return this._offset;\n    }\n\n    /**\n     * Sets if to this PerformanceNode casts shadows.\n     *\n     * @type {Boolean}\n     */\n    set castsShadow(pickable) { // TODO\n\n    }\n\n    /**\n     * Gets if this PerformanceNode casts shadows.\n     *\n     * @type {Boolean}\n     */\n    get castsShadow() { // TODO\n        return false;\n    }\n\n    /**\n     * Whether or not this PerformanceNode can have shadows cast upon it\n     *\n     * @type {Boolean}\n     */\n    set receivesShadow(pickable) { // TODO\n\n    }\n\n    /**\n     * Whether or not this PerformanceNode can have shadows cast upon it\n     *\n     * @type {Boolean}\n     */\n    get receivesShadow() { // TODO\n        return false;\n    }\n\n    /**\n     * Gets if Scalable Ambient Obscurance (SAO) will apply to this PerformanceNode.\n     *\n     * SAO is configured by the Scene's {@link SAO} component.\n     *\n     * @type {Boolean}\n     * @abstract\n     */\n    get saoEnabled() {\n        return this.model.saoEnabled;\n    }\n\n    _finalize() {\n        const scene = this.model.scene;\n        if (this._isObject) {\n            if (this.visible) {\n                scene._objectVisibilityUpdated(this);\n            }\n            if (this.highlighted) {\n                scene._objectHighlightedUpdated(this);\n            }\n            if (this.xrayed) {\n                scene._objectXRayedUpdated(this);\n            }\n            if (this.selected) {\n                scene._objectSelectedUpdated(this);\n            }\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._finalize(this._flags);\n        }\n    }\n\n    _destroy() { // Called by PerformanceModel\n        const scene = this.model.scene;\n        if (this._isObject) {\n            scene._deregisterObject(this);\n            if (this.visible) {\n                scene._objectVisibilityUpdated(this, false);\n            }\n            if (this.xrayed) {\n                scene._objectXRayedUpdated(this);\n            }\n            if (this.selected) {\n                scene._objectSelectedUpdated(this);\n            }\n            if (this.highlighted) {\n                scene._objectHighlightedUpdated(this);\n            }\n            this.scene._objectColorizeUpdated(this, false);\n            this.scene._objectOpacityUpdated(this, false);\n            this.scene._objectOffsetUpdated(this, false);\n        }\n        for (let i = 0, len = this.meshes.length; i < len; i++) {\n            this.meshes[i]._destroy();\n        }\n        scene._aabbDirty = true;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL1BlcmZvcm1hbmNlTW9kZWwvbGliL1BlcmZvcm1hbmNlTm9kZS5qcz8wNzNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStDO0FBQ1A7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELFNBQVMsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdDQUFnQyxrREFBSTs7QUFFcEM7QUFDQTtBQUNBLDJCQUEyQixrREFBSTs7QUFFL0IsdUJBQXVCLGtEQUFJOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsYUFBYTtBQUN6RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx5QkFBeUI7QUFDN0YsUUFBUSxvQkFBb0Isc0JBQXNCLGlCQUFpQixnQkFBZ0Isb0JBQW9CO0FBQ3ZHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QixzQkFBc0IsNkJBQTZCO0FBQzVHO0FBQ0Esa0JBQWtCLCtCQUErQixNQUFNLDhCQUE4QjtBQUNyRixzQkFBc0IseUJBQXlCLEtBQUssMkJBQTJCO0FBQy9FO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQVk7QUFDcEQsU0FBUztBQUNULHlDQUF5Qyw2REFBWTtBQUNyRDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEIsc0JBQXNCLDZCQUE2QjtBQUM1RztBQUNBLGtCQUFrQiwrQkFBK0IsTUFBTSw4QkFBOEI7QUFDckYsc0JBQXNCLHlCQUF5QixLQUFLLDJCQUEyQjtBQUMvRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCLE1BQU0sa0NBQWtDO0FBQ3pGLHNCQUFzQix5QkFBeUIsS0FBSywrQkFBK0I7QUFDbkY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDZCQUE2Qiw2REFBWTtBQUN6QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3Qyw2REFBWTtBQUNwRCxTQUFTO0FBQ1QseUNBQXlDLDZEQUFZO0FBQ3JEO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQixNQUFNLGtDQUFrQztBQUN6RixzQkFBc0IseUJBQXlCLEtBQUssK0JBQStCO0FBQ25GO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQixNQUFNLDZCQUE2QjtBQUNwRixzQkFBc0IseUJBQXlCLEtBQUssMEJBQTBCO0FBQzlFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQVk7QUFDcEQsU0FBUztBQUNULHlDQUF5Qyw2REFBWTtBQUNyRDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0IsTUFBTSw2QkFBNkI7QUFDcEYsc0JBQXNCLHlCQUF5QixLQUFLLDBCQUEwQjtBQUM5RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0IsTUFBTSwrQkFBK0I7QUFDdEYsc0JBQXNCLHlCQUF5QixLQUFLLDRCQUE0QjtBQUNoRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFZO0FBQ3BELFNBQVM7QUFDVCx5Q0FBeUMsNkRBQVk7QUFDckQ7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCLE1BQU0sK0JBQStCO0FBQ3RGLHNCQUFzQix5QkFBeUIsS0FBSyw0QkFBNEI7QUFDaEY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDZCQUE2Qiw2REFBWTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDZCQUE2Qiw2REFBWTtBQUN6QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3Qyw2REFBWTtBQUNwRCxTQUFTO0FBQ1QseUNBQXlDLDZEQUFZO0FBQ3JEO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QixzQkFBc0IsNkJBQTZCO0FBQzVHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQVk7QUFDcEQsU0FBUztBQUNULHlDQUF5Qyw2REFBWTtBQUNyRDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEIsc0JBQXNCLDZCQUE2QjtBQUM1RztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUIsTUFBTSwwQkFBMEI7QUFDbkY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDhCQUE4Qiw2REFBWTtBQUMxQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdDQUF3Qyw2REFBWTtBQUNwRCxTQUFTO0FBQ1QseUNBQXlDLDZEQUFZO0FBQ3JEO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixNQUFNLDBCQUEwQjtBQUNuRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFZO0FBQ3BELFNBQVM7QUFDVCx5Q0FBeUMsNkRBQVk7QUFDckQ7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDLDZEQUFZO0FBQ3BELFNBQVM7QUFDVCx5Q0FBeUMsNkRBQVk7QUFDckQ7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9QZXJmb3JtYW5jZU1vZGVsL2xpYi9QZXJmb3JtYW5jZU5vZGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VOVElUWV9GTEFHU30gZnJvbSAnLi9FTlRJVFlfRkxBR1MuanMnO1xuaW1wb3J0IHttYXRofSBmcm9tIFwiLi4vLi4vbWF0aC9tYXRoLmpzXCI7XG5cbmNvbnN0IHRlbXBGbG9hdFJHQiA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKTtcbmNvbnN0IHRlbXBJbnRSR0IgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDBdKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQZXJmb3JtYW5jZU5vZGUge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgaXNPYmplY3QsIGlkLCBtZXNoZXMsIGZsYWdzLCBhYWJiKSB7XG5cbiAgICAgICAgdGhpcy5faXNPYmplY3QgPSBpc09iamVjdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBTY2VuZX0gdGhhdCBjb250YWlucyB0aGlzIFBlcmZvcm1hbmNlTm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHNjZW5lXG4gICAgICAgICAqIEB0eXBlIHtTY2VuZX1cbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjZW5lID0gbW9kZWwuc2NlbmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBQZXJmb3JtYW5jZU1vZGVsIHRoYXQgY29udGFpbnMgdGhpcyBQZXJmb3JtYW5jZU5vZGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtb2RlbFxuICAgICAgICAgKiBAdHlwZSB7UGVyZm9ybWFuY2VNb2RlbH1cbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBQZXJmb3JtYW5jZU1vZGVsTWVzaCBpbnN0YW5jZXMgY29udGFpbmVkIGJ5IHRoaXMgUGVyZm9ybWFuY2VOb2RlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtZXNoZXNcbiAgICAgICAgICogQHR5cGUge3tBcnJheSBvZiBQZXJmb3JtYW5jZU1vZGVsTWVzaH19XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNoZXMgPSBtZXNoZXM7XG5cbiAgICAgICAgdGhpcy5fbnVtVHJpYW5nbGVzID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgIC8vIFRPRE86IHRpZGllciB3YXk/IFJlZmFjdG9yP1xuICAgICAgICAgICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaGVzW2ldO1xuICAgICAgICAgICAgbWVzaC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbnVtVHJpYW5nbGVzICs9IG1lc2gubnVtVHJpYW5nbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoaXMgUGVyZm9ybWFuY2VOb2RlLCB1bmlxdWUgd2l0aGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgICAgICogQHR5cGUge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJRCBvZiB0aGUgY29ycmVzcG9uZGluZyBvYmplY3Qgd2l0aGluIHRoZSBvcmlnaW5hdGluZyBzeXN0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW5hbFN5c3RlbUlkID0gbWF0aC51bmdsb2JhbGl6ZU9iamVjdElkKG1vZGVsLmlkLCBpZCk7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5fYWFiYiA9IGFhYmI7XG4gICAgICAgIHRoaXMuX29mZnNldEFBQkIgPSBtYXRoLkFBQkIzKGFhYmIpO1xuXG4gICAgICAgIHRoaXMuX29mZnNldCA9IG1hdGgudmVjMygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgbW9kZWwuc2NlbmUuX3JlZ2lzdGVyT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBFbnRpdHkgbWVtYmVyc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBQZXJmb3JtYW5jZU5vZGUgaXMgYW4ge0BsaW5rIEVudGl0eX0uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzRW50aXR5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbHdheXMgcmV0dXJucyBgYGBgZmFsc2VgYGBgIGJlY2F1c2UgYSBQZXJmb3JtYW5jZU5vZGUgY2FuIG5ldmVyIHJlcHJlc2VudCBhIG1vZGVsLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzTW9kZWwoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGBgYGB0cnVlYGBgYCBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSByZXByZXNlbnRzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFdoZW4gYGBgYHRydWVgYGBgIHRoZSBQZXJmb3JtYW5jZU5vZGUgd2lsbCBiZSByZWdpc3RlcmVkIGJ5IHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaWR9IGluXG4gICAgICoge0BsaW5rIFNjZW5lI29iamVjdHN9IGFuZCBtYXkgYWxzbyBoYXZlIGEge0BsaW5rIE1ldGFPYmplY3R9IHdpdGggbWF0Y2hpbmcge0BsaW5rIE1ldGFPYmplY3QjaWR9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV29ybGQtc3BhY2UgM0QgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgb2YgdGhpcyBQZXJmb3JtYW5jZU5vZGUuXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRlZCBieSBhIHNpeC1lbGVtZW50IEZsb2F0NjRBcnJheSBjb250YWluaW5nIHRoZSBtaW4vbWF4IGV4dGVudHMgb2YgdGhlXG4gICAgICogYXhpcy1hbGlnbmVkIHZvbHVtZSwgaWUuIGBgYGBbeG1pbiwgeW1pbix6bWluLHhtYXgseW1heCwgem1heF1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgYWFiYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldEFBQkI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiB0cmlhbmdsZXMgaW4gdGhpcyBQZXJmb3JtYW5jZU5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBudW1UcmlhbmdsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9udW1UcmlhbmdsZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjdmlzaWJsZX0gaXMgYGBgYHRydWVgYGBgIGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2N1bGxlZH0gaXMgYGBgYGZhbHNlYGBgYC5cbiAgICAgKlxuICAgICAqIFdoZW4gYm90aCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2lzT2JqZWN0fSBhbmQge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSN2aXNpYmxlfSBhcmUgYGBgYHRydWVgYGBgIHRoZSBQZXJmb3JtYW5jZU5vZGUgd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpZH0gaW4ge0BsaW5rIFNjZW5lI3Zpc2libGVPYmplY3RzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCB2aXNpYmxlKHZpc2libGUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuX2ZsYWdzICYgRU5USVRZX0ZMQUdTLlZJU0lCTEUpID09PSB2aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIFJlZHVuZGFudCB1cGRhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyB8IEVOVElUWV9GTEFHUy5WSVNJQkxFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5FTlRJVFlfRkxBR1MuVklTSUJMRTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5tZXNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWVzaGVzW2ldLl9zZXRWaXNpYmxlKHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2NlbmUuX29iamVjdFZpc2liaWxpdHlVcGRhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBPbmx5IHJlbmRlcmVkIHdoZW4ge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSN2aXNpYmxlfSBpcyBgYGBgdHJ1ZWBgYGAgYW5kIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjY3VsbGVkfSBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogV2hlbiBib3RoIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaXNPYmplY3R9IGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI3Zpc2libGV9IGFyZSBgYGBgdHJ1ZWBgYGAgdGhlIFBlcmZvcm1hbmNlTm9kZSB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2lkfSBpbiB7QGxpbmsgU2NlbmUjdmlzaWJsZU9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5WSVNJQkxFKTtcbiAgICB9XG5cbiAgICBfZ2V0RmxhZyhmbGFnKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9mbGFncyAmIGZsYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgaGlnaGxpZ2h0ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGJvdGgge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpc09iamVjdH0gYW5kIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaGlnaGxpZ2h0ZWR9IGFyZSBgYGBgdHJ1ZWBgYGAgdGhlIFBlcmZvcm1hbmNlTm9kZSB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2lkfSBpbiB7QGxpbmsgU2NlbmUjaGlnaGxpZ2h0ZWRPYmplY3RzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBoaWdobGlnaHRlZChoaWdobGlnaHRlZCkge1xuICAgICAgICBpZiAoISEodGhpcy5fZmxhZ3MgJiBFTlRJVFlfRkxBR1MuSElHSExJR0hURUQpID09PSBoaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzIHwgRU5USVRZX0ZMQUdTLkhJR0hMSUdIVEVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5FTlRJVFlfRkxBR1MuSElHSExJR0hURUQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0SGlnaGxpZ2h0ZWQodGhpcy5fZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zY2VuZS5fb2JqZWN0SGlnaGxpZ2h0ZWRVcGRhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGlzIGhpZ2hsaWdodGVkLlxuICAgICAqXG4gICAgICogV2hlbiBib3RoIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaXNPYmplY3R9IGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2hpZ2hsaWdodGVkfSBhcmUgYGBgYHRydWVgYGBgIHRoZSBQZXJmb3JtYW5jZU5vZGUgd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpZH0gaW4ge0BsaW5rIFNjZW5lI2hpZ2hsaWdodGVkT2JqZWN0c30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaGlnaGxpZ2h0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5ISUdITElHSFRFRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBpcyB4cmF5ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGJvdGgge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpc09iamVjdH0gYW5kIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjeHJheWVkfSBhcmUgYGBgYHRydWVgYGBgIHRoZSBQZXJmb3JtYW5jZU5vZGUgd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpZH0gaW4ge0BsaW5rIFNjZW5lI3hyYXllZE9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHhyYXllZCh4cmF5ZWQpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuX2ZsYWdzICYgRU5USVRZX0ZMQUdTLlhSQVlFRCkgPT09IHhyYXllZCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhyYXllZCkge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyB8IEVOVElUWV9GTEFHUy5YUkFZRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzICYgfkVOVElUWV9GTEFHUy5YUkFZRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0WFJheWVkKHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2NlbmUuX29iamVjdFhSYXllZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgeHJheWVkLlxuICAgICAqXG4gICAgICogV2hlbiBib3RoIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaXNPYmplY3R9IGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI3hyYXllZH0gYXJlIGBgYGB0cnVlYGBgYCB0aGUgUGVyZm9ybWFuY2VOb2RlIHdpbGwgYmVcbiAgICAgKiByZWdpc3RlcmVkIGJ5IHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaWR9IGluIHtAbGluayBTY2VuZSN4cmF5ZWRPYmplY3RzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCB4cmF5ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5YUkFZRUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGJvdGgge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpc09iamVjdH0gYW5kIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjc2VsZWN0ZWR9IGFyZSBgYGBgdHJ1ZWBgYGAgdGhlIFBlcmZvcm1hbmNlTm9kZSB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2lkfSBpbiB7QGxpbmsgU2NlbmUjc2VsZWN0ZWRPYmplY3RzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICBpZiAoISEodGhpcy5fZmxhZ3MgJiBFTlRJVFlfRkxBR1MuU0VMRUNURUQpID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzIHwgRU5USVRZX0ZMQUdTLlNFTEVDVEVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5FTlRJVFlfRkxBR1MuU0VMRUNURUQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0U2VsZWN0ZWQodGhpcy5fZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zY2VuZS5fb2JqZWN0U2VsZWN0ZWRVcGRhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogV2hlbiBib3RoIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjaXNPYmplY3R9IGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI3NlbGVjdGVkfSBhcmUgYGBgYHRydWVgYGBgIHRoZSBQZXJmb3JtYW5jZU5vZGUgd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIFBlcmZvcm1hbmNlTm9kZSNpZH0gaW4ge0BsaW5rIFNjZW5lI3NlbGVjdGVkT2JqZWN0c30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5TRUxFQ1RFRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSdzIGVkZ2VzIGFyZSBlbmhhbmNlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBlZGdlcyhlZGdlcykge1xuICAgICAgICBpZiAoISEodGhpcy5fZmxhZ3MgJiBFTlRJVFlfRkxBR1MuRURHRVMpID09PSBlZGdlcykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzIHwgRU5USVRZX0ZMQUdTLkVER0VTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5FTlRJVFlfRkxBR1MuRURHRVM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0RWRnZXModGhpcy5fZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlJ3MgZWRnZXMgYXJlIGVuaGFuY2VkLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVkZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmxhZyhFTlRJVFlfRkxBR1MuRURHRVMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgY3VsbGVkLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjdmlzaWJsZX0gaXMgYGBgYHRydWVgYGBgIGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2N1bGxlZH0gaXMgYGBgYGZhbHNlYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBjdWxsZWQoY3VsbGVkKSB7XG4gICAgICAgIGlmICghISh0aGlzLl9mbGFncyAmIEVOVElUWV9GTEFHUy5DVUxMRUQpID09PSBjdWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gUmVkdW5kYW50IHVwZGF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgfCBFTlRJVFlfRkxBR1MuQ1VMTEVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmIH5FTlRJVFlfRkxBR1MuQ1VMTEVEO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tZXNoZXNbaV0uX3NldEN1bGxlZCh0aGlzLl9mbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgY3VsbGVkLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBQZXJmb3JtYW5jZU5vZGUjdmlzaWJsZX0gaXMgYGBgYHRydWVgYGBgIGFuZCB7QGxpbmsgUGVyZm9ybWFuY2VOb2RlI2N1bGxlZH0gaXMgYGBgYGZhbHNlYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjdWxsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5DVUxMRUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhpcyBQZXJmb3JtYW5jZU5vZGUgaXMgY2xpcHBhYmxlLlxuICAgICAqXG4gICAgICogQ2xpcHBpbmcgaXMgZG9uZSBieSB0aGUge0BsaW5rIFNlY3Rpb25QbGFuZX1zIGluIHtAbGluayBTY2VuZSNzZWN0aW9uUGxhbmVzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBjbGlwcGFibGUoY2xpcHBhYmxlKSB7XG4gICAgICAgIGlmICgoISEodGhpcy5fZmxhZ3MgJiBFTlRJVFlfRkxBR1MuQ0xJUFBBQkxFKSkgPT09IGNsaXBwYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaXBwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyB8IEVOVElUWV9GTEFHUy5DTElQUEFCTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzICYgfkVOVElUWV9GTEFHUy5DTElQUEFCTEU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0Q2xpcHBhYmxlKHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBpcyBjbGlwcGFibGUuXG4gICAgICpcbiAgICAgKiBDbGlwcGluZyBpcyBkb25lIGJ5IHRoZSB7QGxpbmsgU2VjdGlvblBsYW5lfXMgaW4ge0BsaW5rIFNjZW5lI3NlY3Rpb25QbGFuZXN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNsaXBwYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEZsYWcoRU5USVRZX0ZMQUdTLkNMSVBQQUJMRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBpcyBpbmNsdWRlZCBpbiBib3VuZGFyeSBjYWxjdWxhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgY29sbGlkYWJsZShjb2xsaWRhYmxlKSB7XG4gICAgICAgIGlmICghISh0aGlzLl9mbGFncyAmIEVOVElUWV9GTEFHUy5DT0xMSURBQkxFKSA9PT0gY29sbGlkYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBSZWR1bmRhbnQgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgfCBFTlRJVFlfRkxBR1MuQ09MTElEQUJMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgJiB+RU5USVRZX0ZMQUdTLkNPTExJREFCTEU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0Q29sbGlkYWJsZSh0aGlzLl9mbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGlzIGluY2x1ZGVkIGluIGJvdW5kYXJ5IGNhbGN1bGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb2xsaWRhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmxhZyhFTlRJVFlfRkxBR1MuQ09MTElEQUJMRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBpcyBwaWNrYWJsZS5cbiAgICAgKlxuICAgICAqIFBpY2tpbmcgaXMgZG9uZSB2aWEgY2FsbHMgdG8ge0BsaW5rIFNjZW5lI3BpY2t9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHBpY2thYmxlKHBpY2thYmxlKSB7XG4gICAgICAgIGlmICghISh0aGlzLl9mbGFncyAmIEVOVElUWV9GTEFHUy5QSUNLQUJMRSkgPT09IHBpY2thYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIFJlZHVuZGFudCB1cGRhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlja2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgfCBFTlRJVFlfRkxBR1MuUElDS0FCTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzICYgfkVOVElUWV9GTEFHUy5QSUNLQUJMRTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5tZXNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWVzaGVzW2ldLl9zZXRQaWNrYWJsZSh0aGlzLl9mbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGlzIHBpY2thYmxlLlxuICAgICAqXG4gICAgICogUGlja2luZyBpcyBkb25lIHZpYSBjYWxscyB0byB7QGxpbmsgU2NlbmUjcGlja30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgcGlja2FibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGbGFnKEVOVElUWV9GTEFHUy5QSUNLQUJMRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUGVyZm9ybWFuY2VOb2RlJ3MgUkdCIGNvbG9yaXplIGNvbG9yLlxuICAgICAqXG4gICAgICogRWFjaCBlbGVtZW50IG9mIHRoZSBjb2xvciBpcyBpbiByYW5nZSBgYGBgWzAuLjFdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgY29sb3JpemUoY29sb3IpIHsgLy8gWzAuLjEsIDAuLjEsIDAuLjFdXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgdGVtcEludFJHQlswXSA9IE1hdGguZmxvb3IoY29sb3JbMF0gKiAyNTUuMCk7IC8vIFF1YW50aXplXG4gICAgICAgICAgICB0ZW1wSW50UkdCWzFdID0gTWF0aC5mbG9vcihjb2xvclsxXSAqIDI1NS4wKTtcbiAgICAgICAgICAgIHRlbXBJbnRSR0JbMl0gPSBNYXRoLmZsb29yKGNvbG9yWzJdICogMjU1LjApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoZXNbaV0uX3NldENvbG9yaXplKHRlbXBJbnRSR0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoZXNbaV0uX3NldENvbG9yaXplKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JpemVkID0gKCEhY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0Q29sb3JpemVVcGRhdGVkKHRoaXMsIGNvbG9yaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBlcmZvcm1hbmNlTm9kZSdzIFJHQiBjb2xvcml6ZSBjb2xvci5cbiAgICAgKlxuICAgICAqIEVhY2ggZWxlbWVudCBvZiB0aGUgY29sb3IgaXMgaW4gcmFuZ2UgYGBgYFswLi4xXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGNvbG9yaXplKCkgeyAvLyBbMC4uMSwgMC4uMSwgMC4uMV1cbiAgICAgICAgaWYgKHRoaXMubWVzaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3JpemUgPSB0aGlzLm1lc2hlc1swXS5fY29sb3JpemU7XG4gICAgICAgIHRlbXBGbG9hdFJHQlswXSA9IGNvbG9yaXplWzBdIC8gMjU1LjA7IC8vIFVucXVhbnRpemVcbiAgICAgICAgdGVtcEZsb2F0UkdCWzFdID0gY29sb3JpemVbMV0gLyAyNTUuMDtcbiAgICAgICAgdGVtcEZsb2F0UkdCWzJdID0gY29sb3JpemVbMl0gLyAyNTUuMDtcbiAgICAgICAgcmV0dXJuIHRlbXBGbG9hdFJHQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQZXJmb3JtYW5jZU5vZGUncyBvcGFjaXR5IGZhY3RvciwgbXVsdGlwbGllcyBieSB0aGUgUGVyZm9ybWFuY2VOb2RlJ3MgcmVuZGVyZWQgZnJhZ21lbnQgYWxwaGFzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvciBpbiByYW5nZSBgYGBgWzAuLjFdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc2V0IG9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgICBpZiAodGhpcy5tZXNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BhY2l0eVVwZGF0ZWQgPSAob3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBsYXN0T3BhY2l0eVF1YW50aXplZCA9IHRoaXMubWVzaGVzWzBdLl9jb2xvcml6ZVszXTtcbiAgICAgICAgbGV0IG9wYWNpdHlRdWFudGl6ZWQgPSAyNTU7XG4gICAgICAgIGlmIChvcGFjaXR5VXBkYXRlZCkge1xuICAgICAgICAgICAgaWYgKG9wYWNpdHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wYWNpdHkgPiAxKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGFjaXR5UXVhbnRpemVkID0gTWF0aC5mbG9vcihvcGFjaXR5ICogMjU1LjApOyAvLyBRdWFudGl6ZVxuICAgICAgICAgICAgaWYgKGxhc3RPcGFjaXR5UXVhbnRpemVkID09PSBvcGFjaXR5UXVhbnRpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3BhY2l0eVF1YW50aXplZCA9IDI1NS4wO1xuICAgICAgICAgICAgaWYgKGxhc3RPcGFjaXR5UXVhbnRpemVkID09PSBvcGFjaXR5UXVhbnRpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLm1lc2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tZXNoZXNbaV0uX3NldE9wYWNpdHkob3BhY2l0eVF1YW50aXplZCwgdGhpcy5fZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T3BhY2l0eVVwZGF0ZWQodGhpcywgb3BhY2l0eVVwZGF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQZXJmb3JtYW5jZU5vZGUncyBvcGFjaXR5IGZhY3Rvci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3IgaW4gcmFuZ2UgYGBgYFswLi4xXWBgYGAgd2hpY2ggbXVsdGlwbGllcyBieSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgYWxwaGFzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgb3BhY2l0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tZXNoZXNbMF0uX2NvbG9yaXplWzNdIC8gMjU1LjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFBlcmZvcm1hbmNlTm9kZSdzIDNEIFdvcmxkLXNwYWNlIG9mZnNldC5cbiAgICAgKlxuICAgICAqIFRoZSBvZmZzZXQgZHluYW1pY2FsbHkgdHJhbnNsYXRlcyB0aGUgUGVyZm9ybWFuY2VOb2RlIGluIFdvcmxkLXNwYWNlLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAsIDAsIDBdYGBgYC5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgYSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZSB0byByZXNldCB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgb2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRbMF0gPSBvZmZzZXRbMF07XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRbMV0gPSBvZmZzZXRbMV07XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRbMl0gPSBvZmZzZXRbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRbMF0gPSAwO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WzFdID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFsyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fc2V0T2Zmc2V0KHRoaXMuX29mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0QUFCQlswXSA9IHRoaXMuX2FhYmJbMF0gKyB0aGlzLl9vZmZzZXRbMF07XG4gICAgICAgIHRoaXMuX29mZnNldEFBQkJbMV0gPSB0aGlzLl9hYWJiWzFdICsgdGhpcy5fb2Zmc2V0WzFdO1xuICAgICAgICB0aGlzLl9vZmZzZXRBQUJCWzJdID0gdGhpcy5fYWFiYlsyXSArIHRoaXMuX29mZnNldFsyXTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0QUFCQlszXSA9IHRoaXMuX2FhYmJbM10gKyB0aGlzLl9vZmZzZXRbMF07XG4gICAgICAgIHRoaXMuX29mZnNldEFBQkJbNF0gPSB0aGlzLl9hYWJiWzRdICsgdGhpcy5fb2Zmc2V0WzFdO1xuICAgICAgICB0aGlzLl9vZmZzZXRBQUJCWzVdID0gdGhpcy5fYWFiYls1XSArIHRoaXMuX29mZnNldFsyXTtcbiAgICAgICAgdGhpcy5zY2VuZS5fYWFiYkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T2Zmc2V0VXBkYXRlZCh0aGlzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLm1vZGVsLl9hYWJiRGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm1vZGVsLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUGVyZm9ybWFuY2VOb2RlJ3MgM0QgV29ybGQtc3BhY2Ugb2Zmc2V0LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAsMCwwXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRvIHRoaXMgUGVyZm9ybWFuY2VOb2RlIGNhc3RzIHNoYWRvd3MuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgY2FzdHNTaGFkb3cocGlja2FibGUpIHsgLy8gVE9ET1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIFBlcmZvcm1hbmNlTm9kZSBjYXN0cyBzaGFkb3dzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhc3RzU2hhZG93KCkgeyAvLyBUT0RPXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFBlcmZvcm1hbmNlTm9kZSBjYW4gaGF2ZSBzaGFkb3dzIGNhc3QgdXBvbiBpdFxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHJlY2VpdmVzU2hhZG93KHBpY2thYmxlKSB7IC8vIFRPRE9cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgUGVyZm9ybWFuY2VOb2RlIGNhbiBoYXZlIHNoYWRvd3MgY2FzdCB1cG9uIGl0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgcmVjZWl2ZXNTaGFkb3coKSB7IC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgU2NhbGFibGUgQW1iaWVudCBPYnNjdXJhbmNlIChTQU8pIHdpbGwgYXBwbHkgdG8gdGhpcyBQZXJmb3JtYW5jZU5vZGUuXG4gICAgICpcbiAgICAgKiBTQU8gaXMgY29uZmlndXJlZCBieSB0aGUgU2NlbmUncyB7QGxpbmsgU0FPfSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBnZXQgc2FvRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2FvRW5hYmxlZDtcbiAgICB9XG5cbiAgICBfZmluYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5tb2RlbC5zY2VuZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuX29iamVjdFZpc2liaWxpdHlVcGRhdGVkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICBzY2VuZS5fb2JqZWN0SGlnaGxpZ2h0ZWRVcGRhdGVkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueHJheWVkKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuX29iamVjdFhSYXllZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLl9vYmplY3RTZWxlY3RlZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fZmluYWxpemUodGhpcy5fZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rlc3Ryb3koKSB7IC8vIENhbGxlZCBieSBQZXJmb3JtYW5jZU1vZGVsXG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5tb2RlbC5zY2VuZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KSB7XG4gICAgICAgICAgICBzY2VuZS5fZGVyZWdpc3Rlck9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBzY2VuZS5fb2JqZWN0VmlzaWJpbGl0eVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueHJheWVkKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuX29iamVjdFhSYXllZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLl9vYmplY3RTZWxlY3RlZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLl9vYmplY3RIaWdobGlnaHRlZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLl9vYmplY3RDb2xvcml6ZVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T3BhY2l0eVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T2Zmc2V0VXBkYXRlZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubWVzaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1lc2hlc1tpXS5fZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHNjZW5lLl9hYWJiRGlydHkgPSB0cnVlO1xuICAgIH1cblxufVxuXG5leHBvcnQge1BlcmZvcm1hbmNlTm9kZX07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/PerformanceNode.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js":
/*!******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js ***!
  \******************************************************************/
/*! exports provided: core */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony import */ var _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/Queue.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n\n\n\n\n\nconst scenesRenderInfo = {}; // Used for throttling FPS for each Scene\nconst sceneIDMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__[\"Map\"](); // Ensures unique scene IDs\nconst taskQueue = new _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__[\"Queue\"](); // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule\nconst tickEvent = {sceneId: null, time: null, startTime: null, prevTime: null, deltaTime: null};\nconst taskBudget = 10; // Millisecs we're allowed to spend on tasks in each frame\nconst fpsSamples = [];\nconst numFPSSamples = 30;\n\nlet defaultScene = null;// Default singleton Scene, lazy-initialized in getter\nlet lastTime = 0;\nlet elapsedTime;\nlet totalFPS = 0;\n\n/**\n * @private\n */\nfunction Core() {\n\n    /**\n     Semantic version number. The value for this is set by an expression that's concatenated to\n     the end of the built binary by the xeokit build script.\n     @property version\n     @namespace xeokit\n     @type {String}\n     */\n    this.version = \"1.0.0\";\n\n    /**\n     Existing {@link Scene}s , mapped to their IDs\n     @property scenes\n     @namespace xeokit\n     @type {{Scene}}\n     */\n    this.scenes = {};\n\n    this._superTypes = {}; // For each component type, a list of its supertypes, ordered upwards in the hierarchy.\n\n    /**\n     * Registers a scene on xeokit.\n     * This is called within the xeokit.Scene constructor.\n     * @private\n     */\n    this._addScene = function (scene) {\n        if (scene.id) { // User-supplied ID\n            if (core.scenes[scene.id]) {\n                console.error(`[ERROR] Scene ${_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"utils\"].inQuotes(scene.id)} already exists`);\n                return;\n            }\n        } else { // Auto-generated ID\n            scene.id = sceneIDMap.addItem({});\n        }\n        core.scenes[scene.id] = scene;\n        const ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n        const ticksPerRender = scene.ticksPerRender;\n        scenesRenderInfo[scene.id] = {\n            ticksPerOcclusionTest: ticksPerOcclusionTest,\n            ticksPerRender: ticksPerRender,\n            renderCountdown: ticksPerRender\n        };\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes++;\n        scene.once(\"destroyed\", () => { // Unregister destroyed scenes\n            sceneIDMap.removeItem(scene.id);\n            delete core.scenes[scene.id];\n            delete scenesRenderInfo[scene.id];\n            _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes--;\n        });\n    };\n\n    /**\n     * @private\n     */\n    this.clear = function () {\n        let scene;\n        for (const id in core.scenes) {\n            if (core.scenes.hasOwnProperty(id)) {\n                scene = core.scenes[id];\n                // Only clear the default Scene\n                // but destroy all the others\n                if (id === \"default.scene\") {\n                    scene.clear();\n                } else {\n                    scene.destroy();\n                    delete core.scenes[scene.id];\n                }\n            }\n        }\n    };\n\n    /**\n     * Schedule a task to run at the next frame.\n     *\n     * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeokit processes the queue\n     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not\n     * get a chance to run during the task are left in the queue to be run next time.\n     *\n     * @param {Function} callback Callback that runs the task.\n     * @param {Object} [scope] Scope for the callback.\n     */\n    this.scheduleTask = function (callback, scope) {\n        taskQueue.push(callback);\n        taskQueue.push(scope);\n    };\n\n    this.runTasks = function (until = -1) { // Pops and processes tasks in the queue, until the given number of milliseconds has elapsed.\n        let time = (new Date()).getTime();\n        let callback;\n        let scope;\n        let tasksRun = 0;\n        while (taskQueue.length > 0 && (until < 0 || time < until)) {\n            callback = taskQueue.shift();\n            scope = taskQueue.shift();\n            if (scope) {\n                callback.call(scope);\n            } else {\n                callback();\n            }\n            time = (new Date()).getTime();\n            tasksRun++;\n        }\n        return tasksRun;\n    };\n\n    this.getNumTasks = function () {\n        return taskQueue.length;\n    };\n}\n\n/**\n * @private\n * @type {Core}\n */\nconst core = new Core();\n\n\nconst frame = function () {\n    let time = Date.now();\n    if (lastTime > 0) { // Log FPS stats\n        elapsedTime = time - lastTime;\n        var newFPS = 1000 / elapsedTime; // Moving average of FPS\n        totalFPS += newFPS;\n        fpsSamples.push(newFPS);\n        if (fpsSamples.length >= numFPSSamples) {\n            totalFPS -= fpsSamples.shift();\n        }\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.fps = Math.round(totalFPS / fpsSamples.length);\n    }\n    runTasks(time);\n    fireTickEvents(time);\n    renderScenes();\n    lastTime = time;\n    window.requestAnimationFrame(frame);\n};\n\nfunction runTasks(time) { // Process as many enqueued tasks as we can within the per-frame task budget\n    const tasksRun = core.runTasks(time + taskBudget);\n    const tasksScheduled = core.getNumTasks();\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksRun = tasksRun;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksScheduled = tasksScheduled;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksBudget = taskBudget;\n}\n\nfunction fireTickEvents(time) { // Fire tick event on each Scene\n    tickEvent.time = time;\n    for (var id in core.scenes) {\n        if (core.scenes.hasOwnProperty(id)) {\n            var scene = core.scenes[id];\n            tickEvent.sceneId = id;\n            tickEvent.startTime = scene.startTime;\n            tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;\n            /**\n             * Fired on each game loop iteration.\n             *\n             * @event tick\n             * @param {String} sceneID The ID of this Scene.\n             * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.\n             * @param {Number} time The time in seconds since 1970 of this \"tick\" event.\n             * @param {Number} prevTime The time of the previous \"tick\" event from this Scene.\n             * @param {Number} deltaTime The time in seconds since the previous \"tick\" event from this Scene.\n             */\n            scene.fire(\"tick\", tickEvent, true);\n        }\n    }\n    tickEvent.prevTime = time;\n}\n\nfunction renderScenes() {\n    const scenes = core.scenes;\n    const forceRender = false;\n    let scene;\n    let renderInfo;\n    let ticksPerOcclusionTest;\n    let ticksPerRender;\n    let id;\n    for (id in scenes) {\n        if (scenes.hasOwnProperty(id)) {\n\n            scene = scenes[id];\n            renderInfo = scenesRenderInfo[id];\n\n            if (!renderInfo) {\n                renderInfo = scenesRenderInfo[id] = {}; // FIXME\n            }\n\n            ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n            if (renderInfo.ticksPerOcclusionTest !== ticksPerOcclusionTest) {\n                renderInfo.ticksPerOcclusionTest = ticksPerOcclusionTest;\n                renderInfo.renderCountdown = ticksPerOcclusionTest;\n            }\n            if (--scene.occlusionTestCountdown <= 0) {\n                scene.doOcclusionTest();\n                scene.occlusionTestCountdown = ticksPerOcclusionTest;\n            }\n\n            ticksPerRender = scene.ticksPerRender;\n            if (renderInfo.ticksPerRender !== ticksPerRender) {\n                renderInfo.ticksPerRender = ticksPerRender;\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n            if (--renderInfo.renderCountdown === 0) {\n                scene.render(forceRender);\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n        }\n    }\n}\n\nwindow.requestAnimationFrame(frame);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL2NvcmUuanM/MzFjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDSjtBQUNGO0FBQ0E7O0FBRWpDLDRCQUE0QjtBQUM1Qix1QkFBdUIsaURBQUcsR0FBRztBQUM3QixzQkFBc0IscURBQUssR0FBRyw4Q0FBOEM7QUFDNUUsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLCtDQUErQywrQ0FBSyxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFLO0FBQ2pCLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLCtDQUFLO0FBQ1QsSUFBSSwrQ0FBSztBQUNULElBQUksK0NBQUs7QUFDVDs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UXVldWV9IGZyb20gJy4vdXRpbHMvUXVldWUuanMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4vdXRpbHMvTWFwLmpzJztcbmltcG9ydCB7c3RhdHN9IGZyb20gJy4vc3RhdHMuanMnO1xuaW1wb3J0IHt1dGlsc30gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHNjZW5lc1JlbmRlckluZm8gPSB7fTsgLy8gVXNlZCBmb3IgdGhyb3R0bGluZyBGUFMgZm9yIGVhY2ggU2NlbmVcbmNvbnN0IHNjZW5lSURNYXAgPSBuZXcgTWFwKCk7IC8vIEVuc3VyZXMgdW5pcXVlIHNjZW5lIElEc1xuY29uc3QgdGFza1F1ZXVlID0gbmV3IFF1ZXVlKCk7IC8vIFRhc2sgcXVldWUsIHdoaWNoIGlzIHB1bXBlZCBvbiBlYWNoIGZyYW1lOyB0YXNrcyBhcmUgcHVzaGVkIHRvIGl0IHdpdGggY2FsbHMgdG8geGVva2l0LnNjaGVkdWxlXG5jb25zdCB0aWNrRXZlbnQgPSB7c2NlbmVJZDogbnVsbCwgdGltZTogbnVsbCwgc3RhcnRUaW1lOiBudWxsLCBwcmV2VGltZTogbnVsbCwgZGVsdGFUaW1lOiBudWxsfTtcbmNvbnN0IHRhc2tCdWRnZXQgPSAxMDsgLy8gTWlsbGlzZWNzIHdlJ3JlIGFsbG93ZWQgdG8gc3BlbmQgb24gdGFza3MgaW4gZWFjaCBmcmFtZVxuY29uc3QgZnBzU2FtcGxlcyA9IFtdO1xuY29uc3QgbnVtRlBTU2FtcGxlcyA9IDMwO1xuXG5sZXQgZGVmYXVsdFNjZW5lID0gbnVsbDsvLyBEZWZhdWx0IHNpbmdsZXRvbiBTY2VuZSwgbGF6eS1pbml0aWFsaXplZCBpbiBnZXR0ZXJcbmxldCBsYXN0VGltZSA9IDA7XG5sZXQgZWxhcHNlZFRpbWU7XG5sZXQgdG90YWxGUFMgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG5cbiAgICAvKipcbiAgICAgU2VtYW50aWMgdmVyc2lvbiBudW1iZXIuIFRoZSB2YWx1ZSBmb3IgdGhpcyBpcyBzZXQgYnkgYW4gZXhwcmVzc2lvbiB0aGF0J3MgY29uY2F0ZW5hdGVkIHRvXG4gICAgIHRoZSBlbmQgb2YgdGhlIGJ1aWx0IGJpbmFyeSBieSB0aGUgeGVva2l0IGJ1aWxkIHNjcmlwdC5cbiAgICAgQHByb3BlcnR5IHZlcnNpb25cbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSBcIjEuMC4wXCI7XG5cbiAgICAvKipcbiAgICAgRXhpc3Rpbmcge0BsaW5rIFNjZW5lfXMgLCBtYXBwZWQgdG8gdGhlaXIgSURzXG4gICAgIEBwcm9wZXJ0eSBzY2VuZXNcbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge3tTY2VuZX19XG4gICAgICovXG4gICAgdGhpcy5zY2VuZXMgPSB7fTtcblxuICAgIHRoaXMuX3N1cGVyVHlwZXMgPSB7fTsgLy8gRm9yIGVhY2ggY29tcG9uZW50IHR5cGUsIGEgbGlzdCBvZiBpdHMgc3VwZXJ0eXBlcywgb3JkZXJlZCB1cHdhcmRzIGluIHRoZSBoaWVyYXJjaHkuXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzY2VuZSBvbiB4ZW9raXQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2l0aGluIHRoZSB4ZW9raXQuU2NlbmUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hZGRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgICBpZiAoc2NlbmUuaWQpIHsgLy8gVXNlci1zdXBwbGllZCBJRFxuICAgICAgICAgICAgaWYgKGNvcmUuc2NlbmVzW3NjZW5lLmlkXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFUlJPUl0gU2NlbmUgJHt1dGlscy5pblF1b3RlcyhzY2VuZS5pZCl9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBdXRvLWdlbmVyYXRlZCBJRFxuICAgICAgICAgICAgc2NlbmUuaWQgPSBzY2VuZUlETWFwLmFkZEl0ZW0oe30pO1xuICAgICAgICB9XG4gICAgICAgIGNvcmUuc2NlbmVzW3NjZW5lLmlkXSA9IHNjZW5lO1xuICAgICAgICBjb25zdCB0aWNrc1Blck9jY2x1c2lvblRlc3QgPSBzY2VuZS50aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgIGNvbnN0IHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdID0ge1xuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0OiB0aWNrc1Blck9jY2x1c2lvblRlc3QsXG4gICAgICAgICAgICB0aWNrc1BlclJlbmRlcjogdGlja3NQZXJSZW5kZXIsXG4gICAgICAgICAgICByZW5kZXJDb3VudGRvd246IHRpY2tzUGVyUmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRzLmNvbXBvbmVudHMuc2NlbmVzKys7XG4gICAgICAgIHNjZW5lLm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4geyAvLyBVbnJlZ2lzdGVyIGRlc3Ryb3llZCBzY2VuZXNcbiAgICAgICAgICAgIHNjZW5lSURNYXAucmVtb3ZlSXRlbShzY2VuZS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgY29yZS5zY2VuZXNbc2NlbmUuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdO1xuICAgICAgICAgICAgc3RhdHMuY29tcG9uZW50cy5zY2VuZXMtLTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIGNvcmUuc2NlbmVzKSB7XG4gICAgICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICAgICAgLy8gT25seSBjbGVhciB0aGUgZGVmYXVsdCBTY2VuZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBkZXN0cm95IGFsbCB0aGUgb3RoZXJzXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBcImRlZmF1bHQuc2NlbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBzY2VuZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvcmUuc2NlbmVzW3NjZW5lLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSB0YXNrIHRvIHJ1biBhdCB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoaXMgcHVzaGVzIHRoZSB0YXNrIHRvIGEgRklGTyBxdWV1ZS4gV2l0aGluIGVhY2ggZnJhbWUgaW50ZXJ2YWwsIHhlb2tpdCBwcm9jZXNzZXMgdGhlIHF1ZXVlXG4gICAgICogZm9yIGEgY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgcG9wcGluZyB0YXNrcyBhbmQgcnVubmluZyB0aGVtLiBBZnRlciBlYWNoIGZyYW1lIGludGVydmFsLCB0YXNrcyB0aGF0IGRpZCBub3RcbiAgICAgKiBnZXQgYSBjaGFuY2UgdG8gcnVuIGR1cmluZyB0aGUgdGFzayBhcmUgbGVmdCBpbiB0aGUgcXVldWUgdG8gYmUgcnVuIG5leHQgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgcnVucyB0aGUgdGFzay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHRoaXMuc2NoZWR1bGVUYXNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0YXNrUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRhc2tRdWV1ZS5wdXNoKHNjb3BlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5ydW5UYXNrcyA9IGZ1bmN0aW9uICh1bnRpbCA9IC0xKSB7IC8vIFBvcHMgYW5kIHByb2Nlc3NlcyB0YXNrcyBpbiB0aGUgcXVldWUsIHVudGlsIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkLlxuICAgICAgICBsZXQgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgbGV0IHNjb3BlO1xuICAgICAgICBsZXQgdGFza3NSdW4gPSAwO1xuICAgICAgICB3aGlsZSAodGFza1F1ZXVlLmxlbmd0aCA+IDAgJiYgKHVudGlsIDwgMCB8fCB0aW1lIDwgdW50aWwpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2tRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgc2NvcGUgPSB0YXNrUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0YXNrc1J1bisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrc1J1bjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXROdW1UYXNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhc2tRdWV1ZS5sZW5ndGg7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0NvcmV9XG4gKi9cbmNvbnN0IGNvcmUgPSBuZXcgQ29yZSgpO1xuXG5cbmNvbnN0IGZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobGFzdFRpbWUgPiAwKSB7IC8vIExvZyBGUFMgc3RhdHNcbiAgICAgICAgZWxhcHNlZFRpbWUgPSB0aW1lIC0gbGFzdFRpbWU7XG4gICAgICAgIHZhciBuZXdGUFMgPSAxMDAwIC8gZWxhcHNlZFRpbWU7IC8vIE1vdmluZyBhdmVyYWdlIG9mIEZQU1xuICAgICAgICB0b3RhbEZQUyArPSBuZXdGUFM7XG4gICAgICAgIGZwc1NhbXBsZXMucHVzaChuZXdGUFMpO1xuICAgICAgICBpZiAoZnBzU2FtcGxlcy5sZW5ndGggPj0gbnVtRlBTU2FtcGxlcykge1xuICAgICAgICAgICAgdG90YWxGUFMgLT0gZnBzU2FtcGxlcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmZyYW1lLmZwcyA9IE1hdGgucm91bmQodG90YWxGUFMgLyBmcHNTYW1wbGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJ1blRhc2tzKHRpbWUpO1xuICAgIGZpcmVUaWNrRXZlbnRzKHRpbWUpO1xuICAgIHJlbmRlclNjZW5lcygpO1xuICAgIGxhc3RUaW1lID0gdGltZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blRhc2tzKHRpbWUpIHsgLy8gUHJvY2VzcyBhcyBtYW55IGVucXVldWVkIHRhc2tzIGFzIHdlIGNhbiB3aXRoaW4gdGhlIHBlci1mcmFtZSB0YXNrIGJ1ZGdldFxuICAgIGNvbnN0IHRhc2tzUnVuID0gY29yZS5ydW5UYXNrcyh0aW1lICsgdGFza0J1ZGdldCk7XG4gICAgY29uc3QgdGFza3NTY2hlZHVsZWQgPSBjb3JlLmdldE51bVRhc2tzKCk7XG4gICAgc3RhdHMuZnJhbWUudGFza3NSdW4gPSB0YXNrc1J1bjtcbiAgICBzdGF0cy5mcmFtZS50YXNrc1NjaGVkdWxlZCA9IHRhc2tzU2NoZWR1bGVkO1xuICAgIHN0YXRzLmZyYW1lLnRhc2tzQnVkZ2V0ID0gdGFza0J1ZGdldDtcbn1cblxuZnVuY3Rpb24gZmlyZVRpY2tFdmVudHModGltZSkgeyAvLyBGaXJlIHRpY2sgZXZlbnQgb24gZWFjaCBTY2VuZVxuICAgIHRpY2tFdmVudC50aW1lID0gdGltZTtcbiAgICBmb3IgKHZhciBpZCBpbiBjb3JlLnNjZW5lcykge1xuICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB2YXIgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICB0aWNrRXZlbnQuc2NlbmVJZCA9IGlkO1xuICAgICAgICAgICAgdGlja0V2ZW50LnN0YXJ0VGltZSA9IHNjZW5lLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRpY2tFdmVudC5kZWx0YVRpbWUgPSB0aWNrRXZlbnQucHJldlRpbWUgIT0gbnVsbCA/IHRpY2tFdmVudC50aW1lIC0gdGlja0V2ZW50LnByZXZUaW1lIDogMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlyZWQgb24gZWFjaCBnYW1lIGxvb3AgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB0aWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2NlbmVJRCBUaGUgSUQgb2YgdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIHRoYXQgdGhpcyBTY2VuZSB3YXMgaW5zdGFudGlhdGVkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIG9mIHRoaXMgXCJ0aWNrXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJldlRpbWUgVGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIFwidGlja1wiIGV2ZW50IGZyb20gdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgcHJldmlvdXMgXCJ0aWNrXCIgZXZlbnQgZnJvbSB0aGlzIFNjZW5lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzY2VuZS5maXJlKFwidGlja1wiLCB0aWNrRXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2tFdmVudC5wcmV2VGltZSA9IHRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNjZW5lcygpIHtcbiAgICBjb25zdCBzY2VuZXMgPSBjb3JlLnNjZW5lcztcbiAgICBjb25zdCBmb3JjZVJlbmRlciA9IGZhbHNlO1xuICAgIGxldCBzY2VuZTtcbiAgICBsZXQgcmVuZGVySW5mbztcbiAgICBsZXQgdGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgIGxldCB0aWNrc1BlclJlbmRlcjtcbiAgICBsZXQgaWQ7XG4gICAgZm9yIChpZCBpbiBzY2VuZXMpIHtcbiAgICAgICAgaWYgKHNjZW5lcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblxuICAgICAgICAgICAgc2NlbmUgPSBzY2VuZXNbaWRdO1xuICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNjZW5lc1JlbmRlckluZm9baWRdO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvID0gc2NlbmVzUmVuZGVySW5mb1tpZF0gPSB7fTsgLy8gRklYTUVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0ID0gc2NlbmUudGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgICAgICAgICAgaWYgKHJlbmRlckluZm8udGlja3NQZXJPY2NsdXNpb25UZXN0ICE9PSB0aWNrc1Blck9jY2x1c2lvblRlc3QpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyT2NjbHVzaW9uVGVzdCA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPD0gMCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLmRvT2NjbHVzaW9uVGVzdCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPSB0aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICBpZiAocmVuZGVySW5mby50aWNrc1BlclJlbmRlciAhPT0gdGlja3NQZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyUmVuZGVyID0gdGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICAgICAgcmVuZGVySW5mby5yZW5kZXJDb3VudGRvd24gPSB0aWNrc1BlclJlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXJlbmRlckluZm8ucmVuZGVyQ291bnRkb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUucmVuZGVyKGZvcmNlUmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyUmVuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcblxuZXhwb3J0IHtjb3JlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/marker/Marker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/marker/Marker.js ***!
  \***************************************************************************/
/*! exports provided: Marker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Marker\", function() { return Marker; });\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\");\n/* harmony import */ var _PerformanceModel_lib_PerformanceNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PerformanceModel/lib/PerformanceNode.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/PerformanceModel/lib/PerformanceNode.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n\n\n\n\n\nconst tempVec4a = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\nconst tempVec4b = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\n\n\n/**\n * @desc Tracks the World, View and Canvas coordinates, and visibility, of a position within a {@link Scene}.\n *\n * ## Position\n *\n * A Marker holds its position in the World, View and Canvas coordinate systems in three properties:\n *\n * * {@link Marker#worldPos} holds the Marker's 3D World-space coordinates. This property can be dynamically updated. The Marker will fire a \"worldPos\" event whenever this property changes.\n * * {@link Marker#viewPos} holds the Marker's 3D View-space coordinates. This property is read-only, and is automatically updated from {@link Marker#worldPos} and the current {@link Camera} position. The Marker will fire a \"viewPos\" event whenever this property changes.\n * * {@link Marker#canvasPos} holds the Marker's 2D Canvas-space coordinates. This property is read-only, and is automatically updated from {@link Marker#canvasPos} and the current {@link Camera} position and projection. The Marker will fire a \"canvasPos\" event whenever this property changes.\n *\n * ## Visibility\n *\n * {@link Marker#visible} indicates if the Marker is currently visible. The Marker will fire a \"visible\" event whenever {@link Marker#visible} changes.\n *\n * This property will be ````false```` when:\n *\n * * {@link Marker#entity} is set to an {@link Entity}, and {@link Entity#visible} is ````false````,\n * * {@link Marker#occludable} is ````true```` and the Marker is occluded by some {@link Entity} in the 3D view, or\n * * {@link Marker#canvasPos} is outside the boundary of the {@link Canvas}.\n *\n * ## Usage\n *\n * In the example below, we'll create a Marker that's associated with a {@link Mesh} (which a type of {@link Entity}).\n *\n * We'll configure our Marker to\n * become invisible whenever it's occluded by any Entities in the canvas.\n *\n * We'll also demonstrate how to query the Marker's visibility status and position (in the World, View and\n * Canvas coordinate systems), and how to subscribe to change events on those properties.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#Markers_SimpleExample)]\n *\n * ````javascript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {GLTFLoaderPlugin} from \"../src/plugins/GLTFLoaderPlugin/GLTFLoaderPlugin.js\";\n * import {Marker} from \"../src/scene/markers/Marker.js\";\n *\n * const viewer = new Viewer({\n *     canvasId: \"myCanvas\"\n * });\n *\n * // Create the torus Mesh\n * // Recall that a Mesh is an Entity\n * new Mesh(viewer.scene, {\n *     geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({\n *         center: [0,0,0],\n *         radius: 1.0,\n *         tube: 0.5,\n *         radialSegments: 32,\n *         tubeSegments: 24,\n *         arc: Math.PI * 2.0\n *     }),\n *     material: new PhongMaterial(viewer.scene, {\n *         diffuseMap: new Texture(viewer.scene, {\n *             src: \"textures/diffuse/uvGrid2.jpg\"\n *         }),\n *         backfaces: true\n *     })\n * });\n *\n * // Create the Marker, associated with our Mesh Entity\n * const myMarker = new Marker({\n *      entity: entity,\n *      worldPos: [10,0,0],\n *      occludable: true\n * });\n *\n * // Get the Marker's current World, View and Canvas coordinates\n * const worldPos   = myMarker.worldPos;     // 3D World-space position\n * const viewPos    = myMarker.viewPos;      // 3D View-space position\n * const canvasPos  = myMarker.canvasPos;    // 2D Canvas-space position\n *\n * const visible = myMarker.visible;\n *\n * // Listen for change of the Marker's 3D World-space position\n * myMarker.on(\"worldPos\", function(worldPos) {\n *    //...\n * });\n *\n * // Listen for change of the Marker's 3D View-space position, which happens\n * // when either worldPos was updated or the Camera was moved\n * myMarker.on(\"viewPos\", function(viewPos) {\n *    //...\n * });\n *\n * // Listen for change of the Marker's 2D Canvas-space position, which happens\n * // when worldPos or viewPos was updated, or Camera's projection was updated\n * myMarker.on(\"canvasPos\", function(canvasPos) {\n *    //...\n * });\n *\n * // Listen for change of Marker visibility. The Marker becomes invisible when it falls outside the canvas,\n * // has an Entity that is also invisible, or when an Entity occludes the Marker's position in the 3D view.\n * myMarker.on(\"visible\", function(visible) { // Marker visibility has changed\n *    if (visible) {\n *        this.log(\"Marker is visible\");\n *    } else {\n *        this.log(\"Marker is invisible\");\n *    }\n * });\n *\n * // Listen for destruction of Marker\n * myMarker.on(\"destroyed\", () => {\n *      //...\n * });\n * ````\n */\nclass Marker extends _Component_js__WEBPACK_IMPORTED_MODULE_1__[\"Component\"] {\n\n    /**\n     * @constructor\n     * @param {Component} [owner]  Owner component. When destroyed, the owner will destroy this Marker as well.\n     * @param {*} [cfg]  Marker configuration\n     * @param {String} [cfg.id] Optional ID, unique among all components in the parent {@link Scene}, generated automatically when omitted.\n     * @param {Entity} [cfg.entity] Entity to associate this Marker with. When the Marker has an Entity, then {@link Marker#visible} will always be ````false```` if {@link Entity#visible} is false.\n     * @param {Boolean} [cfg.occludable=false] Indicates whether or not this Marker is hidden (ie. {@link Marker#visible} is ````false```` whenever occluded by {@link Entity}s in the {@link Scene}.\n     * @param {Number[]} [cfg.worldPos=[0,0,0]] World-space 3D Marker position.\n     */\n    constructor(owner, cfg) {\n\n        super(owner, cfg);\n\n        this._entity = null;\n        this._visible = null;\n        this._worldPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._rtcCenter = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._rtcPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._viewPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._canvasPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec2();\n        this._occludable = false;\n\n        this._onCameraViewMatrix = this.scene.camera.on(\"matrix\", () => {\n            this._viewPosDirty = true;\n            this._needUpdate();\n        });\n\n        this._onCameraProjMatrix = this.scene.camera.on(\"projMatrix\", () => {\n            this._canvasPosDirty = true;\n            this._needUpdate();\n        });\n\n        this._onEntityDestroyed = null;\n        this._onEntityModelDestroyed = null;\n\n        this._renderer.addMarker(this);\n\n        this.entity = cfg.entity;\n        this.worldPos = cfg.worldPos;\n        this.occludable = cfg.occludable;\n    }\n\n    _update() { // this._needUpdate() schedules this for next tick\n        if (this._viewPosDirty) {\n            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformPoint3(this.scene.camera.viewMatrix, this._worldPos, this._viewPos);\n            this._viewPosDirty = false;\n            this._canvasPosDirty = true;\n            this.fire(\"viewPos\", this._viewPos);\n        }\n        if (this._canvasPosDirty) {\n            tempVec4a.set(this._viewPos);\n            tempVec4a[3] = 1.0;\n            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformPoint4(this.scene.camera.projMatrix, tempVec4a, tempVec4b);\n            const aabb = this.scene.canvas.boundary;\n            this._canvasPos[0] = Math.floor((1 + tempVec4b[0] / tempVec4b[3]) * aabb[2] / 2);\n            this._canvasPos[1] = Math.floor((1 - tempVec4b[1] / tempVec4b[3]) * aabb[3] / 2);\n            this._canvasPosDirty = false;\n            this.fire(\"canvasPos\", this._canvasPos);\n        }\n    }\n\n    _setVisible(visible) { // Called by VisibilityTester and this._entity.on(\"destroyed\"..)\n        if (this._visible === visible) {\n            //  return;\n        }\n        this._visible = visible;\n        this.fire(\"visible\", this._visible);\n    }\n\n    /**\n     * Sets the {@link Entity} this Marker is associated with.\n     *\n     * An Entity is optional. When the Marker has an Entity, then {@link Marker#visible} will always be ````false````\n     * if {@link Entity#visible} is false.\n     *\n     * @type {Entity}\n     */\n    set entity(entity) {\n        if (this._entity) {\n            if (this._entity === entity) {\n                return;\n            }\n            if (this._onEntityDestroyed !== null) {\n                this._entity.off(this._onEntityDestroyed);\n                this._onEntityDestroyed = null;\n            }\n            if (this._onEntityModelDestroyed !== null) {\n                this._entity.model.off(this._onEntityModelDestroyed);\n                this._onEntityModelDestroyed = null;\n            }\n        }\n        this._entity = entity;\n        if (this._entity) {\n            if (this._entity instanceof _PerformanceModel_lib_PerformanceNode_js__WEBPACK_IMPORTED_MODULE_2__[\"PerformanceNode\"]) {\n                this._onEntityModelDestroyed = this._entity.model.once(\"destroyed\", () => { // PerformanceNode does not fire events, and cannot exist beyond its PerformanceModel\n                    this._entity = null; // Marker now may become visible, if it was synched to invisible Entity\n                    this._onEntityModelDestroyed = null;\n                });\n            } else {\n                this._onEntityDestroyed = this._entity.once(\"destroyed\", () => {\n                    this._entity = null;\n                    this._onEntityDestroyed = null;\n                });\n            }\n        }\n        this.fire(\"entity\", this._entity, true /* forget */);\n    }\n\n    /**\n     * Gets the {@link Entity} this Marker is associated with.\n     *\n     * @type {Entity}\n     */\n    get entity() {\n        return this._entity;\n    }\n\n    /**\n     * Sets whether occlusion testing is performed for this Marker.\n     *\n     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.\n     *\n     * The {@link Scene} periodically occlusion-tests all Markers on every 20th \"tick\" (which represents a rendered frame). We\n     * can adjust that frequency via property {@link Scene#ticksPerOcclusionTest}.\n     *\n     * @type {Boolean}\n     */\n    set occludable(occludable) {\n        occludable = !!occludable;\n        if (occludable === this._occludable) {\n            return;\n        }\n        this._occludable = occludable;\n    }\n\n    /**\n     * Gets whether occlusion testing is performed for this Marker.\n     *\n     * When this is ````true````, then {@link Marker#visible} will be ````false```` whenever the Marker is occluded by an {@link Entity} in the 3D view.\n     *\n     * @type {Boolean}\n     */\n    get occludable() {\n        return this._occludable;\n    }\n\n    /**\n     * Sets the World-space 3D position of this Marker.\n     *\n     * Fires a \"worldPos\" event with new World position.\n     *\n     * @type {Number[]}\n     */\n    set worldPos(worldPos) {\n        this._worldPos.set(worldPos || [0, 0, 0]);\n        Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_3__[\"worldToRTCPos\"])(this._worldPos, this._rtcCenter, this._rtcPos);\n        if (this._occludable) {\n            this._renderer.markerWorldPosUpdated(this);\n        }\n        this._viewPosDirty = true;\n        this.fire(\"worldPos\", this._worldPos);\n    }\n\n    /**\n     * Gets the World-space 3D position of this Marker.\n     *\n     * @type {Number[]}\n     */\n    get worldPos() {\n        return this._worldPos;\n    }\n\n    /**\n     * Gets the RTC center of this Marker.\n     *\n     * This is automatically calculated from {@link Marker#worldPos}.\n     *\n     * @type {Number[]}\n     */\n    get rtcCenter() {\n        return this._rtcCenter;\n    }\n\n    /**\n     * Gets the RTC position of this Marker.\n     *\n     * This is automatically calculated from {@link Marker#worldPos}.\n     *\n     * @type {Number[]}\n     */\n    get rtcPos() {\n        return this._rtcPos;\n    }\n\n    /**\n     * View-space 3D coordinates of this Marker.\n     *\n     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position.\n     *\n     * The Marker fires a \"viewPos\" event whenever this property changes.\n     *\n     * @type {Number[]}\n     * @final\n     */\n    get viewPos() {\n        this._update();\n        return this._viewPos;\n    }\n\n    /**\n     * Canvas-space 2D coordinates of this Marker.\n     *\n     * This property is read-only and is automatically calculated from {@link Marker#worldPos} and the current {@link Camera} position and projection.\n     *\n     * The Marker fires a \"canvasPos\" event whenever this property changes.\n     *\n     * @type {Number[]}\n     * @final\n     */\n    get canvasPos() {\n        this._update();\n        return this._canvasPos;\n    }\n\n    /**\n     * Indicates if this Marker is currently visible.\n     *\n     * This is read-only and is automatically calculated.\n     *\n     * The Marker is **invisible** whenever:\n     *\n     * * {@link Marker#canvasPos} is currently outside the canvas,\n     * * {@link Marker#entity} is set to an {@link Entity} that has {@link Entity#visible} ````false````, or\n     * * or {@link Marker#occludable} is ````true```` and the Marker is currently occluded by an Entity in the 3D view.\n     *\n     * The Marker fires a \"visible\" event whenever this property changes.\n     *\n     * @type {Boolean}\n     * @final\n     */\n    get visible() {\n        return !!this._visible;\n    }\n\n    /**\n     * Destroys this Marker.\n     */\n    destroy() {\n        this.fire(\"destroyed\", true);\n        this.scene.camera.off(this._onCameraViewMatrix);\n        this.scene.camera.off(this._onCameraProjMatrix);\n        if (this._entity) {\n            if (this._onEntityDestroyed !== null) {\n                this._entity.off(this._onEntityDestroyed);\n            }\n            if (this._onEntityModelDestroyed !== null) {\n                this._entity.model.off(this._onEntityModelDestroyed);\n            }\n        }\n        this._renderer.removeMarker(this);\n        super.destroy();\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hcmtlci9NYXJrZXIuanM/MTliMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDSztBQUNpQztBQUN4Qjs7QUFFbkQsa0JBQWtCLGtEQUFJO0FBQ3RCLGtCQUFrQixrREFBSTs7O0FBR3RCO0FBQ0EsZ0dBQWdHLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQXNCO0FBQzVCLE1BQU0scUJBQXFCLDhHQUE4RyxzQkFBc0Isa0JBQWtCLGFBQWE7QUFDOUwsTUFBTSx1QkFBdUIsZ0hBQWdILHVCQUF1QixrQkFBa0IsYUFBYTtBQUNuTTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQixnR0FBZ0cscUJBQXFCO0FBQzlJO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CLGVBQWUsYUFBYSxPQUFPLHFCQUFxQjtBQUNsRixNQUFNLHdCQUF3QixxREFBcUQsYUFBYTtBQUNoRyxNQUFNLHVCQUF1QixpQ0FBaUMsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVyxtQkFBbUIsYUFBYTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUJBQXFCLHVEQUFTOztBQUU5QjtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU8sa0VBQWtFLFlBQVk7QUFDcEcsZUFBZSxPQUFPLHlGQUF5RixxQkFBcUIsa0NBQWtDLHFCQUFxQjtBQUMzTCxlQUFlLFFBQVEsNkVBQTZFLHFCQUFxQix3Q0FBd0MsYUFBYSxVQUFVLFlBQVk7QUFDcE0sZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixrREFBSTtBQUM3QiwwQkFBMEIsa0RBQUk7QUFDOUIsdUJBQXVCLGtEQUFJO0FBQzNCLHdCQUF3QixrREFBSTtBQUM1QiwwQkFBMEIsa0RBQUk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0EsWUFBWSxrREFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0EsbUVBQW1FLHFCQUFxQjtBQUN4RixXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdGQUFlO0FBQ3ZELDJGQUEyRjtBQUMzRix3Q0FBd0M7QUFDeEM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUIsOERBQThELGFBQWE7QUFDeEk7QUFDQSxZQUFZLFlBQVk7QUFDeEIsK0NBQStDLGtDQUFrQztBQUNqRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUIsOERBQThELGFBQWE7QUFDeEk7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdFQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQkFBc0Isa0JBQWtCLGFBQWE7QUFDN0g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCLGtCQUFrQixhQUFhO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQyxVQUFVLG9CQUFvQixlQUFlLGFBQWEsV0FBVyxxQkFBcUI7QUFDMUYsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hcmtlci9NYXJrZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge21hdGh9IGZyb20gJy4uL21hdGgvbWF0aC5qcyc7XG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnLi4vQ29tcG9uZW50LmpzJztcbmltcG9ydCB7UGVyZm9ybWFuY2VOb2RlfSBmcm9tIFwiLi4vUGVyZm9ybWFuY2VNb2RlbC9saWIvUGVyZm9ybWFuY2VOb2RlLmpzXCI7XG5pbXBvcnQge3dvcmxkVG9SVENQb3N9IGZyb20gXCIuLi9tYXRoL3J0Y0Nvb3Jkcy5qc1wiO1xuXG5jb25zdCB0ZW1wVmVjNGEgPSBtYXRoLnZlYzQoKTtcbmNvbnN0IHRlbXBWZWM0YiA9IG1hdGgudmVjNCgpO1xuXG5cbi8qKlxuICogQGRlc2MgVHJhY2tzIHRoZSBXb3JsZCwgVmlldyBhbmQgQ2FudmFzIGNvb3JkaW5hdGVzLCBhbmQgdmlzaWJpbGl0eSwgb2YgYSBwb3NpdGlvbiB3aXRoaW4gYSB7QGxpbmsgU2NlbmV9LlxuICpcbiAqICMjIFBvc2l0aW9uXG4gKlxuICogQSBNYXJrZXIgaG9sZHMgaXRzIHBvc2l0aW9uIGluIHRoZSBXb3JsZCwgVmlldyBhbmQgQ2FudmFzIGNvb3JkaW5hdGUgc3lzdGVtcyBpbiB0aHJlZSBwcm9wZXJ0aWVzOlxuICpcbiAqICoge0BsaW5rIE1hcmtlciN3b3JsZFBvc30gaG9sZHMgdGhlIE1hcmtlcidzIDNEIFdvcmxkLXNwYWNlIGNvb3JkaW5hdGVzLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBkeW5hbWljYWxseSB1cGRhdGVkLiBUaGUgTWFya2VyIHdpbGwgZmlyZSBhIFwid29ybGRQb3NcIiBldmVudCB3aGVuZXZlciB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXG4gKiAqIHtAbGluayBNYXJrZXIjdmlld1Bvc30gaG9sZHMgdGhlIE1hcmtlcidzIDNEIFZpZXctc3BhY2UgY29vcmRpbmF0ZXMuIFRoaXMgcHJvcGVydHkgaXMgcmVhZC1vbmx5LCBhbmQgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGZyb20ge0BsaW5rIE1hcmtlciN3b3JsZFBvc30gYW5kIHRoZSBjdXJyZW50IHtAbGluayBDYW1lcmF9IHBvc2l0aW9uLiBUaGUgTWFya2VyIHdpbGwgZmlyZSBhIFwidmlld1Bvc1wiIGV2ZW50IHdoZW5ldmVyIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cbiAqICoge0BsaW5rIE1hcmtlciNjYW52YXNQb3N9IGhvbGRzIHRoZSBNYXJrZXIncyAyRCBDYW52YXMtc3BhY2UgY29vcmRpbmF0ZXMuIFRoaXMgcHJvcGVydHkgaXMgcmVhZC1vbmx5LCBhbmQgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGZyb20ge0BsaW5rIE1hcmtlciNjYW52YXNQb3N9IGFuZCB0aGUgY3VycmVudCB7QGxpbmsgQ2FtZXJhfSBwb3NpdGlvbiBhbmQgcHJvamVjdGlvbi4gVGhlIE1hcmtlciB3aWxsIGZpcmUgYSBcImNhbnZhc1Bvc1wiIGV2ZW50IHdoZW5ldmVyIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cbiAqXG4gKiAjIyBWaXNpYmlsaXR5XG4gKlxuICoge0BsaW5rIE1hcmtlciN2aXNpYmxlfSBpbmRpY2F0ZXMgaWYgdGhlIE1hcmtlciBpcyBjdXJyZW50bHkgdmlzaWJsZS4gVGhlIE1hcmtlciB3aWxsIGZpcmUgYSBcInZpc2libGVcIiBldmVudCB3aGVuZXZlciB7QGxpbmsgTWFya2VyI3Zpc2libGV9IGNoYW5nZXMuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGBgYGBmYWxzZWBgYGAgd2hlbjpcbiAqXG4gKiAqIHtAbGluayBNYXJrZXIjZW50aXR5fSBpcyBzZXQgdG8gYW4ge0BsaW5rIEVudGl0eX0sIGFuZCB7QGxpbmsgRW50aXR5I3Zpc2libGV9IGlzIGBgYGBmYWxzZWBgYGAsXG4gKiAqIHtAbGluayBNYXJrZXIjb2NjbHVkYWJsZX0gaXMgYGBgYHRydWVgYGBgIGFuZCB0aGUgTWFya2VyIGlzIG9jY2x1ZGVkIGJ5IHNvbWUge0BsaW5rIEVudGl0eX0gaW4gdGhlIDNEIHZpZXcsIG9yXG4gKiAqIHtAbGluayBNYXJrZXIjY2FudmFzUG9zfSBpcyBvdXRzaWRlIHRoZSBib3VuZGFyeSBvZiB0aGUge0BsaW5rIENhbnZhc30uXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgd2UnbGwgY3JlYXRlIGEgTWFya2VyIHRoYXQncyBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgTWVzaH0gKHdoaWNoIGEgdHlwZSBvZiB7QGxpbmsgRW50aXR5fSkuXG4gKlxuICogV2UnbGwgY29uZmlndXJlIG91ciBNYXJrZXIgdG9cbiAqIGJlY29tZSBpbnZpc2libGUgd2hlbmV2ZXIgaXQncyBvY2NsdWRlZCBieSBhbnkgRW50aXRpZXMgaW4gdGhlIGNhbnZhcy5cbiAqXG4gKiBXZSdsbCBhbHNvIGRlbW9uc3RyYXRlIGhvdyB0byBxdWVyeSB0aGUgTWFya2VyJ3MgdmlzaWJpbGl0eSBzdGF0dXMgYW5kIHBvc2l0aW9uIChpbiB0aGUgV29ybGQsIFZpZXcgYW5kXG4gKiBDYW52YXMgY29vcmRpbmF0ZSBzeXN0ZW1zKSwgYW5kIGhvdyB0byBzdWJzY3JpYmUgdG8gY2hhbmdlIGV2ZW50cyBvbiB0aG9zZSBwcm9wZXJ0aWVzLlxuICpcbiAqIFtbUnVuIHRoaXMgZXhhbXBsZV0oaHR0cDovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jTWFya2Vyc19TaW1wbGVFeGFtcGxlKV1cbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHtWaWV3ZXJ9IGZyb20gXCIuLi9zcmMvdmlld2VyL1ZpZXdlci5qc1wiO1xuICogaW1wb3J0IHtHTFRGTG9hZGVyUGx1Z2lufSBmcm9tIFwiLi4vc3JjL3BsdWdpbnMvR0xURkxvYWRlclBsdWdpbi9HTFRGTG9hZGVyUGx1Z2luLmpzXCI7XG4gKiBpbXBvcnQge01hcmtlcn0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXJrZXJzL01hcmtlci5qc1wiO1xuICpcbiAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3ZXIoe1xuICogICAgIGNhbnZhc0lkOiBcIm15Q2FudmFzXCJcbiAqIH0pO1xuICpcbiAqIC8vIENyZWF0ZSB0aGUgdG9ydXMgTWVzaFxuICogLy8gUmVjYWxsIHRoYXQgYSBNZXNoIGlzIGFuIEVudGl0eVxuICogbmV3IE1lc2godmlld2VyLnNjZW5lLCB7XG4gKiAgICAgZ2VvbWV0cnk6IG5ldyBSZWFkYWJsZUdlb21ldHJ5KHZpZXdlci5zY2VuZSwgYnVpbGRUb3J1c0dlb21ldHJ5KHtcbiAqICAgICAgICAgY2VudGVyOiBbMCwwLDBdLFxuICogICAgICAgICByYWRpdXM6IDEuMCxcbiAqICAgICAgICAgdHViZTogMC41LFxuICogICAgICAgICByYWRpYWxTZWdtZW50czogMzIsXG4gKiAgICAgICAgIHR1YmVTZWdtZW50czogMjQsXG4gKiAgICAgICAgIGFyYzogTWF0aC5QSSAqIDIuMFxuICogICAgIH0pLFxuICogICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgZGlmZnVzZU1hcDogbmV3IFRleHR1cmUodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICBzcmM6IFwidGV4dHVyZXMvZGlmZnVzZS91dkdyaWQyLmpwZ1wiXG4gKiAgICAgICAgIH0pLFxuICogICAgICAgICBiYWNrZmFjZXM6IHRydWVcbiAqICAgICB9KVxuICogfSk7XG4gKlxuICogLy8gQ3JlYXRlIHRoZSBNYXJrZXIsIGFzc29jaWF0ZWQgd2l0aCBvdXIgTWVzaCBFbnRpdHlcbiAqIGNvbnN0IG15TWFya2VyID0gbmV3IE1hcmtlcih7XG4gKiAgICAgIGVudGl0eTogZW50aXR5LFxuICogICAgICB3b3JsZFBvczogWzEwLDAsMF0sXG4gKiAgICAgIG9jY2x1ZGFibGU6IHRydWVcbiAqIH0pO1xuICpcbiAqIC8vIEdldCB0aGUgTWFya2VyJ3MgY3VycmVudCBXb3JsZCwgVmlldyBhbmQgQ2FudmFzIGNvb3JkaW5hdGVzXG4gKiBjb25zdCB3b3JsZFBvcyAgID0gbXlNYXJrZXIud29ybGRQb3M7ICAgICAvLyAzRCBXb3JsZC1zcGFjZSBwb3NpdGlvblxuICogY29uc3Qgdmlld1BvcyAgICA9IG15TWFya2VyLnZpZXdQb3M7ICAgICAgLy8gM0QgVmlldy1zcGFjZSBwb3NpdGlvblxuICogY29uc3QgY2FudmFzUG9zICA9IG15TWFya2VyLmNhbnZhc1BvczsgICAgLy8gMkQgQ2FudmFzLXNwYWNlIHBvc2l0aW9uXG4gKlxuICogY29uc3QgdmlzaWJsZSA9IG15TWFya2VyLnZpc2libGU7XG4gKlxuICogLy8gTGlzdGVuIGZvciBjaGFuZ2Ugb2YgdGhlIE1hcmtlcidzIDNEIFdvcmxkLXNwYWNlIHBvc2l0aW9uXG4gKiBteU1hcmtlci5vbihcIndvcmxkUG9zXCIsIGZ1bmN0aW9uKHdvcmxkUG9zKSB7XG4gKiAgICAvLy4uLlxuICogfSk7XG4gKlxuICogLy8gTGlzdGVuIGZvciBjaGFuZ2Ugb2YgdGhlIE1hcmtlcidzIDNEIFZpZXctc3BhY2UgcG9zaXRpb24sIHdoaWNoIGhhcHBlbnNcbiAqIC8vIHdoZW4gZWl0aGVyIHdvcmxkUG9zIHdhcyB1cGRhdGVkIG9yIHRoZSBDYW1lcmEgd2FzIG1vdmVkXG4gKiBteU1hcmtlci5vbihcInZpZXdQb3NcIiwgZnVuY3Rpb24odmlld1Bvcykge1xuICogICAgLy8uLi5cbiAqIH0pO1xuICpcbiAqIC8vIExpc3RlbiBmb3IgY2hhbmdlIG9mIHRoZSBNYXJrZXIncyAyRCBDYW52YXMtc3BhY2UgcG9zaXRpb24sIHdoaWNoIGhhcHBlbnNcbiAqIC8vIHdoZW4gd29ybGRQb3Mgb3Igdmlld1BvcyB3YXMgdXBkYXRlZCwgb3IgQ2FtZXJhJ3MgcHJvamVjdGlvbiB3YXMgdXBkYXRlZFxuICogbXlNYXJrZXIub24oXCJjYW52YXNQb3NcIiwgZnVuY3Rpb24oY2FudmFzUG9zKSB7XG4gKiAgICAvLy4uLlxuICogfSk7XG4gKlxuICogLy8gTGlzdGVuIGZvciBjaGFuZ2Ugb2YgTWFya2VyIHZpc2liaWxpdHkuIFRoZSBNYXJrZXIgYmVjb21lcyBpbnZpc2libGUgd2hlbiBpdCBmYWxscyBvdXRzaWRlIHRoZSBjYW52YXMsXG4gKiAvLyBoYXMgYW4gRW50aXR5IHRoYXQgaXMgYWxzbyBpbnZpc2libGUsIG9yIHdoZW4gYW4gRW50aXR5IG9jY2x1ZGVzIHRoZSBNYXJrZXIncyBwb3NpdGlvbiBpbiB0aGUgM0Qgdmlldy5cbiAqIG15TWFya2VyLm9uKFwidmlzaWJsZVwiLCBmdW5jdGlvbih2aXNpYmxlKSB7IC8vIE1hcmtlciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkXG4gKiAgICBpZiAodmlzaWJsZSkge1xuICogICAgICAgIHRoaXMubG9nKFwiTWFya2VyIGlzIHZpc2libGVcIik7XG4gKiAgICB9IGVsc2Uge1xuICogICAgICAgIHRoaXMubG9nKFwiTWFya2VyIGlzIGludmlzaWJsZVwiKTtcbiAqICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIExpc3RlbiBmb3IgZGVzdHJ1Y3Rpb24gb2YgTWFya2VyXG4gKiBteU1hcmtlci5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gKiAgICAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYGBcbiAqL1xuY2xhc3MgTWFya2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50fSBbb3duZXJdICBPd25lciBjb21wb25lbnQuIFdoZW4gZGVzdHJveWVkLCB0aGUgb3duZXIgd2lsbCBkZXN0cm95IHRoaXMgTWFya2VyIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIHsqfSBbY2ZnXSAgTWFya2VyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NmZy5pZF0gT3B0aW9uYWwgSUQsIHVuaXF1ZSBhbW9uZyBhbGwgY29tcG9uZW50cyBpbiB0aGUgcGFyZW50IHtAbGluayBTY2VuZX0sIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge0VudGl0eX0gW2NmZy5lbnRpdHldIEVudGl0eSB0byBhc3NvY2lhdGUgdGhpcyBNYXJrZXIgd2l0aC4gV2hlbiB0aGUgTWFya2VyIGhhcyBhbiBFbnRpdHksIHRoZW4ge0BsaW5rIE1hcmtlciN2aXNpYmxlfSB3aWxsIGFsd2F5cyBiZSBgYGBgZmFsc2VgYGBgIGlmIHtAbGluayBFbnRpdHkjdmlzaWJsZX0gaXMgZmFsc2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLm9jY2x1ZGFibGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIE1hcmtlciBpcyBoaWRkZW4gKGllLiB7QGxpbmsgTWFya2VyI3Zpc2libGV9IGlzIGBgYGBmYWxzZWBgYGAgd2hlbmV2ZXIgb2NjbHVkZWQgYnkge0BsaW5rIEVudGl0eX1zIGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtjZmcud29ybGRQb3M9WzAsMCwwXV0gV29ybGQtc3BhY2UgM0QgTWFya2VyIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBjZmcpIHtcblxuICAgICAgICBzdXBlcihvd25lciwgY2ZnKTtcblxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd29ybGRQb3MgPSBtYXRoLnZlYzMoKTtcbiAgICAgICAgdGhpcy5fcnRjQ2VudGVyID0gbWF0aC52ZWMzKCk7XG4gICAgICAgIHRoaXMuX3J0Y1BvcyA9IG1hdGgudmVjMygpO1xuICAgICAgICB0aGlzLl92aWV3UG9zID0gbWF0aC52ZWMzKCk7XG4gICAgICAgIHRoaXMuX2NhbnZhc1BvcyA9IG1hdGgudmVjMigpO1xuICAgICAgICB0aGlzLl9vY2NsdWRhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fb25DYW1lcmFWaWV3TWF0cml4ID0gdGhpcy5zY2VuZS5jYW1lcmEub24oXCJtYXRyaXhcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdmlld1Bvc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRVcGRhdGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb25DYW1lcmFQcm9qTWF0cml4ID0gdGhpcy5zY2VuZS5jYW1lcmEub24oXCJwcm9qTWF0cml4XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1Bvc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRVcGRhdGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb25FbnRpdHlEZXN0cm95ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkVudGl0eU1vZGVsRGVzdHJveWVkID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRNYXJrZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5lbnRpdHkgPSBjZmcuZW50aXR5O1xuICAgICAgICB0aGlzLndvcmxkUG9zID0gY2ZnLndvcmxkUG9zO1xuICAgICAgICB0aGlzLm9jY2x1ZGFibGUgPSBjZmcub2NjbHVkYWJsZTtcbiAgICB9XG5cbiAgICBfdXBkYXRlKCkgeyAvLyB0aGlzLl9uZWVkVXBkYXRlKCkgc2NoZWR1bGVzIHRoaXMgZm9yIG5leHQgdGlja1xuICAgICAgICBpZiAodGhpcy5fdmlld1Bvc0RpcnR5KSB7XG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVBvaW50Myh0aGlzLnNjZW5lLmNhbWVyYS52aWV3TWF0cml4LCB0aGlzLl93b3JsZFBvcywgdGhpcy5fdmlld1Bvcyk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UG9zRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1Bvc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZShcInZpZXdQb3NcIiwgdGhpcy5fdmlld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc1Bvc0RpcnR5KSB7XG4gICAgICAgICAgICB0ZW1wVmVjNGEuc2V0KHRoaXMuX3ZpZXdQb3MpO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzNdID0gMS4wO1xuICAgICAgICAgICAgbWF0aC50cmFuc2Zvcm1Qb2ludDQodGhpcy5zY2VuZS5jYW1lcmEucHJvak1hdHJpeCwgdGVtcFZlYzRhLCB0ZW1wVmVjNGIpO1xuICAgICAgICAgICAgY29uc3QgYWFiYiA9IHRoaXMuc2NlbmUuY2FudmFzLmJvdW5kYXJ5O1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzUG9zWzBdID0gTWF0aC5mbG9vcigoMSArIHRlbXBWZWM0YlswXSAvIHRlbXBWZWM0YlszXSkgKiBhYWJiWzJdIC8gMik7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXNQb3NbMV0gPSBNYXRoLmZsb29yKCgxIC0gdGVtcFZlYzRiWzFdIC8gdGVtcFZlYzRiWzNdKSAqIGFhYmJbM10gLyAyKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1Bvc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpcmUoXCJjYW52YXNQb3NcIiwgdGhpcy5fY2FudmFzUG9zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRWaXNpYmxlKHZpc2libGUpIHsgLy8gQ2FsbGVkIGJ5IFZpc2liaWxpdHlUZXN0ZXIgYW5kIHRoaXMuX2VudGl0eS5vbihcImRlc3Ryb3llZFwiLi4pXG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlID09PSB2aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICB0aGlzLmZpcmUoXCJ2aXNpYmxlXCIsIHRoaXMuX3Zpc2libGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHtAbGluayBFbnRpdHl9IHRoaXMgTWFya2VyIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgKlxuICAgICAqIEFuIEVudGl0eSBpcyBvcHRpb25hbC4gV2hlbiB0aGUgTWFya2VyIGhhcyBhbiBFbnRpdHksIHRoZW4ge0BsaW5rIE1hcmtlciN2aXNpYmxlfSB3aWxsIGFsd2F5cyBiZSBgYGBgZmFsc2VgYGBgXG4gICAgICogaWYge0BsaW5rIEVudGl0eSN2aXNpYmxlfSBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbnRpdHl9XG4gICAgICovXG4gICAgc2V0IGVudGl0eShlbnRpdHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VudGl0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VudGl0eSA9PT0gZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uRW50aXR5RGVzdHJveWVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Lm9mZih0aGlzLl9vbkVudGl0eURlc3Ryb3llZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FbnRpdHlEZXN0cm95ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uRW50aXR5TW9kZWxEZXN0cm95ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHkubW9kZWwub2ZmKHRoaXMuX29uRW50aXR5TW9kZWxEZXN0cm95ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRW50aXR5TW9kZWxEZXN0cm95ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcbiAgICAgICAgaWYgKHRoaXMuX2VudGl0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VudGl0eSBpbnN0YW5jZW9mIFBlcmZvcm1hbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRW50aXR5TW9kZWxEZXN0cm95ZWQgPSB0aGlzLl9lbnRpdHkubW9kZWwub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7IC8vIFBlcmZvcm1hbmNlTm9kZSBkb2VzIG5vdCBmaXJlIGV2ZW50cywgYW5kIGNhbm5vdCBleGlzdCBiZXlvbmQgaXRzIFBlcmZvcm1hbmNlTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5ID0gbnVsbDsgLy8gTWFya2VyIG5vdyBtYXkgYmVjb21lIHZpc2libGUsIGlmIGl0IHdhcyBzeW5jaGVkIHRvIGludmlzaWJsZSBFbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FbnRpdHlNb2RlbERlc3Ryb3llZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRW50aXR5RGVzdHJveWVkID0gdGhpcy5fZW50aXR5Lm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVudGl0eURlc3Ryb3llZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKFwiZW50aXR5XCIsIHRoaXMuX2VudGl0eSwgdHJ1ZSAvKiBmb3JnZXQgKi8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHtAbGluayBFbnRpdHl9IHRoaXMgTWFya2VyIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbnRpdHl9XG4gICAgICovXG4gICAgZ2V0IGVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb2NjbHVzaW9uIHRlc3RpbmcgaXMgcGVyZm9ybWVkIGZvciB0aGlzIE1hcmtlci5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyBpcyBgYGBgdHJ1ZWBgYGAsIHRoZW4ge0BsaW5rIE1hcmtlciN2aXNpYmxlfSB3aWxsIGJlIGBgYGBmYWxzZWBgYGAgd2hlbmV2ZXIgdGhlIE1hcmtlciBpcyBvY2NsdWRlZCBieSBhbiB7QGxpbmsgRW50aXR5fSBpbiB0aGUgM0Qgdmlldy5cbiAgICAgKlxuICAgICAqIFRoZSB7QGxpbmsgU2NlbmV9IHBlcmlvZGljYWxseSBvY2NsdXNpb24tdGVzdHMgYWxsIE1hcmtlcnMgb24gZXZlcnkgMjB0aCBcInRpY2tcIiAod2hpY2ggcmVwcmVzZW50cyBhIHJlbmRlcmVkIGZyYW1lKS4gV2VcbiAgICAgKiBjYW4gYWRqdXN0IHRoYXQgZnJlcXVlbmN5IHZpYSBwcm9wZXJ0eSB7QGxpbmsgU2NlbmUjdGlja3NQZXJPY2NsdXNpb25UZXN0fS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBvY2NsdWRhYmxlKG9jY2x1ZGFibGUpIHtcbiAgICAgICAgb2NjbHVkYWJsZSA9ICEhb2NjbHVkYWJsZTtcbiAgICAgICAgaWYgKG9jY2x1ZGFibGUgPT09IHRoaXMuX29jY2x1ZGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vY2NsdWRhYmxlID0gb2NjbHVkYWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgb2NjbHVzaW9uIHRlc3RpbmcgaXMgcGVyZm9ybWVkIGZvciB0aGlzIE1hcmtlci5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyBpcyBgYGBgdHJ1ZWBgYGAsIHRoZW4ge0BsaW5rIE1hcmtlciN2aXNpYmxlfSB3aWxsIGJlIGBgYGBmYWxzZWBgYGAgd2hlbmV2ZXIgdGhlIE1hcmtlciBpcyBvY2NsdWRlZCBieSBhbiB7QGxpbmsgRW50aXR5fSBpbiB0aGUgM0Qgdmlldy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBvY2NsdWRhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2NjbHVkYWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBXb3JsZC1zcGFjZSAzRCBwb3NpdGlvbiBvZiB0aGlzIE1hcmtlci5cbiAgICAgKlxuICAgICAqIEZpcmVzIGEgXCJ3b3JsZFBvc1wiIGV2ZW50IHdpdGggbmV3IFdvcmxkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIHNldCB3b3JsZFBvcyh3b3JsZFBvcykge1xuICAgICAgICB0aGlzLl93b3JsZFBvcy5zZXQod29ybGRQb3MgfHwgWzAsIDAsIDBdKTtcbiAgICAgICAgd29ybGRUb1JUQ1Bvcyh0aGlzLl93b3JsZFBvcywgdGhpcy5fcnRjQ2VudGVyLCB0aGlzLl9ydGNQb3MpO1xuICAgICAgICBpZiAodGhpcy5fb2NjbHVkYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubWFya2VyV29ybGRQb3NVcGRhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXdQb3NEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlyZShcIndvcmxkUG9zXCIsIHRoaXMuX3dvcmxkUG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBXb3JsZC1zcGFjZSAzRCBwb3NpdGlvbiBvZiB0aGlzIE1hcmtlci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgd29ybGRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZFBvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBSVEMgY2VudGVyIG9mIHRoaXMgTWFya2VyLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSB7QGxpbmsgTWFya2VyI3dvcmxkUG9zfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgcnRjQ2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRjQ2VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJUQyBwb3NpdGlvbiBvZiB0aGlzIE1hcmtlci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20ge0BsaW5rIE1hcmtlciN3b3JsZFBvc30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IHJ0Y1BvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0Y1BvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWaWV3LXNwYWNlIDNEIGNvb3JkaW5hdGVzIG9mIHRoaXMgTWFya2VyLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyByZWFkLW9ubHkgYW5kIGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHtAbGluayBNYXJrZXIjd29ybGRQb3N9IGFuZCB0aGUgY3VycmVudCB7QGxpbmsgQ2FtZXJhfSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBNYXJrZXIgZmlyZXMgYSBcInZpZXdQb3NcIiBldmVudCB3aGVuZXZlciB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgZ2V0IHZpZXdQb3MoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1BvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXMtc3BhY2UgMkQgY29vcmRpbmF0ZXMgb2YgdGhpcyBNYXJrZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHJlYWQtb25seSBhbmQgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20ge0BsaW5rIE1hcmtlciN3b3JsZFBvc30gYW5kIHRoZSBjdXJyZW50IHtAbGluayBDYW1lcmF9IHBvc2l0aW9uIGFuZCBwcm9qZWN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIE1hcmtlciBmaXJlcyBhIFwiY2FudmFzUG9zXCIgZXZlbnQgd2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIGdldCBjYW52YXNQb3MoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzUG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGlzIE1hcmtlciBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgcmVhZC1vbmx5IGFuZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgTWFya2VyIGlzICoqaW52aXNpYmxlKiogd2hlbmV2ZXI6XG4gICAgICpcbiAgICAgKiAqIHtAbGluayBNYXJrZXIjY2FudmFzUG9zfSBpcyBjdXJyZW50bHkgb3V0c2lkZSB0aGUgY2FudmFzLFxuICAgICAqICoge0BsaW5rIE1hcmtlciNlbnRpdHl9IGlzIHNldCB0byBhbiB7QGxpbmsgRW50aXR5fSB0aGF0IGhhcyB7QGxpbmsgRW50aXR5I3Zpc2libGV9IGBgYGBmYWxzZWBgYGAsIG9yXG4gICAgICogKiBvciB7QGxpbmsgTWFya2VyI29jY2x1ZGFibGV9IGlzIGBgYGB0cnVlYGBgYCBhbmQgdGhlIE1hcmtlciBpcyBjdXJyZW50bHkgb2NjbHVkZWQgYnkgYW4gRW50aXR5IGluIHRoZSAzRCB2aWV3LlxuICAgICAqXG4gICAgICogVGhlIE1hcmtlciBmaXJlcyBhIFwidmlzaWJsZVwiIGV2ZW50IHdoZW5ldmVyIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl92aXNpYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgTWFya2VyLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZmlyZShcImRlc3Ryb3llZFwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zY2VuZS5jYW1lcmEub2ZmKHRoaXMuX29uQ2FtZXJhVmlld01hdHJpeCk7XG4gICAgICAgIHRoaXMuc2NlbmUuY2FtZXJhLm9mZih0aGlzLl9vbkNhbWVyYVByb2pNYXRyaXgpO1xuICAgICAgICBpZiAodGhpcy5fZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25FbnRpdHlEZXN0cm95ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHkub2ZmKHRoaXMuX29uRW50aXR5RGVzdHJveWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkVudGl0eU1vZGVsRGVzdHJveWVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Lm1vZGVsLm9mZih0aGlzLl9vbkVudGl0eU1vZGVsRGVzdHJveWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVNYXJrZXIodGhpcyk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7TWFya2VyfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/marker/Marker.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js ***!
  \***********************************************************************/
/*! exports provided: math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"math\", function() { return math; });\n// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE: Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    unglobalizeObjectId(modelId, globalId) {\n        const idx = globalId.indexOf(\"#\");\n        return (idx === modelId.length && globalId.startsWith(modelId)) ? globalId.substring(idx + 1) : globalId;\n    },\n\n    globalizeObjectId(modelId, objectId) {\n        return (modelId + \"#\" + objectId)\n    },\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a list of double-precision values to a list of high-part floats and a list of low-part floats.\n     * @param doubleVals\n     * @param floatValsHigh\n     * @param floatValsLow\n     */\n    doublesToFloats(doubleVals, floatValsHigh, floatValsLow) {\n        const floatPair = new Float32Array(2);\n        for (let i = 0, len = doubleVals.length; i < len; i++) {\n            math.splitDouble(doubleVals[i], floatPair);\n            floatValsHigh[i] = floatPair[0];\n            floatValsLow[i] = floatPair[1];\n        }\n    },\n\n    /**\n     * Splits a double value into two floats.\n     * @param value\n     * @param floatPair\n     */\n    splitDouble(value, floatPair) {\n        const hi = Float32Array.from([value])[0];\n        const low = value - hi;\n        floatPair[0] = hi;\n        floatPair[1] = low;\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Returns true if the two 3-element vectors are the same.\n     * @param v1\n     * @param v2\n     * @returns {boolean}\n     */\n    compareVec3(v1, v2) {\n        return (v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2]);\n    },\n\n    /**\n     * Negates a three-element vector.\n     * @method negateVec3\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec3(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        return dest;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Get the geometric mean of the vectors.\n     * @method geometricMeanVec2\n     * @static\n     * @param {...Array(Number)} vectors Vec2 to mean\n     * @return {Array(Number)} The geometric mean vec2\n     */\n    geometricMeanVec2(...vectors) {\n        const geometricMean = new FloatArrayType(vectors[0]);\n        for (let i = 1; i < vectors.length; i++) {\n            geometricMean[0] += vectors[i][0];\n            geometricMean[1] += vectors[i][1];\n        }\n        geometricMean[0] /= vectors.length;\n        geometricMean[1] /= vectors.length;\n        return geometricMean;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n\n    /**\n     * Creates a new matrix that replaces the translation in the rightmost column of the given\n     * affine matrix with the given translation.\n     * @param m\n     * @param translation\n     * @param dest\n     * @returns {*}\n     */\n    setMat4Translation(m, translation, dest) {\n\n        dest[0] = m[0];\n        dest[1] = m[1];\n        dest[2] = m[2];\n        dest[3] = m[3];\n\n        dest[4] = m[4];\n        dest[5] = m[5];\n        dest[6] = m[6];\n        dest[7] = m[7];\n\n        dest[8] = m[8];\n        dest[9] = m[9];\n        dest[10] = m[10];\n        dest[11] = m[11];\n\n        dest[12] = translation[0];\n        dest[13] = translation[1];\n        dest[14] = translation[2];\n        dest[15] = m[15];\n\n        return dest;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /** @private */\n    getColMat4(mat, c) {\n        const i = c * 4;\n        return [mat[i], mat[i + 1], mat[i + 2], mat[i + 3]];\n    },\n\n    /** @private */\n    setRowMat4(mat, r, v) {\n        mat[r] = v[0];\n        mat[r + 4] = v[1];\n        mat[r + 8] = v[2];\n        mat[r + 12] = v[3];\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Returns true if the two 4x4 matrices are the same.\n     * @param m1\n     * @param m2\n     * @returns {boolean}\n     */\n    compareMat4(m1, m2) {\n        return m1[0] === m2[0] &&\n            m1[1] === m2[1] &&\n            m1[2] === m2[2] &&\n            m1[3] === m2[3] &&\n            m1[4] === m2[4] &&\n            m1[5] === m2[5] &&\n            m1[6] === m2[6] &&\n            m1[7] === m2[7] &&\n            m1[8] === m2[8] &&\n            m1[9] === m2[9] &&\n            m1[10] === m2[10] &&\n            m1[11] === m2[11] &&\n            m1[12] === m2[12] &&\n            m1[13] === m2[13] &&\n            m1[14] === m2[14] &&\n            m1[15] === m2[15];\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = p[0] * f;\n        q[1] = p[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n    /**\n     * Linearly interpolates between two 4x4 matrices.\n     * @method lerpMat4\n     * @static\n     */\n    lerpMat4(t, t1, t2, m1, m2, dest) {\n        const result = dest || math.mat4();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = m1[0] + (f * (m2[0] - m1[0]));\n        result[1] = m1[1] + (f * (m2[1] - m1[1]));\n        result[2] = m1[2] + (f * (m2[2] - m1[2]));\n        result[3] = m1[3] + (f * (m2[3] - m1[3]));\n        result[4] = m1[4] + (f * (m2[4] - m1[4]));\n        result[5] = m1[5] + (f * (m2[5] - m1[5]));\n        result[6] = m1[6] + (f * (m2[6] - m1[6]));\n        result[7] = m1[7] + (f * (m2[7] - m1[7]));\n        result[8] = m1[8] + (f * (m2[8] - m1[8]));\n        result[9] = m1[9] + (f * (m2[9] - m1[9]));\n        result[10] = m1[10] + (f * (m2[10] - m1[10]));\n        result[11] = m1[11] + (f * (m2[11] - m1[11]));\n        result[12] = m1[12] + (f * (m2[12] - m1[12]));\n        result[13] = m1[13] + (f * (m2[13] - m1[13]));\n        result[14] = m1[14] + (f * (m2[14] - m1[14]));\n        result[15] = m1[15] + (f * (m2[15] - m1[15]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the area of an AABB.\n     *\n     * @private\n     */\n    getAABB3Area(aabb) {\n        const width = (aabb[3] - aabb[0]);\n        const height = (aabb[4] - aabb[1]);\n        const depth = (aabb[5] - aabb[2]);\n        return (width * height * depth);\n    },\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n        aabb[4] = math.MIN_DOUBLE;\n        aabb[5] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new Float32Array(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = math.MIN_DOUBLE;\n            let ymax = math.MIN_DOUBLE;\n            let zmax = math.MIN_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new Float32Array(3);\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Gets the 3D center of the given flat array of 3D positions.\n     *\n     * @private\n     */\n    getPositionsCenter(positions, center = math.vec3()) {\n        let xCenter = 0;\n        let yCenter = 0;\n        let zCenter = 0;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            xCenter += positions[i + 0];\n            yCenter += positions[i + 1];\n            zCenter += positions[i + 2];\n        }\n        const numPositions = positions.length / 3;\n        center[0] = xCenter / numPositions;\n        center[1] = yCenter / numPositions;\n        center[2] = zCenter / numPositions;\n        return center;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n     *\n     * @private\n     */\n    expandAABB3Points3(aabb, positions) {\n        var x;\n        var y;\n        var z;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            x = positions[i];\n            y = positions[i + 1];\n            z = positions[i + 2];\n            if (aabb[0] > x) {\n                aabb[0] = x;\n            }\n            if (aabb[1] > y) {\n                aabb[1] = y;\n            }\n            if (aabb[2] > z) {\n                aabb[2] = z;\n            }\n            if (aabb[3] < x) {\n                aabb[3] = x;\n            }\n            if (aabb[4] < y) {\n                aabb[4] = y;\n            }\n            if (aabb[5] < z) {\n                aabb[5] = z;\n            }\n        }\n        return aabb;\n    },\n\n    /**\n     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB2(aabb = math.AABB2()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MIN_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    point3AABB3Intersect(aabb, p) {\n        return aabb[0] > p[0] || aabb[3] < p[0] || aabb[1] > p[1] || aabb[4] < p[1] || aabb[2] > p[2] || aabb[5] < p[2];\n    },\n\n    /**\n     *\n     * @param dir\n     * @param constant\n     * @param aabb\n     * @returns {number}\n     */\n    planeAABB3Intersect(dir, constant, aabb) {\n        let min, max;\n        if (dir[0] > 0) {\n            min = dir[0] * aabb[0];\n            max = dir[0] * aabb[3];\n        } else {\n            min = dir[0] * aabb[3];\n            max = dir[0] * aabb[0];\n        }\n        if (dir[1] > 0) {\n            min += dir[1] * aabb[1];\n            max += dir[1] * aabb[4];\n        } else {\n            min += dir[1] * aabb[4];\n            max += dir[1] * aabb[1];\n        }\n        if (dir[2] > 0) {\n            min += dir[2] * aabb[2];\n            max += dir[2] * aabb[5];\n        } else {\n            min += dir[2] * aabb[5];\n            max += dir[2] * aabb[2];\n        }\n        const outside = (min <= -constant) && (max <= -constant);\n        if (outside) {\n            return -1;\n        }\n\n        const inside = (min >= -constant) && (max >= -constant);\n        if (inside) {\n            return 1;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToAABB2(points, aabb = math.AABB2()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let w;\n        let f;\n\n        for (let i = 0, len = points.length; i < len; i += 4) {\n\n            x = points[i + 0];\n            y = points[i + 1];\n            w = points[i + 3] || 1.0;\n\n            f = 1.0 / w;\n\n            x *= f;\n            y *= f;\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = xmax;\n        aabb[3] = ymax;\n\n        return aabb;\n    },\n\n    /**\n     * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB2(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] < aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 2D boundary to enclose the given point, if required.\n     *\n     * @private\n     */\n    expandAABB2Point2(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] < p[0]) {\n            aabb[2] = p[0];\n        }\n\n        if (aabb[3] < p[1]) {\n            aabb[3] = p[1];\n        }\n\n        return aabb;\n    },\n\n    AABB2ToCanvas(aabb, canvasWidth, canvasHeight, aabb2 = aabb) {\n        const xmin = (aabb[0] + 1.0) * 0.5;\n        const ymin = (aabb[1] + 1.0) * 0.5;\n        const xmax = (aabb[2] + 1.0) * 0.5;\n        const ymax = (aabb[3] + 1.0) * 0.5;\n\n        aabb2[0] = Math.floor(xmin * canvasWidth);\n        aabb2[1] = canvasHeight - Math.floor(ymax * canvasHeight);\n        aabb2[2] = Math.floor(xmax * canvasWidth);\n        aabb2[3] = canvasHeight - Math.floor(ymin * canvasHeight);\n\n        return aabb2;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Curves\n    //------------------------------------------------------------------------------------------------------------------\n\n    tangentQuadraticBezier(t, p0, p1, p2) {\n        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n    },\n\n    tangentQuadraticBezier3(t, p0, p1, p2, p3) {\n        return -3 * p0 * (1 - t) * (1 - t) +\n            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\n            6 * t * p2 * (1 - t) - 3 * t * t * p2 +\n            3 * t * t * p3;\n    },\n\n    tangentSpline(t) {\n        const h00 = 6 * t * t - 6 * t;\n        const h10 = 3 * t * t - 4 * t + 1;\n        const h01 = -6 * t * t + 6 * t;\n        const h11 = 3 * t * t - 2 * t;\n        return h00 + h10 + h01 + h11;\n    },\n\n    catmullRomInterpolate(p0, p1, p2, p3, t) {\n        const v0 = (p2 - p0) * 0.5;\n        const v1 = (p3 - p1) * 0.5;\n        const t2 = t * t;\n        const t3 = t * t2;\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    },\n\n// Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n// Quad Bezier Functions\n\n    b2p0(t, p) {\n        const k = 1 - t;\n        return k * k * p;\n\n    },\n\n    b2p1(t, p) {\n        return 2 * (1 - t) * t * p;\n    },\n\n    b2p2(t, p) {\n        return t * t * p;\n    },\n\n    b2(t, p0, p1, p2) {\n        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);\n    },\n\n// Cubic Bezier Functions\n\n    b3p0(t, p) {\n        const k = 1 - t;\n        return k * k * k * p;\n    },\n\n    b3p1(t, p) {\n        const k = 1 - t;\n        return 3 * k * k * t * p;\n    },\n\n    b3p2(t, p) {\n        const k = 1 - t;\n        return 3 * k * t * t * p;\n    },\n\n    b3p3(t, p) {\n        return t * t * t * p;\n    },\n\n    b3(t, p0, p1, p2, p3) {\n        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Geometry\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    },\n\n    /**\n     * Finds the intersection of a 3D ray with a 3D triangle.\n     *\n     * @private\n     */\n    rayTriangleIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            const EPSILON = 0.000001;\n\n            const edge1 = math.subVec3(b, a, tempVec3);\n            const edge2 = math.subVec3(c, a, tempVec3b);\n\n            const pvec = math.cross3Vec3(dir, edge2, tempVec3c);\n            const det = math.dotVec3(edge1, pvec);\n            if (det < EPSILON) {\n                return null;\n            }\n\n            const tvec = math.subVec3(origin, a, tempVec3d);\n            const u = math.dotVec3(tvec, pvec);\n            if (u < 0 || u > det) {\n                return null;\n            }\n\n            const qvec = math.cross3Vec3(tvec, edge1, tempVec3e);\n            const v = math.dotVec3(dir, qvec);\n            if (v < 0 || u + v > det) {\n                return null;\n            }\n\n            const t = math.dotVec3(edge2, qvec) / det;\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Finds the intersection of a 3D ray with a plane defined by 3 points.\n     *\n     * @private\n     */\n    rayPlaneIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            dir = math.normalizeVec3(dir, tempVec3);\n\n            const edge1 = math.subVec3(b, a, tempVec3b);\n            const edge2 = math.subVec3(c, a, tempVec3c);\n\n            const n = math.cross3Vec3(edge1, edge2, tempVec3d);\n            math.normalizeVec3(n, n);\n\n            const d = -math.dotVec3(a, n);\n\n            const t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);\n\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     *\n     * @private\n     */\n    cartesianToBarycentric: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n\n        return (cartesian, a, b, c, dest) => {\n\n            const v0 = math.subVec3(c, a, tempVec3);\n            const v1 = math.subVec3(b, a, tempVec3b);\n            const v2 = math.subVec3(cartesian, a, tempVec3c);\n\n            const dot00 = math.dotVec3(v0, v0);\n            const dot01 = math.dotVec3(v0, v1);\n            const dot02 = math.dotVec3(v0, v2);\n            const dot11 = math.dotVec3(v1, v1);\n            const dot12 = math.dotVec3(v1, v2);\n\n            const denom = (dot00 * dot11 - dot01 * dot01);\n\n            // Colinear or singular triangle\n\n            if (denom === 0) {\n\n                // Arbitrary location outside of triangle\n\n                return null;\n            }\n\n            const invDenom = 1 / denom;\n\n            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n            dest[0] = 1 - u - v;\n            dest[1] = v;\n            dest[2] = u;\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Returns true if the given barycentric coordinates are within their triangle.\n     *\n     * @private\n     */\n    barycentricInsideTriangle(bary) {\n\n        const v = bary[1];\n        const u = bary[2];\n\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    },\n\n    /**\n     * Gets cartesian coordinates from barycentric coordinates within a triangle.\n     *\n     * @private\n     */\n    barycentricToCartesian(bary, a, b, c, cartesian = math.vec3()) {\n        const u = bary[0];\n        const v = bary[1];\n        const w = bary[2];\n\n        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;\n        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;\n        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;\n\n        return cartesian;\n    },\n\n\n    /**\n     * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n     * modified arrays that have duplicate vertices removed.\n     *\n     * Note: does not work well when co-incident vertices have same positions but different normals and UVs.\n     *\n     * @param positions\n     * @param normals\n     * @param uv\n     * @param indices\n     * @returns {{positions: Array, indices: Array}}\n     * @private\n     */\n    mergeVertices(positions, normals, uv, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        const indicesLookup = [];\n        const uniquePositions = [];\n        const uniqueNormals = normals ? [] : null;\n        const uniqueUV = uv ? [] : null;\n        const indices2 = [];\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let i;\n        let len;\n        let uvi = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = uniquePositions.length / 3;\n                uniquePositions.push(vx);\n                uniquePositions.push(vy);\n                uniquePositions.push(vz);\n                if (normals) {\n                    uniqueNormals.push(normals[i]);\n                    uniqueNormals.push(normals[i + 1]);\n                    uniqueNormals.push(normals[i + 2]);\n                }\n                if (uv) {\n                    uniqueUV.push(uv[uvi]);\n                    uniqueUV.push(uv[uvi + 1]);\n                }\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n            uvi += 2;\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            indices2[i] = indicesLookup[indices[i]];\n        }\n        const result = {\n            positions: uniquePositions,\n            indices: indices2\n        };\n        if (uniqueNormals) {\n            result.normals = uniqueNormals;\n        }\n        if (uniqueUV) {\n            result.uv = uniqueUV;\n\n        }\n        return result;\n    },\n\n    /**\n     * Builds normal vectors from positions and indices.\n     *\n     * @private\n     */\n    buildNormals: ((() => {\n\n        const a = new Float32Array(3);\n        const b = new Float32Array(3);\n        const c = new Float32Array(3);\n        const ab = new Float32Array(3);\n        const ac = new Float32Array(3);\n        const crossVec = new Float32Array(3);\n\n        return (positions, indices, normals) => {\n\n            let i;\n            let len;\n            const nvecs = new Array(positions.length / 3);\n            let j0;\n            let j1;\n            let j2;\n\n            for (i = 0, len = indices.length; i < len; i += 3) {\n\n                j0 = indices[i];\n                j1 = indices[i + 1];\n                j2 = indices[i + 2];\n\n                a[0] = positions[j0 * 3];\n                a[1] = positions[j0 * 3 + 1];\n                a[2] = positions[j0 * 3 + 2];\n\n                b[0] = positions[j1 * 3];\n                b[1] = positions[j1 * 3 + 1];\n                b[2] = positions[j1 * 3 + 2];\n\n                c[0] = positions[j2 * 3];\n                c[1] = positions[j2 * 3 + 1];\n                c[2] = positions[j2 * 3 + 2];\n\n                math.subVec3(b, a, ab);\n                math.subVec3(c, a, ac);\n\n                const normVec = new Float32Array(3);\n\n                math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n                if (!nvecs[j0]) {\n                    nvecs[j0] = [];\n                }\n                if (!nvecs[j1]) {\n                    nvecs[j1] = [];\n                }\n                if (!nvecs[j2]) {\n                    nvecs[j2] = [];\n                }\n\n                nvecs[j0].push(normVec);\n                nvecs[j1].push(normVec);\n                nvecs[j2].push(normVec);\n            }\n\n            normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n            let count;\n            let x;\n            let y;\n            let z;\n\n            for (i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n                count = nvecs[i].length;\n\n                x = 0;\n                y = 0;\n                z = 0;\n\n                for (let j = 0; j < count; j++) {\n                    x += nvecs[i][j][0];\n                    y += nvecs[i][j][1];\n                    z += nvecs[i][j][2];\n                }\n\n                normals[i * 3] = (x / count);\n                normals[i * 3 + 1] = (y / count);\n                normals[i * 3 + 2] = (z / count);\n            }\n\n            return normals;\n        };\n    }))(),\n\n    /**\n     * Builds vertex tangent vectors from positions, UVs and indices.\n     *\n     * @private\n     */\n    buildTangents: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n        const tempVec3f = new Float32Array(3);\n        const tempVec3g = new Float32Array(3);\n\n        return (positions, indices, uv) => {\n\n            const tangents = new Float32Array(positions.length);\n\n            // The vertex arrays needs to be calculated\n            // before the calculation of the tangents\n\n            for (let location = 0; location < indices.length; location += 3) {\n\n                // Recontructing each vertex and UV coordinate into the respective vectors\n\n                let index = indices[location];\n\n                const v0 = positions.subarray(index * 3, index * 3 + 3);\n                const uv0 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 1];\n\n                const v1 = positions.subarray(index * 3, index * 3 + 3);\n                const uv1 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 2];\n\n                const v2 = positions.subarray(index * 3, index * 3 + 3);\n                const uv2 = uv.subarray(index * 2, index * 2 + 2);\n\n                const deltaPos1 = math.subVec3(v1, v0, tempVec3);\n                const deltaPos2 = math.subVec3(v2, v0, tempVec3b);\n\n                const deltaUV1 = math.subVec2(uv1, uv0, tempVec3c);\n                const deltaUV2 = math.subVec2(uv2, uv0, tempVec3d);\n\n                const r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));\n\n                const tangent = math.mulVec3Scalar(\n                    math.subVec3(\n                        math.mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),\n                        math.mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),\n                        tempVec3g\n                    ),\n                    r,\n                    tempVec3f\n                );\n\n                // Average the value of the vectors\n\n                let addTo;\n\n                for (let v = 0; v < 3; v++) {\n                    addTo = indices[location + v] * 3;\n                    tangents[addTo] += tangent[0];\n                    tangents[addTo + 1] += tangent[1];\n                    tangents[addTo + 2] += tangent[2];\n                }\n            }\n\n            return tangents;\n        };\n    }))(),\n\n    /**\n     * Builds vertex and index arrays needed by color-indexed triangle picking.\n     *\n     * @private\n     */\n    buildPickTriangles(positions, indices, compressGeometry) {\n\n        const numIndices = indices.length;\n        const pickPositions = compressGeometry ? new Uint16Array(numIndices * 9) : new Float32Array(numIndices * 9);\n        const pickColors = new Uint8Array(numIndices * 12);\n        let primIndex = 0;\n        let vi;// Positions array index\n        let pvi = 0;// Picking positions array index\n        let pci = 0; // Picking color array index\n\n        // Triangle indices\n        let i;\n        let r;\n        let g;\n        let b;\n        let a;\n\n        for (let location = 0; location < numIndices; location += 3) {\n\n            // Primitive-indexed triangle pick color\n\n            a = (primIndex >> 24 & 0xFF);\n            b = (primIndex >> 16 & 0xFF);\n            g = (primIndex >> 8 & 0xFF);\n            r = (primIndex & 0xFF);\n\n            // A\n\n            i = indices[location];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // B\n\n            i = indices[location + 1];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // C\n\n            i = indices[location + 2];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            primIndex++;\n        }\n\n        return {\n            positions: pickPositions,\n            colors: pickColors\n        };\n    },\n\n    /**\n     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n     * averaging their normal vectors.\n     *\n     * @returns {{positions: Array, normals: *}}\n     */\n    faceToVertexNormals(positions, normals, options = {}) {\n        const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n        const vertexMap = {};\n        const vertexNormals = [];\n        const vertexNormalAccum = {};\n        let acc;\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let posi;\n        let i;\n        let j;\n        let len;\n        let a;\n        let b;\n        let c;\n\n        for (i = 0, len = positions.length; i < len; i += 3) {\n\n            posi = i / 3;\n\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n            if (vertexMap[key] === undefined) {\n                vertexMap[key] = [posi];\n            } else {\n                vertexMap[key].push(posi);\n            }\n\n            const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n            vertexNormals[posi] = normal;\n\n            acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n            vertexNormalAccum[posi] = acc;\n        }\n\n        for (key in vertexMap) {\n\n            if (vertexMap.hasOwnProperty(key)) {\n\n                const vertices = vertexMap[key];\n                const numVerts = vertices.length;\n\n                for (i = 0; i < numVerts; i++) {\n\n                    const ii = vertices[i];\n\n                    acc = vertexNormalAccum[ii];\n\n                    for (j = 0; j < numVerts; j++) {\n\n                        if (i === j) {\n                            continue;\n                        }\n\n                        const jj = vertices[j];\n\n                        a = vertexNormals[ii];\n                        b = vertexNormals[jj];\n\n                        const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                        if (angle < smoothNormalsAngleThreshold) {\n\n                            acc[0] += b[0];\n                            acc[1] += b[1];\n                            acc[2] += b[2];\n                            acc[3] += 1.0;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0, len = normals.length; i < len; i += 3) {\n\n            acc = vertexNormalAccum[i / 3];\n\n            normals[i + 0] = acc[0] / acc[3];\n            normals[i + 1] = acc[1] / acc[3];\n            normals[i + 2] = acc[2] / acc[3];\n\n        }\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Ray casting\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.\n     @method canvasPosToWorldRay\n     @static\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     */\n    canvasPosToWorldRay: ((() => {\n\n        const tempMat4b = new Float32Array(16);\n        const tempMat4c = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n        const tempVec4c = new Float32Array(4);\n        const tempVec4d = new Float32Array(4);\n\n        return (canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir) => {\n\n            const pvMat = math.mulMat4(projMatrix, viewMatrix, tempMat4b);\n            const pvMatInverse = math.inverseMat4(pvMat, tempMat4c);\n\n            // Calculate clip space coordinates, which will be in range\n            // of x=[-1..1] and y=[-1..1], with y=(+1) at top\n\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n\n            const clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates\n            const clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);\n\n            tempVec4a[0] = clipX;\n            tempVec4a[1] = clipY;\n            tempVec4a[2] = -1;\n            tempVec4a[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4a, tempVec4b);\n            math.mulVec4Scalar(tempVec4b, 1 / tempVec4b[3]);\n\n            tempVec4c[0] = clipX;\n            tempVec4c[1] = clipY;\n            tempVec4c[2] = 1;\n            tempVec4c[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4c, tempVec4d);\n            math.mulVec4Scalar(tempVec4d, 1 / tempVec4d[3]);\n\n            worldRayOrigin[0] = tempVec4d[0];\n            worldRayOrigin[1] = tempVec4d[1];\n            worldRayOrigin[2] = tempVec4d[2];\n\n            math.subVec3(tempVec4d, tempVec4b, worldRayDir);\n\n            math.normalizeVec3(worldRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a Canvas-space position to a Mesh's Local-space coordinate system, in the context of a Camera.\n     @method canvasPosToLocalRay\n     @static\n     @param {Camera} camera The Camera.\n     @param {Mesh} mesh The Mesh.\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} worldMatrix Modeling matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    canvasPosToLocalRay: ((() => {\n\n        const worldRayOrigin = new Float32Array(3);\n        const worldRayDir = new Float32Array(3);\n\n        return (canvas, viewMatrix, projMatrix, worldMatrix, canvasPos, localRayOrigin, localRayDir) => {\n            math.canvasPosToWorldRay(canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir);\n            math.worldRayToLocalRay(worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a ray from World-space to a Mesh's Local-space coordinate system.\n     @method worldRayToLocalRay\n     @static\n     @param {Number[]} worldMatrix The World transform matrix\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    worldRayToLocalRay: ((() => {\n\n        const tempMat4 = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n\n        return (worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) => {\n\n            const modelMatInverse = math.inverseMat4(worldMatrix, tempMat4);\n\n            tempVec4a[0] = worldRayOrigin[0];\n            tempVec4a[1] = worldRayOrigin[1];\n            tempVec4a[2] = worldRayOrigin[2];\n            tempVec4a[3] = 1;\n\n            math.transformVec4(modelMatInverse, tempVec4a, tempVec4b);\n\n            localRayOrigin[0] = tempVec4b[0];\n            localRayOrigin[1] = tempVec4b[1];\n            localRayOrigin[2] = tempVec4b[2];\n\n            math.transformVec3(modelMatInverse, worldRayDir, localRayDir);\n        };\n    }))(),\n\n    buildKDTree: ((() => {\n\n        const KD_TREE_MAX_DEPTH = 10;\n        const KD_TREE_MIN_TRIANGLES = 20;\n\n        const dimLength = new Float32Array();\n\n        function buildNode(triangles, indices, positions, depth) {\n            const aabb = new Float32Array(6);\n\n            const node = {\n                triangles: null,\n                left: null,\n                right: null,\n                leaf: false,\n                splitDim: 0,\n                aabb\n            };\n\n            aabb[0] = aabb[1] = aabb[2] = Number.POSITIVE_INFINITY;\n            aabb[3] = aabb[4] = aabb[5] = Number.NEGATIVE_INFINITY;\n\n            let t;\n            let i;\n            let len;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n                var ii = triangles[t] * 3;\n                for (let j = 0; j < 3; ++j) {\n                    const pi = indices[ii + j] * 3;\n                    if (positions[pi] < aabb[0]) {\n                        aabb[0] = positions[pi]\n                    }\n                    if (positions[pi] > aabb[3]) {\n                        aabb[3] = positions[pi]\n                    }\n                    if (positions[pi + 1] < aabb[1]) {\n                        aabb[1] = positions[pi + 1]\n                    }\n                    if (positions[pi + 1] > aabb[4]) {\n                        aabb[4] = positions[pi + 1]\n                    }\n                    if (positions[pi + 2] < aabb[2]) {\n                        aabb[2] = positions[pi + 2]\n                    }\n                    if (positions[pi + 2] > aabb[5]) {\n                        aabb[5] = positions[pi + 2]\n                    }\n                }\n            }\n\n            if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {\n                node.triangles = triangles;\n                node.leaf = true;\n                return node;\n            }\n\n            dimLength[0] = aabb[3] - aabb[0];\n            dimLength[1] = aabb[4] - aabb[1];\n            dimLength[2] = aabb[5] - aabb[2];\n\n            let dim = 0;\n\n            if (dimLength[1] > dimLength[dim]) {\n                dim = 1;\n            }\n\n            if (dimLength[2] > dimLength[dim]) {\n                dim = 2;\n            }\n\n            node.splitDim = dim;\n\n            const mid = (aabb[dim] + aabb[dim + 3]) / 2;\n            const left = new Array(triangles.length);\n            let numLeft = 0;\n            const right = new Array(triangles.length);\n            let numRight = 0;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n\n                var ii = triangles[t] * 3;\n                const i0 = indices[ii];\n                const i1 = indices[ii + 1];\n                const i2 = indices[ii + 2];\n\n                const pi0 = i0 * 3;\n                const pi1 = i1 * 3;\n                const pi2 = i2 * 3;\n\n                if (positions[pi0 + dim] <= mid || positions[pi1 + dim] <= mid || positions[pi2 + dim] <= mid) {\n                    left[numLeft++] = triangles[t];\n                } else {\n                    right[numRight++] = triangles[t];\n                }\n            }\n\n            left.length = numLeft;\n            right.length = numRight;\n\n            node.left = buildNode(left, indices, positions, depth + 1);\n            node.right = buildNode(right, indices, positions, depth + 1);\n\n            return node;\n        }\n\n        return (indices, positions) => {\n            const numTris = indices.length / 3;\n            const triangles = new Array(numTris);\n            for (let i = 0; i < numTris; ++i) {\n                triangles[i] = i;\n            }\n            return buildNode(triangles, indices, positions, 0);\n        };\n    }))(),\n\n\n    decompressPosition(position, decodeMatrix, dest) {\n        dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];\n        dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];\n        dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];\n    },\n\n    decompressPositions(positions, decodeMatrix, dest = new Float32Array(positions.length)) {\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];\n            dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];\n            dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];\n        }\n        return dest;\n    },\n\n    decompressUV(uv, decodeMatrix, dest) {\n        dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];\n        dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];\n    },\n\n    decompressUVs(uvs, decodeMatrix, dest = new Float32Array(uvs.length)) {\n        for (let i = 0, len = uvs.length; i < len; i += 3) {\n            dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];\n            dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];\n        }\n        return dest;\n    },\n\n    octDecodeVec2(oct, result) {\n        let x = oct[0];\n        let y = oct[1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[0] = x / length;\n        result[1] = y / length;\n        result[2] = z / length;\n        return result;\n    },\n\n    octDecodeVec2s(octs, result) {\n        for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n            let x = octs[i + 0];\n            let y = octs[i + 1];\n            x = (2 * x + 1) / 255;\n            y = (2 * y + 1) / 255;\n            const z = 1 - Math.abs(x) - Math.abs(y);\n            if (z < 0) {\n                x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n                y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n            }\n            const length = Math.sqrt(x * x + y * y + z * z);\n            result[j + 0] = x / length;\n            result[j + 1] = y / length;\n            result[j + 2] = z / length;\n            j += 3;\n        }\n        return result;\n    }\n};\n\nmath.buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n    // TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + \",\" + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                dot = math.dotVec3(normal1, normal2);\n                if (dot > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvbWF0aC5qcz9iNWU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1GQUFtRixHQUFHLGVBQWUsRUFBRSxvQkFBb0IsR0FBRyw0QkFBNEIsRUFBRSxxQkFBcUIsR0FBRyxzQkFBc0IsRUFBRSxvQkFBb0IsR0FBRyxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCO0FBQzFYO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrRUFBK0Usb0JBQW9CO0FBQ25HO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsU0FBUzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0JBQWtCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxTQUFTLE9BQU87O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsMkJBQTJCOztBQUU3RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qix1QkFBdUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCOztBQUU1RztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjOztBQUV6Qzs7QUFFQTs7QUFFQSwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG9CQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tYXRoL21hdGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTb21lIHRlbXBvcmFyeSB2YXJzIHRvIGhlbHAgYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cbmNvbnN0IGRvdWJsZVByZWNpc2lvbiA9IHRydWU7XG5jb25zdCBGbG9hdEFycmF5VHlwZSA9IGRvdWJsZVByZWNpc2lvbiA/IEZsb2F0NjRBcnJheSA6IEZsb2F0MzJBcnJheTtcblxuY29uc3QgdGVtcE1hdDEgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcE1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcFZlYzQgPSBuZXcgRmxvYXRBcnJheVR5cGUoNCk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtYXRoID0ge1xuXG4gICAgTUlOX0RPVUJMRTogLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIE1BWF9ET1VCTEU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByYWRpaWFucyBpbiBhIGRlZ3JlZSAoMC4wMTc0NTMyOTI1KS5cbiAgICAgKiBAcHJvcGVydHkgREVHVE9SQURcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIERFR1RPUkFEOiAwLjAxNzQ1MzI5MjUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlZ3JlZXMgaW4gYSByYWRpYW4uXG4gICAgICogQHByb3BlcnR5IFJBRFRPREVHXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBSQURUT0RFRzogNTcuMjk1Nzc5NTEzLFxuXG4gICAgdW5nbG9iYWxpemVPYmplY3RJZChtb2RlbElkLCBnbG9iYWxJZCkge1xuICAgICAgICBjb25zdCBpZHggPSBnbG9iYWxJZC5pbmRleE9mKFwiI1wiKTtcbiAgICAgICAgcmV0dXJuIChpZHggPT09IG1vZGVsSWQubGVuZ3RoICYmIGdsb2JhbElkLnN0YXJ0c1dpdGgobW9kZWxJZCkpID8gZ2xvYmFsSWQuc3Vic3RyaW5nKGlkeCArIDEpIDogZ2xvYmFsSWQ7XG4gICAgfSxcblxuICAgIGdsb2JhbGl6ZU9iamVjdElkKG1vZGVsSWQsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiAobW9kZWxJZCArIFwiI1wiICsgb2JqZWN0SWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjMlxuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjM1xuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCB2ZWM0XG4gICAgICogQHBhcmFtIFt2YWx1ZXNdIEluaXRpYWwgdmFsdWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgdmVjNCh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgNCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM3gzIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDNcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzeDMgbWF0cml4IHRvIDR4NFxuICAgICAqIEBtZXRob2QgbWF0M1RvTWF0NFxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXguXG4gICAgICogQHBhcmFtIG1hdDQgNHg0IG1hdHJpeFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgbWF0M1RvTWF0NChtYXQzLCBtYXQ0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXQ0WzBdID0gbWF0M1swXTtcbiAgICAgICAgbWF0NFsxXSA9IG1hdDNbMV07XG4gICAgICAgIG1hdDRbMl0gPSBtYXQzWzJdO1xuICAgICAgICBtYXQ0WzNdID0gMDtcbiAgICAgICAgbWF0NFs0XSA9IG1hdDNbM107XG4gICAgICAgIG1hdDRbNV0gPSBtYXQzWzRdO1xuICAgICAgICBtYXQ0WzZdID0gbWF0M1s1XTtcbiAgICAgICAgbWF0NFs3XSA9IDA7XG4gICAgICAgIG1hdDRbOF0gPSBtYXQzWzZdO1xuICAgICAgICBtYXQ0WzldID0gbWF0M1s3XTtcbiAgICAgICAgbWF0NFsxMF0gPSBtYXQzWzhdO1xuICAgICAgICBtYXQ0WzExXSA9IDA7XG4gICAgICAgIG1hdDRbMTJdID0gMDtcbiAgICAgICAgbWF0NFsxM10gPSAwO1xuICAgICAgICBtYXQ0WzE0XSA9IDA7XG4gICAgICAgIG1hdDRbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG1hdDQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDRcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQ0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCAxNik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgNHg0IG1hdHJpeCB0byAzeDNcbiAgICAgKiBAbWV0aG9kIG1hdDRUb01hdDNcbiAgICAgKiBAcGFyYW0gbWF0NCA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIG1hdDRUb01hdDMobWF0NCwgbWF0MykgeyAvLyBUT0RPXG4gICAgICAgIC8vcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgOSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiBkb3VibGUtcHJlY2lzaW9uIHZhbHVlcyB0byBhIGxpc3Qgb2YgaGlnaC1wYXJ0IGZsb2F0cyBhbmQgYSBsaXN0IG9mIGxvdy1wYXJ0IGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gZG91YmxlVmFsc1xuICAgICAqIEBwYXJhbSBmbG9hdFZhbHNIaWdoXG4gICAgICogQHBhcmFtIGZsb2F0VmFsc0xvd1xuICAgICAqL1xuICAgIGRvdWJsZXNUb0Zsb2F0cyhkb3VibGVWYWxzLCBmbG9hdFZhbHNIaWdoLCBmbG9hdFZhbHNMb3cpIHtcbiAgICAgICAgY29uc3QgZmxvYXRQYWlyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRvdWJsZVZhbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGguc3BsaXREb3VibGUoZG91YmxlVmFsc1tpXSwgZmxvYXRQYWlyKTtcbiAgICAgICAgICAgIGZsb2F0VmFsc0hpZ2hbaV0gPSBmbG9hdFBhaXJbMF07XG4gICAgICAgICAgICBmbG9hdFZhbHNMb3dbaV0gPSBmbG9hdFBhaXJbMV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgZG91YmxlIHZhbHVlIGludG8gdHdvIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gZmxvYXRQYWlyXG4gICAgICovXG4gICAgc3BsaXREb3VibGUodmFsdWUsIGZsb2F0UGFpcikge1xuICAgICAgICBjb25zdCBoaSA9IEZsb2F0MzJBcnJheS5mcm9tKFt2YWx1ZV0pWzBdO1xuICAgICAgICBjb25zdCBsb3cgPSB2YWx1ZSAtIGhpO1xuICAgICAgICBmbG9hdFBhaXJbMF0gPSBoaTtcbiAgICAgICAgZmxvYXRQYWlyWzFdID0gbG93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFVVSUQuXG4gICAgICogQG1ldGhvZCBjcmVhdGVVVUlEXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4gc3RyaW5nIFRoZSBuZXcgVVVJRFxuICAgICAqL1xuICAgIGNyZWF0ZVVVSUQ6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxmID0ge307XG4gICAgICAgIGNvbnN0IGx1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBsdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgICAgICAgICAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICByZXR1cm4gYCR7bHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXX0tJHtsdXRbZDEgJiAweGZmXX0ke2x1dFtkMSA+PiA4ICYgMHhmZl19LSR7bHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdfSR7bHV0W2QxID4+IDI0ICYgMHhmZl19LSR7bHV0W2QyICYgMHgzZiB8IDB4ODBdfSR7bHV0W2QyID4+IDggJiAweGZmXX0tJHtsdXRbZDIgPj4gMTYgJiAweGZmXX0ke2x1dFtkMiA+PiAyNCAmIDB4ZmZdfSR7bHV0W2QzICYgMHhmZl19JHtsdXRbZDMgPj4gOCAmIDB4ZmZdfSR7bHV0W2QzID4+IDE2ICYgMHhmZl19JHtsdXRbZDMgPj4gMjQgJiAweGZmXX1gO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgdG8gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIExvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gQ2xhbXBlZCByZXN1bHQuXG4gICAgICovXG4gICAgY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmxvYXRpbmctcG9pbnQgbW9kdWx1c1xuICAgICAqIEBtZXRob2QgZm1vZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZm1vZChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIm1hdGguZm1vZCA6IEF0dGVtcHRpbmcgdG8gZmluZCBtb2R1bHVzIHdpdGhpbiBuZWdhdGl2ZSByYW5nZSAtIHdvdWxkIGJlIGluZmluaXRlIGxvb3AgLSBpZ25vcmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiIDw9IGEpIHtcbiAgICAgICAgICAgIGEgLT0gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gMy1lbGVtZW50IHZlY3RvcnMgYXJlIHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSB2MVxuICAgICAqIEBwYXJhbSB2MlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbXBhcmVWZWMzKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gKHYxWzBdID09PSB2MlswXSAmJiB2MVsxXSA9PT0gdjJbMV0gJiYgdjFbMl0gPT09IHYyWzJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbmVnYXRlVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVmVjdG9yIHRvIG5lZ2F0ZVxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBuZWdhdGVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gLXZbMF07XG4gICAgICAgIGRlc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IC12WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBuZWdhdGVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gbmVnYXRlXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG5lZ2F0ZVZlYzQodiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IC12WzFdO1xuICAgICAgICBkZXN0WzJdID0gLXZbMl07XG4gICAgICAgIGRlc3RbM10gPSAtdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgdG8gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICsgdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSArIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICsgdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzY2FsYXIgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICsgcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIHRvIGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBhZGRWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhZGRWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSArIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdICsgdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gKyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNjYWxhciB2YWx1ZSB0byBlYWNoIGVsZW1lbnQgb2YgYSB0aHJlZS1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzNTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgZnJvbSBhbm90aGVyLlxuICAgICAqIEBtZXRob2Qgc3ViVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFZlY3RvciB0byBzdWJ0cmFjdFxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdWJWZWM0KHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAtIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC0gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLSB2WzJdO1xuICAgICAgICBkZXN0WzNdID0gdVszXSAtIHZbM107XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMyh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC0gdlsyXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBvbmUgdHdvLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMih1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdlb21ldHJpYyBtZWFuIG9mIHRoZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZ2VvbWV0cmljTWVhblZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsuLi5BcnJheShOdW1iZXIpfSB2ZWN0b3JzIFZlYzIgdG8gbWVhblxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IFRoZSBnZW9tZXRyaWMgbWVhbiB2ZWMyXG4gICAgICovXG4gICAgZ2VvbWV0cmljTWVhblZlYzIoLi4udmVjdG9ycykge1xuICAgICAgICBjb25zdCBnZW9tZXRyaWNNZWFuID0gbmV3IEZsb2F0QXJyYXlUeXBlKHZlY3RvcnNbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMF0gKz0gdmVjdG9yc1tpXVswXTtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMV0gKz0gdmVjdG9yc1tpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyaWNNZWFuWzBdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICBnZW9tZXRyaWNNZWFuWzFdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cmljTWVhbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGEgc2NhbGFyIHZhbHVlIGZyb20gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN1YlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC0gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLSBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAtIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC0gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZWFjaCBlbGVtZW50IG9mIGEgNC1lbGVtZW50IHZlY3RvciB0byBhIHNjYWxhciB2YWx1ZSBtaW51cyB0aGUgdmFsdWUgb2YgdGhhdCBlbGVtZW50LlxuICAgICAqIEBtZXRob2Qgc3ViU2NhbGFyVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIFRoZSBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHYgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViU2NhbGFyVmVjNCh2LCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBvbmUgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICogdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKiB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSAqIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICogdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzM0Y2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMzU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gKiBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBlYWNoIGVsZW1lbnQgb2YgYSB0d28tZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMyU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMyU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgZm91ci1lbGVtZW50IHZlY3RvciBieSBhbm90aGVyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZGl2VmVjNCh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLyB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAvIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC8gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHVbM10gLyB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLCByZXR1cm5pbmcgYSBuZXcgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgZGl2U2NhbGFyVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZTY2FsYXJWZWMzKHMsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gcyAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSBzIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHMgLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjM1NjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAvIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdIC8gcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gLyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWM0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gcyBzY2FsYXJcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC8gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAvIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC8gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIGZvdXItZWxlbWVudCB2ZWN0b3IsIHJldHVybmluZyBhIG5ldyB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaXZTY2FsYXJWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSBzIHNjYWxhclxuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlNjYWxhclZlYzQocywgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBzIC8gdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHMgLyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gcyAvIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSBzIC8gdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBmb3VyLWVsZW1lbnQgdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBkb3RWZWM0KHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdICsgdVsyXSAqIHZbMl0gKyB1WzNdICogdlszXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIGZvdXItZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBjcm9zcyBwcm9kdWN0XG4gICAgICovXG4gICAgY3Jvc3MzVmVjNCh1LCB2KSB7XG4gICAgICAgIGNvbnN0IHUwID0gdVswXTtcbiAgICAgICAgY29uc3QgdTEgPSB1WzFdO1xuICAgICAgICBjb25zdCB1MiA9IHVbMl07XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB1MSAqIHYyIC0gdTIgKiB2MSxcbiAgICAgICAgICAgIHUyICogdjAgLSB1MCAqIHYyLFxuICAgICAgICAgICAgdTAgKiB2MSAtIHUxICogdjAsXG4gICAgICAgICAgICAwLjBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB0aHJlZS1lbGVtZW50IHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBjcm9zczNWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGNyb3NzIHByb2R1Y3RcbiAgICAgKi9cbiAgICBjcm9zczNWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gdVswXTtcbiAgICAgICAgY29uc3QgeSA9IHVbMV07XG4gICAgICAgIGNvbnN0IHogPSB1WzJdO1xuICAgICAgICBjb25zdCB4MiA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkyID0gdlsxXTtcbiAgICAgICAgY29uc3QgejIgPSB2WzJdO1xuICAgICAgICBkZXN0WzBdID0geSAqIHoyIC0geiAqIHkyO1xuICAgICAgICBkZXN0WzFdID0geiAqIHgyIC0geCAqIHoyO1xuICAgICAgICBkZXN0WzJdID0geCAqIHkyIC0geSAqIHgyO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG5cbiAgICBzcUxlblZlYzQodikgeyAvLyBUT0RPXG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzQodiwgdik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjNCh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzQodikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdGhyZWUtZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzModSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0gKyB1WzJdICogdlsyXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB0d28tZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzIodSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pO1xuICAgIH0sXG5cblxuICAgIHNxTGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzModiwgdik7XG4gICAgfSxcblxuXG4gICAgc3FMZW5WZWMyKHYpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguZG90VmVjMih2LCB2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzModikpO1xuICAgIH0sXG5cbiAgICBkaXN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh2LCB3KSA9PiBtYXRoLmxlblZlYzMobWF0aC5zdWJWZWMzKHYsIHcsIHZlYykpO1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbGVuVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGxlbmd0aFxuICAgICAqL1xuICAgIGxlblZlYzIodikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG1hdGguc3FMZW5WZWMyKHYpKTtcbiAgICB9LFxuXG4gICAgZGlzdFZlYzI6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ZWMgPSBuZXcgRmxvYXRBcnJheVR5cGUoMik7XG4gICAgICAgIHJldHVybiAodiwgdykgPT4gbWF0aC5sZW5WZWMyKG1hdGguc3ViVmVjMih2LCB3LCB2ZWMpKTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcmNwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKlxuICAgICAqL1xuICAgIHJjcFZlYzModiwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5kaXZTY2FsYXJWZWMzKDEuMCwgdiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yXG4gICAgICogQG1ldGhvZCBub3JtYWxpemVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqXG4gICAgICovXG4gICAgbm9ybWFsaXplVmVjNCh2LCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IGYgPSAxLjAgLyBtYXRoLmxlblZlYzQodik7XG4gICAgICAgIHJldHVybiBtYXRoLm11bFZlYzRTY2FsYXIodiwgZiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB0aHJlZS1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMyh2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjM1NjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhIHR3by1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMyKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMih2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjMlNjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAqIEBtZXRob2QgYW5nbGVWZWMzXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcGFyYW0gd1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYW5nbGVWZWMzKHYsIHcpIHtcbiAgICAgICAgbGV0IHRoZXRhID0gbWF0aC5kb3RWZWMzKHYsIHcpIC8gKE1hdGguc3FydChtYXRoLnNxTGVuVmVjMyh2KSAqIG1hdGguc3FMZW5WZWMzKHcpKSk7XG4gICAgICAgIHRoZXRhID0gdGhldGEgPCAtMSA/IC0xIDogKHRoZXRhID4gMSA/IDEgOiB0aGV0YSk7ICAvLyBDbGFtcCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3ModGhldGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgZnJvbSB0aGUgcm90YXRpb24gcGFydCBvZiBhIHNpeHRlZW4tZWxlbWVudCBtYXRyaXguXG4gICAgICogQHBhcmFtIG1cbiAgICAgKiBAcGFyYW0gZGVzdFxuICAgICAqL1xuICAgIHZlYzNGcm9tTWF0NFNjYWxlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcblxuICAgICAgICByZXR1cm4gKG0sIGRlc3QpID0+IHtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzBdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzJdO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzRdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzVdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzZdO1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzhdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzldO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzEwXTtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdGgubGVuVmVjMyh0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gbi1lbGVtZW50IHZlY3RvciB0byBhIEpTT04tc2VyaWFsaXphYmxlXG4gICAgICogYXJyYXkgd2l0aCB2YWx1ZXMgcm91bmRlZCB0byB0d28gZGVjaW1hbCBwbGFjZXMuXG4gICAgICovXG4gICAgdmVjVG9BcnJheTogKCgoKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYgKiAxMDAwMDApIC8gMTAwMDAwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdiA9PiB7XG4gICAgICAgICAgICB2ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZbaV0gPSB0cnVuYyh2W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzLWVsZW1lbnQgdmVjdG9yIGZyb20gYW4gYXJyYXkgdG8gYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGBgYGB7eDo5OTksIHk6OTk5LCB6Ojk5OX1gYGBgLlxuICAgICAqIEBwYXJhbSBhcnJcbiAgICAgKiBAcmV0dXJucyB7e3g6ICosIHk6ICosIHo6ICp9fVxuICAgICAqL1xuICAgIHh5ekFycmF5VG9PYmplY3QoYXJyKSB7XG4gICAgICAgIHJldHVybiB7XCJ4XCI6IGFyclswXSwgXCJ5XCI6IGFyclsxXSwgXCJ6XCI6IGFyclsyXX07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgMy1lbGVtZW50IHZlY3RvciBvYmplY3Qgb2YgdGhlIGZvcm0gYGBgYHt4Ojk5OSwgeTo5OTksIHo6OTk5fWBgYGAgdG8gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSAgW2FycnldXG4gICAgICogQHJldHVybnMgeypbXX1cbiAgICAgKi9cbiAgICB4eXpPYmplY3RUb0FycmF5KHh5eiwgYXJyeSkge1xuICAgICAgICBhcnJ5ID0gYXJyeSB8fCBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGFycnlbMF0gPSB4eXoueDtcbiAgICAgICAgYXJyeVsxXSA9IHh5ei55O1xuICAgICAgICBhcnJ5WzJdID0geHl6Lno7XG4gICAgICAgIHJldHVybiBhcnJ5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEdXBsaWNhdGVzIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGR1cE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZHVwTWF0NChtKSB7XG4gICAgICAgIHJldHVybiBtLnNsaWNlKDAsIDE2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYSAzeDMgbWF0cml4IGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgbWF0NFRvM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBtYXQ0VG8zKG0pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sXG4gICAgICAgICAgICBtWzRdLCBtWzVdLCBtWzZdLFxuICAgICAgICAgICAgbVs4XSwgbVs5XSwgbVsxMF1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUuXG4gICAgICogQG1ldGhvZCBtNHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbTRzKHMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHMsIHMsIHMsIHMsXG4gICAgICAgICAgICBzLCBzLCBzLCBzLFxuICAgICAgICAgICAgcywgcywgcywgcyxcbiAgICAgICAgICAgIHMsIHMsIHMsIHNcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHplcm8uXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9aZXJvZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvWmVyb2VzKCkge1xuICAgICAgICByZXR1cm4gbWF0aC5tNHMoMC4wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIDEuMC5cbiAgICAgKiBAbWV0aG9kIHNldE1hdDRUb09uZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvT25lcygpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubTRzKDEuMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZWFjaCBlbGVtZW50IHNldCB0byAxLjAuXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9PbmVzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHYodikge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKFtcbiAgICAgICAgICAgIHZbMF0sIDAuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgICAwLjAsIHZbMV0sIDAuMCwgMC4wLFxuICAgICAgICAgICAgMC4wLCAwLjAsIHZbMl0sIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIHZbM11cbiAgICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NGMoeCwgeSwgeiwgdykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDR2KFt4LCB5LCB6LCB3XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHMocykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDRjKHMsIHMsIHMsIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGlkZW50aXR5TWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpZGVudGl0eU1hdDQobWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuICAgICAgICBtYXRbM10gPSAwLjA7XG5cbiAgICAgICAgbWF0WzRdID0gMC4wO1xuICAgICAgICBtYXRbNV0gPSAxLjA7XG4gICAgICAgIG1hdFs2XSA9IDAuMDtcbiAgICAgICAgbWF0WzddID0gMC4wO1xuXG4gICAgICAgIG1hdFs4XSA9IDAuMDtcbiAgICAgICAgbWF0WzldID0gMC4wO1xuICAgICAgICBtYXRbMTBdID0gMS4wO1xuICAgICAgICBtYXRbMTFdID0gMC4wO1xuXG4gICAgICAgIG1hdFsxMl0gPSAwLjA7XG4gICAgICAgIG1hdFsxM10gPSAwLjA7XG4gICAgICAgIG1hdFsxNF0gPSAwLjA7XG4gICAgICAgIG1hdFsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG1hdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDN4MyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBpZGVudGl0eU1hdDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaWRlbnRpdHlNYXQzKG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuXG4gICAgICAgIG1hdFszXSA9IDAuMDtcbiAgICAgICAgbWF0WzRdID0gMS4wO1xuICAgICAgICBtYXRbNV0gPSAwLjA7XG5cbiAgICAgICAgbWF0WzZdID0gMC4wO1xuICAgICAgICBtYXRbN10gPSAwLjA7XG4gICAgICAgIG1hdFs4XSA9IDEuMDtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeCBpcyB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqIEBtZXRob2QgaXNJZGVudGl0eU1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNJZGVudGl0eU1hdDQobSkge1xuICAgICAgICBpZiAobVswXSAhPT0gMS4wIHx8IG1bMV0gIT09IDAuMCB8fCBtWzJdICE9PSAwLjAgfHwgbVszXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzRdICE9PSAwLjAgfHwgbVs1XSAhPT0gMS4wIHx8IG1bNl0gIT09IDAuMCB8fCBtWzddICE9PSAwLjAgfHxcbiAgICAgICAgICAgIG1bOF0gIT09IDAuMCB8fCBtWzldICE9PSAwLjAgfHwgbVsxMF0gIT09IDEuMCB8fCBtWzExXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzEyXSAhPT0gMC4wIHx8IG1bMTNdICE9PSAwLjAgfHwgbVsxNF0gIT09IDAuMCB8fCBtWzE1XSAhPT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBuZWdhdGVNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG5lZ2F0ZU1hdDQobSwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1tWzFdO1xuICAgICAgICBkZXN0WzJdID0gLW1bMl07XG4gICAgICAgIGRlc3RbM10gPSAtbVszXTtcbiAgICAgICAgZGVzdFs0XSA9IC1tWzRdO1xuICAgICAgICBkZXN0WzVdID0gLW1bNV07XG4gICAgICAgIGRlc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgZGVzdFs3XSA9IC1tWzddO1xuICAgICAgICBkZXN0WzhdID0gLW1bOF07XG4gICAgICAgIGRlc3RbOV0gPSAtbVs5XTtcbiAgICAgICAgZGVzdFsxMF0gPSAtbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gLW1bMTFdO1xuICAgICAgICBkZXN0WzEyXSA9IC1tWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSAtbVsxM107XG4gICAgICAgIGRlc3RbMTRdID0gLW1bMTRdO1xuICAgICAgICBkZXN0WzE1XSA9IC1tWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIDR4NCBtYXRyaWNlcyB0b2dldGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBkZXN0WzFdID0gYVsxXSArIGJbMV07XG4gICAgICAgIGRlc3RbMl0gPSBhWzJdICsgYlsyXTtcbiAgICAgICAgZGVzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICBkZXN0WzRdID0gYVs0XSArIGJbNF07XG4gICAgICAgIGRlc3RbNV0gPSBhWzVdICsgYls1XTtcbiAgICAgICAgZGVzdFs2XSA9IGFbNl0gKyBiWzZdO1xuICAgICAgICBkZXN0WzddID0gYVs3XSArIGJbN107XG4gICAgICAgIGRlc3RbOF0gPSBhWzhdICsgYls4XTtcbiAgICAgICAgZGVzdFs5XSA9IGFbOV0gKyBiWzldO1xuICAgICAgICBkZXN0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICAgICAgZGVzdFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gICAgICAgIGRlc3RbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICAgICAgZGVzdFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NFNjYWxhcihtLCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKyBzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSArIHM7XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdICsgcztcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKyBzO1xuICAgICAgICBkZXN0WzRdID0gbVs0XSArIHM7XG4gICAgICAgIGRlc3RbNV0gPSBtWzVdICsgcztcbiAgICAgICAgZGVzdFs2XSA9IG1bNl0gKyBzO1xuICAgICAgICBkZXN0WzddID0gbVs3XSArIHM7XG4gICAgICAgIGRlc3RbOF0gPSBtWzhdICsgcztcbiAgICAgICAgZGVzdFs5XSA9IG1bOV0gKyBzO1xuICAgICAgICBkZXN0WzEwXSA9IG1bMTBdICsgcztcbiAgICAgICAgZGVzdFsxMV0gPSBtWzExXSArIHM7XG4gICAgICAgIGRlc3RbMTJdID0gbVsxMl0gKyBzO1xuICAgICAgICBkZXN0WzEzXSA9IG1bMTNdICsgcztcbiAgICAgICAgZGVzdFsxNF0gPSBtWzE0XSArIHM7XG4gICAgICAgIGRlc3RbMTVdID0gbVsxNV0gKyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZFNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmFkZE1hdDRTY2FsYXIobSwgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgc2Vjb25kIDR4NCBtYXRyaXggZnJvbSB0aGUgZmlyc3QuXG4gICAgICogQG1ldGhvZCBzdWJNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN1Yk1hdDQoYSwgYiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGRlc3RbM10gPSBhWzNdIC0gYlszXTtcbiAgICAgICAgZGVzdFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgICAgICBkZXN0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgICAgIGRlc3RbNl0gPSBhWzZdIC0gYls2XTtcbiAgICAgICAgZGVzdFs3XSA9IGFbN10gLSBiWzddO1xuICAgICAgICBkZXN0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgICAgIGRlc3RbOV0gPSBhWzldIC0gYls5XTtcbiAgICAgICAgZGVzdFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICAgICAgICBkZXN0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICAgICAgICBkZXN0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gc2NhbGFyIGZyb20gZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc3ViTWF0NFNjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdWJNYXQ0U2NhbGFyKG0sIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gbVswXSAtIHM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdIC0gcztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gLSBzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAtIHM7XG4gICAgICAgIGRlc3RbNF0gPSBtWzRdIC0gcztcbiAgICAgICAgZGVzdFs1XSA9IG1bNV0gLSBzO1xuICAgICAgICBkZXN0WzZdID0gbVs2XSAtIHM7XG4gICAgICAgIGRlc3RbN10gPSBtWzddIC0gcztcbiAgICAgICAgZGVzdFs4XSA9IG1bOF0gLSBzO1xuICAgICAgICBkZXN0WzldID0gbVs5XSAtIHM7XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF0gLSBzO1xuICAgICAgICBkZXN0WzExXSA9IG1bMTFdIC0gcztcbiAgICAgICAgZGVzdFsxMl0gPSBtWzEyXSAtIHM7XG4gICAgICAgIGRlc3RbMTNdID0gbVsxM10gLSBzO1xuICAgICAgICBkZXN0WzE0XSA9IG1bMTRdIC0gcztcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XSAtIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHN1YlNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3ViU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSBtWzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gbVsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSBtWzNdO1xuICAgICAgICBkZXN0WzRdID0gcyAtIG1bNF07XG4gICAgICAgIGRlc3RbNV0gPSBzIC0gbVs1XTtcbiAgICAgICAgZGVzdFs2XSA9IHMgLSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gcyAtIG1bN107XG4gICAgICAgIGRlc3RbOF0gPSBzIC0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IHMgLSBtWzldO1xuICAgICAgICBkZXN0WzEwXSA9IHMgLSBtWzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBzIC0gbVsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gcyAtIG1bMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IHMgLSBtWzEzXTtcbiAgICAgICAgZGVzdFsxNF0gPSBzIC0gbVsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gcyAtIG1bMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgdHdvIGdpdmVuIDR4NCBtYXRyaXggYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gYVswXTtcblxuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzddO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzldO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdO1xuICAgICAgICBjb25zdCBiMDAgPSBiWzBdO1xuICAgICAgICBjb25zdCBiMDEgPSBiWzFdO1xuICAgICAgICBjb25zdCBiMDIgPSBiWzJdO1xuICAgICAgICBjb25zdCBiMDMgPSBiWzNdO1xuICAgICAgICBjb25zdCBiMTAgPSBiWzRdO1xuICAgICAgICBjb25zdCBiMTEgPSBiWzVdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzZdO1xuICAgICAgICBjb25zdCBiMTMgPSBiWzddO1xuICAgICAgICBjb25zdCBiMjAgPSBiWzhdO1xuICAgICAgICBjb25zdCBiMjEgPSBiWzldO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzEwXTtcbiAgICAgICAgY29uc3QgYjIzID0gYlsxMV07XG4gICAgICAgIGNvbnN0IGIzMCA9IGJbMTJdO1xuICAgICAgICBjb25zdCBiMzEgPSBiWzEzXTtcbiAgICAgICAgY29uc3QgYjMyID0gYlsxNF07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbMTVdO1xuXG4gICAgICAgIGRlc3RbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzA7XG4gICAgICAgIGRlc3RbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzE7XG4gICAgICAgIGRlc3RbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzI7XG4gICAgICAgIGRlc3RbM10gPSBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzM7XG4gICAgICAgIGRlc3RbNF0gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzA7XG4gICAgICAgIGRlc3RbNV0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzE7XG4gICAgICAgIGRlc3RbNl0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzI7XG4gICAgICAgIGRlc3RbN10gPSBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzM7XG4gICAgICAgIGRlc3RbOF0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzA7XG4gICAgICAgIGRlc3RbOV0gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzE7XG4gICAgICAgIGRlc3RbMTBdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyICsgYjIzICogYTMyO1xuICAgICAgICBkZXN0WzExXSA9IGIyMCAqIGEwMyArIGIyMSAqIGExMyArIGIyMiAqIGEyMyArIGIyMyAqIGEzMztcbiAgICAgICAgZGVzdFsxMl0gPSBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzA7XG4gICAgICAgIGRlc3RbMTNdID0gYjMwICogYTAxICsgYjMxICogYTExICsgYjMyICogYTIxICsgYjMzICogYTMxO1xuICAgICAgICBkZXN0WzE0XSA9IGIzMCAqIGEwMiArIGIzMSAqIGExMiArIGIzMiAqIGEyMiArIGIzMyAqIGEzMjtcbiAgICAgICAgZGVzdFsxNV0gPSBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIHR3byBnaXZlbiAzeDMgbWF0cmljZXMgYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0MyhhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGExMSA9IGFbMF07XG4gICAgICAgIGNvbnN0IGExMiA9IGFbM107XG4gICAgICAgIGNvbnN0IGExMyA9IGFbNl07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEyMiA9IGFbNF07XG4gICAgICAgIGNvbnN0IGEyMyA9IGFbN107XG4gICAgICAgIGNvbnN0IGEzMSA9IGFbMl07XG4gICAgICAgIGNvbnN0IGEzMiA9IGFbNV07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbOF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbMF07XG4gICAgICAgIGNvbnN0IGIxMiA9IGJbM107XG4gICAgICAgIGNvbnN0IGIxMyA9IGJbNl07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGIyMiA9IGJbNF07XG4gICAgICAgIGNvbnN0IGIyMyA9IGJbN107XG4gICAgICAgIGNvbnN0IGIzMSA9IGJbMl07XG4gICAgICAgIGNvbnN0IGIzMiA9IGJbNV07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbOF07XG5cbiAgICAgICAgZGVzdFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcbiAgICAgICAgZGVzdFszXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcbiAgICAgICAgZGVzdFs2XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMztcblxuICAgICAgICBkZXN0WzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xuICAgICAgICBkZXN0WzRdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuICAgICAgICBkZXN0WzddID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xuXG4gICAgICAgIGRlc3RbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG4gICAgICAgIGRlc3RbNV0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG4gICAgICAgIGRlc3RbOF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4IGJ5IHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG11bE1hdDRTY2FsYXIobSwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IG1bMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogcztcbiAgICAgICAgZGVzdFs0XSA9IG1bNF0gKiBzO1xuICAgICAgICBkZXN0WzVdID0gbVs1XSAqIHM7XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdICogcztcbiAgICAgICAgZGVzdFs3XSA9IG1bN10gKiBzO1xuICAgICAgICBkZXN0WzhdID0gbVs4XSAqIHM7XG4gICAgICAgIGRlc3RbOV0gPSBtWzldICogcztcbiAgICAgICAgZGVzdFsxMF0gPSBtWzEwXSAqIHM7XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV0gKiBzO1xuICAgICAgICBkZXN0WzEyXSA9IG1bMTJdICogcztcbiAgICAgICAgZGVzdFsxM10gPSBtWzEzXSAqIHM7XG4gICAgICAgIGRlc3RbMTRdID0gbVsxNF0gKiBzO1xuICAgICAgICBkZXN0WzE1XSA9IG1bMTVdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXggYnkgdGhlIGdpdmVuIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0djRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NHY0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogdjAgKyBtWzRdICogdjEgKyBtWzhdICogdjIgKyBtWzEyXSAqIHYzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHYwICsgbVs1XSAqIHYxICsgbVs5XSAqIHYyICsgbVsxM10gKiB2MztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gKiB2MCArIG1bNl0gKiB2MSArIG1bMTBdICogdjIgKyBtWzE0XSAqIHYzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAqIHYwICsgbVs3XSAqIHYxICsgbVsxMV0gKiB2MiArIG1bMTVdICogdjM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNwb3NlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc3Bvc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgICAgIGNvbnN0IG00ID0gbWF0WzRdO1xuXG4gICAgICAgIGNvbnN0IG0xNCA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IG04ID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbMTNdO1xuICAgICAgICBjb25zdCBtMTIgPSBtYXRbMTJdO1xuICAgICAgICBjb25zdCBtOSA9IG1hdFs5XTtcbiAgICAgICAgaWYgKCFkZXN0IHx8IG1hdCA9PT0gZGVzdCkge1xuICAgICAgICAgICAgY29uc3QgYTAxID0gbWF0WzFdO1xuICAgICAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICAgICAgY29uc3QgYTAzID0gbWF0WzNdO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gbWF0WzZdO1xuICAgICAgICAgICAgY29uc3QgYTEzID0gbWF0WzddO1xuICAgICAgICAgICAgY29uc3QgYTIzID0gbWF0WzExXTtcbiAgICAgICAgICAgIG1hdFsxXSA9IG00O1xuICAgICAgICAgICAgbWF0WzJdID0gbTg7XG4gICAgICAgICAgICBtYXRbM10gPSBtMTI7XG4gICAgICAgICAgICBtYXRbNF0gPSBhMDE7XG4gICAgICAgICAgICBtYXRbNl0gPSBtOTtcbiAgICAgICAgICAgIG1hdFs3XSA9IG0xMztcbiAgICAgICAgICAgIG1hdFs4XSA9IGEwMjtcbiAgICAgICAgICAgIG1hdFs5XSA9IGExMjtcbiAgICAgICAgICAgIG1hdFsxMV0gPSBtMTQ7XG4gICAgICAgICAgICBtYXRbMTJdID0gYTAzO1xuICAgICAgICAgICAgbWF0WzEzXSA9IGExMztcbiAgICAgICAgICAgIG1hdFsxNF0gPSBhMjM7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgIGRlc3RbMV0gPSBtNDtcbiAgICAgICAgZGVzdFsyXSA9IG04O1xuICAgICAgICBkZXN0WzNdID0gbTEyO1xuICAgICAgICBkZXN0WzRdID0gbWF0WzFdO1xuICAgICAgICBkZXN0WzVdID0gbWF0WzVdO1xuICAgICAgICBkZXN0WzZdID0gbTk7XG4gICAgICAgIGRlc3RbN10gPSBtMTM7XG4gICAgICAgIGRlc3RbOF0gPSBtYXRbMl07XG4gICAgICAgIGRlc3RbOV0gPSBtYXRbNl07XG4gICAgICAgIGRlc3RbMTBdID0gbWF0WzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBtMTQ7XG4gICAgICAgIGRlc3RbMTJdID0gbWF0WzNdO1xuICAgICAgICBkZXN0WzEzXSA9IG1hdFs3XTtcbiAgICAgICAgZGVzdFsxNF0gPSBtYXRbMTFdO1xuICAgICAgICBkZXN0WzE1XSA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiAzeDMgbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0cmFuc3Bvc2VNYXQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zcG9zZU1hdDMobWF0LCBkZXN0KSB7XG4gICAgICAgIGlmIChkZXN0ID09PSBtYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgICAgIGNvbnN0IGEwMiA9IG1hdFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IG1hdFs1XTtcbiAgICAgICAgICAgIGRlc3RbMV0gPSBtYXRbM107XG4gICAgICAgICAgICBkZXN0WzJdID0gbWF0WzZdO1xuICAgICAgICAgICAgZGVzdFszXSA9IGEwMTtcbiAgICAgICAgICAgIGRlc3RbNV0gPSBtYXRbN107XG4gICAgICAgICAgICBkZXN0WzZdID0gYTAyO1xuICAgICAgICAgICAgZGVzdFs3XSA9IGExMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0WzNdO1xuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdFs2XTtcbiAgICAgICAgICAgIGRlc3RbM10gPSBtYXRbMV07XG4gICAgICAgICAgICBkZXN0WzRdID0gbWF0WzRdO1xuICAgICAgICAgICAgZGVzdFs1XSA9IG1hdFs3XTtcbiAgICAgICAgICAgIGRlc3RbNl0gPSBtYXRbMl07XG4gICAgICAgICAgICBkZXN0WzddID0gbWF0WzVdO1xuICAgICAgICAgICAgZGVzdFs4XSA9IG1hdFs4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBkZXRlcm1pbmFudE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZGV0ZXJtaW5hbnRNYXQ0KG1hdCkge1xuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBhMzAgKiBhMjEgKiBhMTIgKiBhMDMgLSBhMjAgKiBhMzEgKiBhMTIgKiBhMDMgLSBhMzAgKiBhMTEgKiBhMjIgKiBhMDMgKyBhMTAgKiBhMzEgKiBhMjIgKiBhMDMgK1xuICAgICAgICAgICAgYTIwICogYTExICogYTMyICogYTAzIC0gYTEwICogYTIxICogYTMyICogYTAzIC0gYTMwICogYTIxICogYTAyICogYTEzICsgYTIwICogYTMxICogYTAyICogYTEzICtcbiAgICAgICAgICAgIGEzMCAqIGEwMSAqIGEyMiAqIGExMyAtIGEwMCAqIGEzMSAqIGEyMiAqIGExMyAtIGEyMCAqIGEwMSAqIGEzMiAqIGExMyArIGEwMCAqIGEyMSAqIGEzMiAqIGExMyArXG4gICAgICAgICAgICBhMzAgKiBhMTEgKiBhMDIgKiBhMjMgLSBhMTAgKiBhMzEgKiBhMDIgKiBhMjMgLSBhMzAgKiBhMDEgKiBhMTIgKiBhMjMgKyBhMDAgKiBhMzEgKiBhMTIgKiBhMjMgK1xuICAgICAgICAgICAgYTEwICogYTAxICogYTMyICogYTIzIC0gYTAwICogYTExICogYTMyICogYTIzIC0gYTIwICogYTExICogYTAyICogYTMzICsgYTEwICogYTIxICogYTAyICogYTMzICtcbiAgICAgICAgICAgIGEyMCAqIGEwMSAqIGExMiAqIGEzMyAtIGEwMCAqIGEyMSAqIGExMiAqIGEzMyAtIGExMCAqIGEwMSAqIGEyMiAqIGEzMyArIGEwMCAqIGExMSAqIGEyMiAqIGEzMztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGludmVyc2VNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGludmVyc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCAoaW5saW5lZCB0byBhdm9pZCBkb3VibGUtY2FjaGluZylcbiAgICAgICAgY29uc3QgaW52RGV0ID0gMSAvIChiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgICAgIGRlc3RbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxXSA9ICgtYTAxICogYjExICsgYTAyICogYjEwIC0gYTAzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzNdID0gKC1hMjEgKiBiMDUgKyBhMjIgKiBiMDQgLSBhMjMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzRdID0gKC1hMTAgKiBiMTEgKyBhMTIgKiBiMDggLSBhMTMgKiBiMDcpICogaW52RGV0O1xuICAgICAgICBkZXN0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbNl0gPSAoLWEzMCAqIGIwNSArIGEzMiAqIGIwMiAtIGEzMyAqIGIwMSkgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGludkRldDtcbiAgICAgICAgZGVzdFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzldID0gKC1hMDAgKiBiMTAgKyBhMDEgKiBiMDggLSBhMDMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzExXSA9ICgtYTIwICogYjA0ICsgYTIxICogYjAyIC0gYTIzICogYjAwKSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxMl0gPSAoLWExMCAqIGIwOSArIGExMSAqIGIwNyAtIGExMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTRdID0gKC1hMzAgKiBiMDMgKyBhMzEgKiBiMDEgLSBhMzIgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogaW52RGV0O1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFjZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYWNlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFjZU1hdDQobSkge1xuICAgICAgICByZXR1cm4gKG1bMF0gKyBtWzVdICsgbVsxMF0gKyBtWzE1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDR2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgbVsxMl0gPSB2WzBdO1xuICAgICAgICBtWzEzXSA9IHZbMV07XG4gICAgICAgIG1bMTRdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0M1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDN2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDMoKTtcbiAgICAgICAgbVs2XSA9IHZbMF07XG4gICAgICAgIG1bN10gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRpb25NYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDRjOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgeHl6ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICByZXR1cm4gKHgsIHksIHosIGRlc3QpID0+IHtcbiAgICAgICAgICAgIHh5elswXSA9IHg7XG4gICAgICAgICAgICB4eXpbMV0gPSB5O1xuICAgICAgICAgICAgeHl6WzJdID0gejtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNsYXRpb25NYXQ0cyhzLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NGMocywgcywgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWF0NHYoeHl6LCBtKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0ZU1hdDRjKHh5elswXSwgeHl6WzFdLCB4eXpbMl0sIG0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnRseSBwb3N0LWNvbmNhdGVuYXRlcyBhIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB6XG4gICAgICogQHBhcmFtIG1cbiAgICAgKi9cbiAgICBPTER0cmFuc2xhdGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIG1bMF0gKz0gbTEyICogeDtcbiAgICAgICAgbVs0XSArPSBtMTIgKiB5O1xuICAgICAgICBtWzhdICs9IG0xMiAqIHo7XG5cbiAgICAgICAgY29uc3QgbTEzID0gbVsxM107XG4gICAgICAgIG1bMV0gKz0gbTEzICogeDtcbiAgICAgICAgbVs1XSArPSBtMTMgKiB5O1xuICAgICAgICBtWzldICs9IG0xMyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIG1bMl0gKz0gbTE0ICogeDtcbiAgICAgICAgbVs2XSArPSBtMTQgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTQgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzNdICs9IG0xNSAqIHg7XG4gICAgICAgIG1bN10gKz0gbTE1ICogeTtcbiAgICAgICAgbVsxMV0gKz0gbTE1ICogejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlTWF0NGMoeCwgeSwgeiwgbSkge1xuXG4gICAgICAgIGNvbnN0IG0zID0gbVszXTtcbiAgICAgICAgbVswXSArPSBtMyAqIHg7XG4gICAgICAgIG1bMV0gKz0gbTMgKiB5O1xuICAgICAgICBtWzJdICs9IG0zICogejtcblxuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIG1bNF0gKz0gbTcgKiB4O1xuICAgICAgICBtWzVdICs9IG03ICogeTtcbiAgICAgICAgbVs2XSArPSBtNyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIG1bOF0gKz0gbTExICogeDtcbiAgICAgICAgbVs5XSArPSBtMTEgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTEgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzEyXSArPSBtMTUgKiB4O1xuICAgICAgICBtWzEzXSArPSBtMTUgKiB5O1xuICAgICAgICBtWzE0XSArPSBtMTUgKiB6O1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCB0aGF0IHJlcGxhY2VzIHRoZSB0cmFuc2xhdGlvbiBpbiB0aGUgcmlnaHRtb3N0IGNvbHVtbiBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBhZmZpbmUgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSBtXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIGRlc3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRNYXQ0VHJhbnNsYXRpb24obSwgdHJhbnNsYXRpb24sIGRlc3QpIHtcblxuICAgICAgICBkZXN0WzBdID0gbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdO1xuICAgICAgICBkZXN0WzNdID0gbVszXTtcblxuICAgICAgICBkZXN0WzRdID0gbVs0XTtcbiAgICAgICAgZGVzdFs1XSA9IG1bNV07XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gbVs3XTtcblxuICAgICAgICBkZXN0WzhdID0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IG1bOV07XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV07XG5cbiAgICAgICAgZGVzdFsxMl0gPSB0cmFuc2xhdGlvblswXTtcbiAgICAgICAgZGVzdFsxM10gPSB0cmFuc2xhdGlvblsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB0cmFuc2xhdGlvblsyXTtcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgcm90YXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgcm90YXRpb25NYXQ0dlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICByb3RhdGlvbk1hdDR2KGFuZ2xlcmFkLCBheGlzLCBtKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gbWF0aC5ub3JtYWxpemVWZWM0KFtheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdLCAwLjBdLCBbXSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IHEgPSAxLjAgLSBjO1xuXG4gICAgICAgIGNvbnN0IHggPSBheFswXTtcbiAgICAgICAgY29uc3QgeSA9IGF4WzFdO1xuICAgICAgICBjb25zdCB6ID0gYXhbMl07XG5cbiAgICAgICAgbGV0IHh5O1xuICAgICAgICBsZXQgeXo7XG4gICAgICAgIGxldCB6eDtcbiAgICAgICAgbGV0IHhzO1xuICAgICAgICBsZXQgeXM7XG4gICAgICAgIGxldCB6cztcblxuICAgICAgICAvL3h4ID0geCAqIHg7IHVzZWQgb25jZVxuICAgICAgICAvL3l5ID0geSAqIHk7IHVzZWQgb25jZVxuICAgICAgICAvL3p6ID0geiAqIHo7IHVzZWQgb25jZVxuICAgICAgICB4eSA9IHggKiB5O1xuICAgICAgICB5eiA9IHkgKiB6O1xuICAgICAgICB6eCA9IHogKiB4O1xuICAgICAgICB4cyA9IHggKiBzO1xuICAgICAgICB5cyA9IHkgKiBzO1xuICAgICAgICB6cyA9IHogKiBzO1xuXG4gICAgICAgIG0gPSBtIHx8IG1hdGgubWF0NCgpO1xuXG4gICAgICAgIG1bMF0gPSAocSAqIHggKiB4KSArIGM7XG4gICAgICAgIG1bMV0gPSAocSAqIHh5KSArIHpzO1xuICAgICAgICBtWzJdID0gKHEgKiB6eCkgLSB5cztcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gKHEgKiB4eSkgLSB6cztcbiAgICAgICAgbVs1XSA9IChxICogeSAqIHkpICsgYztcbiAgICAgICAgbVs2XSA9IChxICogeXopICsgeHM7XG4gICAgICAgIG1bN10gPSAwLjA7XG5cbiAgICAgICAgbVs4XSA9IChxICogengpICsgeXM7XG4gICAgICAgIG1bOV0gPSAocSAqIHl6KSAtIHhzO1xuICAgICAgICBtWzEwXSA9IChxICogeiAqIHopICsgYztcbiAgICAgICAgbVsxMV0gPSAwLjA7XG5cbiAgICAgICAgbVsxMl0gPSAwLjA7XG4gICAgICAgIG1bMTNdID0gMC4wO1xuICAgICAgICBtWzE0XSA9IDAuMDtcbiAgICAgICAgbVsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHJvdGF0aW9uTWF0NGNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcm90YXRpb25NYXQ0YyhhbmdsZXJhZCwgeCwgeSwgeiwgbWF0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnJvdGF0aW9uTWF0NHYoYW5nbGVyYWQsIFt4LCB5LCB6XSwgbWF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0dih2LCBtID0gbWF0aC5pZGVudGl0eU1hdDQoKSkge1xuICAgICAgICBtWzBdID0gdlswXTtcbiAgICAgICAgbVs1XSA9IHZbMV07XG4gICAgICAgIG1bMTBdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHNjYWxlIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHNjYWxpbmdNYXQzdlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzY2FsaW5nTWF0M3YodiwgbSA9IG1hdGguaWRlbnRpdHlNYXQzKCkpIHtcbiAgICAgICAgbVswXSA9IHZbMF07XG4gICAgICAgIG1bNF0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0YzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHh5eiA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh4LCB5LCB6LCBkZXN0KSA9PiB7XG4gICAgICAgICAgICB4eXpbMF0gPSB4O1xuICAgICAgICAgICAgeHl6WzFdID0geTtcbiAgICAgICAgICAgIHh5elsyXSA9IHo7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsaW5nTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgc2NhbGluZyB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGVNYXQ0Y1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gelxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgbVswXSAqPSB4O1xuICAgICAgICBtWzRdICo9IHk7XG4gICAgICAgIG1bOF0gKj0gejtcblxuICAgICAgICBtWzFdICo9IHg7XG4gICAgICAgIG1bNV0gKj0geTtcbiAgICAgICAgbVs5XSAqPSB6O1xuXG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuXG4gICAgICAgIG1bM10gKj0geDtcbiAgICAgICAgbVs3XSAqPSB5O1xuICAgICAgICBtWzExXSAqPSB6O1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRWZmaWNpZW50bHkgcG9zdC1jb25jYXRlbmF0ZXMgYSBzY2FsaW5nIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBzY2FsZU1hdDRjXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0dih4eXosIG0pIHtcblxuICAgICAgICBjb25zdCB4ID0geHl6WzBdO1xuICAgICAgICBjb25zdCB5ID0geHl6WzFdO1xuICAgICAgICBjb25zdCB6ID0geHl6WzJdO1xuXG4gICAgICAgIG1bMF0gKj0geDtcbiAgICAgICAgbVs0XSAqPSB5O1xuICAgICAgICBtWzhdICo9IHo7XG4gICAgICAgIG1bMV0gKj0geDtcbiAgICAgICAgbVs1XSAqPSB5O1xuICAgICAgICBtWzldICo9IHo7XG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuICAgICAgICBtWzNdICo9IHg7XG4gICAgICAgIG1bN10gKj0geTtcbiAgICAgICAgbVsxMV0gKj0gejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0cyhzKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjYWxpbmdNYXQ0YyhzLCBzLCBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgRGVzdGluYXRpb24gbWF0cml4XG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICovXG4gICAgcm90YXRpb25UcmFuc2xhdGlvbk1hdDQocSwgdiwgZGVzdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIGNvbnN0IHggPSBxWzBdO1xuICAgICAgICBjb25zdCB5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcgPSBxWzNdO1xuXG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICAgICAgY29uc3QgeHogPSB4ICogejI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG5cbiAgICAgICAgZGVzdFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgICAgIGRlc3RbMV0gPSB4eSArIHd6O1xuICAgICAgICBkZXN0WzJdID0geHogLSB3eTtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSB4eSAtIHd6O1xuICAgICAgICBkZXN0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICAgICAgZGVzdFs2XSA9IHl6ICsgd3g7XG4gICAgICAgIGRlc3RbN10gPSAwO1xuICAgICAgICBkZXN0WzhdID0geHogKyB3eTtcbiAgICAgICAgZGVzdFs5XSA9IHl6IC0gd3g7XG4gICAgICAgIGRlc3RbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICAgICAgZGVzdFsxMV0gPSAwO1xuICAgICAgICBkZXN0WzEyXSA9IHZbMF07XG4gICAgICAgIGRlc3RbMTNdID0gdlsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB2WzJdO1xuICAgICAgICBkZXN0WzE1XSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgRXVsZXIgYW5nbGVzIGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0IFRoZSA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBEZXNpcmVkIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gRXVsZXIgYW5nbGVzLCBjcmVhdGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgRXVsZXIgYW5nbGVzLlxuICAgICAqL1xuICAgIG1hdDRUb0V1bGVyKG1hdCwgb3JkZXIsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBjbGFtcCA9IG1hdGguY2xhbXA7XG5cbiAgICAgICAgLy8gQXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICBjb25zdCBtMTEgPSBtYXRbMF07XG5cbiAgICAgICAgY29uc3QgbTEyID0gbWF0WzRdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBtMjMgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1hdFsyXTtcbiAgICAgICAgY29uc3QgbTMyID0gbWF0WzZdO1xuICAgICAgICBjb25zdCBtMzMgPSBtYXRbMTBdO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMTMpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIoLW0xMiwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1lYWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMihtMTMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIobTIxLCBtMjIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmFzaW4oY2xhbXAobTMyLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMzMpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMzEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzJdID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1laWCcpIHtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0yMik7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmFzaW4oLWNsYW1wKG0xMiwgLTEsIDEpKTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb21wb3NlTWF0NChwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUsIG1hdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIG1hdGgucXVhdGVybmlvblRvUm90YXRpb25NYXQ0KHF1YXRlcm5pb24sIG1hdCk7XG4gICAgICAgIG1hdGguc2NhbGVNYXQ0dihzY2FsZSwgbWF0KTtcbiAgICAgICAgbWF0aC50cmFuc2xhdGVNYXQ0dihwb3NpdGlvbiwgbWF0KTtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICBkZWNvbXBvc2VNYXQ0OiAoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKG1hdCwgcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlKSB7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFswXTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFsxXTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFsyXTtcblxuICAgICAgICAgICAgbGV0IHN4ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFs0XTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFs1XTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFs2XTtcblxuICAgICAgICAgICAgY29uc3Qgc3kgPSBtYXRoLmxlblZlYzModmVjKTtcblxuICAgICAgICAgICAgdmVjWzhdID0gbWF0WzhdO1xuICAgICAgICAgICAgdmVjWzldID0gbWF0WzldO1xuICAgICAgICAgICAgdmVjWzEwXSA9IG1hdFsxMF07XG5cbiAgICAgICAgICAgIGNvbnN0IHN6ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRldGVybWluYW50TWF0NChtYXQpO1xuXG4gICAgICAgICAgICBpZiAoZGV0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvblswXSA9IG1hdFsxMl07XG4gICAgICAgICAgICBwb3NpdGlvblsxXSA9IG1hdFsxM107XG4gICAgICAgICAgICBwb3NpdGlvblsyXSA9IG1hdFsxNF07XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgICAgICAgICBtYXRyaXguc2V0KG1hdCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xuICAgICAgICAgICAgY29uc3QgaW52U1kgPSAxIC8gc3k7XG4gICAgICAgICAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgICAgICAgICAgbWF0cml4WzBdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzFdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzJdICo9IGludlNYO1xuXG4gICAgICAgICAgICBtYXRyaXhbNF0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNV0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNl0gKj0gaW52U1k7XG5cbiAgICAgICAgICAgIG1hdHJpeFs4XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFs5XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFsxMF0gKj0gaW52U1o7XG5cbiAgICAgICAgICAgIG1hdGgubWF0NFRvUXVhdGVybmlvbihtYXRyaXgsIHF1YXRlcm5pb24pO1xuXG4gICAgICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgICAgIHNjYWxlWzJdID0gc3o7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KSgpLFxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZ2V0Q29sTWF0NChtYXQsIGMpIHtcbiAgICAgICAgY29uc3QgaSA9IGMgKiA0O1xuICAgICAgICByZXR1cm4gW21hdFtpXSwgbWF0W2kgKyAxXSwgbWF0W2kgKyAyXSwgbWF0W2kgKyAzXV07XG4gICAgfSxcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHNldFJvd01hdDQobWF0LCByLCB2KSB7XG4gICAgICAgIG1hdFtyXSA9IHZbMF07XG4gICAgICAgIG1hdFtyICsgNF0gPSB2WzFdO1xuICAgICAgICBtYXRbciArIDhdID0gdlsyXTtcbiAgICAgICAgbWF0W3IgKyAxMl0gPSB2WzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0ICdsb29rYXQnIHZpZXdpbmcgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGxvb2tBdE1hdDR2XG4gICAgICogQHBhcmFtIHBvcyB2ZWMzIHBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHZlYzMgcG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gICAgICogQHBhcmFtIHVwIHZlYzMgcG9pbnRpbmcgXCJ1cFwiXG4gICAgICogQHBhcmFtIGRlc3QgbWF0NCBPcHRpb25hbCwgbWF0NCBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21hdDR9IGRlc3QgaWYgc3BlY2lmaWVkLCBhIG5ldyBtYXQ0IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGxvb2tBdE1hdDR2KHBvcywgdGFyZ2V0LCB1cCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXRoLm1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc3ggPSBwb3NbMF07XG4gICAgICAgIGNvbnN0IHBvc3kgPSBwb3NbMV07XG4gICAgICAgIGNvbnN0IHBvc3ogPSBwb3NbMl07XG4gICAgICAgIGNvbnN0IHVweCA9IHVwWzBdO1xuICAgICAgICBjb25zdCB1cHkgPSB1cFsxXTtcbiAgICAgICAgY29uc3QgdXB6ID0gdXBbMl07XG4gICAgICAgIGNvbnN0IHRhcmdldHggPSB0YXJnZXRbMF07XG4gICAgICAgIGNvbnN0IHRhcmdldHkgPSB0YXJnZXRbMV07XG4gICAgICAgIGNvbnN0IHRhcmdldHogPSB0YXJnZXRbMl07XG5cbiAgICAgICAgaWYgKHBvc3ggPT09IHRhcmdldHggJiYgcG9zeSA9PT0gdGFyZ2V0eSAmJiBwb3N6ID09PSB0YXJnZXR6KSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB6MDtcbiAgICAgICAgbGV0IHoxO1xuICAgICAgICBsZXQgejI7XG4gICAgICAgIGxldCB4MDtcbiAgICAgICAgbGV0IHgxO1xuICAgICAgICBsZXQgeDI7XG4gICAgICAgIGxldCB5MDtcbiAgICAgICAgbGV0IHkxO1xuICAgICAgICBsZXQgeTI7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgLy92ZWMzLmRpcmVjdGlvbihleWUsIGNlbnRlciwgeik7XG4gICAgICAgIHowID0gcG9zeCAtIHRhcmdldHg7XG4gICAgICAgIHoxID0gcG9zeSAtIHRhcmdldHk7XG4gICAgICAgIHoyID0gcG9zeiAtIHRhcmdldHo7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIChubyBjaGVjayBuZWVkZWQgZm9yIDAgYmVjYXVzZSBvZiBlYXJseSByZXR1cm4pXG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICAgICAgejAgKj0gbGVuO1xuICAgICAgICB6MSAqPSBsZW47XG4gICAgICAgIHoyICo9IGxlbjtcblxuICAgICAgICAvL3ZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHosIHgpKTtcbiAgICAgICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICB4MCA9IDA7XG4gICAgICAgICAgICB4MSA9IDA7XG4gICAgICAgICAgICB4MiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICAgICAgeDIgKj0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy92ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHosIHgsIHkpKTtcbiAgICAgICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICAgICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICAgICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHkwID0gMDtcbiAgICAgICAgICAgIHkxID0gMDtcbiAgICAgICAgICAgIHkyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgICAgICB5MiAqPSBsZW47XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzBdID0geDA7XG4gICAgICAgIGRlc3RbMV0gPSB5MDtcbiAgICAgICAgZGVzdFsyXSA9IHowO1xuICAgICAgICBkZXN0WzNdID0gMDtcbiAgICAgICAgZGVzdFs0XSA9IHgxO1xuICAgICAgICBkZXN0WzVdID0geTE7XG4gICAgICAgIGRlc3RbNl0gPSB6MTtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSB4MjtcbiAgICAgICAgZGVzdFs5XSA9IHkyO1xuICAgICAgICBkZXN0WzEwXSA9IHoyO1xuICAgICAgICBkZXN0WzExXSA9IDA7XG4gICAgICAgIGRlc3RbMTJdID0gLSh4MCAqIHBvc3ggKyB4MSAqIHBvc3kgKyB4MiAqIHBvc3opO1xuICAgICAgICBkZXN0WzEzXSA9IC0oeTAgKiBwb3N4ICsgeTEgKiBwb3N5ICsgeTIgKiBwb3N6KTtcbiAgICAgICAgZGVzdFsxNF0gPSAtKHowICogcG9zeCArIHoxICogcG9zeSArIHoyICogcG9zeik7XG4gICAgICAgIGRlc3RbMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCAnbG9va2F0JyB2aWV3aW5nIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBsb29rQXRNYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsb29rQXRNYXQ0Yyhwb3N4LCBwb3N5LCBwb3N6LCB0YXJnZXR4LCB0YXJnZXR5LCB0YXJnZXR6LCB1cHgsIHVweSwgdXB6KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmxvb2tBdE1hdDR2KFtwb3N4LCBwb3N5LCBwb3N6XSwgW3RhcmdldHgsIHRhcmdldHksIHRhcmdldHpdLCBbdXB4LCB1cHksIHVwel0sIFtdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBvcnRob01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG9ydGhvTWF0NGMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG5cbiAgICAgICAgZGVzdFswXSA9IDIuMCAvIHJsO1xuICAgICAgICBkZXN0WzFdID0gMC4wO1xuICAgICAgICBkZXN0WzJdID0gMC4wO1xuICAgICAgICBkZXN0WzNdID0gMC4wO1xuXG4gICAgICAgIGRlc3RbNF0gPSAwLjA7XG4gICAgICAgIGRlc3RbNV0gPSAyLjAgLyB0YjtcbiAgICAgICAgZGVzdFs2XSA9IDAuMDtcbiAgICAgICAgZGVzdFs3XSA9IDAuMDtcblxuICAgICAgICBkZXN0WzhdID0gMC4wO1xuICAgICAgICBkZXN0WzldID0gMC4wO1xuICAgICAgICBkZXN0WzEwXSA9IC0yLjAgLyBmbjtcbiAgICAgICAgZGVzdFsxMV0gPSAwLjA7XG5cbiAgICAgICAgZGVzdFsxMl0gPSAtKGxlZnQgKyByaWdodCkgLyBybDtcbiAgICAgICAgZGVzdFsxM10gPSAtKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxNF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMS4wO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgZnJ1c3R1bU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGZydXN0dW1NYXQ0dihmbWluLCBmbWF4LCBtKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IG1hdGgubWF0NCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm1pbjQgPSBbZm1pblswXSwgZm1pblsxXSwgZm1pblsyXSwgMC4wXTtcbiAgICAgICAgY29uc3QgZm1heDQgPSBbZm1heFswXSwgZm1heFsxXSwgZm1heFsyXSwgMC4wXTtcblxuICAgICAgICBtYXRoLmFkZFZlYzQoZm1heDQsIGZtaW40LCB0ZW1wTWF0MSk7XG4gICAgICAgIG1hdGguc3ViVmVjNChmbWF4NCwgZm1pbjQsIHRlbXBNYXQyKTtcblxuICAgICAgICBjb25zdCB0ID0gMi4wICogZm1pbjRbMl07XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDIwID0gdGVtcE1hdDJbMF07XG4gICAgICAgIGNvbnN0IHRlbXBNYXQyMSA9IHRlbXBNYXQyWzFdO1xuICAgICAgICBjb25zdCB0ZW1wTWF0MjIgPSB0ZW1wTWF0MlsyXTtcblxuICAgICAgICBtWzBdID0gdCAvIHRlbXBNYXQyMDtcbiAgICAgICAgbVsxXSA9IDAuMDtcbiAgICAgICAgbVsyXSA9IDAuMDtcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gMC4wO1xuICAgICAgICBtWzVdID0gdCAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVs2XSA9IDAuMDtcbiAgICAgICAgbVs3XSA9IDAuMDtcblxuICAgICAgICBtWzhdID0gdGVtcE1hdDFbMF0gLyB0ZW1wTWF0MjA7XG4gICAgICAgIG1bOV0gPSB0ZW1wTWF0MVsxXSAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVsxMF0gPSAtdGVtcE1hdDFbMl0gLyB0ZW1wTWF0MjI7XG4gICAgICAgIG1bMTFdID0gLTEuMDtcblxuICAgICAgICBtWzEyXSA9IDAuMDtcbiAgICAgICAgbVsxM10gPSAwLjA7XG4gICAgICAgIG1bMTRdID0gLXQgKiBmbWF4NFsyXSAvIHRlbXBNYXQyMjtcbiAgICAgICAgbVsxNV0gPSAwLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBmcnVzdHVtTWF0NHZcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZnJ1c3R1bU1hdDQobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG4gICAgICAgIGRlc3RbMF0gPSAobmVhciAqIDIpIC8gcmw7XG4gICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICBkZXN0WzJdID0gMDtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSAwO1xuICAgICAgICBkZXN0WzVdID0gKG5lYXIgKiAyKSAvIHRiO1xuICAgICAgICBkZXN0WzZdID0gMDtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSAocmlnaHQgKyBsZWZ0KSAvIHJsO1xuICAgICAgICBkZXN0WzldID0gKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxMF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTFdID0gLTE7XG4gICAgICAgIGRlc3RbMTJdID0gMDtcbiAgICAgICAgZGVzdFsxM10gPSAwO1xuICAgICAgICBkZXN0WzE0XSA9IC0oZmFyICogbmVhciAqIDIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBwZXJzcGVjdGl2ZU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHBlcnNwZWN0aXZlTWF0NChmb3Z5cmFkLCBhc3BlY3RyYXRpbywgem5lYXIsIHpmYXIsIG0pIHtcbiAgICAgICAgY29uc3QgcG1pbiA9IFtdO1xuICAgICAgICBjb25zdCBwbWF4ID0gW107XG5cbiAgICAgICAgcG1pblsyXSA9IHpuZWFyO1xuICAgICAgICBwbWF4WzJdID0gemZhcjtcblxuICAgICAgICBwbWF4WzFdID0gcG1pblsyXSAqIE1hdGgudGFuKGZvdnlyYWQgLyAyLjApO1xuICAgICAgICBwbWluWzFdID0gLXBtYXhbMV07XG5cbiAgICAgICAgcG1heFswXSA9IHBtYXhbMV0gKiBhc3BlY3RyYXRpbztcbiAgICAgICAgcG1pblswXSA9IC1wbWF4WzBdO1xuXG4gICAgICAgIHJldHVybiBtYXRoLmZydXN0dW1NYXQ0dihwbWluLCBwbWF4LCBtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gNHg0IG1hdHJpY2VzIGFyZSB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gbTFcbiAgICAgKiBAcGFyYW0gbTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wYXJlTWF0NChtMSwgbTIpIHtcbiAgICAgICAgcmV0dXJuIG0xWzBdID09PSBtMlswXSAmJlxuICAgICAgICAgICAgbTFbMV0gPT09IG0yWzFdICYmXG4gICAgICAgICAgICBtMVsyXSA9PT0gbTJbMl0gJiZcbiAgICAgICAgICAgIG0xWzNdID09PSBtMlszXSAmJlxuICAgICAgICAgICAgbTFbNF0gPT09IG0yWzRdICYmXG4gICAgICAgICAgICBtMVs1XSA9PT0gbTJbNV0gJiZcbiAgICAgICAgICAgIG0xWzZdID09PSBtMls2XSAmJlxuICAgICAgICAgICAgbTFbN10gPT09IG0yWzddICYmXG4gICAgICAgICAgICBtMVs4XSA9PT0gbTJbOF0gJiZcbiAgICAgICAgICAgIG0xWzldID09PSBtMls5XSAmJlxuICAgICAgICAgICAgbTFbMTBdID09PSBtMlsxMF0gJiZcbiAgICAgICAgICAgIG0xWzExXSA9PT0gbTJbMTFdICYmXG4gICAgICAgICAgICBtMVsxMl0gPT09IG0yWzEyXSAmJlxuICAgICAgICAgICAgbTFbMTNdID09PSBtMlsxM10gJiZcbiAgICAgICAgICAgIG0xWzE0XSA9PT0gbTJbMTRdICYmXG4gICAgICAgICAgICBtMVsxNV0gPT09IG0yWzE1XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIHRocmVlLWVsZW1lbnQgcG9zaXRpb24gYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9pbnQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50MyhtLCBwLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcblxuICAgICAgICBjb25zdCB4ID0gcFswXTtcbiAgICAgICAgY29uc3QgeSA9IHBbMV07XG4gICAgICAgIGNvbnN0IHogPSBwWzJdO1xuXG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHgpICsgKG1bNF0gKiB5KSArIChtWzhdICogeikgKyBtWzEyXTtcbiAgICAgICAgZGVzdFsxXSA9IChtWzFdICogeCkgKyAobVs1XSAqIHkpICsgKG1bOV0gKiB6KSArIG1bMTNdO1xuICAgICAgICBkZXN0WzJdID0gKG1bMl0gKiB4KSArIChtWzZdICogeSkgKyAobVsxMF0gKiB6KSArIG1bMTRdO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgaG9tb2dlbmVvdXMgY29vcmRpbmF0ZSBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBkZXN0WzBdID0gbVswXSAqIHZbMF0gKyBtWzRdICogdlsxXSArIG1bOF0gKiB2WzJdICsgbVsxMl0gKiB2WzNdO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHZbMF0gKyBtWzVdICogdlsxXSArIG1bOV0gKiB2WzJdICsgbVsxM10gKiB2WzNdO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHZbMF0gKyBtWzZdICogdlsxXSArIG1bMTBdICogdlsyXSArIG1bMTRdICogdlszXTtcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzExXSAqIHZbMl0gKyBtWzE1XSAqIHZbM107XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiB0aHJlZS1lbGVtZW50IHBvc2l0aW9ucyBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludHMzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50czMobSwgcG9pbnRzLCBwb2ludHMyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBvaW50czIgfHwgW107XG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCBwMDtcbiAgICAgICAgbGV0IHAxO1xuICAgICAgICBsZXQgcDI7XG4gICAgICAgIGxldCBwaTtcblxuICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuXG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgbGV0IHI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgICAgIHBpID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBwMCA9IHBpWzBdO1xuICAgICAgICAgICAgcDEgPSBwaVsxXTtcbiAgICAgICAgICAgIHAyID0gcGlbMl07XG5cbiAgICAgICAgICAgIHIgPSByZXN1bHRbaV0gfHwgKHJlc3VsdFtpXSA9IFswLCAwLCAwXSk7XG5cbiAgICAgICAgICAgIHJbMF0gPSAobTAgKiBwMCkgKyAobTQgKiBwMSkgKyAobTggKiBwMikgKyBtMTI7XG4gICAgICAgICAgICByWzFdID0gKG0xICogcDApICsgKG01ICogcDEpICsgKG05ICogcDIpICsgbTEzO1xuICAgICAgICAgICAgclsyXSA9IChtMiAqIHAwKSArIChtNiAqIHAxKSArIChtMTAgKiBwMikgKyBtMTQ7XG4gICAgICAgICAgICByWzNdID0gKG0zICogcDApICsgKG03ICogcDEpICsgKG0xMSAqIHAyKSArIG0xNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW47XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9zaXRpb25zM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1Qb3NpdGlvbnMzKG0sIHAsIHAyID0gcCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgbGVuID0gcC5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgejtcblxuICAgICAgICBjb25zdCBtMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHggPSBwW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBwW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwW2kgKyAyXTtcblxuICAgICAgICAgICAgcDJbaSArIDBdID0gKG0wICogeCkgKyAobTQgKiB5KSArIChtOCAqIHopICsgbTEyO1xuICAgICAgICAgICAgcDJbaSArIDFdID0gKG0xICogeCkgKyAobTUgKiB5KSArIChtOSAqIHopICsgbTEzO1xuICAgICAgICAgICAgcDJbaSArIDJdID0gKG0yICogeCkgKyAobTYgKiB5KSArIChtMTAgKiB6KSArIG0xNDtcbiAgICAgICAgICAgIHAyW2kgKyAzXSA9IChtMyAqIHgpICsgKG03ICogeSkgKyAobTExICogeikgKyBtMTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgcG9zaXRpb25zIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zZm9ybVBvc2l0aW9uczRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9zaXRpb25zNChtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWMzKG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgZGVzdCA9IGRlc3QgfHwgdGhpcy52ZWMzKCk7XG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHYwKSArIChtWzRdICogdjEpICsgKG1bOF0gKiB2Mik7XG4gICAgICAgIGRlc3RbMV0gPSAobVsxXSAqIHYwKSArIChtWzVdICogdjEpICsgKG1bOV0gKiB2Mik7XG4gICAgICAgIGRlc3RbMl0gPSAobVsyXSAqIHYwKSArIChtWzZdICogdjEpICsgKG1bMTBdICogdjIpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWM0KG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICBkZXN0ID0gZGVzdCB8fCBtYXRoLnZlYzQoKTtcbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKiB2MCArIG1bNF0gKiB2MSArIG1bOF0gKiB2MiArIG1bMTJdICogdjM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdICogdjAgKyBtWzVdICogdjEgKyBtWzldICogdjIgKyBtWzEzXSAqIHYzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHYwICsgbVs2XSAqIHYxICsgbVsxMF0gKiB2MiArIG1bMTRdICogdjM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogdjAgKyBtWzddICogdjEgKyBtWzExXSAqIHYyICsgbVsxNV0gKiB2MztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNYKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXTtcbiAgICAgICAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhjKSAtIHBbMl0gKiBNYXRoLnNpbihjKTtcbiAgICAgICAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihjKSArIHBbMl0gKiBNYXRoLmNvcyhjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNZKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFsyXSAqIE1hdGguc2luKGMpICsgcFswXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzFdID0gcFsxXTtcbiAgICAgICAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhjKSAtIHBbMF0gKiBNYXRoLnNpbihjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNaKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXSAqIE1hdGguY29zKGMpIC0gcFsxXSAqIE1hdGguc2luKGMpO1xuICAgICAgICByWzFdID0gcFswXSAqIE1hdGguc2luKGMpICsgcFsxXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzJdID0gcFsyXTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yIGJ5IGEgNHg0IHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcm9qZWN0VmVjNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHAgM0QgVmlldy1zcGFjZSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcSAyRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gMkQgUHJvamVjdGVkIGNvb3JkaW5hdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcHJvamVjdFZlYzQocCwgcSkge1xuICAgICAgICBjb25zdCBmID0gMS4wIC8gcFszXTtcbiAgICAgICAgcSA9IHEgfHwgbWF0aC52ZWMyKCk7XG4gICAgICAgIHFbMF0gPSBwWzBdICogZjtcbiAgICAgICAgcVsxXSA9IHBbMV0gKiBmO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5wcm9qZWN0cyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnByb2plY3RWZWMzXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcCAzRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXQgVmlldyBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IHByb2pNYXQgUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdW5wcm9qZWN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSgxNik7XG4gICAgICAgIGNvbnN0IG1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuICAgICAgICBjb25zdCBtYXQzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwLCB2aWV3TWF0LCBwcm9qTWF0LCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1WZWMzKHRoaXMubXVsTWF0NCh0aGlzLmludmVyc2VNYXQ0KHZpZXdNYXQsIG1hdCksIHRoaXMuaW52ZXJzZU1hdDQocHJvak1hdCwgbWF0MiksIG1hdDMpLCBwLCBxKVxuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIDNEIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBsZXJwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwVmVjMyh0LCB0MSwgdDIsIHAxLCBwMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgudmVjMygpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IHAxWzBdICsgKGYgKiAocDJbMF0gLSBwMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBwMVsxXSArIChmICogKHAyWzFdIC0gcDFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gcDFbMl0gKyAoZiAqIChwMlsyXSAtIHAxWzJdKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHR3byA0eDQgbWF0cmljZXMuXG4gICAgICogQG1ldGhvZCBsZXJwTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwTWF0NCh0LCB0MSwgdDIsIG0xLCBtMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgubWF0NCgpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IG0xWzBdICsgKGYgKiAobTJbMF0gLSBtMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBtMVsxXSArIChmICogKG0yWzFdIC0gbTFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gbTFbMl0gKyAoZiAqIChtMlsyXSAtIG0xWzJdKSk7XG4gICAgICAgIHJlc3VsdFszXSA9IG0xWzNdICsgKGYgKiAobTJbM10gLSBtMVszXSkpO1xuICAgICAgICByZXN1bHRbNF0gPSBtMVs0XSArIChmICogKG0yWzRdIC0gbTFbNF0pKTtcbiAgICAgICAgcmVzdWx0WzVdID0gbTFbNV0gKyAoZiAqIChtMls1XSAtIG0xWzVdKSk7XG4gICAgICAgIHJlc3VsdFs2XSA9IG0xWzZdICsgKGYgKiAobTJbNl0gLSBtMVs2XSkpO1xuICAgICAgICByZXN1bHRbN10gPSBtMVs3XSArIChmICogKG0yWzddIC0gbTFbN10pKTtcbiAgICAgICAgcmVzdWx0WzhdID0gbTFbOF0gKyAoZiAqIChtMls4XSAtIG0xWzhdKSk7XG4gICAgICAgIHJlc3VsdFs5XSA9IG0xWzldICsgKGYgKiAobTJbOV0gLSBtMVs5XSkpO1xuICAgICAgICByZXN1bHRbMTBdID0gbTFbMTBdICsgKGYgKiAobTJbMTBdIC0gbTFbMTBdKSk7XG4gICAgICAgIHJlc3VsdFsxMV0gPSBtMVsxMV0gKyAoZiAqIChtMlsxMV0gLSBtMVsxMV0pKTtcbiAgICAgICAgcmVzdWx0WzEyXSA9IG0xWzEyXSArIChmICogKG0yWzEyXSAtIG0xWzEyXSkpO1xuICAgICAgICByZXN1bHRbMTNdID0gbTFbMTNdICsgKGYgKiAobTJbMTNdIC0gbTFbMTNdKSk7XG4gICAgICAgIHJlc3VsdFsxNF0gPSBtMVsxNF0gKyAoZiAqIChtMlsxNF0gLSBtMVsxNF0pKTtcbiAgICAgICAgcmVzdWx0WzE1XSA9IG0xWzE1XSArIChmICogKG0yWzE1XSAtIG0xWzE1XSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGludG8gYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZsYXR0ZW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheSBvZiBBcnJheXN9IGEgQSAyRCBhcnJheVxuICAgICAqIEByZXR1cm5zIEZsYXR0ZW5lZCAxRCBhcnJheVxuICAgICAqL1xuICAgIGZsYXR0ZW4oYSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW5qO1xuICAgICAgICBsZXQgaXRlbTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5pID0gYS5sZW5ndGg7IGkgPCBsZW5pOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuaiA9IGl0ZW0ubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIGlkZW50aXR5UXVhdGVybmlvbihkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgZGVzdFswXSA9IDAuMDtcbiAgICAgICAgZGVzdFsxXSA9IDAuMDtcbiAgICAgICAgZGVzdFsyXSA9IDAuMDtcbiAgICAgICAgZGVzdFszXSA9IDEuMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgcXVhdGVybmlvbiBmcm9tIEV1bGVyIGFuZ2xlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGV1bGVyIFRoZSBFdWxlciBhbmdsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gcXVhdGVybmlvbiwgY3JlYXRlZCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgZXVsZXJUb1F1YXRlcm5pb24oZXVsZXIsIG9yZGVyLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgICAgICAvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuICAgICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICAgICAgY29uc3QgYSA9IChldWxlclswXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYiA9IChldWxlclsxXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYyA9IChldWxlclsyXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcblxuICAgICAgICBjb25zdCBjMSA9IE1hdGguY29zKGEpO1xuICAgICAgICBjb25zdCBjMiA9IE1hdGguY29zKGIpO1xuICAgICAgICBjb25zdCBjMyA9IE1hdGguY29zKGMpO1xuICAgICAgICBjb25zdCBzMSA9IE1hdGguc2luKGEpO1xuICAgICAgICBjb25zdCBzMiA9IE1hdGguc2luKGIpO1xuICAgICAgICBjb25zdCBzMyA9IE1hdGguc2luKGMpO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgbWF0NFRvUXVhdGVybmlvbihtLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgICAgICAvLyBBc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMTBdO1xuICAgICAgICBsZXQgcztcblxuICAgICAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuICAgICAgICBpZiAodHJhY2UgPiAwKSB7XG5cbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuXG4gICAgICAgICAgICBkZXN0WzNdID0gMC4yNSAvIHM7XG4gICAgICAgICAgICBkZXN0WzBdID0gKG0zMiAtIG0yMykgKiBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IChtMTMgLSBtMzEpICogcztcbiAgICAgICAgICAgIGRlc3RbMl0gPSAobTIxIC0gbTEyKSAqIHM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTExIC0gbTIyIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMzIgLSBtMjMpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAwLjI1ICogcztcbiAgICAgICAgICAgIGRlc3RbMV0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0xMyArIG0zMSkgLyBzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobTIyID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMTMgLSBtMzEpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0yMyArIG0zMikgLyBzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEzICsgbTMxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gKG0yMyArIG0zMikgLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IDAuMjUgKiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNQYWlyVG9RdWF0ZXJuaW9uKHUsIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBub3JtX3Vfbm9ybV92ID0gTWF0aC5zcXJ0KG1hdGguZG90VmVjMyh1LCB1KSAqIG1hdGguZG90VmVjMyh2LCB2KSk7XG4gICAgICAgIGxldCByZWFsX3BhcnQgPSBub3JtX3Vfbm9ybV92ICsgbWF0aC5kb3RWZWMzKHUsIHYpO1xuXG4gICAgICAgIGlmIChyZWFsX3BhcnQgPCAwLjAwMDAwMDAxICogbm9ybV91X25vcm1fdikge1xuXG4gICAgICAgICAgICAvLyBJZiB1IGFuZCB2IGFyZSBleGFjdGx5IG9wcG9zaXRlLCByb3RhdGUgMTgwIGRlZ3JlZXNcbiAgICAgICAgICAgIC8vIGFyb3VuZCBhbiBhcmJpdHJhcnkgb3J0aG9nb25hbCBheGlzLiBBeGlzIG5vcm1hbGlzYXRpb25cbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gbGF0ZXIsIHdoZW4gd2Ugbm9ybWFsaXNlIHRoZSBxdWF0ZXJuaW9uLlxuXG4gICAgICAgICAgICByZWFsX3BhcnQgPSAwLjA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh1WzBdKSA+IE1hdGguYWJzKHVbMl0pKSB7XG5cbiAgICAgICAgICAgICAgICBkZXN0WzBdID0gLXVbMV07XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IHVbMF07XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IDA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IC11WzJdO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSB1WzFdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBxdWF0ZXJuaW9uIHRoZSBzdGFuZGFyZCB3YXkuXG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzModSwgdiwgZGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzNdID0gcmVhbF9wYXJ0O1xuXG4gICAgICAgIHJldHVybiBtYXRoLm5vcm1hbGl6ZVF1YXRlcm5pb24oZGVzdCk7XG4gICAgfSxcblxuICAgIGFuZ2xlQXhpc1RvUXVhdGVybmlvbihhbmdsZUF4aXMsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUF4aXNbM10gLyAyLjA7XG4gICAgICAgIGNvbnN0IGZzaW4gPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBkZXN0WzBdID0gZnNpbiAqIGFuZ2xlQXhpc1swXTtcbiAgICAgICAgZGVzdFsxXSA9IGZzaW4gKiBhbmdsZUF4aXNbMV07XG4gICAgICAgIGRlc3RbMl0gPSBmc2luICogYW5nbGVBeGlzWzJdO1xuICAgICAgICBkZXN0WzNdID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0V1bGVyOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIChxLCBvcmRlciwgZGVzdCkgPT4ge1xuICAgICAgICAgICAgZGVzdCA9IGRlc3QgfHwgbWF0aC52ZWMzKCk7XG4gICAgICAgICAgICBtYXRoLnF1YXRlcm5pb25Ub1JvdGF0aW9uTWF0NChxLCBtYXQpO1xuICAgICAgICAgICAgbWF0aC5tYXQ0VG9FdWxlcihtYXQsIG9yZGVyLCBkZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgbXVsUXVhdGVybmlvbnMocCwgcSwgZGVzdCA9IG1hdGgudmVjNCgpKSB7XG4gICAgICAgIGNvbnN0IHAwID0gcFswXTtcbiAgICAgICAgY29uc3QgcDEgPSBwWzFdO1xuICAgICAgICBjb25zdCBwMiA9IHBbMl07XG4gICAgICAgIGNvbnN0IHAzID0gcFszXTtcbiAgICAgICAgY29uc3QgcTAgPSBxWzBdO1xuICAgICAgICBjb25zdCBxMSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBkZXN0WzBdID0gcDMgKiBxMCArIHAwICogcTMgKyBwMSAqIHEyIC0gcDIgKiBxMTtcbiAgICAgICAgZGVzdFsxXSA9IHAzICogcTEgKyBwMSAqIHEzICsgcDIgKiBxMCAtIHAwICogcTI7XG4gICAgICAgIGRlc3RbMl0gPSBwMyAqIHEyICsgcDIgKiBxMyArIHAwICogcTEgLSBwMSAqIHEwO1xuICAgICAgICBkZXN0WzNdID0gcDMgKiBxMyAtIHAwICogcTAgLSBwMSAqIHExIC0gcDIgKiBxMjtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNBcHBseVF1YXRlcm5pb24ocSwgdmVjLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgeCA9IHZlY1swXTtcbiAgICAgICAgY29uc3QgeSA9IHZlY1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHZlY1syXTtcblxuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gICAgICAgIGRlc3RbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgICBkZXN0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICAgICAgZGVzdFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub01hdDQocSwgZGVzdCkge1xuXG4gICAgICAgIGRlc3QgPSBtYXRoLmlkZW50aXR5TWF0NChkZXN0KTtcblxuICAgICAgICBjb25zdCBxMCA9IHFbMF07ICAvL3hcbiAgICAgICAgY29uc3QgcTEgPSBxWzFdOyAgLy95XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTsgIC8velxuICAgICAgICBjb25zdCBxMyA9IHFbM107ICAvL3dcblxuICAgICAgICBjb25zdCB0eCA9IDIuMCAqIHEwO1xuICAgICAgICBjb25zdCB0eSA9IDIuMCAqIHExO1xuICAgICAgICBjb25zdCB0eiA9IDIuMCAqIHEyO1xuXG4gICAgICAgIGNvbnN0IHR3eCA9IHR4ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eSA9IHR5ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eiA9IHR6ICogcTM7XG5cbiAgICAgICAgY29uc3QgdHh4ID0gdHggKiBxMDtcbiAgICAgICAgY29uc3QgdHh5ID0gdHkgKiBxMDtcbiAgICAgICAgY29uc3QgdHh6ID0gdHogKiBxMDtcblxuICAgICAgICBjb25zdCB0eXkgPSB0eSAqIHExO1xuICAgICAgICBjb25zdCB0eXogPSB0eiAqIHExO1xuICAgICAgICBjb25zdCB0enogPSB0eiAqIHEyO1xuXG4gICAgICAgIGRlc3RbMF0gPSAxLjAgLSAodHl5ICsgdHp6KTtcbiAgICAgICAgZGVzdFsxXSA9IHR4eSArIHR3ejtcbiAgICAgICAgZGVzdFsyXSA9IHR4eiAtIHR3eTtcblxuICAgICAgICBkZXN0WzRdID0gdHh5IC0gdHd6O1xuICAgICAgICBkZXN0WzVdID0gMS4wIC0gKHR4eCArIHR6eik7XG4gICAgICAgIGRlc3RbNl0gPSB0eXogKyB0d3g7XG5cbiAgICAgICAgZGVzdFs4XSA9IHR4eiArIHR3eTtcbiAgICAgICAgZGVzdFs5XSA9IHR5eiAtIHR3eDtcblxuICAgICAgICBkZXN0WzEwXSA9IDEuMCAtICh0eHggKyB0eXkpO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBxdWF0ZXJuaW9uVG9Sb3RhdGlvbk1hdDQocSwgbSkge1xuICAgICAgICBjb25zdCB4ID0gcVswXTtcbiAgICAgICAgY29uc3QgeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHogPSBxWzJdO1xuICAgICAgICBjb25zdCB3ID0gcVszXTtcblxuICAgICAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgICAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICAgICAgY29uc3QgeHkgPSB4ICogeTI7XG4gICAgICAgIGNvbnN0IHh6ID0geCAqIHoyO1xuICAgICAgICBjb25zdCB5eSA9IHkgKiB5MjtcbiAgICAgICAgY29uc3QgeXogPSB5ICogejI7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xuICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xuXG4gICAgICAgIG1bMF0gPSAxIC0gKHl5ICsgenopO1xuICAgICAgICBtWzRdID0geHkgLSB3ejtcbiAgICAgICAgbVs4XSA9IHh6ICsgd3k7XG5cbiAgICAgICAgbVsxXSA9IHh5ICsgd3o7XG4gICAgICAgIG1bNV0gPSAxIC0gKHh4ICsgenopO1xuICAgICAgICBtWzldID0geXogLSB3eDtcblxuICAgICAgICBtWzJdID0geHogLSB3eTtcbiAgICAgICAgbVs2XSA9IHl6ICsgd3g7XG4gICAgICAgIG1bMTBdID0gMSAtICh4eCArIHl5KTtcblxuICAgICAgICAvLyBsYXN0IGNvbHVtblxuICAgICAgICBtWzNdID0gMDtcbiAgICAgICAgbVs3XSA9IDA7XG4gICAgICAgIG1bMTFdID0gMDtcblxuICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgIG1bMTJdID0gMDtcbiAgICAgICAgbVsxM10gPSAwO1xuICAgICAgICBtWzE0XSA9IDA7XG4gICAgICAgIG1bMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplUXVhdGVybmlvbihxLCBkZXN0ID0gcSkge1xuICAgICAgICBjb25zdCBsZW4gPSBtYXRoLmxlblZlYzQoW3FbMF0sIHFbMV0sIHFbMl0sIHFbM11dKTtcbiAgICAgICAgZGVzdFswXSA9IHFbMF0gLyBsZW47XG4gICAgICAgIGRlc3RbMV0gPSBxWzFdIC8gbGVuO1xuICAgICAgICBkZXN0WzJdID0gcVsyXSAvIGxlbjtcbiAgICAgICAgZGVzdFszXSA9IHFbM10gLyBsZW47XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb25qdWdhdGVRdWF0ZXJuaW9uKHEsIGRlc3QgPSBxKSB7XG4gICAgICAgIGRlc3RbMF0gPSAtcVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1xWzFdO1xuICAgICAgICBkZXN0WzJdID0gLXFbMl07XG4gICAgICAgIGRlc3RbM10gPSBxWzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgaW52ZXJzZVF1YXRlcm5pb24ocSwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKG1hdGguY29uanVnYXRlUXVhdGVybmlvbihxLCBkZXN0KSk7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0FuZ2xlQXhpcyhxLCBhbmdsZUF4aXMgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBxID0gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKHEsIHRlbXBWZWM0KTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3MocTMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KDEgLSBxMyAqIHEzKTtcbiAgICAgICAgaWYgKHMgPCAwLjAwMSkgeyAvLyB0ZXN0IHRvIGF2b2lkIGRpdmlkZSBieSB6ZXJvLCBzIGlzIGFsd2F5cyBwb3NpdGl2ZSBkdWUgdG8gc3FydFxuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXTtcbiAgICAgICAgICAgIGFuZ2xlQXhpc1sxXSA9IHFbMV07XG4gICAgICAgICAgICBhbmdsZUF4aXNbMl0gPSBxWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXSAvIHM7XG4gICAgICAgICAgICBhbmdsZUF4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgICAgIGFuZ2xlQXhpc1syXSA9IHFbMl0gLyBzO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlQXhpc1szXSA9IGFuZ2xlOyAvLyAqIDU3LjI5NTc3OTU3OTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlQXhpcztcbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb3VuZGFyaWVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM0QgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQUFCQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIDJEIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEFBQkIyKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAzRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAyRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDE2KTtcbiAgICB9LFxuXG4gICAgLyoqIFJldHVybnMgYSBuZXcgM0QgYm91bmRpbmcgc3BoZXJlICovXG4gICAgU3BoZXJlMyh4LCB5LCB6LCByKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUoW3gsIHksIHosIHJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBPQkIzIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJhbnNmb3JtT0JCMyhtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBBQUJCIGNvbnRhaW5zIHRoZSBzZWNvbmQgQUFCQi5cbiAgICAgKiBAcGFyYW0gYWFiYjFcbiAgICAgKiBAcGFyYW0gYWFiYjJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc0FBQkIzOiBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChcbiAgICAgICAgICAgIGFhYmIxWzBdIDw9IGFhYmIyWzBdICYmIGFhYmIyWzNdIDw9IGFhYmIxWzNdICYmXG4gICAgICAgICAgICBhYWJiMVsxXSA8PSBhYWJiMlsxXSAmJiBhYWJiMls0XSA8PSBhYWJiMVs0XSAmJlxuICAgICAgICAgICAgYWFiYjFbMl0gPD0gYWFiYjJbMl0gJiYgYWFiYjJbNV0gPD0gYWFiYjFbNV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpYWdvbmFsIHNpemUgb2YgYW4gQUFCQjMgZ2l2ZW4gYXMgbWluaW1hIGFuZCBtYXhpbWEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzRGlhZzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiBhYWJiID0+IHtcblxuICAgICAgICAgICAgbWluWzBdID0gYWFiYlswXTtcbiAgICAgICAgICAgIG1pblsxXSA9IGFhYmJbMV07XG4gICAgICAgICAgICBtaW5bMl0gPSBhYWJiWzJdO1xuXG4gICAgICAgICAgICBtYXhbMF0gPSBhYWJiWzNdO1xuICAgICAgICAgICAgbWF4WzFdID0gYWFiYls0XTtcbiAgICAgICAgICAgIG1heFsyXSA9IGFhYmJbNV07XG5cbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF0aC5sZW5WZWMzKHRlbXBWZWMzKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkaWFnb25hbCBib3VuZGFyeSBzaXplIHRoYXQgaXMgc3ltbWV0cmljYWwgYWJvdXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCM0RpYWdQb2ludDogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiAoYWFiYiwgcCkgPT4ge1xuXG4gICAgICAgICAgICBtaW5bMF0gPSBhYWJiWzBdO1xuICAgICAgICAgICAgbWluWzFdID0gYWFiYlsxXTtcbiAgICAgICAgICAgIG1pblsyXSA9IGFhYmJbMl07XG5cbiAgICAgICAgICAgIG1heFswXSA9IGFhYmJbM107XG4gICAgICAgICAgICBtYXhbMV0gPSBhYWJiWzRdO1xuICAgICAgICAgICAgbWF4WzJdID0gYWFiYls1XTtcblxuICAgICAgICAgICAgY29uc3QgZGlhZ1ZlYyA9IG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICBjb25zdCB4bmVnID0gcFswXSAtIGFhYmJbMF07XG4gICAgICAgICAgICBjb25zdCB4cG9zID0gYWFiYlszXSAtIHBbMF07XG4gICAgICAgICAgICBjb25zdCB5bmVnID0gcFsxXSAtIGFhYmJbMV07XG4gICAgICAgICAgICBjb25zdCB5cG9zID0gYWFiYls0XSAtIHBbMV07XG4gICAgICAgICAgICBjb25zdCB6bmVnID0gcFsyXSAtIGFhYmJbMl07XG4gICAgICAgICAgICBjb25zdCB6cG9zID0gYWFiYls1XSAtIHBbMl07XG5cbiAgICAgICAgICAgIGRpYWdWZWNbMF0gKz0gKHhuZWcgPiB4cG9zKSA/IHhuZWcgOiB4cG9zO1xuICAgICAgICAgICAgZGlhZ1ZlY1sxXSArPSAoeW5lZyA+IHlwb3MpID8geW5lZyA6IHlwb3M7XG4gICAgICAgICAgICBkaWFnVmVjWzJdICs9ICh6bmVnID4genBvcykgPyB6bmVnIDogenBvcztcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1hdGgubGVuVmVjMyhkaWFnVmVjKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmVhIG9mIGFuIEFBQkIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzQXJlYShhYWJiKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKGFhYmJbM10gLSBhYWJiWzBdKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGFhYmJbNF0gLSBhYWJiWzFdKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSAoYWFiYls1XSAtIGFhYmJbMl0pO1xuICAgICAgICByZXR1cm4gKHdpZHRoICogaGVpZ2h0ICogZGVwdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYW4gQUFCQi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QUFCQjNDZW50ZXIoYWFiYiwgZGVzdCkge1xuICAgICAgICBjb25zdCByID0gZGVzdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICByWzBdID0gKGFhYmJbMF0gKyBhYWJiWzNdKSAvIDI7XG4gICAgICAgIHJbMV0gPSAoYWFiYlsxXSArIGFhYmJbNF0pIC8gMjtcbiAgICAgICAgclsyXSA9IChhYWJiWzJdICsgYWFiYls1XSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSAyRCBBQUJCLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCMkNlbnRlcihhYWJiLCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IHIgPSBkZXN0IHx8IG1hdGgudmVjMigpO1xuXG4gICAgICAgIHJbMF0gPSAoYWFiYlsyXSArIGFhYmJbMF0pIC8gMjtcbiAgICAgICAgclsxXSA9IChhYWJiWzNdICsgYWFiYlsxXSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAzRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgM0QgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMyhhYWJiID0gbWF0aC5BQUJCMygpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNF0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNV0gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBpbnRvIGFuIG9yaWVudGVkIGJvdW5kYXJ5IGNvbnNpc3Rpbmcgb2ZcbiAgICAgKiBhbiBhcnJheSBvZiBlaWdodCAzRCBwb3NpdGlvbnMsIG9uZSBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGJvdW5kYXJ5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBBQUJCM1RvT0JCMyhhYWJiLCBvYmIgPSBtYXRoLk9CQjMoKSkge1xuICAgICAgICBvYmJbMF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMV0gPSBhYWJiWzFdO1xuICAgICAgICBvYmJbMl0gPSBhYWJiWzJdO1xuICAgICAgICBvYmJbM10gPSAxO1xuXG4gICAgICAgIG9iYls0XSA9IGFhYmJbM107XG4gICAgICAgIG9iYls1XSA9IGFhYmJbMV07XG4gICAgICAgIG9iYls2XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYls3XSA9IDE7XG5cbiAgICAgICAgb2JiWzhdID0gYWFiYlszXTtcbiAgICAgICAgb2JiWzldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzEwXSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxMV0gPSAxO1xuXG4gICAgICAgIG9iYlsxMl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTNdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzE0XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxNV0gPSAxO1xuXG4gICAgICAgIG9iYlsxNl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTddID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzE4XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsxOV0gPSAxO1xuXG4gICAgICAgIG9iYlsyMF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjFdID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzIyXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyM10gPSAxO1xuXG4gICAgICAgIG9iYlsyNF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjVdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzI2XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyN10gPSAxO1xuXG4gICAgICAgIG9iYlsyOF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMjldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzMwXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlszMV0gPSAxO1xuXG4gICAgICAgIHJldHVybiBvYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvc2l0aW9uczNUb0FBQkIzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBwID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgYWFiYiwgcG9zaXRpb25zRGVjb2RlTWF0cml4KSA9PiB7XG4gICAgICAgICAgICBhYWJiID0gYWFiYiB8fCBtYXRoLkFBQkIzKCk7XG5cbiAgICAgICAgICAgIGxldCB4bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCB6O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHBvc2l0aW9uc1tpICsgMF07XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gcG9zaXRpb25zW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICBtYXRoLmRlY29tcHJlc3NQb3NpdGlvbihwLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHBbMl07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcG9zaXRpb25zW2kgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgeW1pbiA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHptaW4gPSB6O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgICAgICB4bWF4ID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHptYXggPSB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgICAgICBhYWJiWzFdID0geW1pbjtcbiAgICAgICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICAgICAgYWFiYlszXSA9IHhtYXg7XG4gICAgICAgICAgICBhYWJiWzRdID0geW1heDtcbiAgICAgICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgICAgICByZXR1cm4gYWFiYjtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIzKG9iYiwgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9iYi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gb2JiW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBvYmJbaSArIDFdO1xuICAgICAgICAgICAgeiA9IG9iYltpICsgMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb0FBQkIzKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICB4ID0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpXVsxXTtcbiAgICAgICAgICAgIHogPSBwb2ludHNbaV1bMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvaW50cywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHkgKz0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9pbnRzW2ldWzJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzMocG9pbnRzW2ldLCBzcGhlcmUsIHRlbXBWZWMzKSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gZGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwaGVyZVszXSA9IHJhZGl1cztcblxuICAgICAgICAgICAgcmV0dXJuIHNwaGVyZTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGJvdW5kYXJ5IHNwaGVyZSBlbmNsb3NpbmcgdGhlIGdpdmVuIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcG9zaXRpb25zM1RvU3BoZXJlMzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcFZlYzNhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGxlblBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgeCArPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgeSArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbnVtUG9zaXRpb25zID0gbGVuUG9zaXRpb25zIC8gMztcblxuICAgICAgICAgICAgc3BoZXJlWzBdID0geCAvIG51bVBvc2l0aW9ucztcbiAgICAgICAgICAgIHNwaGVyZVsxXSA9IHkgLyBudW1Qb3NpdGlvbnM7XG4gICAgICAgICAgICBzcGhlcmVbMl0gPSB6IC8gbnVtUG9zaXRpb25zO1xuXG4gICAgICAgICAgICBsZXQgZGlzdDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdGVtcFZlYzNhWzFdID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMl0gPSBwb3NpdGlvbnNbaSArIDJdO1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzModGVtcFZlYzNhLCBzcGhlcmUsIHRlbXBWZWMzYikpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9pbnRzLCBzcGhlcmUpID0+IHtcblxuICAgICAgICAgICAgc3BoZXJlID0gc3BoZXJlIHx8IG1hdGgudmVjNCgpO1xuXG4gICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBsZXQgeiA9IDA7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgbGVuUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IGxlblBvaW50cyAvIDQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICB5ICs9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgeiArPSBwb2ludHNbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuXG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludFsyXSA9IHBvaW50c1tpICsgMl07XG5cbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMobWF0aC5sZW5WZWMzKG1hdGguc3ViVmVjMyhwb2ludCwgc3BoZXJlLCB0ZW1wVmVjMykpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSBib3VuZGluZyBzcGhlcmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNwaGVyZTNDZW50ZXIoc3BoZXJlLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgZGVzdFswXSA9IHNwaGVyZVswXTtcbiAgICAgICAgZGVzdFsxXSA9IHNwaGVyZVsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHNwaGVyZVsyXTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgM0QgY2VudGVyIG9mIHRoZSBnaXZlbiBmbGF0IGFycmF5IG9mIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25zQ2VudGVyKHBvc2l0aW9ucywgY2VudGVyID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgbGV0IHhDZW50ZXIgPSAwO1xuICAgICAgICBsZXQgeUNlbnRlciA9IDA7XG4gICAgICAgIGxldCB6Q2VudGVyID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgeENlbnRlciArPSBwb3NpdGlvbnNbaSArIDBdO1xuICAgICAgICAgICAgeUNlbnRlciArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgekNlbnRlciArPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuICAgICAgICBjZW50ZXJbMF0gPSB4Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMV0gPSB5Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMl0gPSB6Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBmaXJzdCBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgc2Vjb25kLCBpZiByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhwYW5kQUFCQjMoYWFiYjEsIGFhYmIyKSB7XG5cbiAgICAgICAgaWYgKGFhYmIxWzBdID4gYWFiYjJbMF0pIHtcbiAgICAgICAgICAgIGFhYmIxWzBdID0gYWFiYjJbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbMV0gPiBhYWJiMlsxXSkge1xuICAgICAgICAgICAgYWFiYjFbMV0gPSBhYWJiMlsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsyXSA+IGFhYmIyWzJdKSB7XG4gICAgICAgICAgICBhYWJiMVsyXSA9IGFhYmIyWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzNdIDwgYWFiYjJbM10pIHtcbiAgICAgICAgICAgIGFhYmIxWzNdID0gYWFiYjJbM107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbNF0gPCBhYWJiMls0XSkge1xuICAgICAgICAgICAgYWFiYjFbNF0gPSBhYWJiMls0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVs1XSA8IGFhYmIyWzVdKSB7XG4gICAgICAgICAgICBhYWJiMVs1XSA9IGFhYmIyWzVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmIxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBnaXZlbiBwb2ludCwgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50MyhhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA+IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzRdIDwgcFsxXSkge1xuICAgICAgICAgICAgYWFiYls0XSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYls1XSA8IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbNV0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYW4gYXhpcy1hbGlnbmVkIDNEIGJvdW5kYXJ5IHRvIGVuY2xvc2UgdGhlIGdpdmVuIHBvaW50cywgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50czMoYWFiYiwgcG9zaXRpb25zKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgaWYgKGFhYmJbMF0gPiB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlswXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYlsxXSA+IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzJdID4geikge1xuICAgICAgICAgICAgICAgIGFhYmJbMl0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhYmJbM10gPCB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlszXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYls0XSA8IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzRdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzVdIDwgeikge1xuICAgICAgICAgICAgICAgIGFhYmJbNV0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAyRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgMkQgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMihhYWJiID0gbWF0aC5BQUJCMigpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIHBvaW50M0FBQkIzSW50ZXJzZWN0KGFhYmIsIHApIHtcbiAgICAgICAgcmV0dXJuIGFhYmJbMF0gPiBwWzBdIHx8IGFhYmJbM10gPCBwWzBdIHx8IGFhYmJbMV0gPiBwWzFdIHx8IGFhYmJbNF0gPCBwWzFdIHx8IGFhYmJbMl0gPiBwWzJdIHx8IGFhYmJbNV0gPCBwWzJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXJcbiAgICAgKiBAcGFyYW0gY29uc3RhbnRcbiAgICAgKiBAcGFyYW0gYWFiYlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGxhbmVBQUJCM0ludGVyc2VjdChkaXIsIGNvbnN0YW50LCBhYWJiKSB7XG4gICAgICAgIGxldCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRpclswXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgICAgICBtYXggPSBkaXJbMF0gKiBhYWJiWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluID0gZGlyWzBdICogYWFiYlszXTtcbiAgICAgICAgICAgIG1heCA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclsxXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICAgICAgbWF4ICs9IGRpclsxXSAqIGFhYmJbNF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzFdICogYWFiYls0XTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJbMl0gPiAwKSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMl0gKiBhYWJiWzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluICs9IGRpclsyXSAqIGFhYmJbNV07XG4gICAgICAgICAgICBtYXggKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRzaWRlID0gKG1pbiA8PSAtY29uc3RhbnQpICYmIChtYXggPD0gLWNvbnN0YW50KTtcbiAgICAgICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluc2lkZSA9IChtaW4gPj0gLWNvbnN0YW50KSAmJiAobWF4ID49IC1jb25zdGFudCk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIDJEIHByb2plY3RlZCBheGlzLWFsaWduZWQgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIyKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjIoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICBsZXQgeW1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCB3O1xuICAgICAgICBsZXQgZjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgICAgIHggPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB3ID0gcG9pbnRzW2kgKyAzXSB8fCAxLjA7XG5cbiAgICAgICAgICAgIGYgPSAxLjAgLyB3O1xuXG4gICAgICAgICAgICB4ICo9IGY7XG4gICAgICAgICAgICB5ICo9IGY7XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPiB4bWF4KSB7XG4gICAgICAgICAgICAgICAgeG1heCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5ID4geW1heCkge1xuICAgICAgICAgICAgICAgIHltYXggPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgIGFhYmJbMV0gPSB5bWluO1xuICAgICAgICBhYWJiWzJdID0geG1heDtcbiAgICAgICAgYWFiYlszXSA9IHltYXg7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIGZpcnN0IGF4aXMtYWxpZ25lZCAyRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBzZWNvbmQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMihhYWJiMSwgYWFiYjIpIHtcblxuICAgICAgICBpZiAoYWFiYjFbMF0gPiBhYWJiMlswXSkge1xuICAgICAgICAgICAgYWFiYjFbMF0gPSBhYWJiMlswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsxXSA+IGFhYmIyWzFdKSB7XG4gICAgICAgICAgICBhYWJiMVsxXSA9IGFhYmIyWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzJdIDwgYWFiYjJbMl0pIHtcbiAgICAgICAgICAgIGFhYmIxWzJdID0gYWFiYjJbMl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbM10gPCBhYWJiMlszXSkge1xuICAgICAgICAgICAgYWFiYjFbM10gPSBhYWJiMlszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbiBheGlzLWFsaWduZWQgMkQgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgZ2l2ZW4gcG9pbnQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMlBvaW50MihhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA8IHBbMF0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzFdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICBBQUJCMlRvQ2FudmFzKGFhYmIsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIGFhYmIyID0gYWFiYikge1xuICAgICAgICBjb25zdCB4bWluID0gKGFhYmJbMF0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWluID0gKGFhYmJbMV0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB4bWF4ID0gKGFhYmJbMl0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWF4ID0gKGFhYmJbM10gKyAxLjApICogMC41O1xuXG4gICAgICAgIGFhYmIyWzBdID0gTWF0aC5mbG9vcih4bWluICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlsxXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1heCAqIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGFhYmIyWzJdID0gTWF0aC5mbG9vcih4bWF4ICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlszXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1pbiAqIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIGFhYmIyO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEN1cnZlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyKHQsIHAwLCBwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogKHAxIC0gcDApICsgMiAqIHQgKiAocDIgLSBwMSk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgK1xuICAgICAgICAgICAgMyAqIHAxICogKDEgLSB0KSAqICgxIC0gdCkgLSA2ICogdCAqIHAxICogKDEgLSB0KSArXG4gICAgICAgICAgICA2ICogdCAqIHAyICogKDEgLSB0KSAtIDMgKiB0ICogdCAqIHAyICtcbiAgICAgICAgICAgIDMgKiB0ICogdCAqIHAzO1xuICAgIH0sXG5cbiAgICB0YW5nZW50U3BsaW5lKHQpIHtcbiAgICAgICAgY29uc3QgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7XG4gICAgICAgIGNvbnN0IGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTtcbiAgICAgICAgY29uc3QgaDAxID0gLTYgKiB0ICogdCArIDYgKiB0O1xuICAgICAgICBjb25zdCBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcbiAgICAgICAgcmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcbiAgICB9LFxuXG4gICAgY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIGNvbnN0IHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICBjb25zdCB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICAgICAgY29uc3QgdDMgPSB0ICogdDI7XG4gICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICB9LFxuXG4vLyBCZXppZXIgQ3VydmUgZm9ybXVsaWkgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cbi8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjJwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogcDtcblxuICAgIH0sXG5cbiAgICBiMnAxKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIycDIodCwgcCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiMih0LCBwMCwgcDEsIHAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIycDAodCwgcDApICsgdGhpcy5iMnAxKHQsIHAxKSArIHRoaXMuYjJwMih0LCBwMik7XG4gICAgfSxcblxuLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjNwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG4gICAgfSxcblxuICAgIGIzcDEodCwgcCkge1xuICAgICAgICBjb25zdCBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcbiAgICB9LFxuXG4gICAgYjNwMih0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiM3AzKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIzcDAodCwgcDApICsgdGhpcy5iM3AxKHQsIHAxKSArIHRoaXMuYjNwMih0LCBwMikgKyB0aGlzLmIzcDModCwgcDMpO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdlb21ldHJ5XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbCB2ZWN0b3Igb2YgYSB0cmlhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJpYW5nbGVOb3JtYWwoYSwgYiwgYywgbm9ybWFsID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgcDF4ID0gYlswXSAtIGFbMF07XG4gICAgICAgIGNvbnN0IHAxeSA9IGJbMV0gLSBhWzFdO1xuICAgICAgICBjb25zdCBwMXogPSBiWzJdIC0gYVsyXTtcblxuICAgICAgICBjb25zdCBwMnggPSBjWzBdIC0gYVswXTtcbiAgICAgICAgY29uc3QgcDJ5ID0gY1sxXSAtIGFbMV07XG4gICAgICAgIGNvbnN0IHAyeiA9IGNbMl0gLSBhWzJdO1xuXG4gICAgICAgIGNvbnN0IHAzeCA9IHAxeSAqIHAyeiAtIHAxeiAqIHAyeTtcbiAgICAgICAgY29uc3QgcDN5ID0gcDF6ICogcDJ4IC0gcDF4ICogcDJ6O1xuICAgICAgICBjb25zdCBwM3ogPSBwMXggKiBwMnkgLSBwMXkgKiBwMng7XG5cbiAgICAgICAgY29uc3QgbWFnID0gTWF0aC5zcXJ0KHAzeCAqIHAzeCArIHAzeSAqIHAzeSArIHAzeiAqIHAzeik7XG4gICAgICAgIGlmIChtYWcgPT09IDApIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IDA7XG4gICAgICAgICAgICBub3JtYWxbMV0gPSAwO1xuICAgICAgICAgICAgbm9ybWFsWzJdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IHAzeCAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsxXSA9IHAzeSAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsyXSA9IHAzeiAvIG1hZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgM0QgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJheVRyaWFuZ2xlSW50ZXJzZWN0OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChvcmlnaW4sIGRpciwgYSwgYiwgYywgaXNlY3QpID0+IHtcblxuICAgICAgICAgICAgaXNlY3QgPSBpc2VjdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICAgICAgY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG4gICAgICAgICAgICBjb25zdCBlZGdlMSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2IpO1xuXG4gICAgICAgICAgICBjb25zdCBwdmVjID0gbWF0aC5jcm9zczNWZWMzKGRpciwgZWRnZTIsIHRlbXBWZWMzYyk7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRvdFZlYzMoZWRnZTEsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKGRldCA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHZlYyA9IG1hdGguc3ViVmVjMyhvcmlnaW4sIGEsIHRlbXBWZWMzZCk7XG4gICAgICAgICAgICBjb25zdCB1ID0gbWF0aC5kb3RWZWMzKHR2ZWMsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKHUgPCAwIHx8IHUgPiBkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcXZlYyA9IG1hdGguY3Jvc3MzVmVjMyh0dmVjLCBlZGdlMSwgdGVtcFZlYzNlKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtYXRoLmRvdFZlYzMoZGlyLCBxdmVjKTtcbiAgICAgICAgICAgIGlmICh2IDwgMCB8fCB1ICsgdiA+IGRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ID0gbWF0aC5kb3RWZWMzKGVkZ2UyLCBxdmVjKSAvIGRldDtcbiAgICAgICAgICAgIGlzZWN0WzBdID0gb3JpZ2luWzBdICsgdCAqIGRpclswXTtcbiAgICAgICAgICAgIGlzZWN0WzFdID0gb3JpZ2luWzFdICsgdCAqIGRpclsxXTtcbiAgICAgICAgICAgIGlzZWN0WzJdID0gb3JpZ2luWzJdICsgdCAqIGRpclsyXTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzZWN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSAzIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmF5UGxhbmVJbnRlcnNlY3Q6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNkID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKG9yaWdpbiwgZGlyLCBhLCBiLCBjLCBpc2VjdCkgPT4ge1xuXG4gICAgICAgICAgICBpc2VjdCA9IGlzZWN0IHx8IG1hdGgudmVjMygpO1xuXG4gICAgICAgICAgICBkaXIgPSBtYXRoLm5vcm1hbGl6ZVZlYzMoZGlyLCB0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVkZ2UxID0gbWF0aC5zdWJWZWMzKGIsIGEsIHRlbXBWZWMzYik7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBuID0gbWF0aC5jcm9zczNWZWMzKGVkZ2UxLCBlZGdlMiwgdGVtcFZlYzNkKTtcbiAgICAgICAgICAgIG1hdGgubm9ybWFsaXplVmVjMyhuLCBuKTtcblxuICAgICAgICAgICAgY29uc3QgZCA9IC1tYXRoLmRvdFZlYzMoYSwgbik7XG5cbiAgICAgICAgICAgIGNvbnN0IHQgPSAtKG1hdGguZG90VmVjMyhvcmlnaW4sIG4pICsgZCkgLyBtYXRoLmRvdFZlYzMoZGlyLCBuKTtcblxuICAgICAgICAgICAgaXNlY3RbMF0gPSBvcmlnaW5bMF0gKyB0ICogZGlyWzBdO1xuICAgICAgICAgICAgaXNlY3RbMV0gPSBvcmlnaW5bMV0gKyB0ICogZGlyWzFdO1xuICAgICAgICAgICAgaXNlY3RbMl0gPSBvcmlnaW5bMl0gKyB0ICogZGlyWzJdO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNlY3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGZyb20gY2FydGVzaWFuIGNvb3JkaW5hdGVzIHdpdGhpbiBhIHRyaWFuZ2xlLlxuICAgICAqIEdldHMgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgZnJvbSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhcnRlc2lhblRvQmFyeWNlbnRyaWM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhcnRlc2lhbiwgYSwgYiwgYywgZGVzdCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB2MCA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCB2MSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjM2IpO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBtYXRoLnN1YlZlYzMoY2FydGVzaWFuLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBkb3QwMCA9IG1hdGguZG90VmVjMyh2MCwgdjApO1xuICAgICAgICAgICAgY29uc3QgZG90MDEgPSBtYXRoLmRvdFZlYzModjAsIHYxKTtcbiAgICAgICAgICAgIGNvbnN0IGRvdDAyID0gbWF0aC5kb3RWZWMzKHYwLCB2Mik7XG4gICAgICAgICAgICBjb25zdCBkb3QxMSA9IG1hdGguZG90VmVjMyh2MSwgdjEpO1xuICAgICAgICAgICAgY29uc3QgZG90MTIgPSBtYXRoLmRvdFZlYzModjEsIHYyKTtcblxuICAgICAgICAgICAgY29uc3QgZGVub20gPSAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuXG4gICAgICAgICAgICAvLyBDb2xpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXG4gICAgICAgICAgICBpZiAoZGVub20gPT09IDApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cbiAgICAgICAgICAgIGNvbnN0IHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgICAgICBjb25zdCB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gMSAtIHUgLSB2O1xuICAgICAgICAgICAgZGVzdFsxXSA9IHY7XG4gICAgICAgICAgICBkZXN0WzJdID0gdTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlaXIgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljSW5zaWRlVHJpYW5nbGUoYmFyeSkge1xuXG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB1ID0gYmFyeVsyXTtcblxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FydGVzaWFuIGNvb3JkaW5hdGVzIGZyb20gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljVG9DYXJ0ZXNpYW4oYmFyeSwgYSwgYiwgYywgY2FydGVzaWFuID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgdSA9IGJhcnlbMF07XG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB3ID0gYmFyeVsyXTtcblxuICAgICAgICBjYXJ0ZXNpYW5bMF0gPSBhWzBdICogdSArIGJbMF0gKiB2ICsgY1swXSAqIHc7XG4gICAgICAgIGNhcnRlc2lhblsxXSA9IGFbMV0gKiB1ICsgYlsxXSAqIHYgKyBjWzFdICogdztcbiAgICAgICAgY2FydGVzaWFuWzJdID0gYVsyXSAqIHUgKyBiWzJdICogdiArIGNbMl0gKiB3O1xuXG4gICAgICAgIHJldHVybiBjYXJ0ZXNpYW47XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gZ2VvbWV0cnkgZGVmaW5lZCBhcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMsIG9wdGlvbmFsIG5vcm1hbHMsIG9wdGlvbiB1diBhbmQgYW4gYXJyYXkgb2YgaW5kaWNlcywgcmV0dXJuc1xuICAgICAqIG1vZGlmaWVkIGFycmF5cyB0aGF0IGhhdmUgZHVwbGljYXRlIHZlcnRpY2VzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBkb2VzIG5vdCB3b3JrIHdlbGwgd2hlbiBjby1pbmNpZGVudCB2ZXJ0aWNlcyBoYXZlIHNhbWUgcG9zaXRpb25zIGJ1dCBkaWZmZXJlbnQgbm9ybWFscyBhbmQgVVZzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSBub3JtYWxzXG4gICAgICogQHBhcmFtIHV2XG4gICAgICogQHBhcmFtIGluZGljZXNcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIGluZGljZXM6IEFycmF5fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1lcmdlVmVydGljZXMocG9zaXRpb25zLCBub3JtYWxzLCB1diwgaW5kaWNlcykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICAgICAgY29uc3QgaW5kaWNlc0xvb2t1cCA9IFtdO1xuICAgICAgICBjb25zdCB1bmlxdWVQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5pcXVlTm9ybWFscyA9IG5vcm1hbHMgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVVWID0gdXYgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGluZGljZXMyID0gW107XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgdXZpID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zTWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc01hcFtrZXldID0gdW5pcXVlUG9zaXRpb25zLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zLnB1c2godngpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9ucy5wdXNoKHZ5KTtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnMucHVzaCh2eik7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlTm9ybWFscy5wdXNoKG5vcm1hbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmldKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmkgKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgICAgIHV2aSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGluZGljZXMyW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHVuaXF1ZVBvc2l0aW9ucyxcbiAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMyXG4gICAgICAgIH07XG4gICAgICAgIGlmICh1bmlxdWVOb3JtYWxzKSB7XG4gICAgICAgICAgICByZXN1bHQubm9ybWFscyA9IHVuaXF1ZU5vcm1hbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXF1ZVVWKSB7XG4gICAgICAgICAgICByZXN1bHQudXYgPSB1bmlxdWVVVjtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBub3JtYWwgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucyBhbmQgaW5kaWNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGROb3JtYWxzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBjb25zdCBhYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgY3Jvc3NWZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9zaXRpb25zLCBpbmRpY2VzLCBub3JtYWxzKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgICAgIGNvbnN0IG52ZWNzID0gbmV3IEFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzKTtcbiAgICAgICAgICAgIGxldCBqMDtcbiAgICAgICAgICAgIGxldCBqMTtcbiAgICAgICAgICAgIGxldCBqMjtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuXG4gICAgICAgICAgICAgICAgajAgPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGoxID0gaW5kaWNlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgajIgPSBpbmRpY2VzW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgIGFbMF0gPSBwb3NpdGlvbnNbajAgKiAzXTtcbiAgICAgICAgICAgICAgICBhWzFdID0gcG9zaXRpb25zW2owICogMyArIDFdO1xuICAgICAgICAgICAgICAgIGFbMl0gPSBwb3NpdGlvbnNbajAgKiAzICsgMl07XG5cbiAgICAgICAgICAgICAgICBiWzBdID0gcG9zaXRpb25zW2oxICogM107XG4gICAgICAgICAgICAgICAgYlsxXSA9IHBvc2l0aW9uc1tqMSAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICBiWzJdID0gcG9zaXRpb25zW2oxICogMyArIDJdO1xuXG4gICAgICAgICAgICAgICAgY1swXSA9IHBvc2l0aW9uc1tqMiAqIDNdO1xuICAgICAgICAgICAgICAgIGNbMV0gPSBwb3NpdGlvbnNbajIgKiAzICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHBvc2l0aW9uc1tqMiAqIDMgKyAyXTtcblxuICAgICAgICAgICAgICAgIG1hdGguc3ViVmVjMyhiLCBhLCBhYik7XG4gICAgICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGEsIGFjKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1WZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKG1hdGguY3Jvc3MzVmVjMyhhYiwgYWMsIGNyb3NzVmVjKSwgbm9ybVZlYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW52ZWNzW2owXSkge1xuICAgICAgICAgICAgICAgICAgICBudmVjc1tqMF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFudmVjc1tqMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnZlY3NbajFdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbnZlY3NbajJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG52ZWNzW2oyXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG52ZWNzW2owXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oxXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oyXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3JtYWxzID0gKG5vcm1hbHMgJiYgbm9ybWFscy5sZW5ndGggPT09IHBvc2l0aW9ucy5sZW5ndGgpID8gbm9ybWFscyA6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGxldCBjb3VudDtcbiAgICAgICAgICAgIGxldCB4O1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgejtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbnZlY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgIC8vIE5vdyBnbyB0aHJvdWdoIGFuZCBhdmVyYWdlIG91dCBldmVyeXRoaW5nXG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IG52ZWNzW2ldLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIHogPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbnZlY3NbaV1bal1bMF07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbnZlY3NbaV1bal1bMV07XG4gICAgICAgICAgICAgICAgICAgIHogKz0gbnZlY3NbaV1bal1bMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9ybWFsc1tpICogM10gPSAoeCAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMV0gPSAoeSAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMl0gPSAoeiAvIGNvdW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IHRhbmdlbnQgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucywgVVZzIGFuZCBpbmRpY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFRhbmdlbnRzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbnMsIGluZGljZXMsIHV2KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gVGhlIHZlcnRleCBhcnJheXMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgdGFuZ2VudHNcblxuICAgICAgICAgICAgZm9yIChsZXQgbG9jYXRpb24gPSAwOyBsb2NhdGlvbiA8IGluZGljZXMubGVuZ3RoOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWNvbnRydWN0aW5nIGVhY2ggdmVydGV4IGFuZCBVViBjb29yZGluYXRlIGludG8gdGhlIHJlc3BlY3RpdmUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHBvc2l0aW9ucy5zdWJhcnJheShpbmRleCAqIDMsIGluZGV4ICogMyArIDMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHV2MCA9IHV2LnN1YmFycmF5KGluZGV4ICogMiwgaW5kZXggKiAyICsgMik7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gcG9zaXRpb25zLnN1YmFycmF5KGluZGV4ICogMywgaW5kZXggKiAzICsgMyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXYxID0gdXYuc3ViYXJyYXkoaW5kZXggKiAyLCBpbmRleCAqIDIgKyAyKTtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbiArIDJdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdjIgPSBwb3NpdGlvbnMuc3ViYXJyYXkoaW5kZXggKiAzLCBpbmRleCAqIDMgKyAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1djIgPSB1di5zdWJhcnJheShpbmRleCAqIDIsIGluZGV4ICogMiArIDIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFQb3MxID0gbWF0aC5zdWJWZWMzKHYxLCB2MCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhUG9zMiA9IG1hdGguc3ViVmVjMyh2MiwgdjAsIHRlbXBWZWMzYik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMSA9IG1hdGguc3ViVmVjMih1djEsIHV2MCwgdGVtcFZlYzNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMiA9IG1hdGguc3ViVmVjMih1djIsIHV2MCwgdGVtcFZlYzNkKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAxIC8gKChkZWx0YVVWMVswXSAqIGRlbHRhVVYyWzFdKSAtIChkZWx0YVVWMVsxXSAqIGRlbHRhVVYyWzBdKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gbWF0aC5tdWxWZWMzU2NhbGFyKFxuICAgICAgICAgICAgICAgICAgICBtYXRoLnN1YlZlYzMoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm11bFZlYzNTY2FsYXIoZGVsdGFQb3MxLCBkZWx0YVVWMlsxXSwgdGVtcFZlYzNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubXVsVmVjM1NjYWxhcihkZWx0YVBvczIsIGRlbHRhVVYxWzFdLCB0ZW1wVmVjM2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFZlYzNnXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZWMzZlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBdmVyYWdlIHRoZSB2YWx1ZSBvZiB0aGUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGFkZFRvO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCAzOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG8gPSBpbmRpY2VzW2xvY2F0aW9uICsgdl0gKiAzO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUb10gKz0gdGFuZ2VudFswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudHNbYWRkVG8gKyAxXSArPSB0YW5nZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUbyArIDJdICs9IHRhbmdlbnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFuZ2VudHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IGFuZCBpbmRleCBhcnJheXMgbmVlZGVkIGJ5IGNvbG9yLWluZGV4ZWQgdHJpYW5nbGUgcGlja2luZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRQaWNrVHJpYW5nbGVzKHBvc2l0aW9ucywgaW5kaWNlcywgY29tcHJlc3NHZW9tZXRyeSkge1xuXG4gICAgICAgIGNvbnN0IG51bUluZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGlja1Bvc2l0aW9ucyA9IGNvbXByZXNzR2VvbWV0cnkgPyBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcyAqIDkpIDogbmV3IEZsb2F0MzJBcnJheShudW1JbmRpY2VzICogOSk7XG4gICAgICAgIGNvbnN0IHBpY2tDb2xvcnMgPSBuZXcgVWludDhBcnJheShudW1JbmRpY2VzICogMTIpO1xuICAgICAgICBsZXQgcHJpbUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHZpOy8vIFBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcHZpID0gMDsvLyBQaWNraW5nIHBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcGNpID0gMDsgLy8gUGlja2luZyBjb2xvciBhcnJheSBpbmRleFxuXG4gICAgICAgIC8vIFRyaWFuZ2xlIGluZGljZXNcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCByO1xuICAgICAgICBsZXQgZztcbiAgICAgICAgbGV0IGI7XG4gICAgICAgIGxldCBhO1xuXG4gICAgICAgIGZvciAobGV0IGxvY2F0aW9uID0gMDsgbG9jYXRpb24gPCBudW1JbmRpY2VzOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZS1pbmRleGVkIHRyaWFuZ2xlIHBpY2sgY29sb3JcblxuICAgICAgICAgICAgYSA9IChwcmltSW5kZXggPj4gMjQgJiAweEZGKTtcbiAgICAgICAgICAgIGIgPSAocHJpbUluZGV4ID4+IDE2ICYgMHhGRik7XG4gICAgICAgICAgICBnID0gKHByaW1JbmRleCA+PiA4ICYgMHhGRik7XG4gICAgICAgICAgICByID0gKHByaW1JbmRleCAmIDB4RkYpO1xuXG4gICAgICAgICAgICAvLyBBXG5cbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2xvY2F0aW9uXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIEJcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIENcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAyXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIHByaW1JbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogcGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGNvbG9yczogcGlja0NvbG9yc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBzdXJmYWNlLXBlcnBlbmRpY3VsYXIgZmFjZSBub3JtYWxzIHRvIHZlcnRleCBub3JtYWxzLiBBc3N1bWVzIHRoYXQgdGhlIG1lc2ggY29udGFpbnMgZGlzam9pbnQgdHJpYW5nbGVzXG4gICAgICogdGhhdCBkb24ndCBzaGFyZSB2ZXJ0ZXggYXJyYXkgZWxlbWVudHMuIFdvcmtzIGJ5IGZpbmRpbmcgZ3JvdXBzIG9mIHZlcnRpY2VzIHRoYXQgaGF2ZSB0aGUgc2FtZSBsb2NhdGlvbiBhbmRcbiAgICAgKiBhdmVyYWdpbmcgdGhlaXIgbm9ybWFsIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIG5vcm1hbHM6ICp9fVxuICAgICAqL1xuICAgIGZhY2VUb1ZlcnRleE5vcm1hbHMocG9zaXRpb25zLCBub3JtYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc21vb3RoTm9ybWFsc0FuZ2xlVGhyZXNob2xkID0gb3B0aW9ucy5zbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQgfHwgMjA7XG4gICAgICAgIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJ0ZXhOb3JtYWxzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnRleE5vcm1hbEFjY3VtID0ge307XG4gICAgICAgIGxldCBhY2M7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBwb3NpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW47XG4gICAgICAgIGxldCBhO1xuICAgICAgICBsZXQgYjtcbiAgICAgICAgbGV0IGM7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHBvc2kgPSBpIC8gMztcblxuICAgICAgICAgICAgdnggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB2eSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICB2eiA9IHBvc2l0aW9uc1tpICsgMl07XG5cbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4TWFwW2tleV0gPSBbcG9zaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRleE1hcFtrZXldLnB1c2gocG9zaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IG1hdGgubm9ybWFsaXplVmVjMyhbbm9ybWFsc1tpXSwgbm9ybWFsc1tpICsgMV0sIG5vcm1hbHNbaSArIDJdXSk7XG5cbiAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbcG9zaV0gPSBub3JtYWw7XG5cbiAgICAgICAgICAgIGFjYyA9IG1hdGgudmVjNChbbm9ybWFsWzBdLCBub3JtYWxbMV0sIG5vcm1hbFsyXSwgMV0pO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxBY2N1bVtwb3NpXSA9IGFjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHZlcnRleE1hcCkge1xuXG4gICAgICAgICAgICBpZiAodmVydGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdmVydGV4TWFwW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtVmVydHMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlpID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgYWNjID0gdmVydGV4Tm9ybWFsQWNjdW1baWldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1WZXJ0czsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpqID0gdmVydGljZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB2ZXJ0ZXhOb3JtYWxzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB2ZXJ0ZXhOb3JtYWxzW2pqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhtYXRoLmFuZ2xlVmVjMyhhLCBiKSAvIG1hdGguREVHVE9SQUQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCBzbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1swXSArPSBiWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1sxXSArPSBiWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1syXSArPSBiWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1szXSArPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub3JtYWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIGFjYyA9IHZlcnRleE5vcm1hbEFjY3VtW2kgLyAzXTtcblxuICAgICAgICAgICAgbm9ybWFsc1tpICsgMF0gPSBhY2NbMF0gLyBhY2NbM107XG4gICAgICAgICAgICBub3JtYWxzW2kgKyAxXSA9IGFjY1sxXSAvIGFjY1szXTtcbiAgICAgICAgICAgIG5vcm1hbHNbaSArIDJdID0gYWNjWzJdIC8gYWNjWzNdO1xuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSYXkgY2FzdGluZ1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgVHJhbnNmb3JtcyBhIENhbnZhcy1zcGFjZSBwb3NpdGlvbiBpbnRvIGEgV29ybGQtc3BhY2UgcmF5LCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb1dvcmxkUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gdmlld01hdHJpeCBWaWV3IG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSBwcm9qTWF0cml4IFByb2plY3Rpb24gbWF0cml4XG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGNhbnZhc1BvcyBUaGUgQ2FudmFzLXNwYWNlIHBvc2l0aW9uLlxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgY2FudmFzUG9zVG9Xb3JsZFJheTogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDRiID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0YyA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGIgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGMgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIHJldHVybiAoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBwdk1hdCA9IG1hdGgubXVsTWF0NChwcm9qTWF0cml4LCB2aWV3TWF0cml4LCB0ZW1wTWF0NGIpO1xuICAgICAgICAgICAgY29uc3QgcHZNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NChwdk1hdCwgdGVtcE1hdDRjKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNsaXAgc3BhY2UgY29vcmRpbmF0ZXMsIHdoaWNoIHdpbGwgYmUgaW4gcmFuZ2VcbiAgICAgICAgICAgIC8vIG9mIHg9Wy0xLi4xXSBhbmQgeT1bLTEuLjFdLCB3aXRoIHk9KCsxKSBhdCB0b3BcblxuICAgICAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCBjbGlwWCA9IChjYW52YXNQb3NbMF0gLSBjYW52YXNXaWR0aCAvIDIpIC8gKGNhbnZhc1dpZHRoIC8gMik7ICAvLyBDYWxjdWxhdGUgY2xpcCBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29uc3QgY2xpcFkgPSAtKGNhbnZhc1Bvc1sxXSAtIGNhbnZhc0hlaWdodCAvIDIpIC8gKGNhbnZhc0hlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSBjbGlwWDtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IGNsaXBZO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gLTE7XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRiLCAxIC8gdGVtcFZlYzRiWzNdKTtcblxuICAgICAgICAgICAgdGVtcFZlYzRjWzBdID0gY2xpcFg7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbMV0gPSBjbGlwWTtcbiAgICAgICAgICAgIHRlbXBWZWM0Y1syXSA9IDE7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGMsIHRlbXBWZWM0ZCk7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRkLCAxIC8gdGVtcFZlYzRkWzNdKTtcblxuICAgICAgICAgICAgd29ybGRSYXlPcmlnaW5bMF0gPSB0ZW1wVmVjNGRbMF07XG4gICAgICAgICAgICB3b3JsZFJheU9yaWdpblsxXSA9IHRlbXBWZWM0ZFsxXTtcbiAgICAgICAgICAgIHdvcmxkUmF5T3JpZ2luWzJdID0gdGVtcFZlYzRkWzJdO1xuXG4gICAgICAgICAgICBtYXRoLnN1YlZlYzModGVtcFZlYzRkLCB0ZW1wVmVjNGIsIHdvcmxkUmF5RGlyKTtcblxuICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKHdvcmxkUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICBUcmFuc2Zvcm1zIGEgQ2FudmFzLXNwYWNlIHBvc2l0aW9uIHRvIGEgTWVzaCdzIExvY2FsLXNwYWNlIGNvb3JkaW5hdGUgc3lzdGVtLCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb0xvY2FsUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBUaGUgQ2FtZXJhLlxuICAgICBAcGFyYW0ge01lc2h9IG1lc2ggVGhlIE1lc2guXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXRyaXggVmlldyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gcHJvak1hdHJpeCBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBNb2RlbGluZyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gY2FudmFzUG9zIFRoZSBDYW52YXMtc3BhY2UgcG9zaXRpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBjYW52YXNQb3NUb0xvY2FsUmF5OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB3b3JsZFJheU9yaWdpbiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHdvcmxkUmF5RGlyID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhbnZhcywgdmlld01hdHJpeCwgcHJvak1hdHJpeCwgd29ybGRNYXRyaXgsIGNhbnZhc1BvcywgbG9jYWxSYXlPcmlnaW4sIGxvY2FsUmF5RGlyKSA9PiB7XG4gICAgICAgICAgICBtYXRoLmNhbnZhc1Bvc1RvV29ybGRSYXkoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcik7XG4gICAgICAgICAgICBtYXRoLndvcmxkUmF5VG9Mb2NhbFJheSh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgIFRyYW5zZm9ybXMgYSByYXkgZnJvbSBXb3JsZC1zcGFjZSB0byBhIE1lc2gncyBMb2NhbC1zcGFjZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgQG1ldGhvZCB3b3JsZFJheVRvTG9jYWxSYXlcbiAgICAgQHN0YXRpY1xuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBUaGUgV29ybGQgdHJhbnNmb3JtIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB3b3JsZFJheVRvTG9jYWxSYXk6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAgICAgcmV0dXJuICh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NCh3b3JsZE1hdHJpeCwgdGVtcE1hdDQpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSB3b3JsZFJheU9yaWdpblswXTtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IHdvcmxkUmF5T3JpZ2luWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gd29ybGRSYXlPcmlnaW5bMl07XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQobW9kZWxNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG5cbiAgICAgICAgICAgIGxvY2FsUmF5T3JpZ2luWzBdID0gdGVtcFZlYzRiWzBdO1xuICAgICAgICAgICAgbG9jYWxSYXlPcmlnaW5bMV0gPSB0ZW1wVmVjNGJbMV07XG4gICAgICAgICAgICBsb2NhbFJheU9yaWdpblsyXSA9IHRlbXBWZWM0YlsyXTtcblxuICAgICAgICAgICAgbWF0aC50cmFuc2Zvcm1WZWMzKG1vZGVsTWF0SW52ZXJzZSwgd29ybGRSYXlEaXIsIGxvY2FsUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIGJ1aWxkS0RUcmVlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBLRF9UUkVFX01BWF9ERVBUSCA9IDEwO1xuICAgICAgICBjb25zdCBLRF9UUkVFX01JTl9UUklBTkdMRVMgPSAyMDtcblxuICAgICAgICBjb25zdCBkaW1MZW5ndGggPSBuZXcgRmxvYXQzMkFycmF5KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGROb2RlKHRyaWFuZ2xlcywgaW5kaWNlcywgcG9zaXRpb25zLCBkZXB0aCkge1xuICAgICAgICAgICAgY29uc3QgYWFiYiA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGVhZjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3BsaXREaW06IDAsXG4gICAgICAgICAgICAgICAgYWFiYlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWFiYlswXSA9IGFhYmJbMV0gPSBhYWJiWzJdID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgYWFiYlszXSA9IGFhYmJbNF0gPSBhYWJiWzVdID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlpID0gdHJpYW5nbGVzW3RdICogMztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGluZGljZXNbaWkgKyBqXSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGldIDwgYWFiYlswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlswXSA9IHBvc2l0aW9uc1twaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW3BpXSA+IGFhYmJbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhYmJbM10gPSBwb3NpdGlvbnNbcGldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdIDwgYWFiYlsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsxXSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdID4gYWFiYls0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls0XSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdIDwgYWFiYlsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsyXSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdID4gYWFiYls1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls1XSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmlhbmdsZXMubGVuZ3RoIDwgS0RfVFJFRV9NSU5fVFJJQU5HTEVTIHx8IGRlcHRoID4gS0RfVFJFRV9NQVhfREVQVEgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcbiAgICAgICAgICAgICAgICBub2RlLmxlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaW1MZW5ndGhbMF0gPSBhYWJiWzNdIC0gYWFiYlswXTtcbiAgICAgICAgICAgIGRpbUxlbmd0aFsxXSA9IGFhYmJbNF0gLSBhYWJiWzFdO1xuICAgICAgICAgICAgZGltTGVuZ3RoWzJdID0gYWFiYls1XSAtIGFhYmJbMl07XG5cbiAgICAgICAgICAgIGxldCBkaW0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzFdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzJdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLnNwbGl0RGltID0gZGltO1xuXG4gICAgICAgICAgICBjb25zdCBtaWQgPSAoYWFiYltkaW1dICsgYWFiYltkaW0gKyAzXSkgLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG5ldyBBcnJheSh0cmlhbmdsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBudW1MZWZ0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbmV3IEFycmF5KHRyaWFuZ2xlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IG51bVJpZ2h0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWkgPSB0cmlhbmdsZXNbdF0gKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkwID0gaW5kaWNlc1tpaV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTEgPSBpbmRpY2VzW2lpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTIgPSBpbmRpY2VzW2lpICsgMl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwaTAgPSBpMCAqIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGkxID0gaTEgKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpMiA9IGkyICogMztcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGkwICsgZGltXSA8PSBtaWQgfHwgcG9zaXRpb25zW3BpMSArIGRpbV0gPD0gbWlkIHx8IHBvc2l0aW9uc1twaTIgKyBkaW1dIDw9IG1pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0W251bUxlZnQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRbbnVtUmlnaHQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0Lmxlbmd0aCA9IG51bUxlZnQ7XG4gICAgICAgICAgICByaWdodC5sZW5ndGggPSBudW1SaWdodDtcblxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gYnVpbGROb2RlKGxlZnQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSBidWlsZE5vZGUocmlnaHQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGluZGljZXMsIHBvc2l0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbnVtVHJpcyA9IGluZGljZXMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IG5ldyBBcnJheShudW1UcmlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJpczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZE5vZGUodHJpYW5nbGVzLCBpbmRpY2VzLCBwb3NpdGlvbnMsIDApO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG5cbiAgICBkZWNvbXByZXNzUG9zaXRpb24ocG9zaXRpb24sIGRlY29kZU1hdHJpeCwgZGVzdCkge1xuICAgICAgICBkZXN0WzBdID0gcG9zaXRpb25bMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbMTJdO1xuICAgICAgICBkZXN0WzFdID0gcG9zaXRpb25bMV0gKiBkZWNvZGVNYXRyaXhbNV0gKyBkZWNvZGVNYXRyaXhbMTNdO1xuICAgICAgICBkZXN0WzJdID0gcG9zaXRpb25bMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1Bvc2l0aW9ucyhwb3NpdGlvbnMsIGRlY29kZU1hdHJpeCwgZGVzdCA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgZGVzdFtpICsgMF0gPSBwb3NpdGlvbnNbaSArIDBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzEyXTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gcG9zaXRpb25zW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs1XSArIGRlY29kZU1hdHJpeFsxM107XG4gICAgICAgICAgICBkZXN0W2kgKyAyXSA9IHBvc2l0aW9uc1tpICsgMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1VWKHV2LCBkZWNvZGVNYXRyaXgsIGRlc3QpIHtcbiAgICAgICAgZGVzdFswXSA9IHV2WzBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzZdO1xuICAgICAgICBkZXN0WzFdID0gdXZbMV0gKiBkZWNvZGVNYXRyaXhbNF0gKyBkZWNvZGVNYXRyaXhbN107XG4gICAgfSxcblxuICAgIGRlY29tcHJlc3NVVnModXZzLCBkZWNvZGVNYXRyaXgsIGRlc3QgPSBuZXcgRmxvYXQzMkFycmF5KHV2cy5sZW5ndGgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB1dnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGRlc3RbaSArIDBdID0gdXZzW2kgKyAwXSAqIGRlY29kZU1hdHJpeFswXSArIGRlY29kZU1hdHJpeFs2XTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gdXZzW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs0XSArIGRlY29kZU1hdHJpeFs3XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMihvY3QsIHJlc3VsdCkge1xuICAgICAgICBsZXQgeCA9IG9jdFswXTtcbiAgICAgICAgbGV0IHkgPSBvY3RbMV07XG4gICAgICAgIHggPSAoMiAqIHggKyAxKSAvIDI1NTtcbiAgICAgICAgeSA9ICgyICogeSArIDEpIC8gMjU1O1xuICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgeCA9ICgxIC0gTWF0aC5hYnMoeSkpICogKHggPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgcmVzdWx0WzBdID0geCAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzJdID0geiAvIGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMnMob2N0cywgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbGVuID0gb2N0cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHggPSBvY3RzW2kgKyAwXTtcbiAgICAgICAgICAgIGxldCB5ID0gb2N0c1tpICsgMV07XG4gICAgICAgICAgICB4ID0gKDIgKiB4ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICB5ID0gKDIgKiB5ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gKDEgLSBNYXRoLmFicyh5KSkgKiAoeCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICAgICAgcmVzdWx0W2ogKyAwXSA9IHggLyBsZW5ndGg7XG4gICAgICAgICAgICByZXN1bHRbaiArIDFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdFtqICsgMl0gPSB6IC8gbGVuZ3RoO1xuICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubWF0aC5idWlsZEVkZ2VJbmRpY2VzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHVuaXF1ZVBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXNMb29rdXAgPSBbXTtcbiAgICBjb25zdCBpbmRpY2VzUmV2ZXJzZUxvb2t1cCA9IFtdO1xuICAgIGNvbnN0IHdlbGRlZEluZGljZXMgPSBbXTtcblxuICAgIC8vIFRPRE86IE9wdGltaXplIHdpdGggY2FjaGluZywgYnV0IG5lZWQgdG8gY2F0ZXIgdG8gYm90aCBjb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgcG9zaXRpb25zXG5cbiAgICBjb25zdCBmYWNlcyA9IFtdO1xuICAgIGxldCBudW1GYWNlcyA9IDA7XG4gICAgY29uc3QgY29tcGEgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGIgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGMgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgYSA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBjID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgY2IgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBhYiA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGNyb3NzID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3Qgbm9ybWFsID0gbWF0aC52ZWMzKCk7XG5cbiAgICBmdW5jdGlvbiB3ZWxkVmVydGljZXMocG9zaXRpb25zLCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuICAgICAgICBsZXQgdng7XG4gICAgICAgIGxldCB2eTtcbiAgICAgICAgbGV0IHZ6O1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBjb25zdCBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvblBvaW50cyk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgbGVuVW5pcXVlUG9zaXRpb25zID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IE1hdGgucm91bmQodnggKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2eSAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZ6ICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbnNNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zTWFwW2tleV0gPSBsZW5VbmlxdWVQb3NpdGlvbnMgLyAzO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9uc1tsZW5VbmlxdWVQb3NpdGlvbnMrK10gPSB2eDtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnNbbGVuVW5pcXVlUG9zaXRpb25zKytdID0gdnk7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zW2xlblVuaXF1ZVBvc2l0aW9ucysrXSA9IHZ6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB3ZWxkZWRJbmRpY2VzW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgICAgIGluZGljZXNSZXZlcnNlTG9va3VwW3dlbGRlZEluZGljZXNbaV1dID0gaW5kaWNlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmFjZXMobnVtSW5kaWNlcywgcG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgIG51bUZhY2VzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG51bUluZGljZXM7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgaWEgPSAoKHdlbGRlZEluZGljZXNbaV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYiA9ICgod2VsZGVkSW5kaWNlc1tpICsgMV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYyA9ICgod2VsZGVkSW5kaWNlc1tpICsgMl0pICogMyk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgY29tcGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGNvbXBhWzFdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMV07XG4gICAgICAgICAgICAgICAgY29tcGFbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAyXTtcbiAgICAgICAgICAgICAgICBjb21wYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgY29tcGJbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb21wYlsyXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDJdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjb21wY1sxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDFdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzJdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMl07XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlXG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGEsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYSk7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGIsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYik7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGMsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGFbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAxXTtcbiAgICAgICAgICAgICAgICBhWzJdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMl07XG4gICAgICAgICAgICAgICAgYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgYlsxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDFdO1xuICAgICAgICAgICAgICAgIGJbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAyXTtcbiAgICAgICAgICAgICAgICBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjWzFdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGIsIGNiKTtcbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhhLCBiLCBhYik7XG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzMoY2IsIGFiLCBjcm9zcyk7XG4gICAgICAgICAgICBtYXRoLm5vcm1hbGl6ZVZlYzMoY3Jvc3MsIG5vcm1hbCk7XG4gICAgICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbbnVtRmFjZXNdIHx8IChmYWNlc1tudW1GYWNlc10gPSB7bm9ybWFsOiBtYXRoLnZlYzMoKX0pO1xuICAgICAgICAgICAgZmFjZS5ub3JtYWxbMF0gPSBub3JtYWxbMF07XG4gICAgICAgICAgICBmYWNlLm5vcm1hbFsxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICAgIGZhY2Uubm9ybWFsWzJdID0gbm9ybWFsWzJdO1xuICAgICAgICAgICAgbnVtRmFjZXMrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocG9zaXRpb25zLCBpbmRpY2VzLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGVkZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgd2VsZFZlcnRpY2VzKHBvc2l0aW9ucywgaW5kaWNlcyk7XG4gICAgICAgIGJ1aWxkRmFjZXMoaW5kaWNlcy5sZW5ndGgsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgIGNvbnN0IGVkZ2VJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKG1hdGguREVHVE9SQUQgKiBlZGdlVGhyZXNob2xkKTtcbiAgICAgICAgY29uc3QgZWRnZXMgPSB7fTtcbiAgICAgICAgbGV0IGVkZ2UxO1xuICAgICAgICBsZXQgZWRnZTI7XG4gICAgICAgIGxldCBpbmRleDE7XG4gICAgICAgIGxldCBpbmRleDI7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCBsYXJnZUluZGV4ID0gZmFsc2U7XG4gICAgICAgIGxldCBlZGdlO1xuICAgICAgICBsZXQgbm9ybWFsMTtcbiAgICAgICAgbGV0IG5vcm1hbDI7XG4gICAgICAgIGxldCBkb3Q7XG4gICAgICAgIGxldCBpYTtcbiAgICAgICAgbGV0IGliO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgZmFjZUluZGV4ID0gaSAvIDM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgIGVkZ2UxID0gd2VsZGVkSW5kaWNlc1tpICsgal07XG4gICAgICAgICAgICAgICAgZWRnZTIgPSB3ZWxkZWRJbmRpY2VzW2kgKyAoKGogKyAxKSAlIDMpXTtcbiAgICAgICAgICAgICAgICBpbmRleDEgPSBNYXRoLm1pbihlZGdlMSwgZWRnZTIpO1xuICAgICAgICAgICAgICAgIGluZGV4MiA9IE1hdGgubWF4KGVkZ2UxLCBlZGdlMik7XG4gICAgICAgICAgICAgICAga2V5ID0gaW5kZXgxICsgXCIsXCIgKyBpbmRleDI7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxOiBpbmRleDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDI6IGluZGV4MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UxOiBmYWNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlMjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNba2V5XS5mYWNlMiA9IGZhY2VJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gZWRnZXMpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1trZXldO1xuICAgICAgICAgICAgLy8gYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXG4gICAgICAgICAgICBpZiAoZWRnZS5mYWNlMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsMSA9IGZhY2VzW2VkZ2UuZmFjZTFdLm5vcm1hbDtcbiAgICAgICAgICAgICAgICBub3JtYWwyID0gZmFjZXNbZWRnZS5mYWNlMl0ubm9ybWFsO1xuICAgICAgICAgICAgICAgIGRvdCA9IG1hdGguZG90VmVjMyhub3JtYWwxLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gdGhyZXNob2xkRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlhID0gaW5kaWNlc1JldmVyc2VMb29rdXBbZWRnZS5pbmRleDFdO1xuICAgICAgICAgICAgaWIgPSBpbmRpY2VzUmV2ZXJzZUxvb2t1cFtlZGdlLmluZGV4Ml07XG4gICAgICAgICAgICBpZiAoIWxhcmdlSW5kZXggJiYgaWEgPiA2NTUzNSB8fCBpYiA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgbGFyZ2VJbmRleCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGdlSW5kaWNlcy5wdXNoKGlhKTtcbiAgICAgICAgICAgIGVkZ2VJbmRpY2VzLnB1c2goaWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGFyZ2VJbmRleCkgPyBuZXcgVWludDMyQXJyYXkoZWRnZUluZGljZXMpIDogbmV3IFVpbnQxNkFycmF5KGVkZ2VJbmRpY2VzKTtcbiAgICB9O1xufSkoKTtcblxuXG5leHBvcnQge21hdGh9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js ***!
  \****************************************************************************/
/*! exports provided: createRTCViewMat, worldToRTCPos, worldToRTCPositions, rtcToWorldPos, getPlaneRTCPos */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRTCViewMat\", function() { return createRTCViewMat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"worldToRTCPos\", function() { return worldToRTCPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"worldToRTCPositions\", function() { return worldToRTCPositions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rtcToWorldPos\", function() { return rtcToWorldPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPlaneRTCPos\", function() { return getPlaneRTCPos; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n\n\nconst tempVec3a = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\nconst tempAABB3 = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].AABB3();\n\n/**\n * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix\n * to transform RTC coordinates to View-space.\n *\n * The returned view matrix is\n *\n * @private\n */\nconst createRTCViewMat = (function () {\n\n    const tempMat = new Float32Array(16);\n    const rtcCenterWorld = new Float64Array(4);\n    const rtcCenterView = new Float64Array(4);\n\n    return function (viewMat, rtcCenter, rtcViewMat = tempMat) {\n        rtcCenterWorld[0] = rtcCenter[0];\n        rtcCenterWorld[1] = rtcCenter[1];\n        rtcCenterWorld[2] = rtcCenter[2];\n        rtcCenterWorld[3] = 1;\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformVec4(viewMat, rtcCenterWorld, rtcCenterView);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].setMat4Translation(viewMat, rtcCenterView, rtcViewMat);\n        return rtcViewMat;\n    }\n}());\n\n/**\n * Converts a World-space 3D position to RTC.\n *\n * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos\n * and a single-precision offset fom that center.\n *\n * @param {Float64Array} worldPos The World-space position.\n * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param {Float32Array} rtcPos Single-precision offset fom that center.\n */\nfunction worldToRTCPos(worldPos, rtcCenter, rtcPos) {\n\n    const xHigh = Float32Array.from([worldPos[0]])[0];\n    const xLow = worldPos[0] - xHigh;\n\n    const yHigh = Float32Array.from([worldPos[1]])[0];\n    const yLow = worldPos[1] - yHigh;\n\n    const zHigh = Float32Array.from([worldPos[2]])[0];\n    const zLow = worldPos[2] - zHigh;\n\n    rtcCenter[0] = xHigh;\n    rtcCenter[1] = yHigh;\n    rtcCenter[2] = zHigh;\n\n    rtcPos[0] = xLow;\n    rtcPos[1] = yLow;\n    rtcPos[2] = zLow;\n}\n\n\n/**\n * Converts a flat array of double-precision positions to RTC positions.\n *\n * Returns the RTC positions, along with a computed RTC center for those positions.\n *\n * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,\n * identical RTC positions are reused for different positions arrays.\n *\n * @param {Float64Array} worldPositions Flat array of World-space 3D positions.\n * @param {Float64Array} rtcPositions Outputs the computed flat array of 3D RTC positions.\n * @param {Float64Array} rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.\n * @param {Number} [cellSize=10000000] The size of each coordinate cell within the RTC coordinate system.\n * @returns {Boolean} ````True```` if the positions actually needed conversion to RTC, else ````false````. When\n * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,\n * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.\n */\nfunction worldToRTCPositions(worldPositions, rtcPositions, rtcCenter, cellSize = 10000000) {\n\n    const center = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].getPositionsCenter(worldPositions, tempVec3a);\n\n    const rtcCenterX = Math.round(center[0] / cellSize) * cellSize;\n    const rtcCenterY = Math.round(center[1] / cellSize) * cellSize;\n    const rtcCenterZ = Math.round(center[2] / cellSize) * cellSize;\n\n    for (let i = 0, len = worldPositions.length; i < len; i += 3) {\n        rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;\n        rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;\n        rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;\n    }\n\n    rtcCenter[0] = rtcCenterX;\n    rtcCenter[1] = rtcCenterY;\n    rtcCenter[2] = rtcCenterZ;\n\n    const rtcNeeded = (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0);\n\n    return rtcNeeded;\n}\n\n/**\n * Converts an RTC 3D position to World-space.\n *\n * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param {Float32Array} rtcPos Single-precision offset fom that center.\n * @param {Float64Array} worldPos The World-space position.\n */\nfunction rtcToWorldPos(rtcCenter, rtcPos, worldPos) {\n    worldPos[0] = rtcCenter[0] + rtcPos[0];\n    worldPos[1] = rtcCenter[1] + rtcPos[1];\n    worldPos[2] = rtcCenter[2] + rtcPos[2];\n    return worldPos;\n}\n\n/**\n * Given a 3D plane defined by distance from origin and direction, and an RTC center position,\n * return a plane position that is relative to the RTC center.\n *\n * @param dist\n * @param dir\n * @param rtcCenter\n * @param rtcPlanePos\n * @returns {*}\n */\nfunction getPlaneRTCPos(dist, dir, rtcCenter, rtcPlanePos) {\n    const rtcCenterToPlaneDist = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].dotVec3(dir, rtcCenter) + dist;\n    const dirNormalized = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].normalizeVec3(dir, tempVec3a);\n    _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);\n    return rtcPlanePos;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvcnRjQ29vcmRzLmpzP2E1NTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7O0FBRS9CLGtCQUFrQiw2Q0FBSTtBQUN0QixrQkFBa0IsNkNBQUk7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw2Q0FBSTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBSTtBQUNyQywwQkFBMEIsNkNBQUk7QUFDOUIsSUFBSSw2Q0FBSTtBQUNSO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWF0aC9ydGNDb29yZHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge21hdGh9IGZyb20gJy4vbWF0aC5qcyc7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuY29uc3QgdGVtcEFBQkIzID0gbWF0aC5BQUJCMygpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmlldyBtYXRyaXggYW5kIGEgcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNvb3JkaW5hdGUgb3JpZ2luLCByZXR1cm5zIGEgdmlldyBtYXRyaXhcbiAqIHRvIHRyYW5zZm9ybSBSVEMgY29vcmRpbmF0ZXMgdG8gVmlldy1zcGFjZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgdmlldyBtYXRyaXggaXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjcmVhdGVSVENWaWV3TWF0ID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHRlbXBNYXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBjb25zdCBydGNDZW50ZXJXb3JsZCA9IG5ldyBGbG9hdDY0QXJyYXkoNCk7XG4gICAgY29uc3QgcnRjQ2VudGVyVmlldyA9IG5ldyBGbG9hdDY0QXJyYXkoNCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXdNYXQsIHJ0Y0NlbnRlciwgcnRjVmlld01hdCA9IHRlbXBNYXQpIHtcbiAgICAgICAgcnRjQ2VudGVyV29ybGRbMF0gPSBydGNDZW50ZXJbMF07XG4gICAgICAgIHJ0Y0NlbnRlcldvcmxkWzFdID0gcnRjQ2VudGVyWzFdO1xuICAgICAgICBydGNDZW50ZXJXb3JsZFsyXSA9IHJ0Y0NlbnRlclsyXTtcbiAgICAgICAgcnRjQ2VudGVyV29ybGRbM10gPSAxO1xuICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQodmlld01hdCwgcnRjQ2VudGVyV29ybGQsIHJ0Y0NlbnRlclZpZXcpO1xuICAgICAgICBtYXRoLnNldE1hdDRUcmFuc2xhdGlvbih2aWV3TWF0LCBydGNDZW50ZXJWaWV3LCBydGNWaWV3TWF0KTtcbiAgICAgICAgcmV0dXJuIHJ0Y1ZpZXdNYXQ7XG4gICAgfVxufSgpKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFdvcmxkLXNwYWNlIDNEIHBvc2l0aW9uIHRvIFJUQy5cbiAqXG4gKiBHaXZlbiBhIGRvdWJsZS1wcmVjaXNpb24gV29ybGQtc3BhY2UgcG9zaXRpb24sIHJldHVybnMgYSBkb3VibGUtcHJlY2lzaW9uIHJlbGF0aXZlLXRvLWNlbnRlciAoUlRDKSBjZW50ZXIgcG9zXG4gKiBhbmQgYSBzaW5nbGUtcHJlY2lzaW9uIG9mZnNldCBmb20gdGhhdCBjZW50ZXIuXG4gKlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHdvcmxkUG9zIFRoZSBXb3JsZC1zcGFjZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBydGNDZW50ZXIgRG91YmxlLXByZWNpc2lvbiByZWxhdGl2ZS10by1jZW50ZXIgKFJUQykgY2VudGVyIHBvcy5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBydGNQb3MgU2luZ2xlLXByZWNpc2lvbiBvZmZzZXQgZm9tIHRoYXQgY2VudGVyLlxuICovXG5mdW5jdGlvbiB3b3JsZFRvUlRDUG9zKHdvcmxkUG9zLCBydGNDZW50ZXIsIHJ0Y1Bvcykge1xuXG4gICAgY29uc3QgeEhpZ2ggPSBGbG9hdDMyQXJyYXkuZnJvbShbd29ybGRQb3NbMF1dKVswXTtcbiAgICBjb25zdCB4TG93ID0gd29ybGRQb3NbMF0gLSB4SGlnaDtcblxuICAgIGNvbnN0IHlIaWdoID0gRmxvYXQzMkFycmF5LmZyb20oW3dvcmxkUG9zWzFdXSlbMF07XG4gICAgY29uc3QgeUxvdyA9IHdvcmxkUG9zWzFdIC0geUhpZ2g7XG5cbiAgICBjb25zdCB6SGlnaCA9IEZsb2F0MzJBcnJheS5mcm9tKFt3b3JsZFBvc1syXV0pWzBdO1xuICAgIGNvbnN0IHpMb3cgPSB3b3JsZFBvc1syXSAtIHpIaWdoO1xuXG4gICAgcnRjQ2VudGVyWzBdID0geEhpZ2g7XG4gICAgcnRjQ2VudGVyWzFdID0geUhpZ2g7XG4gICAgcnRjQ2VudGVyWzJdID0gekhpZ2g7XG5cbiAgICBydGNQb3NbMF0gPSB4TG93O1xuICAgIHJ0Y1Bvc1sxXSA9IHlMb3c7XG4gICAgcnRjUG9zWzJdID0gekxvdztcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGEgZmxhdCBhcnJheSBvZiBkb3VibGUtcHJlY2lzaW9uIHBvc2l0aW9ucyB0byBSVEMgcG9zaXRpb25zLlxuICpcbiAqIFJldHVybnMgdGhlIFJUQyBwb3NpdGlvbnMsIGFsb25nIHdpdGggYSBjb21wdXRlZCBSVEMgY2VudGVyIGZvciB0aG9zZSBwb3NpdGlvbnMuXG4gKlxuICogV2hlbiBjb21wdXRpbmcgdGhlIFJUQyBwb3NpdGlvbiwgdGhpcyBmdW5jdGlvbiB1c2VzIGEgbW9kdWx1cyBvcGVyYXRpb24gdG8gZW5zdXJlIHRoYXQsIHdoZW5ldmVyIHBvc3NpYmxlLFxuICogaWRlbnRpY2FsIFJUQyBwb3NpdGlvbnMgYXJlIHJldXNlZCBmb3IgZGlmZmVyZW50IHBvc2l0aW9ucyBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHdvcmxkUG9zaXRpb25zIEZsYXQgYXJyYXkgb2YgV29ybGQtc3BhY2UgM0QgcG9zaXRpb25zLlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHJ0Y1Bvc2l0aW9ucyBPdXRwdXRzIHRoZSBjb21wdXRlZCBmbGF0IGFycmF5IG9mIDNEIFJUQyBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gcnRjQ2VudGVyIE91dHB1dHMgdGhlIGNvbXB1dGVkIGRvdWJsZS1wcmVjaXNpb24gcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNlbnRlciBwb3MuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NlbGxTaXplPTEwMDAwMDAwXSBUaGUgc2l6ZSBvZiBlYWNoIGNvb3JkaW5hdGUgY2VsbCB3aXRoaW4gdGhlIFJUQyBjb29yZGluYXRlIHN5c3RlbS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgYGBgVHJ1ZWBgYGAgaWYgdGhlIHBvc2l0aW9ucyBhY3R1YWxseSBuZWVkZWQgY29udmVyc2lvbiB0byBSVEMsIGVsc2UgYGBgYGZhbHNlYGBgYC4gV2hlblxuICogYGBgYGZhbHNlYGBgYCwgd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIGRhdGEgcmV0dXJuZWQgaW4gYGBgYHJ0Y1Bvc2l0aW9uc2BgYGAgYW5kIGBgYGBydGNDZW50ZXJgYGBgLFxuICogc2luY2UgYGBgYHJ0Y0NlbnRlcmBgYGAgd2lsbCBlcXVhbCBgYGBgWzAsMCwwXWBgYGAsIGFuZCBgYGBgcnRjUG9zaXRpb25zYGBgYCB3aWxsIGNvbnRhaW4gaWRlbnRpY2FsIHZhbHVlcyB0byBgYGBgcG9zaXRpb25zYGBgYC5cbiAqL1xuZnVuY3Rpb24gd29ybGRUb1JUQ1Bvc2l0aW9ucyh3b3JsZFBvc2l0aW9ucywgcnRjUG9zaXRpb25zLCBydGNDZW50ZXIsIGNlbGxTaXplID0gMTAwMDAwMDApIHtcblxuICAgIGNvbnN0IGNlbnRlciA9IG1hdGguZ2V0UG9zaXRpb25zQ2VudGVyKHdvcmxkUG9zaXRpb25zLCB0ZW1wVmVjM2EpO1xuXG4gICAgY29uc3QgcnRjQ2VudGVyWCA9IE1hdGgucm91bmQoY2VudGVyWzBdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gICAgY29uc3QgcnRjQ2VudGVyWSA9IE1hdGgucm91bmQoY2VudGVyWzFdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gICAgY29uc3QgcnRjQ2VudGVyWiA9IE1hdGgucm91bmQoY2VudGVyWzJdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gd29ybGRQb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgcnRjUG9zaXRpb25zW2kgKyAwXSA9IHdvcmxkUG9zaXRpb25zW2kgKyAwXSAtIHJ0Y0NlbnRlclg7XG4gICAgICAgIHJ0Y1Bvc2l0aW9uc1tpICsgMV0gPSB3b3JsZFBvc2l0aW9uc1tpICsgMV0gLSBydGNDZW50ZXJZO1xuICAgICAgICBydGNQb3NpdGlvbnNbaSArIDJdID0gd29ybGRQb3NpdGlvbnNbaSArIDJdIC0gcnRjQ2VudGVyWjtcbiAgICB9XG5cbiAgICBydGNDZW50ZXJbMF0gPSBydGNDZW50ZXJYO1xuICAgIHJ0Y0NlbnRlclsxXSA9IHJ0Y0NlbnRlclk7XG4gICAgcnRjQ2VudGVyWzJdID0gcnRjQ2VudGVyWjtcblxuICAgIGNvbnN0IHJ0Y05lZWRlZCA9IChydGNDZW50ZXJbMF0gIT09IDAgfHwgcnRjQ2VudGVyWzFdICE9PSAwIHx8IHJ0Y0NlbnRlclsyXSAhPT0gMCk7XG5cbiAgICByZXR1cm4gcnRjTmVlZGVkO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJUQyAzRCBwb3NpdGlvbiB0byBXb3JsZC1zcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gcnRjQ2VudGVyIERvdWJsZS1wcmVjaXNpb24gcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNlbnRlciBwb3MuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gcnRjUG9zIFNpbmdsZS1wcmVjaXNpb24gb2Zmc2V0IGZvbSB0aGF0IGNlbnRlci5cbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSB3b3JsZFBvcyBUaGUgV29ybGQtc3BhY2UgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJ0Y1RvV29ybGRQb3MocnRjQ2VudGVyLCBydGNQb3MsIHdvcmxkUG9zKSB7XG4gICAgd29ybGRQb3NbMF0gPSBydGNDZW50ZXJbMF0gKyBydGNQb3NbMF07XG4gICAgd29ybGRQb3NbMV0gPSBydGNDZW50ZXJbMV0gKyBydGNQb3NbMV07XG4gICAgd29ybGRQb3NbMl0gPSBydGNDZW50ZXJbMl0gKyBydGNQb3NbMl07XG4gICAgcmV0dXJuIHdvcmxkUG9zO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgM0QgcGxhbmUgZGVmaW5lZCBieSBkaXN0YW5jZSBmcm9tIG9yaWdpbiBhbmQgZGlyZWN0aW9uLCBhbmQgYW4gUlRDIGNlbnRlciBwb3NpdGlvbixcbiAqIHJldHVybiBhIHBsYW5lIHBvc2l0aW9uIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIFJUQyBjZW50ZXIuXG4gKlxuICogQHBhcmFtIGRpc3RcbiAqIEBwYXJhbSBkaXJcbiAqIEBwYXJhbSBydGNDZW50ZXJcbiAqIEBwYXJhbSBydGNQbGFuZVBvc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldFBsYW5lUlRDUG9zKGRpc3QsIGRpciwgcnRjQ2VudGVyLCBydGNQbGFuZVBvcykge1xuICAgIGNvbnN0IHJ0Y0NlbnRlclRvUGxhbmVEaXN0ID0gbWF0aC5kb3RWZWMzKGRpciwgcnRjQ2VudGVyKSArIGRpc3Q7XG4gICAgY29uc3QgZGlyTm9ybWFsaXplZCA9IG1hdGgubm9ybWFsaXplVmVjMyhkaXIsIHRlbXBWZWMzYSk7XG4gICAgbWF0aC5tdWxWZWMzU2NhbGFyKGRpck5vcm1hbGl6ZWQsIC1ydGNDZW50ZXJUb1BsYW5lRGlzdCwgcnRjUGxhbmVQb3MpO1xuICAgIHJldHVybiBydGNQbGFuZVBvcztcbn1cblxuZXhwb3J0IHtjcmVhdGVSVENWaWV3TWF0LCB3b3JsZFRvUlRDUG9zLCB3b3JsZFRvUlRDUG9zaXRpb25zLCBydGNUb1dvcmxkUG9zLCBnZXRQbGFuZVJUQ1Bvc307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js ***!
  \*******************************************************************/
/*! exports provided: stats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stats\", function() { return stats; });\n/**\n * xeokit runtime statistics.\n * @private\n * @type {{components: {models: number, objects: number, scenes: number, meshes: number}, memory: {indices: number, uvs: number, textures: number, materials: number, transforms: number, positions: number, programs: number, normals: number, meshes: number, colors: number}, build: {version: string}, client: {browser: string}, frame: {frameCount: number, useProgram: number, bindTexture: number, drawElements: number, bindArray: number, tasksRun: number, fps: number, drawArrays: number, tasksScheduled: number}}}\n */\nconst stats = {\n    build: {\n        version: \"0.8\"\n    },\n    client: {\n        browser: (navigator && navigator.userAgent) ? navigator.userAgent : \"n/a\"\n    },\n\n    components: {\n        scenes: 0,\n        models: 0,\n        meshes: 0,\n        objects: 0\n    },\n    memory: {\n        meshes: 0,\n        positions: 0,\n        colors: 0,\n        normals: 0,\n        uvs: 0,\n        indices: 0,\n        textures: 0,\n        transforms: 0,\n        materials: 0,\n        programs: 0\n    },\n    frame: {\n        frameCount: 0,\n        fps: 0,\n        useProgram: 0,\n        bindTexture: 0,\n        bindArray: 0,\n        drawElements: 0,\n        drawArrays: 0,\n        tasksRun: 0,\n        tasksScheduled: 0\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzPzg0NDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxnRUFBZ0UsV0FBVyw0S0FBNEssVUFBVSxnQkFBZ0IsV0FBVyxnQkFBZ0IsVUFBVTtBQUM5VTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB4ZW9raXQgcnVudGltZSBzdGF0aXN0aWNzLlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHt7Y29tcG9uZW50czoge21vZGVsczogbnVtYmVyLCBvYmplY3RzOiBudW1iZXIsIHNjZW5lczogbnVtYmVyLCBtZXNoZXM6IG51bWJlcn0sIG1lbW9yeToge2luZGljZXM6IG51bWJlciwgdXZzOiBudW1iZXIsIHRleHR1cmVzOiBudW1iZXIsIG1hdGVyaWFsczogbnVtYmVyLCB0cmFuc2Zvcm1zOiBudW1iZXIsIHBvc2l0aW9uczogbnVtYmVyLCBwcm9ncmFtczogbnVtYmVyLCBub3JtYWxzOiBudW1iZXIsIG1lc2hlczogbnVtYmVyLCBjb2xvcnM6IG51bWJlcn0sIGJ1aWxkOiB7dmVyc2lvbjogc3RyaW5nfSwgY2xpZW50OiB7YnJvd3Nlcjogc3RyaW5nfSwgZnJhbWU6IHtmcmFtZUNvdW50OiBudW1iZXIsIHVzZVByb2dyYW06IG51bWJlciwgYmluZFRleHR1cmU6IG51bWJlciwgZHJhd0VsZW1lbnRzOiBudW1iZXIsIGJpbmRBcnJheTogbnVtYmVyLCB0YXNrc1J1bjogbnVtYmVyLCBmcHM6IG51bWJlciwgZHJhd0FycmF5czogbnVtYmVyLCB0YXNrc1NjaGVkdWxlZDogbnVtYmVyfX19XG4gKi9cbmNvbnN0IHN0YXRzID0ge1xuICAgIGJ1aWxkOiB7XG4gICAgICAgIHZlcnNpb246IFwiMC44XCJcbiAgICB9LFxuICAgIGNsaWVudDoge1xuICAgICAgICBicm93c2VyOiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IFwibi9hXCJcbiAgICB9LFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBzY2VuZXM6IDAsXG4gICAgICAgIG1vZGVsczogMCxcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBvYmplY3RzOiAwXG4gICAgfSxcbiAgICBtZW1vcnk6IHtcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBwb3NpdGlvbnM6IDAsXG4gICAgICAgIGNvbG9yczogMCxcbiAgICAgICAgbm9ybWFsczogMCxcbiAgICAgICAgdXZzOiAwLFxuICAgICAgICBpbmRpY2VzOiAwLFxuICAgICAgICB0ZXh0dXJlczogMCxcbiAgICAgICAgdHJhbnNmb3JtczogMCxcbiAgICAgICAgbWF0ZXJpYWxzOiAwLFxuICAgICAgICBwcm9ncmFtczogMFxuICAgIH0sXG4gICAgZnJhbWU6IHtcbiAgICAgICAgZnJhbWVDb3VudDogMCxcbiAgICAgICAgZnBzOiAwLFxuICAgICAgICB1c2VQcm9ncmFtOiAwLFxuICAgICAgICBiaW5kVGV4dHVyZTogMCxcbiAgICAgICAgYmluZEFycmF5OiAwLFxuICAgICAgICBkcmF3RWxlbWVudHM6IDAsXG4gICAgICAgIGRyYXdBcnJheXM6IDAsXG4gICAgICAgIHRhc2tzUnVuOiAwLFxuICAgICAgICB0YXNrc1NjaGVkdWxlZDogMFxuICAgIH1cbn07XG5cbmV4cG9ydCB7c3RhdHN9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js ***!
  \*******************************************************************/
/*! exports provided: utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n/**\n * @private\n */\nfunction xmlToJson(node, attributeRenamer) {\n    if (node.nodeType === node.TEXT_NODE) {\n        var v = node.nodeValue;\n        if (v.match(/^\\s+$/) === null) {\n            return v;\n        }\n    } else if (node.nodeType === node.ELEMENT_NODE ||\n        node.nodeType === node.DOCUMENT_NODE) {\n        var json = {type: node.nodeName, children: []};\n\n        if (node.nodeType === node.ELEMENT_NODE) {\n            for (var j = 0; j < node.attributes.length; j++) {\n                var attribute = node.attributes[j];\n                var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;\n                json[nm] = attribute.nodeValue;\n            }\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n            var item = node.childNodes[i];\n            var j = xmlToJson(item, attributeRenamer);\n            if (j) json.children.push(j);\n        }\n\n        return json;\n    }\n}\n\n/**\n * @private\n */\nfunction clone(ob) {\n    return JSON.parse(JSON.stringify(ob));\n}\n\n/**\n * @private\n */\nvar guidChars = [[\"0\", 10], [\"A\", 26], [\"a\", 26], [\"_\", 1], [\"$\", 1]].map(function (a) {\n    var li = [];\n    var st = a[0].charCodeAt(0);\n    var en = st + a[1];\n    for (var i = st; i < en; ++i) {\n        li.push(i);\n    }\n    return String.fromCharCode.apply(null, li);\n}).join(\"\");\n\n/**\n * @private\n */\nfunction b64(v, len) {\n    var r = (!len || len === 4) ? [0, 6, 12, 18] : [0, 6];\n    return r.map(function (i) {\n        return guidChars.substr(parseInt(v / (1 << i)) % 64, 1)\n    }).reverse().join(\"\");\n}\n\n/**\n * @private\n */\nfunction compressGuid(g) {\n    var bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function (i) {\n        return parseInt(g.substr(i, 2), 16);\n    });\n    return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function (i) {\n        return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2]);\n    }).join(\"\");\n}\n\n/**\n * @private\n */\nfunction findNodeOfType(m, t) {\n    var li = [];\n    var _ = function (n) {\n        if (n.type === t) li.push(n);\n        (n.children || []).forEach(function (c) {\n            _(c);\n        });\n    };\n    _(m);\n    return li;\n}\n\n/**\n * @private\n */\nfunction timeout(dt) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(resolve, dt);\n    });\n}\n\n/**\n * @private\n */\nfunction httpRequest(args) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(args.method || \"GET\", args.url, true);\n        xhr.onload = function (e) {\n            console.log(args.url, xhr.readyState, xhr.status);\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.responseXML);\n                } else {\n                    reject(xhr.statusText);\n                }\n            }\n        };\n        xhr.send(null);\n    });\n}\n\n/**\n * @private\n */\nconst queryString = function () {\n    // This function is anonymous, is executed immediately and\n    // the return value is assigned to QueryString!\n    var query_string = {};\n    var query = window.location.search.substring(1);\n    var vars = query.split(\"&\");\n    for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        // If first entry with this name\n        if (typeof query_string[pair[0]] === \"undefined\") {\n            query_string[pair[0]] = decodeURIComponent(pair[1]);\n            // If second entry with this name\n        } else if (typeof query_string[pair[0]] === \"string\") {\n            var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];\n            query_string[pair[0]] = arr;\n            // If third or later entry with this name\n        } else {\n            query_string[pair[0]].push(decodeURIComponent(pair[1]));\n        }\n    }\n    return query_string;\n}();\n\n/**\n * @private\n */\nfunction loadJSON(url, ok, err) {\n    // Avoid checking ok and err on each use.\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n\n    var request = new XMLHttpRequest();\n    request.overrideMimeType(\"application/json\");\n    request.open('GET', url, true);\n    request.addEventListener('load', function (event) {\n        var response = event.target.response;\n        if (this.status === 200) {\n            var json;\n            try {\n                json = JSON.parse(response);\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n            ok(json);\n        } else if (this.status === 0) {\n            // Some browsers return HTTP Status 0 when using non-http protocol\n            // e.g. 'file://' or 'data://'. Handle as success.\n            console.warn('loadFile: HTTP Status 0 received.');\n            try {\n                ok(JSON.parse(response));\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n        } else {\n            err(event);\n        }\n    }, false);\n\n    request.addEventListener('error', function (event) {\n        err(event);\n    }, false);\n    request.send(null);\n}\n\n/**\n * @private\n */\nfunction loadArraybuffer(url, ok, err) {\n    // Check for data: URI\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n        const isBase64 = !!dataUriRegexResult[2];\n        var data = dataUriRegexResult[3];\n        data = window.decodeURIComponent(data);\n        if (isBase64) {\n            data = window.atob(data);\n        }\n        try {\n            const buffer = new ArrayBuffer(data.length);\n            const view = new Uint8Array(buffer);\n            for (var i = 0; i < data.length; i++) {\n                view[i] = data.charCodeAt(i);\n            }\n            window.setTimeout(function () {\n                ok(buffer);\n            }, 0);\n        } catch (error) {\n            window.setTimeout(function () {\n                err(error);\n            }, 0);\n        }\n    } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.responseType = 'arraybuffer';\n        request.onreadystatechange = function () {\n            if (request.readyState === 4) {\n                if (request.status === 200) {\n                    ok(request.response);\n                } else {\n                    err('loadArrayBuffer error : ' + request.response);\n                }\n            }\n        };\n        request.send(null);\n    }\n}\n\n/**\n Tests if the given object is an array\n @private\n */\nfunction isArray(value) {\n    return value && !(value.propertyIsEnumerable('length')) && typeof value === 'object' && typeof value.length === 'number';\n}\n\n/**\n Tests if the given value is a string\n @param value\n @returns {boolean}\n @private\n */\nfunction isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n Tests if the given value is a number\n @param value\n @returns {boolean}\n @private\n */\nfunction isNumeric(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/**\n Tests if the given value is an ID\n @param value\n @returns {boolean}\n @private\n */\nfunction isID(value) {\n    return utils.isString(value) || utils.isNumeric(value);\n}\n\n/**\n Tests if the given components are the same, where the components can be either IDs or instances.\n @param c1\n @param c2\n @returns {boolean}\n @private\n */\nfunction isSameComponent(c1, c2) {\n    if (!c1 || !c2) {\n        return false;\n    }\n    const id1 = (utils.isNumeric(c1) || utils.isString(c1)) ? `${c1}` : c1.id;\n    const id2 = (utils.isNumeric(c2) || utils.isString(c2)) ? `${c2}` : c2.id;\n    return id1 === id2;\n}\n\n/**\n Tests if the given value is a function\n @param value\n @returns {boolean}\n @private\n */\nfunction isFunction(value) {\n    return (typeof value === \"function\");\n}\n\n/**\n Tests if the given value is a JavaScript JSON object, eg, ````{ foo: \"bar\" }````.\n @param value\n @returns {boolean}\n @private\n */\nfunction isObject(value) {\n    const objectConstructor = {}.constructor;\n    return (!!value && value.constructor === objectConstructor);\n}\n\n/** Returns a shallow copy\n */\nfunction copy(o) {\n    return utils.apply(o, {});\n}\n\n/** Add properties of o to o2, overwriting them on o2 if already there\n */\nfunction apply(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            o2[name] = o[name];\n        }\n    }\n    return o2;\n}\n\n/**\n Add non-null/defined properties of o to o2\n @private\n */\nfunction apply2(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o[name] !== undefined && o[name] !== null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Add properties of o to o2 where undefined or null on o2\n @private\n */\nfunction applyIf(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o2[name] === undefined || o2[name] === null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Returns true if the given map is empty.\n @param obj\n @returns {boolean}\n @private\n */\nfunction isEmptyObject(obj) {\n    for (const name in obj) {\n        if (obj.hasOwnProperty(name)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n Returns the given ID as a string, in quotes if the ID was a string to begin with.\n\n This is useful for logging IDs.\n\n @param {Number| String} id The ID\n @returns {String}\n @private\n */\nfunction inQuotes(id) {\n    return utils.isNumeric(id) ? (`${id}`) : (`'${id}'`);\n}\n\n/**\n Returns the concatenation of two typed arrays.\n @param a\n @param b\n @returns {*|a}\n @private\n */\nfunction concat(a, b) {\n    const c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n}\n\nfunction flattenParentChildHierarchy(root) {\n    var list = [];\n\n    function visit(node) {\n        node.id = node.uuid;\n        delete node.oid;\n        list.push(node);\n        var children = node.children;\n\n        if (children) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                child.parent = node.id;\n                visit(children[i]);\n            }\n        }\n        node.children = [];\n    }\n\n    visit(root);\n    return list;\n}\n\n/**\n * @private\n */\nconst utils = {\n    xmlToJson: xmlToJson,\n    clone: clone,\n    compressGuid: compressGuid,\n    findNodeOfType: findNodeOfType,\n    timeout: timeout,\n    httpRequest: httpRequest,\n    loadJSON: loadJSON,\n    loadArraybuffer: loadArraybuffer,\n    queryString: queryString,\n    isArray: isArray,\n    isString: isString,\n    isNumeric: isNumeric,\n    isID: isID,\n    isSameComponent: isSameComponent,\n    isFunction: isFunction,\n    isObject: isObject,\n    copy: copy,\n    apply: apply,\n    apply2: apply2,\n    applyIf: applyIf,\n    isEmptyObject: isEmptyObject,\n    inQuotes: inQuotes,\n    concat: concat,\n    flattenParentChildHierarchy: flattenParentChildHierarchy\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzLmpzP2NkYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlFQUF5RSxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5RUFBeUUsRUFBRTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsZUFBZTtBQUN4QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsVUFBVSxHQUFHO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHhtbFRvSnNvbihub2RlLCBhdHRyaWJ1dGVSZW5hbWVyKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIHZhciB2ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGlmICh2Lm1hdGNoKC9eXFxzKyQvKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFIHx8XG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIganNvbiA9IHt0eXBlOiBub2RlLm5vZGVOYW1lLCBjaGlsZHJlbjogW119O1xuXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBubSA9IGF0dHJpYnV0ZVJlbmFtZXJbYXR0cmlidXRlLm5vZGVOYW1lXSB8fCBhdHRyaWJ1dGUubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAganNvbltubV0gPSBhdHRyaWJ1dGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSB4bWxUb0pzb24oaXRlbSwgYXR0cmlidXRlUmVuYW1lcik7XG4gICAgICAgICAgICBpZiAoaikganNvbi5jaGlsZHJlbi5wdXNoKGopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2IpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ3VpZENoYXJzID0gW1tcIjBcIiwgMTBdLCBbXCJBXCIsIDI2XSwgW1wiYVwiLCAyNl0sIFtcIl9cIiwgMV0sIFtcIiRcIiwgMV1dLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBzdCA9IGFbMF0uY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZW4gPSBzdCArIGFbMV07XG4gICAgZm9yICh2YXIgaSA9IHN0OyBpIDwgZW47ICsraSkge1xuICAgICAgICBsaS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBsaSk7XG59KS5qb2luKFwiXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGI2NCh2LCBsZW4pIHtcbiAgICB2YXIgciA9ICghbGVuIHx8IGxlbiA9PT0gNCkgPyBbMCwgNiwgMTIsIDE4XSA6IFswLCA2XTtcbiAgICByZXR1cm4gci5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGd1aWRDaGFycy5zdWJzdHIocGFyc2VJbnQodiAvICgxIDw8IGkpKSAlIDY0LCAxKVxuICAgIH0pLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzR3VpZChnKSB7XG4gICAgdmFyIGJzID0gWzAsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE2LCAxOCwgMjAsIDIyLCAyNCwgMjYsIDI4LCAzMF0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChnLnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiBiNjQoYnNbMF0sIDIpICsgWzEsIDQsIDcsIDEwLCAxM10ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBiNjQoKGJzW2ldIDw8IDE2KSArIChic1tpICsgMV0gPDwgOCkgKyBic1tpICsgMl0pO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmluZE5vZGVPZlR5cGUobSwgdCkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBfID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4udHlwZSA9PT0gdCkgbGkucHVzaChuKTtcbiAgICAgICAgKG4uY2hpbGRyZW4gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF8oYyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXyhtKTtcbiAgICByZXR1cm4gbGk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKGFyZ3MubWV0aG9kIHx8IFwiR0VUXCIsIGFyZ3MudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLnVybCwgeGhyLnJlYWR5U3RhdGUsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZVhNTCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHhoci5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYW5vbnltb3VzLCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBhbmRcbiAgICAvLyB0aGUgcmV0dXJuIHZhbHVlIGlzIGFzc2lnbmVkIHRvIFF1ZXJ5U3RyaW5nIVxuICAgIHZhciBxdWVyeV9zdHJpbmcgPSB7fTtcbiAgICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgLy8gSWYgZmlyc3QgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgICAgIC8vIElmIHNlY29uZCBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbcXVlcnlfc3RyaW5nW3BhaXJbMF1dLCBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSldO1xuICAgICAgICAgICAgcXVlcnlfc3RyaW5nW3BhaXJbMF1dID0gYXJyO1xuICAgICAgICAgICAgLy8gSWYgdGhpcmQgb3IgbGF0ZXIgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXS5wdXNoKGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5X3N0cmluZztcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkSlNPTih1cmwsIG9rLCBlcnIpIHtcbiAgICAvLyBBdm9pZCBjaGVja2luZyBvayBhbmQgZXJyIG9uIGVhY2ggdXNlLlxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGV2ZW50LnRhcmdldC5yZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBqc29uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9rKGpzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcbiAgICAgICAgICAgIC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2xvYWRGaWxlOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvayhKU09OLnBhcnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycihldmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVycihldmVudCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkQXJyYXlidWZmZXIodXJsLCBvaywgZXJyKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KTtcbiAgICBpZiAoZGF0YVVyaVJlZ2V4UmVzdWx0KSB7IC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgZGF0YSBVUklzIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgY29uc3QgaXNCYXNlNjQgPSAhIWRhdGFVcmlSZWdleFJlc3VsdFsyXTtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhVXJpUmVnZXhSZXN1bHRbM107XG4gICAgICAgIGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB3aW5kb3cuYXRvYihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlld1tpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvayhidWZmZXIpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXJyKGVycm9yKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2socmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyKCdsb2FkQXJyYXlCdWZmZXIgZXJyb3IgOiAnICsgcmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgfVxufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGFycmF5XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhKHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gVGVzdHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXJcbiBAcGFyYW0gdmFsdWVcbiBAcmV0dXJucyB7Ym9vbGVhbn1cbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJRFxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSUQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNTdHJpbmcodmFsdWUpIHx8IHV0aWxzLmlzTnVtZXJpYyh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiBjb21wb25lbnRzIGFyZSB0aGUgc2FtZSwgd2hlcmUgdGhlIGNvbXBvbmVudHMgY2FuIGJlIGVpdGhlciBJRHMgb3IgaW5zdGFuY2VzLlxuIEBwYXJhbSBjMVxuIEBwYXJhbSBjMlxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZUNvbXBvbmVudChjMSwgYzIpIHtcbiAgICBpZiAoIWMxIHx8ICFjMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlkMSA9ICh1dGlscy5pc051bWVyaWMoYzEpIHx8IHV0aWxzLmlzU3RyaW5nKGMxKSkgPyBgJHtjMX1gIDogYzEuaWQ7XG4gICAgY29uc3QgaWQyID0gKHV0aWxzLmlzTnVtZXJpYyhjMikgfHwgdXRpbHMuaXNTdHJpbmcoYzIpKSA/IGAke2MyfWAgOiBjMi5pZDtcbiAgICByZXR1cm4gaWQxID09PSBpZDI7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKYXZhU2NyaXB0IEpTT04gb2JqZWN0LCBlZywgYGBgYHsgZm9vOiBcImJhclwiIH1gYGBgLlxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqZWN0Q29uc3RydWN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gKCEhdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IG9iamVjdENvbnN0cnVjdG9yKTtcbn1cblxuLyoqIFJldHVybnMgYSBzaGFsbG93IGNvcHlcbiAqL1xuZnVuY3Rpb24gY29weShvKSB7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5KG8sIHt9KTtcbn1cblxuLyoqIEFkZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzIsIG92ZXJ3cml0aW5nIHRoZW0gb24gbzIgaWYgYWxyZWFkeSB0aGVyZVxuICovXG5mdW5jdGlvbiBhcHBseShvLCBvMikge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBBZGQgbm9uLW51bGwvZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzJcbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcHBseTIobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG9bbmFtZV0gIT09IHVuZGVmaW5lZCAmJiBvW25hbWVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbzJbbmFtZV0gPSBvW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvMjtcbn1cblxuLyoqXG4gQWRkIHByb3BlcnRpZXMgb2YgbyB0byBvMiB3aGVyZSB1bmRlZmluZWQgb3IgbnVsbCBvbiBvMlxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SWYobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG8yW25hbWVdID09PSB1bmRlZmluZWQgfHwgbzJbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1hcCBpcyBlbXB0eS5cbiBAcGFyYW0gb2JqXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgZ2l2ZW4gSUQgYXMgYSBzdHJpbmcsIGluIHF1b3RlcyBpZiB0aGUgSUQgd2FzIGEgc3RyaW5nIHRvIGJlZ2luIHdpdGguXG5cbiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9nZ2luZyBJRHMuXG5cbiBAcGFyYW0ge051bWJlcnwgU3RyaW5nfSBpZCBUaGUgSURcbiBAcmV0dXJucyB7U3RyaW5nfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluUXVvdGVzKGlkKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzTnVtZXJpYyhpZCkgPyAoYCR7aWR9YCkgOiAoYCcke2lkfSdgKTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gdHlwZWQgYXJyYXlzLlxuIEBwYXJhbSBhXG4gQHBhcmFtIGJcbiBAcmV0dXJucyB7KnxhfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgYyA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5KHJvb3QpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgICAgICBub2RlLmlkID0gbm9kZS51dWlkO1xuICAgICAgICBkZWxldGUgbm9kZS5vaWQ7XG4gICAgICAgIGxpc3QucHVzaChub2RlKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgICAgICAgICB2aXNpdChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cblxuICAgIHZpc2l0KHJvb3QpO1xuICAgIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHV0aWxzID0ge1xuICAgIHhtbFRvSnNvbjogeG1sVG9Kc29uLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBjb21wcmVzc0d1aWQ6IGNvbXByZXNzR3VpZCxcbiAgICBmaW5kTm9kZU9mVHlwZTogZmluZE5vZGVPZlR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBodHRwUmVxdWVzdDogaHR0cFJlcXVlc3QsXG4gICAgbG9hZEpTT046IGxvYWRKU09OLFxuICAgIGxvYWRBcnJheWJ1ZmZlcjogbG9hZEFycmF5YnVmZmVyLFxuICAgIHF1ZXJ5U3RyaW5nOiBxdWVyeVN0cmluZyxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc051bWVyaWM6IGlzTnVtZXJpYyxcbiAgICBpc0lEOiBpc0lELFxuICAgIGlzU2FtZUNvbXBvbmVudDogaXNTYW1lQ29tcG9uZW50LFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGNvcHk6IGNvcHksXG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIGFwcGx5MjogYXBwbHkyLFxuICAgIGFwcGx5SWY6IGFwcGx5SWYsXG4gICAgaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcbiAgICBpblF1b3RlczogaW5RdW90ZXMsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5OiBmbGF0dGVuUGFyZW50Q2hpbGRIaWVyYXJjaHlcbn07XG5cbmV4cG9ydCB7dXRpbHN9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js ***!
  \***********************************************************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return Map; });\n/** @private */\nclass Map {\n\n    constructor(items, baseId) {\n        this.items = items || [];\n        this._lastUniqueId = (baseId || 0) + 1;\n    }\n\n    /**\n     * Usage:\n     *\n     * id = myMap.addItem(\"foo\") // ID internally generated\n     * id = myMap.addItem(\"foo\", \"bar\") // ID is \"foo\"\n     */\n    addItem() {\n        let item;\n        if (arguments.length === 2) {\n            const id = arguments[0];\n            item = arguments[1];\n            if (this.items[id]) { // Won't happen if given ID is string\n                throw \"ID clash: '\" + id + \"'\";\n            }\n            this.items[id] = item;\n            return id;\n\n        } else {\n            item = arguments[0] || {};\n            while (true) {\n                const findId = this._lastUniqueId++;\n                if (!this.items[findId]) {\n                    this.items[findId] = item;\n                    return findId;\n                }\n            }\n        }\n    }\n\n    removeItem(id) {\n        const item = this.items[id];\n        delete this.items[id];\n        return item;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL01hcC5qcz84ZDZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS91dGlscy9NYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmNsYXNzIE1hcCB7XG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgYmFzZUlkKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5fbGFzdFVuaXF1ZUlkID0gKGJhc2VJZCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIikgLy8gSUQgaW50ZXJuYWxseSBnZW5lcmF0ZWRcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIiwgXCJiYXJcIikgLy8gSUQgaXMgXCJmb29cIlxuICAgICAqL1xuICAgIGFkZEl0ZW0oKSB7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaWRdKSB7IC8vIFdvbid0IGhhcHBlbiBpZiBnaXZlbiBJRCBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aHJvdyBcIklEIGNsYXNoOiAnXCIgKyBpZCArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kSWQgPSB0aGlzLl9sYXN0VW5pcXVlSWQrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXNbZmluZElkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ZpbmRJZF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oaWQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1tpZF07XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js ***!
  \*************************************************************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Queue\", function() { return Queue; });\n// Fast queue that avoids using potentially inefficient array .shift() calls\n// Based on https://github.com/creationix/fastqueue\n\n/** @private */\nclass Queue {\n\n    constructor() {\n\n        this._head = [];\n        this._headLength = 0;\n        this._tail = [];\n        this._index = 0;\n        this._length = 0;\n    }\n\n    get length() {\n        return this._length;\n    }\n\n    shift() {\n        if (this._index >= this._headLength) {\n            const t = this._head;\n            t.length = 0;\n            this._head = this._tail;\n            this._tail = t;\n            this._index = 0;\n            this._headLength = this._head.length;\n            if (!this._headLength) {\n                return;\n            }\n        }\n        const value = this._head[this._index];\n        if (this._index < 0) {\n            delete this._head[this._index++];\n        }\n        else {\n            this._head[this._index++] = undefined;\n        }\n        this._length--;\n        return value;\n    }\n\n    push(item) {\n        this._length++;\n        this._tail.push(item);\n        return this;\n    };\n\n    unshift(item) {\n        this._head[--this._index] = item;\n        this._length++;\n        return this;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzP2Y5YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRmFzdCBxdWV1ZSB0aGF0IGF2b2lkcyB1c2luZyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCBhcnJheSAuc2hpZnQoKSBjYWxsc1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NyZWF0aW9uaXgvZmFzdHF1ZXVlXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgUXVldWUge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5faGVhZCA9IFtdO1xuICAgICAgICB0aGlzLl9oZWFkTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IFtdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX2hlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRMZW5ndGggPSB0aGlzLl9oZWFkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGVhZExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2hlYWRbdGhpcy5faW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZFt0aGlzLl9pbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRbdGhpcy5faW5kZXgrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHRoaXMuX3RhaWwucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHVuc2hpZnQoaXRlbSkge1xuICAgICAgICB0aGlzLl9oZWFkWy0tdGhpcy5faW5kZXhdID0gaXRlbTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHtRdWV1ZX07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\n");

/***/ })

}]);