(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[4],{

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js ***!
  \***********************************************************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n\n\n\n\n/**\n * @desc Base class for all xeokit components.\n *\n * ## Component IDs\n *\n * Every Component has an ID that's unique within the parent {@link Scene}. xeokit generates\n * the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a\n * scene comprised of {@link Scene}, {@link Material}, {@link ReadableGeometry} and\n * {@link Mesh} components, while letting xeokit generate its own ID for\n * the {@link ReadableGeometry}:\n *\n *````JavaScript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {Mesh} from \"../src/scene/mesh/Mesh.js\";\n * import {buildTorusGeometry} from \"../src/scene/geometry/builders/buildTorusGeometry.js\";\n * import {ReadableGeometry} from \"../src/scene/geometry/ReadableGeometry.js\";\n * import {PhongMaterial} from \"../src/scene/materials/PhongMaterial.js\";\n * import {Texture} from \"../src/scene/materials/Texture.js\";\n * import {Fresnel} from \"../src/scene/materials/Fresnel.js\";\n *\n * const viewer = new Viewer({\n *        canvasId: \"myCanvas\"\n *    });\n *\n * viewer.scene.camera.eye = [0, 0, 5];\n * viewer.scene.camera.look = [0, 0, 0];\n * viewer.scene.camera.up = [0, 1, 0];\n *\n * new Mesh(viewer.scene, {\n *      geometry: new ReadableGeometry(viewer.scene, buildTorusGeometry({\n *          center: [0, 0, 0],\n *          radius: 1.5,\n *          tube: 0.5,\n *          radialSegments: 32,\n *          tubeSegments: 24,\n *          arc: Math.PI * 2.0\n *      }),\n *      material: new PhongMaterial(viewer.scene, {\n *          id: \"myMaterial\",\n *          ambient: [0.9, 0.3, 0.9],\n *          shininess: 30,\n *          diffuseMap: new Texture(viewer.scene, {\n *              src: \"textures/diffuse/uvGrid2.jpg\"\n *          }),\n *          specularFresnel: new Fresnel(viewer.scene, {\n *              leftColor: [1.0, 1.0, 1.0],\n *              rightColor: [0.0, 0.0, 0.0],\n *              power: 4\n *          })\n *     })\n * });\n *````\n *\n * We can then find those components like this:\n *\n * ````javascript\n * // Find the Material\n * var material = viewer.scene.components[\"myMaterial\"];\n *\n * // Find all PhongMaterials in the Scene\n * var phongMaterials = viewer.scene.types[\"PhongMaterial\"];\n *\n * // Find our Material within the PhongMaterials\n * var materialAgain = phongMaterials[\"myMaterial\"];\n * ````\n *\n * ## Restriction on IDs\n *\n * Auto-generated IDs are of the form ````\"__0\"````, ````\"__1\"````, ````\"__2\"```` ... and so on.\n *\n * Scene maintains a map of these IDs, along with a counter that it increments each time it generates a new ID.\n *\n * If Scene has created the IDs listed above, and we then destroy the ````Component```` with ID ````\"__1\"````,\n * Scene will mark that ID as available, and will reuse it for the next default ID.\n *\n * Therefore, two restrictions your on IDs:\n *\n * * don't use IDs that begin with two underscores, and\n * * don't reuse auto-generated IDs of destroyed Components.\n *\n * ## Logging\n *\n * Components have methods to log ID-prefixed messages to the JavaScript console:\n *\n * ````javascript\n * material.log(\"Everything is fine, situation normal.\");\n * material.warn(\"Wait, whats that red light?\");\n * material.error(\"Aw, snap!\");\n * ````\n *\n * The logged messages will look like this in the console:\n *\n * ````text\n * [LOG]   myMaterial: Everything is fine, situation normal.\n * [WARN]  myMaterial: Wait, whats that red light..\n * [ERROR] myMaterial: Aw, snap!\n * ````\n *\n * ## Destruction\n *\n * Get notification of destruction of Components:\n *\n * ````javascript\n * material.once(\"destroyed\", function() {\n *     this.log(\"Component was destroyed: \" + this.id);\n * });\n * ````\n *\n * Or get notification of destruction of any Component within its {@link Scene}:\n *\n * ````javascript\n * scene.on(\"componentDestroyed\", function(component) {\n *     this.log(\"Component was destroyed: \" + component.id);\n * });\n * ````\n *\n * Then destroy a component like this:\n *\n * ````javascript\n * material.destroy();\n * ````\n */\nclass Component {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"Component\";\n    }\n\n    /**\n     * @private\n     */\n    get isComponent() {\n        return true;\n    }\n\n    constructor(owner = null, cfg = {}) {\n\n        /**\n         * The parent {@link Scene} that contains this Component.\n         *\n         * @property scene\n         * @type {Scene}\n         * @final\n         */\n        this.scene = null;\n\n        if (this.type === \"Scene\") {\n            this.scene = this;\n            /**\n             * The viewer that contains this Scene.\n             * @property viewer\n             * @type {Viewer}\n             */\n            this.viewer = cfg.viewer;\n        } else {\n            if (owner.type === \"Scene\") {\n                this.scene = owner;\n            } else if (owner instanceof Component) {\n                this.scene = owner.scene;\n            } else {\n                throw \"Invalid param: owner must be a Component\"\n            }\n            this._owner = owner;\n            this._renderer = this.scene._renderer;\n        }\n\n        this._dontClear = !!cfg.dontClear; // Prevent Scene#clear from destroying this component\n\n        this._renderer = this.scene._renderer;\n\n        /**\n         Arbitrary, user-defined metadata on this component.\n\n         @property metadata\n         @type Object\n         */\n        this.meta = cfg.meta || {};\n\n\n        /**\n         * ID of this Component, unique within the {@link Scene}.\n         *\n         * Components are mapped by this ID in {@link Scene#components}.\n         *\n         * @property id\n         * @type {String|Number}\n         */\n        this.id = cfg.id; // Auto-generated by Scene by default\n\n        /**\n         True as soon as this Component has been destroyed\n\n         @property destroyed\n         @type {Boolean}\n         */\n        this.destroyed = false;\n\n        this._attached = {}; // Attached components with names.\n        this._attachments = null; // Attached components keyed to IDs - lazy-instantiated\n        this._subIdMap = null; // Subscription subId pool\n        this._subIdEvents = null; // Subscription subIds mapped to event names\n        this._eventSubs = null; // Event names mapped to subscribers\n        this._eventSubsNum = null;\n        this._events = null; // Maps names to events\n        this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events\n        this._ownedComponents = null; // // Components created with #create - lazy-instantiated\n\n        if (this !== this.scene) { // Don't add scene to itself\n            this.scene._addComponent(this); // Assigns this component an automatic ID if not yet assigned\n        }\n\n        this._updateScheduled = false; // True when #_update will be called on next tick\n\n        if (owner) {\n            owner._own(this);\n        }\n    }\n\n    // /**\n    //  * Unique ID for this Component within its {@link Scene}.\n    //  *\n    //  * @property\n    //  * @type {String}\n    //  */\n    // get id() {\n    //     return this._id;\n    // }\n\n    /**\n     Indicates that we need to redraw the scene.\n\n     This is called by certain subclasses after they have made some sort of state update that requires the\n     renderer to perform a redraw.\n\n     For example: a {@link Mesh} calls this on itself whenever you update its\n     {@link Mesh#layer} property, which manually controls its render order in\n     relation to other Meshes.\n\n     If this component has a ````castsShadow```` property that's set ````true````, then this will also indicate\n     that the renderer needs to redraw shadow map associated with this component. Components like\n     {@link DirLight} have that property set when they produce light that creates shadows, while\n     components like {@link Mesh\"}}layer{{/crossLink}} have that property set when they cast shadows.\n\n     @protected\n     */\n    glRedraw() {\n        this._renderer.imageDirty();\n        if (this.castsShadow) { // Light source or object\n            this._renderer.shadowsDirty();\n        }\n    }\n\n    /**\n     Indicates that we need to re-sort the renderer's state-ordered drawables list.\n\n     For efficiency, the renderer keeps its list of drawables ordered so that runs of the same state updates can be\n     combined.  This method is called by certain subclasses after they have made some sort of state update that would\n     require re-ordering of the drawables list.\n\n     For example: a {@link DirLight} calls this on itself whenever you update {@link DirLight#dir}.\n\n     @protected\n     */\n    glResort() {\n        this._renderer.needStateSort();\n    }\n\n    /**\n     * The {@link Component} that owns the lifecycle of this Component, if any.\n     *\n     * When that component is destroyed, this component will be automatically destroyed also.\n     *\n     * Will be null if this Component has no owner.\n     *\n     * @property owner\n     * @type {Component}\n     */\n    get owner() {\n        return this._owner;\n    }\n\n    /**\n     * Tests if this component is of the given type, or is a subclass of the given type.\n     * @type {Boolean}\n     */\n    isType(type) {\n        return this.type === type;\n    }\n\n    /**\n     * Fires an event on this component.\n     *\n     * Notifies existing subscribers to the event, optionally retains the event to give to\n     * any subsequent notifications on the event as they are made.\n     *\n     * @param {String} event The event type name\n     * @param {Object} value The event parameters\n     * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers\n     */\n    fire(event, value, forget) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n            this._eventSubsNum = {};\n        }\n        if (forget !== true) {\n            this._events[event] = value || true; // Save notification\n        }\n        const subs = this._eventSubs[event];\n        let sub;\n        if (subs) { // Notify subscriptions\n            for (const subId in subs) {\n                if (subs.hasOwnProperty(subId)) {\n                    sub = subs[subId];\n                    this._eventCallDepth++;\n                    if (this._eventCallDepth < 300) {\n                        sub.callback.call(sub.scope, value);\n                    } else {\n                        this.error(\"fire: potential stack overflow from recursive event '\" + event + \"' - dropping this event\");\n                    }\n                    this._eventCallDepth--;\n                }\n            }\n        }\n    }\n\n    /**\n     * Subscribes to an event on this component.\n     *\n     * The callback is be called with this component as scope.\n     *\n     * @param {String} event The event\n     * @param {Function} callback Called fired on the event\n     * @param {Object} [scope=this] Scope for the callback\n     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.\n     */\n    on(event, callback, scope) {\n        if (!this._events) {\n            this._events = {};\n        }\n        if (!this._subIdMap) {\n            this._subIdMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_2__[\"Map\"](); // Subscription subId pool\n        }\n        if (!this._subIdEvents) {\n            this._subIdEvents = {};\n        }\n        if (!this._eventSubs) {\n            this._eventSubs = {};\n        }\n        if (!this._eventSubsNum) {\n            this._eventSubsNum = {};\n        }\n        let subs = this._eventSubs[event];\n        if (!subs) {\n            subs = {};\n            this._eventSubs[event] = subs;\n            this._eventSubsNum[event] = 1;\n        } else {\n            this._eventSubsNum[event]++;\n        }\n        const subId = this._subIdMap.addItem(); // Create unique subId\n        subs[subId] = {\n            callback: callback,\n            scope: scope || this\n        };\n        this._subIdEvents[subId] = event;\n        const value = this._events[event];\n        if (value !== undefined) { // A publication exists, notify callback immediately\n            callback.call(scope || this, value);\n        }\n        return subId;\n    }\n\n    /**\n     * Cancels an event subscription that was previously made with {@link Component#on} or {@link Component#once}.\n     *\n     * @param {String} subId Subscription ID\n     */\n    off(subId) {\n        if (subId === undefined || subId === null) {\n            return;\n        }\n        if (!this._subIdEvents) {\n            return;\n        }\n        const event = this._subIdEvents[subId];\n        if (event) {\n            delete this._subIdEvents[subId];\n            const subs = this._eventSubs[event];\n            if (subs) {\n                delete subs[subId];\n                this._eventSubsNum[event]--;\n            }\n            this._subIdMap.removeItem(subId); // Release subId\n        }\n    }\n\n    /**\n     * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is subIdd.\n     *\n     * This is equivalent to calling {@link Component#on}, and then calling {@link Component#off} inside the callback function.\n     *\n     * @param {String} event Data event to listen to\n     * @param {Function} callback Called when fresh data is available at the event\n     * @param {Object} [scope=this] Scope for the callback\n     */\n    once(event, callback, scope) {\n        const self = this;\n        const subId = this.on(event,\n            function (value) {\n                self.off(subId);\n                callback.call(scope || this, value);\n            },\n            scope);\n    }\n\n    /**\n     * Returns true if there are any subscribers to the given event on this component.\n     *\n     * @param {String} event The event\n     * @return {Boolean} True if there are any subscribers to the given event on this component.\n     */\n    hasSubs(event) {\n        return (this._eventSubsNum && (this._eventSubsNum[event] > 0));\n    }\n\n    /**\n     * Logs a console debugging message for this component.\n     *\n     * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*\n     *\n     * Also fires the message as a \"log\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    log(message) {\n        message = \"[LOG]\" + this._message(message);\n        window.console.log(message);\n        this.scene.fire(\"log\", message);\n    }\n\n    _message(message) {\n        return \" [\" + this.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(this.id) + \"]: \" + message;\n    }\n\n    /**\n     * Logs a warning for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as a \"warn\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    warn(message) {\n        message = \"[WARN]\" + this._message(message);\n        window.console.warn(message);\n        this.scene.fire(\"warn\", message);\n    }\n\n    /**\n     * Logs an error for this component to the JavaScript console.\n     *\n     * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*\n     *\n     * Also fires the message as an \"error\" event on the parent {@link Scene}.\n     *\n     * @param {String} message The message to log\n     */\n    error(message) {\n        message = \"[ERROR]\" + this._message(message);\n        window.console.error(message);\n        this.scene.fire(\"error\", message);\n    }\n\n    /**\n     * Adds a child component to this.\n     *\n     * When component not given, attaches the scene's default instance for the given name (if any).\n     * Publishes the new child component on this component, keyed to the given name.\n     *\n     * @param {*} params\n     * @param {String} params.name component name\n     * @param {Component} [params.component] The component\n     * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will\n     * cause an exception if the given child is not the same type or a subtype of this.\n     * @param {Boolean} [params.sceneDefault=false]\n     * @param {Boolean} [params.sceneSingleton=false]\n     * @param {Function} [params.onAttached] Optional callback called when component attached\n     * @param {Function} [params.onAttached.callback] Callback function\n     * @param {Function} [params.onAttached.scope] Optional scope for callback\n     * @param {Function} [params.onDetached] Optional callback called when component is detached\n     * @param {Function} [params.onDetached.callback] Callback function\n     * @param {Function} [params.onDetached.scope] Optional scope for callback\n     * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component\n     * @param {Boolean} [params.recompiles=true] When true, fires \"dirty\" events on this component\n     * @private\n     */\n    _attach(params) {\n\n        const name = params.name;\n\n        if (!name) {\n            this.error(\"Component 'name' expected\");\n            return;\n        }\n\n        let component = params.component;\n        const sceneDefault = params.sceneDefault;\n        const sceneSingleton = params.sceneSingleton;\n        const type = params.type;\n        const on = params.on;\n        const recompiles = params.recompiles !== false;\n\n        // True when child given as config object, where parent manages its instantiation and destruction\n        let managingLifecycle = false;\n\n        if (component) {\n\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isNumeric(component) || _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isString(component)) {\n\n                // Component ID given\n                // Both numeric and string IDs are supported\n\n                const id = component;\n\n                component = this.scene.components[id];\n\n                if (!component) {\n\n                    // Quote string IDs in errors\n\n                    this.error(\"Component not found: \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(id));\n                    return;\n                }\n            }\n        }\n\n        if (!component) {\n\n            if (sceneSingleton === true) {\n\n                // Using the first instance of the component type we find\n\n                const instances = this.scene.types[type];\n                for (const id2 in instances) {\n                    if (instances.hasOwnProperty) {\n                        component = instances[id2];\n                        break;\n                    }\n                }\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n\n            } else if (sceneDefault === true) {\n\n                // Using a default scene component\n\n                component = this.scene[name];\n\n                if (!component) {\n                    this.error(\"Scene has no default component for '\" + name + \"'\");\n                    return null;\n                }\n            }\n        }\n\n        if (component) {\n\n            if (component.scene.id !== this.scene.id) {\n                this.error(\"Not in same scene: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                return;\n            }\n\n            if (type) {\n\n                if (!component.isType(type)) {\n                    this.error(\"Expected a \" + type + \" type or subtype: \" + component.type + \" \" + _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].inQuotes(component.id));\n                    return;\n                }\n            }\n        }\n\n        if (!this._attachments) {\n            this._attachments = {};\n        }\n\n        const oldComponent = this._attached[name];\n        let subs;\n        let i;\n        let len;\n\n        if (oldComponent) {\n\n            if (component && oldComponent.id === component.id) {\n\n                // Reject attempt to reattach same component\n                return;\n            }\n\n            const oldAttachment = this._attachments[oldComponent.id];\n\n            // Unsubscribe from events on old component\n\n            subs = oldAttachment.subs;\n\n            for (i = 0, len = subs.length; i < len; i++) {\n                oldComponent.off(subs[i]);\n            }\n\n            delete this._attached[name];\n            delete this._attachments[oldComponent.id];\n\n            const onDetached = oldAttachment.params.onDetached;\n            if (onDetached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onDetached)) {\n                    onDetached(oldComponent);\n                } else {\n                    onDetached.scope ? onDetached.callback.call(onDetached.scope, oldComponent) : onDetached.callback(oldComponent);\n                }\n            }\n\n            if (oldAttachment.managingLifecycle) {\n\n                // Note that we just unsubscribed from all events fired by the child\n                // component, so destroying it won't fire events back at us now.\n\n                oldComponent.destroy();\n            }\n        }\n\n        if (component) {\n\n            // Set and publish the new component on this component\n\n            const attachment = {\n                params: params,\n                component: component,\n                subs: [],\n                managingLifecycle: managingLifecycle\n            };\n\n            attachment.subs.push(\n                component.once(\"destroyed\",\n                    function () {\n                        attachment.params.component = null;\n                        this._attach(attachment.params);\n                    },\n                    this));\n\n            if (recompiles) {\n                attachment.subs.push(\n                    component.on(\"dirty\",\n                        function () {\n                            this.fire(\"dirty\", this);\n                        },\n                        this));\n            }\n\n            this._attached[name] = component;\n            this._attachments[component.id] = attachment;\n\n            // Bind destruct listener to new component to remove it\n            // from this component when destroyed\n\n            const onAttached = params.onAttached;\n            if (onAttached) {\n                if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(onAttached)) {\n                    onAttached(component);\n                } else {\n                    onAttached.scope ? onAttached.callback.call(onAttached.scope, component) : onAttached.callback(component);\n                }\n            }\n\n            if (on) {\n\n                let event;\n                let subIdr;\n                let callback;\n                let scope;\n\n                for (event in on) {\n                    if (on.hasOwnProperty(event)) {\n\n                        subIdr = on[event];\n\n                        if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isFunction(subIdr)) {\n                            callback = subIdr;\n                            scope = null;\n                        } else {\n                            callback = subIdr.callback;\n                            scope = subIdr.scope;\n                        }\n\n                        if (!callback) {\n                            continue;\n                        }\n\n                        attachment.subs.push(component.on(event, callback, scope));\n                    }\n                }\n            }\n        }\n\n        if (recompiles) {\n            this.fire(\"dirty\", this); // FIXME: May trigger spurous mesh recompilations unless able to limit with param?\n        }\n\n        this.fire(name, component); // Component can be null\n\n        return component;\n    }\n\n    _checkComponent(expectedType, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (expectedType !== component.type) {\n            this.error(\"Expected a \" + expectedType + \" Component\");\n            return;\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        return component;\n    }\n\n    _checkComponent2(expectedTypes, component) {\n        if (!component.isComponent) {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"utils\"].isID(component)) {\n                const id = component;\n                component = this.scene.components[id];\n                if (!component) {\n                    this.error(\"Component not found: \" + id);\n                    return;\n                }\n            } else {\n                this.error(\"Expected a Component or ID\");\n                return;\n            }\n        }\n        if (component.scene.id !== this.scene.id) {\n            this.error(\"Not in same scene: \" + component.type);\n            return;\n        }\n        for (var i = 0, len = expectedTypes.length; i < len; i++) {\n            if (expectedTypes[i] === component.type) {\n                return component;\n            }\n        }\n        this.error(\"Expected component types: \" + expectedTypes);\n        return null;\n    }\n\n    _own(component) {\n        if (!this._ownedComponents) {\n            this._ownedComponents = {};\n        }\n        if (!this._ownedComponents[component.id]) {\n            this._ownedComponents[component.id] = component;\n        }\n        component.once(\"destroyed\", () => {\n            delete this._ownedComponents[component.id];\n        }, this);\n    }\n\n    /**\n     * Protected method, called by sub-classes to queue a call to _update().\n     * @protected\n     * @param {Number} [priority=1]\n     */\n    _needUpdate(priority) {\n        if (!this._updateScheduled) {\n            this._updateScheduled = true;\n            if (priority === 0) {\n                this._doUpdate();\n            } else {\n                _core_js__WEBPACK_IMPORTED_MODULE_0__[\"core\"].scheduleTask(this._doUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    _doUpdate() {\n        if (this._updateScheduled) {\n            this._updateScheduled = false;\n            if (this._update) {\n                this._update();\n            }\n        }\n    }\n\n    /**\n     * Protected virtual template method, optionally implemented\n     * by sub-classes to perform a scheduled task.\n     *\n     * @protected\n     */\n    _update() {\n    }\n\n    /**\n     * Destroys all {@link Component}s that are owned by this. These are Components that were instantiated with\n     * this Component as their first constructor argument.\n     */\n    clear() {\n        if (this._ownedComponents) {\n            for (var id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    const component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n    }\n\n    /**\n     * Destroys this component.\n     */\n    destroy() {\n\n        if (this.destroyed) {\n            return;\n        }\n\n        /**\n         * Fired when this Component is destroyed.\n         * @event destroyed\n         */\n        this.fire(\"destroyed\", this.destroyed = true); // Must fire before we blow away subscription maps, below\n\n        // Unsubscribe from child components and destroy then\n\n        let id;\n        let attachment;\n        let component;\n        let subs;\n        let i;\n        let len;\n\n        if (this._attachments) {\n            for (id in this._attachments) {\n                if (this._attachments.hasOwnProperty(id)) {\n                    attachment = this._attachments[id];\n                    component = attachment.component;\n                    subs = attachment.subs;\n                    for (i = 0, len = subs.length; i < len; i++) {\n                        component.off(subs[i]);\n                    }\n                    if (attachment.managingLifecycle) {\n                        component.destroy();\n                    }\n                }\n            }\n        }\n\n        if (this._ownedComponents) {\n            for (id in this._ownedComponents) {\n                if (this._ownedComponents.hasOwnProperty(id)) {\n                    component = this._ownedComponents[id];\n                    component.destroy();\n                    delete this._ownedComponents[id];\n                }\n            }\n        }\n\n        this.scene._removeComponent(this);\n\n        // Memory leak avoidance\n        this._attached = {};\n        this._attachments = null;\n        this._subIdMap = null;\n        this._subIdEvents = null;\n        this._eventSubs = null;\n        this._events = null;\n        this._eventCallDepth = 0;\n        this._ownedComponents = null;\n        this._updateScheduled = false;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL0NvbXBvbmVudC5qcz9hMDM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFDRTtBQUNFOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSx1QkFBdUIsWUFBWSxHQUFHLGVBQWUsR0FBRyx1QkFBdUI7QUFDL0UsSUFBSSxXQUFXO0FBQ2YsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixRQUFRO0FBQ1IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMscUNBQXFDOztBQUVyQyxrQ0FBa0M7QUFDbEMsMkNBQTJDO0FBQzNDOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQyxNQUFNLGlCQUFpQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLHNCQUFzQixhQUFhLE9BQU8sWUFBWTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixlQUFlLDJDQUEyQyxtQkFBbUI7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTyxvRUFBb0UsV0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQUcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsbUJBQW1CLEtBQUsscUJBQXFCO0FBQ2pIO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQ2pHO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QywrQ0FBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPLGdFQUFnRTtBQUN0RjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQiwrQ0FBSyx5QkFBeUIsK0NBQUs7O0FBRW5EO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlELCtDQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEVBQTBFLCtDQUFLO0FBQy9FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvR0FBb0csK0NBQUs7QUFDekc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBSztBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFLO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QiwrQ0FBSztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLDZDQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvQ29tcG9uZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjb3JlfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7TWFwfSBmcm9tIFwiLi91dGlscy9NYXAuanNcIjtcblxuLyoqXG4gKiBAZGVzYyBCYXNlIGNsYXNzIGZvciBhbGwgeGVva2l0IGNvbXBvbmVudHMuXG4gKlxuICogIyMgQ29tcG9uZW50IElEc1xuICpcbiAqIEV2ZXJ5IENvbXBvbmVudCBoYXMgYW4gSUQgdGhhdCdzIHVuaXF1ZSB3aXRoaW4gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LiB4ZW9raXQgZ2VuZXJhdGVzXG4gKiB0aGUgSURzIGF1dG9tYXRpY2FsbHkgYnkgZGVmYXVsdCwgaG93ZXZlciB5b3UgY2FuIGFsc28gc3BlY2lmeSB0aGVtIHlvdXJzZWxmLiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgd2UncmUgY3JlYXRpbmcgYVxuICogc2NlbmUgY29tcHJpc2VkIG9mIHtAbGluayBTY2VuZX0sIHtAbGluayBNYXRlcmlhbH0sIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fSBhbmRcbiAqIHtAbGluayBNZXNofSBjb21wb25lbnRzLCB3aGlsZSBsZXR0aW5nIHhlb2tpdCBnZW5lcmF0ZSBpdHMgb3duIElEIGZvclxuICogdGhlIHtAbGluayBSZWFkYWJsZUdlb21ldHJ5fTpcbiAqXG4gKmBgYGBKYXZhU2NyaXB0XG4gKiBpbXBvcnQge1ZpZXdlcn0gZnJvbSBcIi4uL3NyYy92aWV3ZXIvVmlld2VyLmpzXCI7XG4gKiBpbXBvcnQge01lc2h9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWVzaC9NZXNoLmpzXCI7XG4gKiBpbXBvcnQge2J1aWxkVG9ydXNHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9idWlsZGVycy9idWlsZFRvcnVzR2VvbWV0cnkuanNcIjtcbiAqIGltcG9ydCB7UmVhZGFibGVHZW9tZXRyeX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9nZW9tZXRyeS9SZWFkYWJsZUdlb21ldHJ5LmpzXCI7XG4gKiBpbXBvcnQge1Bob25nTWF0ZXJpYWx9IGZyb20gXCIuLi9zcmMvc2NlbmUvbWF0ZXJpYWxzL1Bob25nTWF0ZXJpYWwuanNcIjtcbiAqIGltcG9ydCB7VGV4dHVyZX0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvVGV4dHVyZS5qc1wiO1xuICogaW1wb3J0IHtGcmVzbmVsfSBmcm9tIFwiLi4vc3JjL3NjZW5lL21hdGVyaWFscy9GcmVzbmVsLmpzXCI7XG4gKlxuICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXdlcih7XG4gKiAgICAgICAgY2FudmFzSWQ6IFwibXlDYW52YXNcIlxuICogICAgfSk7XG4gKlxuICogdmlld2VyLnNjZW5lLmNhbWVyYS5leWUgPSBbMCwgMCwgNV07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmxvb2sgPSBbMCwgMCwgMF07XG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLnVwID0gWzAsIDEsIDBdO1xuICpcbiAqIG5ldyBNZXNoKHZpZXdlci5zY2VuZSwge1xuICogICAgICBnZW9tZXRyeTogbmV3IFJlYWRhYmxlR2VvbWV0cnkodmlld2VyLnNjZW5lLCBidWlsZFRvcnVzR2VvbWV0cnkoe1xuICogICAgICAgICAgY2VudGVyOiBbMCwgMCwgMF0sXG4gKiAgICAgICAgICByYWRpdXM6IDEuNSxcbiAqICAgICAgICAgIHR1YmU6IDAuNSxcbiAqICAgICAgICAgIHJhZGlhbFNlZ21lbnRzOiAzMixcbiAqICAgICAgICAgIHR1YmVTZWdtZW50czogMjQsXG4gKiAgICAgICAgICBhcmM6IE1hdGguUEkgKiAyLjBcbiAqICAgICAgfSksXG4gKiAgICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgIGlkOiBcIm15TWF0ZXJpYWxcIixcbiAqICAgICAgICAgIGFtYmllbnQ6IFswLjksIDAuMywgMC45XSxcbiAqICAgICAgICAgIHNoaW5pbmVzczogMzAsXG4gKiAgICAgICAgICBkaWZmdXNlTWFwOiBuZXcgVGV4dHVyZSh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgICAgICBzcmM6IFwidGV4dHVyZXMvZGlmZnVzZS91dkdyaWQyLmpwZ1wiXG4gKiAgICAgICAgICB9KSxcbiAqICAgICAgICAgIHNwZWN1bGFyRnJlc25lbDogbmV3IEZyZXNuZWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgbGVmdENvbG9yOiBbMS4wLCAxLjAsIDEuMF0sXG4gKiAgICAgICAgICAgICAgcmlnaHRDb2xvcjogWzAuMCwgMC4wLCAwLjBdLFxuICogICAgICAgICAgICAgIHBvd2VyOiA0XG4gKiAgICAgICAgICB9KVxuICogICAgIH0pXG4gKiB9KTtcbiAqYGBgYFxuICpcbiAqIFdlIGNhbiB0aGVuIGZpbmQgdGhvc2UgY29tcG9uZW50cyBsaWtlIHRoaXM6XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIC8vIEZpbmQgdGhlIE1hdGVyaWFsXG4gKiB2YXIgbWF0ZXJpYWwgPSB2aWV3ZXIuc2NlbmUuY29tcG9uZW50c1tcIm15TWF0ZXJpYWxcIl07XG4gKlxuICogLy8gRmluZCBhbGwgUGhvbmdNYXRlcmlhbHMgaW4gdGhlIFNjZW5lXG4gKiB2YXIgcGhvbmdNYXRlcmlhbHMgPSB2aWV3ZXIuc2NlbmUudHlwZXNbXCJQaG9uZ01hdGVyaWFsXCJdO1xuICpcbiAqIC8vIEZpbmQgb3VyIE1hdGVyaWFsIHdpdGhpbiB0aGUgUGhvbmdNYXRlcmlhbHNcbiAqIHZhciBtYXRlcmlhbEFnYWluID0gcGhvbmdNYXRlcmlhbHNbXCJteU1hdGVyaWFsXCJdO1xuICogYGBgYFxuICpcbiAqICMjIFJlc3RyaWN0aW9uIG9uIElEc1xuICpcbiAqIEF1dG8tZ2VuZXJhdGVkIElEcyBhcmUgb2YgdGhlIGZvcm0gYGBgYFwiX18wXCJgYGBgLCBgYGBgXCJfXzFcImBgYGAsIGBgYGBcIl9fMlwiYGBgYCAuLi4gYW5kIHNvIG9uLlxuICpcbiAqIFNjZW5lIG1haW50YWlucyBhIG1hcCBvZiB0aGVzZSBJRHMsIGFsb25nIHdpdGggYSBjb3VudGVyIHRoYXQgaXQgaW5jcmVtZW50cyBlYWNoIHRpbWUgaXQgZ2VuZXJhdGVzIGEgbmV3IElELlxuICpcbiAqIElmIFNjZW5lIGhhcyBjcmVhdGVkIHRoZSBJRHMgbGlzdGVkIGFib3ZlLCBhbmQgd2UgdGhlbiBkZXN0cm95IHRoZSBgYGBgQ29tcG9uZW50YGBgYCB3aXRoIElEIGBgYGBcIl9fMVwiYGBgYCxcbiAqIFNjZW5lIHdpbGwgbWFyayB0aGF0IElEIGFzIGF2YWlsYWJsZSwgYW5kIHdpbGwgcmV1c2UgaXQgZm9yIHRoZSBuZXh0IGRlZmF1bHQgSUQuXG4gKlxuICogVGhlcmVmb3JlLCB0d28gcmVzdHJpY3Rpb25zIHlvdXIgb24gSURzOlxuICpcbiAqICogZG9uJ3QgdXNlIElEcyB0aGF0IGJlZ2luIHdpdGggdHdvIHVuZGVyc2NvcmVzLCBhbmRcbiAqICogZG9uJ3QgcmV1c2UgYXV0by1nZW5lcmF0ZWQgSURzIG9mIGRlc3Ryb3llZCBDb21wb25lbnRzLlxuICpcbiAqICMjIExvZ2dpbmdcbiAqXG4gKiBDb21wb25lbnRzIGhhdmUgbWV0aG9kcyB0byBsb2cgSUQtcHJlZml4ZWQgbWVzc2FnZXMgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZTpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogbWF0ZXJpYWwubG9nKFwiRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlwiKTtcbiAqIG1hdGVyaWFsLndhcm4oXCJXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodD9cIik7XG4gKiBtYXRlcmlhbC5lcnJvcihcIkF3LCBzbmFwIVwiKTtcbiAqIGBgYGBcbiAqXG4gKiBUaGUgbG9nZ2VkIG1lc3NhZ2VzIHdpbGwgbG9vayBsaWtlIHRoaXMgaW4gdGhlIGNvbnNvbGU6XG4gKlxuICogYGBgYHRleHRcbiAqIFtMT0ddICAgbXlNYXRlcmlhbDogRXZlcnl0aGluZyBpcyBmaW5lLCBzaXR1YXRpb24gbm9ybWFsLlxuICogW1dBUk5dICBteU1hdGVyaWFsOiBXYWl0LCB3aGF0cyB0aGF0IHJlZCBsaWdodC4uXG4gKiBbRVJST1JdIG15TWF0ZXJpYWw6IEF3LCBzbmFwIVxuICogYGBgYFxuICpcbiAqICMjIERlc3RydWN0aW9uXG4gKlxuICogR2V0IG5vdGlmaWNhdGlvbiBvZiBkZXN0cnVjdGlvbiBvZiBDb21wb25lbnRzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5vbmNlKFwiZGVzdHJveWVkXCIsIGZ1bmN0aW9uKCkge1xuICogICAgIHRoaXMubG9nKFwiQ29tcG9uZW50IHdhcyBkZXN0cm95ZWQ6IFwiICsgdGhpcy5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBPciBnZXQgbm90aWZpY2F0aW9uIG9mIGRlc3RydWN0aW9uIG9mIGFueSBDb21wb25lbnQgd2l0aGluIGl0cyB7QGxpbmsgU2NlbmV9OlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBzY2VuZS5vbihcImNvbXBvbmVudERlc3Ryb3llZFwiLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAqICAgICB0aGlzLmxvZyhcIkNvbXBvbmVudCB3YXMgZGVzdHJveWVkOiBcIiArIGNvbXBvbmVudC5pZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBUaGVuIGRlc3Ryb3kgYSBjb21wb25lbnQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBtYXRlcmlhbC5kZXN0cm95KCk7XG4gKiBgYGBgXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ29tcG9uZW50XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgaXNDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKG93bmVyID0gbnVsbCwgY2ZnID0ge30pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9IHRoYXQgY29udGFpbnMgdGhpcyBDb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzY2VuZVxuICAgICAgICAgKiBAdHlwZSB7U2NlbmV9XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gdGhpcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZpZXdlciB0aGF0IGNvbnRhaW5zIHRoaXMgU2NlbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdmlld2VyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Vmlld2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpZXdlciA9IGNmZy52aWV3ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3duZXIudHlwZSA9PT0gXCJTY2VuZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG93bmVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lciBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBvd25lci5zY2VuZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmFtOiBvd25lciBtdXN0IGJlIGEgQ29tcG9uZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuc2NlbmUuX3JlbmRlcmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9udENsZWFyID0gISFjZmcuZG9udENsZWFyOyAvLyBQcmV2ZW50IFNjZW5lI2NsZWFyIGZyb20gZGVzdHJveWluZyB0aGlzIGNvbXBvbmVudFxuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5zY2VuZS5fcmVuZGVyZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBBcmJpdHJhcnksIHVzZXItZGVmaW5lZCBtZXRhZGF0YSBvbiB0aGlzIGNvbXBvbmVudC5cblxuICAgICAgICAgQHByb3BlcnR5IG1ldGFkYXRhXG4gICAgICAgICBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0YSA9IGNmZy5tZXRhIHx8IHt9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoaXMgQ29tcG9uZW50LCB1bmlxdWUgd2l0aGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb21wb25lbnRzIGFyZSBtYXBwZWQgYnkgdGhpcyBJRCBpbiB7QGxpbmsgU2NlbmUjY29tcG9uZW50c30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfE51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBjZmcuaWQ7IC8vIEF1dG8tZ2VuZXJhdGVkIGJ5IFNjZW5lIGJ5IGRlZmF1bHRcblxuICAgICAgICAvKipcbiAgICAgICAgIFRydWUgYXMgc29vbiBhcyB0aGlzIENvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWRcblxuICAgICAgICAgQHByb3BlcnR5IGRlc3Ryb3llZFxuICAgICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkID0ge307IC8vIEF0dGFjaGVkIGNvbXBvbmVudHMgd2l0aCBuYW1lcy5cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMgPSBudWxsOyAvLyBBdHRhY2hlZCBjb21wb25lbnRzIGtleWVkIHRvIElEcyAtIGxhenktaW5zdGFudGlhdGVkXG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDsgLy8gU3Vic2NyaXB0aW9uIHN1YklkIHBvb2xcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsOyAvLyBTdWJzY3JpcHRpb24gc3ViSWRzIG1hcHBlZCB0byBldmVudCBuYW1lc1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsOyAvLyBFdmVudCBuYW1lcyBtYXBwZWQgdG8gc3Vic2NyaWJlcnNcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDsgLy8gTWFwcyBuYW1lcyB0byBldmVudHNcbiAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGggPSAwOyAvLyBIZWxwcyB1cyBjYXRjaCBzdGFjayBvdmVyZmxvd3MgZnJvbSByZWN1cnNpdmUgZXZlbnRzXG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7IC8vIC8vIENvbXBvbmVudHMgY3JlYXRlZCB3aXRoICNjcmVhdGUgLSBsYXp5LWluc3RhbnRpYXRlZFxuXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnNjZW5lKSB7IC8vIERvbid0IGFkZCBzY2VuZSB0byBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX2FkZENvbXBvbmVudCh0aGlzKTsgLy8gQXNzaWducyB0aGlzIGNvbXBvbmVudCBhbiBhdXRvbWF0aWMgSUQgaWYgbm90IHlldCBhc3NpZ25lZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7IC8vIFRydWUgd2hlbiAjX3VwZGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiBuZXh0IHRpY2tcblxuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICAgIG93bmVyLl9vd24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgQ29tcG9uZW50IHdpdGhpbiBpdHMge0BsaW5rIFNjZW5lfS5cbiAgICAvLyAgKlxuICAgIC8vICAqIEBwcm9wZXJ0eVxuICAgIC8vICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgLy8gICovXG4gICAgLy8gZ2V0IGlkKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmVkcmF3IHRoZSBzY2VuZS5cblxuICAgICBUaGlzIGlzIGNhbGxlZCBieSBjZXJ0YWluIHN1YmNsYXNzZXMgYWZ0ZXIgdGhleSBoYXZlIG1hZGUgc29tZSBzb3J0IG9mIHN0YXRlIHVwZGF0ZSB0aGF0IHJlcXVpcmVzIHRoZVxuICAgICByZW5kZXJlciB0byBwZXJmb3JtIGEgcmVkcmF3LlxuXG4gICAgIEZvciBleGFtcGxlOiBhIHtAbGluayBNZXNofSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIGl0c1xuICAgICB7QGxpbmsgTWVzaCNsYXllcn0gcHJvcGVydHksIHdoaWNoIG1hbnVhbGx5IGNvbnRyb2xzIGl0cyByZW5kZXIgb3JkZXIgaW5cbiAgICAgcmVsYXRpb24gdG8gb3RoZXIgTWVzaGVzLlxuXG4gICAgIElmIHRoaXMgY29tcG9uZW50IGhhcyBhIGBgYGBjYXN0c1NoYWRvd2BgYGAgcHJvcGVydHkgdGhhdCdzIHNldCBgYGBgdHJ1ZWBgYGAsIHRoZW4gdGhpcyB3aWxsIGFsc28gaW5kaWNhdGVcbiAgICAgdGhhdCB0aGUgcmVuZGVyZXIgbmVlZHMgdG8gcmVkcmF3IHNoYWRvdyBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LiBDb21wb25lbnRzIGxpa2VcbiAgICAge0BsaW5rIERpckxpZ2h0fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBwcm9kdWNlIGxpZ2h0IHRoYXQgY3JlYXRlcyBzaGFkb3dzLCB3aGlsZVxuICAgICBjb21wb25lbnRzIGxpa2Uge0BsaW5rIE1lc2hcIn19bGF5ZXJ7ey9jcm9zc0xpbmt9fSBoYXZlIHRoYXQgcHJvcGVydHkgc2V0IHdoZW4gdGhleSBjYXN0IHNoYWRvd3MuXG5cbiAgICAgQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdsUmVkcmF3KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbWFnZURpcnR5KCk7XG4gICAgICAgIGlmICh0aGlzLmNhc3RzU2hhZG93KSB7IC8vIExpZ2h0IHNvdXJjZSBvciBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNoYWRvd3NEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIEluZGljYXRlcyB0aGF0IHdlIG5lZWQgdG8gcmUtc29ydCB0aGUgcmVuZGVyZXIncyBzdGF0ZS1vcmRlcmVkIGRyYXdhYmxlcyBsaXN0LlxuXG4gICAgIEZvciBlZmZpY2llbmN5LCB0aGUgcmVuZGVyZXIga2VlcHMgaXRzIGxpc3Qgb2YgZHJhd2FibGVzIG9yZGVyZWQgc28gdGhhdCBydW5zIG9mIHRoZSBzYW1lIHN0YXRlIHVwZGF0ZXMgY2FuIGJlXG4gICAgIGNvbWJpbmVkLiAgVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGNlcnRhaW4gc3ViY2xhc3NlcyBhZnRlciB0aGV5IGhhdmUgbWFkZSBzb21lIHNvcnQgb2Ygc3RhdGUgdXBkYXRlIHRoYXQgd291bGRcbiAgICAgcmVxdWlyZSByZS1vcmRlcmluZyBvZiB0aGUgZHJhd2FibGVzIGxpc3QuXG5cbiAgICAgRm9yIGV4YW1wbGU6IGEge0BsaW5rIERpckxpZ2h0fSBjYWxscyB0aGlzIG9uIGl0c2VsZiB3aGVuZXZlciB5b3UgdXBkYXRlIHtAbGluayBEaXJMaWdodCNkaXJ9LlxuXG4gICAgIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnbFJlc29ydCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIubmVlZFN0YXRlU29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQ29tcG9uZW50fSB0aGF0IG93bnMgdGhlIGxpZmVjeWNsZSBvZiB0aGlzIENvbXBvbmVudCwgaWYgYW55LlxuICAgICAqXG4gICAgICogV2hlbiB0aGF0IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQsIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgYWxzby5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgbnVsbCBpZiB0aGlzIENvbXBvbmVudCBoYXMgbm8gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3duZXJcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBvd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX293bmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgY29tcG9uZW50IGlzIG9mIHRoZSBnaXZlbiB0eXBlLCBvciBpcyBhIHN1YmNsYXNzIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBOb3RpZmllcyBleGlzdGluZyBzdWJzY3JpYmVycyB0byB0aGUgZXZlbnQsIG9wdGlvbmFsbHkgcmV0YWlucyB0aGUgZXZlbnQgdG8gZ2l2ZSB0b1xuICAgICAqIGFueSBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMgb24gdGhlIGV2ZW50IGFzIHRoZXkgYXJlIG1hZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmdldD1mYWxzZV0gV2hlbiB0cnVlLCBkb2VzIG5vdCByZXRhaW4gZm9yIHN1YnNlcXVlbnQgc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50LCB2YWx1ZSwgZm9yZ2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNOdW0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yZ2V0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdmFsdWUgfHwgdHJ1ZTsgLy8gU2F2ZSBub3RpZmljYXRpb25cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgbGV0IHN1YjtcbiAgICAgICAgaWYgKHN1YnMpIHsgLy8gTm90aWZ5IHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViSWQgaW4gc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzLmhhc093blByb3BlcnR5KHN1YklkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWJzW3N1YklkXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRDYWxsRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbERlcHRoIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2suY2FsbChzdWIuc2NvcGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJmaXJlOiBwb3RlbnRpYWwgc3RhY2sgb3ZlcmZsb3cgZnJvbSByZWN1cnNpdmUgZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgLSBkcm9wcGluZyB0aGlzIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Q2FsbERlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBhbiBldmVudCBvbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBiZSBjYWxsZWQgd2l0aCB0aGlzIGNvbXBvbmVudCBhcyBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgZmlyZWQgb24gdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBIYW5kbGUgdG8gdGhlIHN1YnNjcmlwdGlvbiwgd2hpY2ggbWF5IGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgd2l0aCB7QGxpbmsgI29mZn0uXG4gICAgICovXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZE1hcCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRNYXAgPSBuZXcgTWFwKCk7IC8vIFN1YnNjcmlwdGlvbiBzdWJJZCBwb29sXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50U3Vicykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudFN1YnNOdW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFzdWJzKSB7XG4gICAgICAgICAgICBzdWJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9ldmVudFN1YnNbZXZlbnRdID0gc3VicztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRNYXAuYWRkSXRlbSgpOyAvLyBDcmVhdGUgdW5pcXVlIHN1YklkXG4gICAgICAgIHN1YnNbc3ViSWRdID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlIHx8IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgLy8gQSBwdWJsaWNhdGlvbiBleGlzdHMsIG5vdGlmeSBjYWxsYmFjayBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSB8fCB0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uIHRoYXQgd2FzIHByZXZpb3VzbHkgbWFkZSB3aXRoIHtAbGluayBDb21wb25lbnQjb259IG9yIHtAbGluayBDb21wb25lbnQjb25jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViSWQgU3Vic2NyaXB0aW9uIElEXG4gICAgICovXG4gICAgb2ZmKHN1YklkKSB7XG4gICAgICAgIGlmIChzdWJJZCA9PT0gdW5kZWZpbmVkIHx8IHN1YklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdWJJZEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fc3ViSWRFdmVudHNbc3ViSWRdO1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZEV2ZW50c1tzdWJJZF07XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5fZXZlbnRTdWJzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNbc3ViSWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50U3Vic051bVtldmVudF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YklkTWFwLnJlbW92ZUl0ZW0oc3ViSWQpOyAvLyBSZWxlYXNlIHN1YklkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGV2ZW50LCB0aGVuIHVuLXN1YnNjcmliZXMgYXMgc29vbiBhcyB0aGUgZXZlbnQgaXMgc3ViSWRkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvbn0sIGFuZCB0aGVuIGNhbGxpbmcge0BsaW5rIENvbXBvbmVudCNvZmZ9IGluc2lkZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRGF0YSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBmcmVzaCBkYXRhIGlzIGF2YWlsYWJsZSBhdCB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlPXRoaXNdIFNjb3BlIGZvciB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvbmNlKGV2ZW50LCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5vbihldmVudCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub2ZmKHN1YklkKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlIHx8IHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY29wZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgc3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIGV2ZW50IG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIGFueSBzdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gZXZlbnQgb24gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgaGFzU3VicyhldmVudCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2V2ZW50U3Vic051bSAmJiAodGhpcy5fZXZlbnRTdWJzTnVtW2V2ZW50XSA+IDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgY29uc29sZSBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbTE9HXSBbPGNvbXBvbmVudCB0eXBlPiA8Y29tcG9uZW50IGlkPjogPG1lc3NhZ2U+YGBgYCpcbiAgICAgKlxuICAgICAqIEFsc28gZmlyZXMgdGhlIG1lc3NhZ2UgYXMgYSBcImxvZ1wiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIltMT0ddXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcImxvZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBfbWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBcIiBbXCIgKyB0aGlzLnR5cGUgKyBcIiBcIiArIHV0aWxzLmluUXVvdGVzKHRoaXMuaWQpICsgXCJdOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIHdhcm5pbmcgZm9yIHRoaXMgY29tcG9uZW50IHRvIHRoZSBKYXZhU2NyaXB0IGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29uc29sZSBtZXNzYWdlIHdpbGwgaGF2ZSB0aGlzIGZvcm1hdDogKmBgYGBbV0FSTl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhIFwid2FyblwiIGV2ZW50IG9uIHRoZSBwYXJlbnQge0BsaW5rIFNjZW5lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZ1xuICAgICAqL1xuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbV0FSTl1cIiArIHRoaXMuX21lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuZmlyZShcIndhcm5cIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhbiBlcnJvciBmb3IgdGhpcyBjb21wb25lbnQgdG8gdGhlIEphdmFTY3JpcHQgY29uc29sZS5cbiAgICAgKlxuICAgICAqIFRoZSBjb25zb2xlIG1lc3NhZ2Ugd2lsbCBoYXZlIHRoaXMgZm9ybWF0OiAqYGBgYFtFUlJPUl0gWzxjb21wb25lbnQgdHlwZT4gPTxjb21wb25lbnQgaWQ+OiA8bWVzc2FnZT5gYGBgKlxuICAgICAqXG4gICAgICogQWxzbyBmaXJlcyB0aGUgbWVzc2FnZSBhcyBhbiBcImVycm9yXCIgZXZlbnQgb24gdGhlIHBhcmVudCB7QGxpbmsgU2NlbmV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gXCJbRVJST1JdXCIgKyB0aGlzLl9tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zY2VuZS5maXJlKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGlzLlxuICAgICAqXG4gICAgICogV2hlbiBjb21wb25lbnQgbm90IGdpdmVuLCBhdHRhY2hlcyB0aGUgc2NlbmUncyBkZWZhdWx0IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbmFtZSAoaWYgYW55KS5cbiAgICAgKiBQdWJsaXNoZXMgdGhlIG5ldyBjaGlsZCBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnQsIGtleWVkIHRvIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gW3BhcmFtcy5jb21wb25lbnRdIFRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy50eXBlXSBPcHRpb25hbCBleHBlY3RlZCB0eXBlIG9mIGJhc2UgdHlwZSBvZiB0aGUgY2hpbGQ7IHdoZW4gc3VwcGxpZWQsIHdpbGxcbiAgICAgKiBjYXVzZSBhbiBleGNlcHRpb24gaWYgdGhlIGdpdmVuIGNoaWxkIGlzIG5vdCB0aGUgc2FtZSB0eXBlIG9yIGEgc3VidHlwZSBvZiB0aGlzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5zY2VuZURlZmF1bHQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnNjZW5lU2luZ2xldG9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZF0gT3B0aW9uYWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gY29tcG9uZW50IGF0dGFjaGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkF0dGFjaGVkLmNhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbXMub25BdHRhY2hlZC5zY29wZV0gT3B0aW9uYWwgc2NvcGUgZm9yIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkXSBPcHRpb25hbCBjYWxsYmFjayBjYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgZGV0YWNoZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyYW1zLm9uRGV0YWNoZWQuY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmFtcy5vbkRldGFjaGVkLnNjb3BlXSBPcHRpb25hbCBzY29wZSBmb3IgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3tTdHJpbmc6RnVuY3Rpb259fSBbcGFyYW1zLm9uXSBDYWxsYmFja3MgdG8gc3Vic2NyaWJlIHRvIHByb3BlcnRpZXMgb24gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnJlY29tcGlsZXM9dHJ1ZV0gV2hlbiB0cnVlLCBmaXJlcyBcImRpcnR5XCIgZXZlbnRzIG9uIHRoaXMgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoKHBhcmFtcykge1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcblxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgJ25hbWUnIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHBhcmFtcy5jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IHNjZW5lRGVmYXVsdCA9IHBhcmFtcy5zY2VuZURlZmF1bHQ7XG4gICAgICAgIGNvbnN0IHNjZW5lU2luZ2xldG9uID0gcGFyYW1zLnNjZW5lU2luZ2xldG9uO1xuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGNvbnN0IG9uID0gcGFyYW1zLm9uO1xuICAgICAgICBjb25zdCByZWNvbXBpbGVzID0gcGFyYW1zLnJlY29tcGlsZXMgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vIFRydWUgd2hlbiBjaGlsZCBnaXZlbiBhcyBjb25maWcgb2JqZWN0LCB3aGVyZSBwYXJlbnQgbWFuYWdlcyBpdHMgaW5zdGFudGlhdGlvbiBhbmQgZGVzdHJ1Y3Rpb25cbiAgICAgICAgbGV0IG1hbmFnaW5nTGlmZWN5Y2xlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1lcmljKGNvbXBvbmVudCkgfHwgdXRpbHMuaXNTdHJpbmcoY29tcG9uZW50KSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50IElEIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gQm90aCBudW1lcmljIGFuZCBzdHJpbmcgSURzIGFyZSBzdXBwb3J0ZWRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5zY2VuZS5jb21wb25lbnRzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUXVvdGUgc3RyaW5nIElEcyBpbiBlcnJvcnNcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29tcG9uZW50IG5vdCBmb3VuZDogXCIgKyB1dGlscy5pblF1b3RlcyhpZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKHNjZW5lU2luZ2xldG9uID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCB0eXBlIHdlIGZpbmRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuc2NlbmUudHlwZXNbdHlwZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZDIgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGluc3RhbmNlc1tpZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiU2NlbmUgaGFzIG5vIGRlZmF1bHQgY29tcG9uZW50IGZvciAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmVEZWZhdWx0ID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBhIGRlZmF1bHQgc2NlbmUgY29tcG9uZW50XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlNjZW5lIGhhcyBubyBkZWZhdWx0IGNvbXBvbmVudCBmb3IgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIk5vdCBpbiBzYW1lIHNjZW5lOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5pc1R5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgXCIgKyB0eXBlICsgXCIgdHlwZSBvciBzdWJ0eXBlOiBcIiArIGNvbXBvbmVudC50eXBlICsgXCIgXCIgKyB1dGlscy5pblF1b3Rlcyhjb21wb25lbnQuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRDb21wb25lbnQgPSB0aGlzLl9hdHRhY2hlZFtuYW1lXTtcbiAgICAgICAgbGV0IHN1YnM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmIChvbGRDb21wb25lbnQpIHtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBvbGRDb21wb25lbnQuaWQgPT09IGNvbXBvbmVudC5pZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGF0dGVtcHQgdG8gcmVhdHRhY2ggc2FtZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dGFjaG1lbnQgPSB0aGlzLl9hdHRhY2htZW50c1tvbGRDb21wb25lbnQuaWRdO1xuXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIGV2ZW50cyBvbiBvbGQgY29tcG9uZW50XG5cbiAgICAgICAgICAgIHN1YnMgPSBvbGRBdHRhY2htZW50LnN1YnM7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN1YnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQub2ZmKHN1YnNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNoZWRbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXR0YWNobWVudHNbb2xkQ29tcG9uZW50LmlkXTtcblxuICAgICAgICAgICAgY29uc3Qgb25EZXRhY2hlZCA9IG9sZEF0dGFjaG1lbnQucGFyYW1zLm9uRGV0YWNoZWQ7XG4gICAgICAgICAgICBpZiAob25EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9uRGV0YWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGV0YWNoZWQob2xkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbkRldGFjaGVkLnNjb3BlID8gb25EZXRhY2hlZC5jYWxsYmFjay5jYWxsKG9uRGV0YWNoZWQuc2NvcGUsIG9sZENvbXBvbmVudCkgOiBvbkRldGFjaGVkLmNhbGxiYWNrKG9sZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2xkQXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGp1c3QgdW5zdWJzY3JpYmVkIGZyb20gYWxsIGV2ZW50cyBmaXJlZCBieSB0aGUgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQsIHNvIGRlc3Ryb3lpbmcgaXQgd29uJ3QgZmlyZSBldmVudHMgYmFjayBhdCB1cyBub3cuXG5cbiAgICAgICAgICAgICAgICBvbGRDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICAvLyBTZXQgYW5kIHB1Ymxpc2ggdGhlIG5ldyBjb21wb25lbnQgb24gdGhpcyBjb21wb25lbnRcblxuICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdWJzOiBbXSxcbiAgICAgICAgICAgICAgICBtYW5hZ2luZ0xpZmVjeWNsZTogbWFuYWdpbmdMaWZlY3ljbGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbmNlKFwiZGVzdHJveWVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucGFyYW1zLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2goYXR0YWNobWVudC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzKSk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvbXBpbGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5zdWJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbihcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFtuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzW2NvbXBvbmVudC5pZF0gPSBhdHRhY2htZW50O1xuXG4gICAgICAgICAgICAvLyBCaW5kIGRlc3RydWN0IGxpc3RlbmVyIHRvIG5ldyBjb21wb25lbnQgdG8gcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBmcm9tIHRoaXMgY29tcG9uZW50IHdoZW4gZGVzdHJveWVkXG5cbiAgICAgICAgICAgIGNvbnN0IG9uQXR0YWNoZWQgPSBwYXJhbXMub25BdHRhY2hlZDtcbiAgICAgICAgICAgIGlmIChvbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob25BdHRhY2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25BdHRhY2hlZChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQXR0YWNoZWQuc2NvcGUgPyBvbkF0dGFjaGVkLmNhbGxiYWNrLmNhbGwob25BdHRhY2hlZC5zY29wZSwgY29tcG9uZW50KSA6IG9uQXR0YWNoZWQuY2FsbGJhY2soY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCBzdWJJZHI7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGxldCBzY29wZTtcblxuICAgICAgICAgICAgICAgIGZvciAoZXZlbnQgaW4gb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJJZHIgPSBvbltldmVudF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHN1YklkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHN1YklkcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc3ViSWRyLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc3ViSWRyLnNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuc3Vicy5wdXNoKGNvbXBvbmVudC5vbihldmVudCwgY2FsbGJhY2ssIHNjb3BlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb21waWxlcykge1xuICAgICAgICAgICAgdGhpcy5maXJlKFwiZGlydHlcIiwgdGhpcyk7IC8vIEZJWE1FOiBNYXkgdHJpZ2dlciBzcHVyb3VzIG1lc2ggcmVjb21waWxhdGlvbnMgdW5sZXNzIGFibGUgdG8gbGltaXQgd2l0aCBwYXJhbT9cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZShuYW1lLCBjb21wb25lbnQpOyAvLyBDb21wb25lbnQgY2FuIGJlIG51bGxcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIF9jaGVja0NvbXBvbmVudChleHBlY3RlZFR5cGUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzSUQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuc2NlbmUuY29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbXBvbmVudCBub3QgZm91bmQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBDb21wb25lbnQgb3IgSURcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGNvbXBvbmVudC50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYSBcIiArIGV4cGVjdGVkVHlwZSArIFwiIENvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgX2NoZWNrQ29tcG9uZW50MihleHBlY3RlZFR5cGVzLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0lEKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLnNjZW5lLmNvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb21wb25lbnQgbm90IGZvdW5kOiBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgQ29tcG9uZW50IG9yIElEXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50LnNjZW5lLmlkICE9PSB0aGlzLnNjZW5lLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTm90IGluIHNhbWUgc2NlbmU6IFwiICsgY29tcG9uZW50LnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlc1tpXSA9PT0gY29tcG9uZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBjb21wb25lbnQgdHlwZXM6IFwiICsgZXhwZWN0ZWRUeXBlcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9vd24oY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX293bmVkQ29tcG9uZW50c1tjb21wb25lbnQuaWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lZENvbXBvbmVudHNbY29tcG9uZW50LmlkXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnQub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2NvbXBvbmVudC5pZF07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3RlY3RlZCBtZXRob2QsIGNhbGxlZCBieSBzdWItY2xhc3NlcyB0byBxdWV1ZSBhIGNhbGwgdG8gX3VwZGF0ZSgpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5PTFdXG4gICAgICovXG4gICAgX25lZWRVcGRhdGUocHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1VwZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3JlLnNjaGVkdWxlVGFzayh0aGlzLl9kb1VwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kb1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm90ZWN0ZWQgdmlydHVhbCB0ZW1wbGF0ZSBtZXRob2QsIG9wdGlvbmFsbHkgaW1wbGVtZW50ZWRcbiAgICAgKiBieSBzdWItY2xhc3NlcyB0byBwZXJmb3JtIGEgc2NoZWR1bGVkIHRhc2suXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbGwge0BsaW5rIENvbXBvbmVudH1zIHRoYXQgYXJlIG93bmVkIGJ5IHRoaXMuIFRoZXNlIGFyZSBDb21wb25lbnRzIHRoYXQgd2VyZSBpbnN0YW50aWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgQ29tcG9uZW50IGFzIHRoZWlyIGZpcnN0IGNvbnN0cnVjdG9yIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZWRDb21wb25lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9vd25lZENvbXBvbmVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBDb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBAZXZlbnQgZGVzdHJveWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoXCJkZXN0cm95ZWRcIiwgdGhpcy5kZXN0cm95ZWQgPSB0cnVlKTsgLy8gTXVzdCBmaXJlIGJlZm9yZSB3ZSBibG93IGF3YXkgc3Vic2NyaXB0aW9uIG1hcHMsIGJlbG93XG5cbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBjaGlsZCBjb21wb25lbnRzIGFuZCBkZXN0cm95IHRoZW5cblxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGxldCBhdHRhY2htZW50O1xuICAgICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgICBsZXQgc3VicztcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5fYXR0YWNobWVudHNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBhdHRhY2htZW50LmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgc3VicyA9IGF0dGFjaG1lbnQuc3VicztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm9mZihzdWJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5tYW5hZ2luZ0xpZmVjeWNsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vd25lZENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoaWQgaW4gdGhpcy5fb3duZWRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVkQ29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5fb3duZWRDb21wb25lbnRzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX293bmVkQ29tcG9uZW50c1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS5fcmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xuXG4gICAgICAgIC8vIE1lbW9yeSBsZWFrIGF2b2lkYW5jZVxuICAgICAgICB0aGlzLl9hdHRhY2hlZCA9IHt9O1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YklkTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3ViSWRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ldmVudENhbGxEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX293bmVkQ29tcG9uZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHtDb21wb25lbnR9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js":
/*!******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js ***!
  \******************************************************************/
/*! exports provided: core */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony import */ var _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/Queue.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\");\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\");\n\n\n\n\n\nconst scenesRenderInfo = {}; // Used for throttling FPS for each Scene\nconst sceneIDMap = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_1__[\"Map\"](); // Ensures unique scene IDs\nconst taskQueue = new _utils_Queue_js__WEBPACK_IMPORTED_MODULE_0__[\"Queue\"](); // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule\nconst tickEvent = {sceneId: null, time: null, startTime: null, prevTime: null, deltaTime: null};\nconst taskBudget = 10; // Millisecs we're allowed to spend on tasks in each frame\nconst fpsSamples = [];\nconst numFPSSamples = 30;\n\nlet defaultScene = null;// Default singleton Scene, lazy-initialized in getter\nlet lastTime = 0;\nlet elapsedTime;\nlet totalFPS = 0;\n\n/**\n * @private\n */\nfunction Core() {\n\n    /**\n     Semantic version number. The value for this is set by an expression that's concatenated to\n     the end of the built binary by the xeokit build script.\n     @property version\n     @namespace xeokit\n     @type {String}\n     */\n    this.version = \"1.0.0\";\n\n    /**\n     Existing {@link Scene}s , mapped to their IDs\n     @property scenes\n     @namespace xeokit\n     @type {{Scene}}\n     */\n    this.scenes = {};\n\n    this._superTypes = {}; // For each component type, a list of its supertypes, ordered upwards in the hierarchy.\n\n    /**\n     * Registers a scene on xeokit.\n     * This is called within the xeokit.Scene constructor.\n     * @private\n     */\n    this._addScene = function (scene) {\n        if (scene.id) { // User-supplied ID\n            if (core.scenes[scene.id]) {\n                console.error(`[ERROR] Scene ${_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"utils\"].inQuotes(scene.id)} already exists`);\n                return;\n            }\n        } else { // Auto-generated ID\n            scene.id = sceneIDMap.addItem({});\n        }\n        core.scenes[scene.id] = scene;\n        const ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n        const ticksPerRender = scene.ticksPerRender;\n        scenesRenderInfo[scene.id] = {\n            ticksPerOcclusionTest: ticksPerOcclusionTest,\n            ticksPerRender: ticksPerRender,\n            renderCountdown: ticksPerRender\n        };\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes++;\n        scene.once(\"destroyed\", () => { // Unregister destroyed scenes\n            sceneIDMap.removeItem(scene.id);\n            delete core.scenes[scene.id];\n            delete scenesRenderInfo[scene.id];\n            _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].components.scenes--;\n        });\n    };\n\n    /**\n     * @private\n     */\n    this.clear = function () {\n        let scene;\n        for (const id in core.scenes) {\n            if (core.scenes.hasOwnProperty(id)) {\n                scene = core.scenes[id];\n                // Only clear the default Scene\n                // but destroy all the others\n                if (id === \"default.scene\") {\n                    scene.clear();\n                } else {\n                    scene.destroy();\n                    delete core.scenes[scene.id];\n                }\n            }\n        }\n    };\n\n    /**\n     * Schedule a task to run at the next frame.\n     *\n     * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeokit processes the queue\n     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not\n     * get a chance to run during the task are left in the queue to be run next time.\n     *\n     * @param {Function} callback Callback that runs the task.\n     * @param {Object} [scope] Scope for the callback.\n     */\n    this.scheduleTask = function (callback, scope) {\n        taskQueue.push(callback);\n        taskQueue.push(scope);\n    };\n\n    this.runTasks = function (until = -1) { // Pops and processes tasks in the queue, until the given number of milliseconds has elapsed.\n        let time = (new Date()).getTime();\n        let callback;\n        let scope;\n        let tasksRun = 0;\n        while (taskQueue.length > 0 && (until < 0 || time < until)) {\n            callback = taskQueue.shift();\n            scope = taskQueue.shift();\n            if (scope) {\n                callback.call(scope);\n            } else {\n                callback();\n            }\n            time = (new Date()).getTime();\n            tasksRun++;\n        }\n        return tasksRun;\n    };\n\n    this.getNumTasks = function () {\n        return taskQueue.length;\n    };\n}\n\n/**\n * @private\n * @type {Core}\n */\nconst core = new Core();\n\n\nconst frame = function () {\n    let time = Date.now();\n    if (lastTime > 0) { // Log FPS stats\n        elapsedTime = time - lastTime;\n        var newFPS = 1000 / elapsedTime; // Moving average of FPS\n        totalFPS += newFPS;\n        fpsSamples.push(newFPS);\n        if (fpsSamples.length >= numFPSSamples) {\n            totalFPS -= fpsSamples.shift();\n        }\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.fps = Math.round(totalFPS / fpsSamples.length);\n    }\n    runTasks(time);\n    fireTickEvents(time);\n    renderScenes();\n    lastTime = time;\n    window.requestAnimationFrame(frame);\n};\n\nfunction runTasks(time) { // Process as many enqueued tasks as we can within the per-frame task budget\n    const tasksRun = core.runTasks(time + taskBudget);\n    const tasksScheduled = core.getNumTasks();\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksRun = tasksRun;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksScheduled = tasksScheduled;\n    _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].frame.tasksBudget = taskBudget;\n}\n\nfunction fireTickEvents(time) { // Fire tick event on each Scene\n    tickEvent.time = time;\n    for (var id in core.scenes) {\n        if (core.scenes.hasOwnProperty(id)) {\n            var scene = core.scenes[id];\n            tickEvent.sceneId = id;\n            tickEvent.startTime = scene.startTime;\n            tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;\n            /**\n             * Fired on each game loop iteration.\n             *\n             * @event tick\n             * @param {String} sceneID The ID of this Scene.\n             * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.\n             * @param {Number} time The time in seconds since 1970 of this \"tick\" event.\n             * @param {Number} prevTime The time of the previous \"tick\" event from this Scene.\n             * @param {Number} deltaTime The time in seconds since the previous \"tick\" event from this Scene.\n             */\n            scene.fire(\"tick\", tickEvent, true);\n        }\n    }\n    tickEvent.prevTime = time;\n}\n\nfunction renderScenes() {\n    const scenes = core.scenes;\n    const forceRender = false;\n    let scene;\n    let renderInfo;\n    let ticksPerOcclusionTest;\n    let ticksPerRender;\n    let id;\n    for (id in scenes) {\n        if (scenes.hasOwnProperty(id)) {\n\n            scene = scenes[id];\n            renderInfo = scenesRenderInfo[id];\n\n            if (!renderInfo) {\n                renderInfo = scenesRenderInfo[id] = {}; // FIXME\n            }\n\n            ticksPerOcclusionTest = scene.ticksPerOcclusionTest;\n            if (renderInfo.ticksPerOcclusionTest !== ticksPerOcclusionTest) {\n                renderInfo.ticksPerOcclusionTest = ticksPerOcclusionTest;\n                renderInfo.renderCountdown = ticksPerOcclusionTest;\n            }\n            if (--scene.occlusionTestCountdown <= 0) {\n                scene.doOcclusionTest();\n                scene.occlusionTestCountdown = ticksPerOcclusionTest;\n            }\n\n            ticksPerRender = scene.ticksPerRender;\n            if (renderInfo.ticksPerRender !== ticksPerRender) {\n                renderInfo.ticksPerRender = ticksPerRender;\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n            if (--renderInfo.renderCountdown === 0) {\n                scene.render(forceRender);\n                renderInfo.renderCountdown = ticksPerRender;\n            }\n        }\n    }\n}\n\nwindow.requestAnimationFrame(frame);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL2NvcmUuanM/MzFjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDSjtBQUNGO0FBQ0E7O0FBRWpDLDRCQUE0QjtBQUM1Qix1QkFBdUIsaURBQUcsR0FBRztBQUM3QixzQkFBc0IscURBQUssR0FBRyw4Q0FBOEM7QUFDNUUsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLCtDQUErQywrQ0FBSyxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFLO0FBQ2pCLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLCtDQUFLO0FBQ1QsSUFBSSwrQ0FBSztBQUNULElBQUksK0NBQUs7QUFDVDs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UXVldWV9IGZyb20gJy4vdXRpbHMvUXVldWUuanMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4vdXRpbHMvTWFwLmpzJztcbmltcG9ydCB7c3RhdHN9IGZyb20gJy4vc3RhdHMuanMnO1xuaW1wb3J0IHt1dGlsc30gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHNjZW5lc1JlbmRlckluZm8gPSB7fTsgLy8gVXNlZCBmb3IgdGhyb3R0bGluZyBGUFMgZm9yIGVhY2ggU2NlbmVcbmNvbnN0IHNjZW5lSURNYXAgPSBuZXcgTWFwKCk7IC8vIEVuc3VyZXMgdW5pcXVlIHNjZW5lIElEc1xuY29uc3QgdGFza1F1ZXVlID0gbmV3IFF1ZXVlKCk7IC8vIFRhc2sgcXVldWUsIHdoaWNoIGlzIHB1bXBlZCBvbiBlYWNoIGZyYW1lOyB0YXNrcyBhcmUgcHVzaGVkIHRvIGl0IHdpdGggY2FsbHMgdG8geGVva2l0LnNjaGVkdWxlXG5jb25zdCB0aWNrRXZlbnQgPSB7c2NlbmVJZDogbnVsbCwgdGltZTogbnVsbCwgc3RhcnRUaW1lOiBudWxsLCBwcmV2VGltZTogbnVsbCwgZGVsdGFUaW1lOiBudWxsfTtcbmNvbnN0IHRhc2tCdWRnZXQgPSAxMDsgLy8gTWlsbGlzZWNzIHdlJ3JlIGFsbG93ZWQgdG8gc3BlbmQgb24gdGFza3MgaW4gZWFjaCBmcmFtZVxuY29uc3QgZnBzU2FtcGxlcyA9IFtdO1xuY29uc3QgbnVtRlBTU2FtcGxlcyA9IDMwO1xuXG5sZXQgZGVmYXVsdFNjZW5lID0gbnVsbDsvLyBEZWZhdWx0IHNpbmdsZXRvbiBTY2VuZSwgbGF6eS1pbml0aWFsaXplZCBpbiBnZXR0ZXJcbmxldCBsYXN0VGltZSA9IDA7XG5sZXQgZWxhcHNlZFRpbWU7XG5sZXQgdG90YWxGUFMgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG5cbiAgICAvKipcbiAgICAgU2VtYW50aWMgdmVyc2lvbiBudW1iZXIuIFRoZSB2YWx1ZSBmb3IgdGhpcyBpcyBzZXQgYnkgYW4gZXhwcmVzc2lvbiB0aGF0J3MgY29uY2F0ZW5hdGVkIHRvXG4gICAgIHRoZSBlbmQgb2YgdGhlIGJ1aWx0IGJpbmFyeSBieSB0aGUgeGVva2l0IGJ1aWxkIHNjcmlwdC5cbiAgICAgQHByb3BlcnR5IHZlcnNpb25cbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSBcIjEuMC4wXCI7XG5cbiAgICAvKipcbiAgICAgRXhpc3Rpbmcge0BsaW5rIFNjZW5lfXMgLCBtYXBwZWQgdG8gdGhlaXIgSURzXG4gICAgIEBwcm9wZXJ0eSBzY2VuZXNcbiAgICAgQG5hbWVzcGFjZSB4ZW9raXRcbiAgICAgQHR5cGUge3tTY2VuZX19XG4gICAgICovXG4gICAgdGhpcy5zY2VuZXMgPSB7fTtcblxuICAgIHRoaXMuX3N1cGVyVHlwZXMgPSB7fTsgLy8gRm9yIGVhY2ggY29tcG9uZW50IHR5cGUsIGEgbGlzdCBvZiBpdHMgc3VwZXJ0eXBlcywgb3JkZXJlZCB1cHdhcmRzIGluIHRoZSBoaWVyYXJjaHkuXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzY2VuZSBvbiB4ZW9raXQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2l0aGluIHRoZSB4ZW9raXQuU2NlbmUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hZGRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgICBpZiAoc2NlbmUuaWQpIHsgLy8gVXNlci1zdXBwbGllZCBJRFxuICAgICAgICAgICAgaWYgKGNvcmUuc2NlbmVzW3NjZW5lLmlkXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFUlJPUl0gU2NlbmUgJHt1dGlscy5pblF1b3RlcyhzY2VuZS5pZCl9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBdXRvLWdlbmVyYXRlZCBJRFxuICAgICAgICAgICAgc2NlbmUuaWQgPSBzY2VuZUlETWFwLmFkZEl0ZW0oe30pO1xuICAgICAgICB9XG4gICAgICAgIGNvcmUuc2NlbmVzW3NjZW5lLmlkXSA9IHNjZW5lO1xuICAgICAgICBjb25zdCB0aWNrc1Blck9jY2x1c2lvblRlc3QgPSBzY2VuZS50aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgIGNvbnN0IHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdID0ge1xuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0OiB0aWNrc1Blck9jY2x1c2lvblRlc3QsXG4gICAgICAgICAgICB0aWNrc1BlclJlbmRlcjogdGlja3NQZXJSZW5kZXIsXG4gICAgICAgICAgICByZW5kZXJDb3VudGRvd246IHRpY2tzUGVyUmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRzLmNvbXBvbmVudHMuc2NlbmVzKys7XG4gICAgICAgIHNjZW5lLm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4geyAvLyBVbnJlZ2lzdGVyIGRlc3Ryb3llZCBzY2VuZXNcbiAgICAgICAgICAgIHNjZW5lSURNYXAucmVtb3ZlSXRlbShzY2VuZS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgY29yZS5zY2VuZXNbc2NlbmUuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHNjZW5lc1JlbmRlckluZm9bc2NlbmUuaWRdO1xuICAgICAgICAgICAgc3RhdHMuY29tcG9uZW50cy5zY2VuZXMtLTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIGNvcmUuc2NlbmVzKSB7XG4gICAgICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICAgICAgLy8gT25seSBjbGVhciB0aGUgZGVmYXVsdCBTY2VuZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBkZXN0cm95IGFsbCB0aGUgb3RoZXJzXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBcImRlZmF1bHQuc2NlbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBzY2VuZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvcmUuc2NlbmVzW3NjZW5lLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSB0YXNrIHRvIHJ1biBhdCB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoaXMgcHVzaGVzIHRoZSB0YXNrIHRvIGEgRklGTyBxdWV1ZS4gV2l0aGluIGVhY2ggZnJhbWUgaW50ZXJ2YWwsIHhlb2tpdCBwcm9jZXNzZXMgdGhlIHF1ZXVlXG4gICAgICogZm9yIGEgY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgcG9wcGluZyB0YXNrcyBhbmQgcnVubmluZyB0aGVtLiBBZnRlciBlYWNoIGZyYW1lIGludGVydmFsLCB0YXNrcyB0aGF0IGRpZCBub3RcbiAgICAgKiBnZXQgYSBjaGFuY2UgdG8gcnVuIGR1cmluZyB0aGUgdGFzayBhcmUgbGVmdCBpbiB0aGUgcXVldWUgdG8gYmUgcnVuIG5leHQgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgcnVucyB0aGUgdGFzay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBTY29wZSBmb3IgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHRoaXMuc2NoZWR1bGVUYXNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0YXNrUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRhc2tRdWV1ZS5wdXNoKHNjb3BlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5ydW5UYXNrcyA9IGZ1bmN0aW9uICh1bnRpbCA9IC0xKSB7IC8vIFBvcHMgYW5kIHByb2Nlc3NlcyB0YXNrcyBpbiB0aGUgcXVldWUsIHVudGlsIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkLlxuICAgICAgICBsZXQgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgbGV0IHNjb3BlO1xuICAgICAgICBsZXQgdGFza3NSdW4gPSAwO1xuICAgICAgICB3aGlsZSAodGFza1F1ZXVlLmxlbmd0aCA+IDAgJiYgKHVudGlsIDwgMCB8fCB0aW1lIDwgdW50aWwpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2tRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgc2NvcGUgPSB0YXNrUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0YXNrc1J1bisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrc1J1bjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXROdW1UYXNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhc2tRdWV1ZS5sZW5ndGg7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0NvcmV9XG4gKi9cbmNvbnN0IGNvcmUgPSBuZXcgQ29yZSgpO1xuXG5cbmNvbnN0IGZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobGFzdFRpbWUgPiAwKSB7IC8vIExvZyBGUFMgc3RhdHNcbiAgICAgICAgZWxhcHNlZFRpbWUgPSB0aW1lIC0gbGFzdFRpbWU7XG4gICAgICAgIHZhciBuZXdGUFMgPSAxMDAwIC8gZWxhcHNlZFRpbWU7IC8vIE1vdmluZyBhdmVyYWdlIG9mIEZQU1xuICAgICAgICB0b3RhbEZQUyArPSBuZXdGUFM7XG4gICAgICAgIGZwc1NhbXBsZXMucHVzaChuZXdGUFMpO1xuICAgICAgICBpZiAoZnBzU2FtcGxlcy5sZW5ndGggPj0gbnVtRlBTU2FtcGxlcykge1xuICAgICAgICAgICAgdG90YWxGUFMgLT0gZnBzU2FtcGxlcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmZyYW1lLmZwcyA9IE1hdGgucm91bmQodG90YWxGUFMgLyBmcHNTYW1wbGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJ1blRhc2tzKHRpbWUpO1xuICAgIGZpcmVUaWNrRXZlbnRzKHRpbWUpO1xuICAgIHJlbmRlclNjZW5lcygpO1xuICAgIGxhc3RUaW1lID0gdGltZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blRhc2tzKHRpbWUpIHsgLy8gUHJvY2VzcyBhcyBtYW55IGVucXVldWVkIHRhc2tzIGFzIHdlIGNhbiB3aXRoaW4gdGhlIHBlci1mcmFtZSB0YXNrIGJ1ZGdldFxuICAgIGNvbnN0IHRhc2tzUnVuID0gY29yZS5ydW5UYXNrcyh0aW1lICsgdGFza0J1ZGdldCk7XG4gICAgY29uc3QgdGFza3NTY2hlZHVsZWQgPSBjb3JlLmdldE51bVRhc2tzKCk7XG4gICAgc3RhdHMuZnJhbWUudGFza3NSdW4gPSB0YXNrc1J1bjtcbiAgICBzdGF0cy5mcmFtZS50YXNrc1NjaGVkdWxlZCA9IHRhc2tzU2NoZWR1bGVkO1xuICAgIHN0YXRzLmZyYW1lLnRhc2tzQnVkZ2V0ID0gdGFza0J1ZGdldDtcbn1cblxuZnVuY3Rpb24gZmlyZVRpY2tFdmVudHModGltZSkgeyAvLyBGaXJlIHRpY2sgZXZlbnQgb24gZWFjaCBTY2VuZVxuICAgIHRpY2tFdmVudC50aW1lID0gdGltZTtcbiAgICBmb3IgKHZhciBpZCBpbiBjb3JlLnNjZW5lcykge1xuICAgICAgICBpZiAoY29yZS5zY2VuZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB2YXIgc2NlbmUgPSBjb3JlLnNjZW5lc1tpZF07XG4gICAgICAgICAgICB0aWNrRXZlbnQuc2NlbmVJZCA9IGlkO1xuICAgICAgICAgICAgdGlja0V2ZW50LnN0YXJ0VGltZSA9IHNjZW5lLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRpY2tFdmVudC5kZWx0YVRpbWUgPSB0aWNrRXZlbnQucHJldlRpbWUgIT0gbnVsbCA/IHRpY2tFdmVudC50aW1lIC0gdGlja0V2ZW50LnByZXZUaW1lIDogMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlyZWQgb24gZWFjaCBnYW1lIGxvb3AgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBldmVudCB0aWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2NlbmVJRCBUaGUgSUQgb2YgdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIHRoYXQgdGhpcyBTY2VuZSB3YXMgaW5zdGFudGlhdGVkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSAxOTcwIG9mIHRoaXMgXCJ0aWNrXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJldlRpbWUgVGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzIFwidGlja1wiIGV2ZW50IGZyb20gdGhpcyBTY2VuZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWUgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgcHJldmlvdXMgXCJ0aWNrXCIgZXZlbnQgZnJvbSB0aGlzIFNjZW5lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzY2VuZS5maXJlKFwidGlja1wiLCB0aWNrRXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2tFdmVudC5wcmV2VGltZSA9IHRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNjZW5lcygpIHtcbiAgICBjb25zdCBzY2VuZXMgPSBjb3JlLnNjZW5lcztcbiAgICBjb25zdCBmb3JjZVJlbmRlciA9IGZhbHNlO1xuICAgIGxldCBzY2VuZTtcbiAgICBsZXQgcmVuZGVySW5mbztcbiAgICBsZXQgdGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgIGxldCB0aWNrc1BlclJlbmRlcjtcbiAgICBsZXQgaWQ7XG4gICAgZm9yIChpZCBpbiBzY2VuZXMpIHtcbiAgICAgICAgaWYgKHNjZW5lcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblxuICAgICAgICAgICAgc2NlbmUgPSBzY2VuZXNbaWRdO1xuICAgICAgICAgICAgcmVuZGVySW5mbyA9IHNjZW5lc1JlbmRlckluZm9baWRdO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvID0gc2NlbmVzUmVuZGVySW5mb1tpZF0gPSB7fTsgLy8gRklYTUVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlja3NQZXJPY2NsdXNpb25UZXN0ID0gc2NlbmUudGlja3NQZXJPY2NsdXNpb25UZXN0O1xuICAgICAgICAgICAgaWYgKHJlbmRlckluZm8udGlja3NQZXJPY2NsdXNpb25UZXN0ICE9PSB0aWNrc1Blck9jY2x1c2lvblRlc3QpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyT2NjbHVzaW9uVGVzdCA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyT2NjbHVzaW9uVGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPD0gMCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLmRvT2NjbHVzaW9uVGVzdCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lLm9jY2x1c2lvblRlc3RDb3VudGRvd24gPSB0aWNrc1Blck9jY2x1c2lvblRlc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpY2tzUGVyUmVuZGVyID0gc2NlbmUudGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICBpZiAocmVuZGVySW5mby50aWNrc1BlclJlbmRlciAhPT0gdGlja3NQZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnRpY2tzUGVyUmVuZGVyID0gdGlja3NQZXJSZW5kZXI7XG4gICAgICAgICAgICAgICAgcmVuZGVySW5mby5yZW5kZXJDb3VudGRvd24gPSB0aWNrc1BlclJlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLXJlbmRlckluZm8ucmVuZGVyQ291bnRkb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUucmVuZGVyKGZvcmNlUmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXJJbmZvLnJlbmRlckNvdW50ZG93biA9IHRpY2tzUGVyUmVuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcblxuZXhwb3J0IHtjb3JlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/core.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/geometryCompressionUtils.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/geometryCompressionUtils.js ***!
  \*******************************************************************************************/
/*! exports provided: geometryCompressionUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geometryCompressionUtils\", function() { return geometryCompressionUtils; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/**\n * Private geometry compression and decompression utilities.\n */\n\n\n\n/**\n * @private\n * @param array\n * @returns {{min: Float32Array, max: Float32Array}}\n */\nfunction getPositionsBounds(array) {\n    const min = new Float32Array(3);\n    const max = new Float32Array(3);\n    let i, j;\n    for (i = 0; i < 3; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 3) {\n        for (j = 0; j < 3; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n\nconst createPositionsDecodeMatrix = (function () {\n    const translate = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n    const scale = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n    return function (aabb, positionsDecodeMatrix) {\n        positionsDecodeMatrix = positionsDecodeMatrix || _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n        const xmin = aabb[0];\n        const ymin = aabb[1];\n        const zmin = aabb[2];\n        const xwid = aabb[3] - xmin;\n        const ywid = aabb[4] - ymin;\n        const zwid = aabb[5] - zmin;\n        const maxInt = 65535;\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4(translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].translationMat4v(aabb, translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4(scale);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulMat4(translate, scale, positionsDecodeMatrix);\n        return positionsDecodeMatrix;\n    };\n})();\n\n/**\n * @private\n */\nvar compressPositions = (function () { // http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf\n    const translate = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n    const scale = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n    return function (array, min, max) {\n        const quantized = new Uint16Array(array.length);\n        var multiplier = new Float32Array([\n            max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,\n            max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,\n            max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0\n        ]);\n        let i;\n        for (i = 0; i < array.length; i += 3) {\n            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n            quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n        }\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4(translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].translationMat4v(min, translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4(scale);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].scalingMat4v([\n            (max[0] - min[0]) / 65535,\n            (max[1] - min[1]) / 65535,\n            (max[2] - min[2]) / 65535\n        ], scale);\n        const decodeMat = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulMat4(translate, scale, _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4());\n        return {\n            quantized: quantized,\n            decodeMatrix: decodeMat\n        };\n    };\n})();\n\nfunction decompressPosition(position, decodeMatrix, dest) {\n    dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];\n    dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];\n    dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];\n    return dest;\n}\n\nfunction decompressAABB(aabb, decodeMatrix, dest=aabb) {\n    dest[0] = aabb[0] * decodeMatrix[0] + decodeMatrix[12];\n    dest[1] = aabb[1] * decodeMatrix[5] + decodeMatrix[13];\n    dest[2] = aabb[2] * decodeMatrix[10] + decodeMatrix[14];\n    dest[3] = aabb[3] * decodeMatrix[0] + decodeMatrix[12];\n    dest[4] = aabb[4] * decodeMatrix[5] + decodeMatrix[13];\n    dest[5] = aabb[5] * decodeMatrix[10] + decodeMatrix[14];\n    return dest;\n}\n\n/**\n * @private\n */\nfunction decompressPositions(positions, decodeMatrix, dest = new Float32Array(positions.length)) {\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];\n        dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];\n        dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];\n    }\n    return dest;\n}\n\n//--------------- UVs --------------------------------------------------------------------------------------------------\n\n/**\n * @private\n * @param array\n * @returns {{min: Float32Array, max: Float32Array}}\n */\nfunction getUVBounds(array) {\n    const min = new Float32Array(2);\n    const max = new Float32Array(2);\n    let i, j;\n    for (i = 0; i < 2; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 2) {\n        for (j = 0; j < 2; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n\n/**\n * @private\n */\nvar compressUVs = (function () {\n    const translate = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat3();\n    const scale = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat3();\n    return function (array, min, max) {\n        const quantized = new Uint16Array(array.length);\n        const multiplier = new Float32Array([\n            65535 / (max[0] - min[0]),\n            65535 / (max[1] - min[1])\n        ]);\n        let i;\n        for (i = 0; i < array.length; i += 2) {\n            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        }\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat3(translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].translationMat3v(min, translate);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat3(scale);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].scalingMat3v([\n            (max[0] - min[0]) / 65535,\n            (max[1] - min[1]) / 65535\n        ], scale);\n        const decodeMat = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulMat3(translate, scale, _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat3());\n        return {\n            quantized: quantized,\n            decodeMatrix: decodeMat\n        };\n    };\n})();\n\n\n//--------------- Normals ----------------------------------------------------------------------------------------------\n\n/**\n * @private\n */\nfunction compressNormals(array) { // http://jcgt.org/published/0003/02/01/\n\n    // Note: three elements for each encoded normal, in which the last element in each triplet is redundant.\n    // This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/\n\n    const encoded = new Int8Array(array.length);\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < array.length; i += 3) {\n        // Test various combinations of ceil and floor\n        // to minimize rounding errors\n        best = oct = octEncodeVec3(array, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(array, i, dec);\n        oct = octEncodeVec3(array, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(array, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(array, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        encoded[i] = best[0];\n        encoded[i + 1] = best[1];\n    }\n    return encoded;\n}\n\n/**\n * @private\n */\nfunction octEncodeVec3(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    return new Int8Array([\n        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),\n        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))\n    ]);\n}\n\n/**\n * Decode an oct-encoded normal\n */\nfunction octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    x /= x < 0 ? 127 : 128;\n    y /= y < 0 ? 127 : 128;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [\n        x / length,\n        y / length,\n        z / length\n    ];\n}\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n * @private\n */\nfunction dot(array, i, vec3) {\n    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];\n}\n\n/**\n * @private\n */\nfunction decompressUV(uv, decodeMatrix, dest) {\n    dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];\n    dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];\n}\n\n/**\n * @private\n */\nfunction decompressUVs(uvs, decodeMatrix, dest = new Float32Array(uvs.length)) {\n    for (let i = 0, len = uvs.length; i < len; i += 3) {\n        dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];\n        dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];\n    }\n    return dest;\n}\n\n/**\n * @private\n */\nfunction decompressNormal(oct, result) {\n    let x = oct[0];\n    let y = oct[1];\n    x = (2 * x + 1) / 255;\n    y = (2 * y + 1) / 255;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    result[0] = x / length;\n    result[1] = y / length;\n    result[2] = z / length;\n    return result;\n}\n\n/**\n * @private\n */\nfunction decompressNormals(octs, result) {\n    for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n        let x = octs[i + 0];\n        let y = octs[i + 1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[j + 0] = x / length;\n        result[j + 1] = y / length;\n        result[j + 2] = z / length;\n        j += 3;\n    }\n    return result;\n}\n\n/**\n * @private\n */\nconst geometryCompressionUtils = {\n\n    getPositionsBounds: getPositionsBounds,\n    createPositionsDecodeMatrix: createPositionsDecodeMatrix,\n    compressPositions: compressPositions,\n    decompressPositions: decompressPositions,\n    decompressPosition: decompressPosition,\n    decompressAABB: decompressAABB,\n\n    getUVBounds: getUVBounds,\n    compressUVs: compressUVs,\n    decompressUVs: decompressUVs,\n    decompressUV: decompressUV,\n\n    compressNormals: compressNormals,\n    decompressNormals: decompressNormals,\n    decompressNormal: decompressNormal\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvZ2VvbWV0cnlDb21wcmVzc2lvblV0aWxzLmpzPzhkMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUUrQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDZDQUFJO0FBQzFCLGtCQUFrQiw2Q0FBSTtBQUN0QjtBQUNBLHlEQUF5RCw2Q0FBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1osUUFBUSw2Q0FBSTtBQUNaLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNCQUFzQiw2Q0FBSTtBQUMxQixrQkFBa0IsNkNBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFJO0FBQ1osUUFBUSw2Q0FBSTtBQUNaLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQUksMkJBQTJCLDZDQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFJO0FBQzFCLGtCQUFrQiw2Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBSTtBQUNaLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1osUUFBUSw2Q0FBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBSSwyQkFBMkIsNkNBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tYXRoL2dlb21ldHJ5Q29tcHJlc3Npb25VdGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJpdmF0ZSBnZW9tZXRyeSBjb21wcmVzc2lvbiBhbmQgZGVjb21wcmVzc2lvbiB1dGlsaXRpZXMuXG4gKi9cblxuaW1wb3J0IHttYXRofSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybnMge3ttaW46IEZsb2F0MzJBcnJheSwgbWF4OiBGbG9hdDMyQXJyYXl9fVxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbnNCb3VuZHMoYXJyYXkpIHtcbiAgICBjb25zdCBtaW4gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIGNvbnN0IG1heCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBtaW5baV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBtYXhbaV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgIG1pbltqXSA9IE1hdGgubWluKG1pbltqXSwgYXJyYXlbaSArIGpdKTtcbiAgICAgICAgICAgIG1heFtqXSA9IE1hdGgubWF4KG1heFtqXSwgYXJyYXlbaSArIGpdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1hdGgubWF0NCgpO1xuICAgIGNvbnN0IHNjYWxlID0gbWF0aC5tYXQ0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhYWJiLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgcG9zaXRpb25zRGVjb2RlTWF0cml4ID0gcG9zaXRpb25zRGVjb2RlTWF0cml4IHx8IG1hdGgubWF0NCgpO1xuICAgICAgICBjb25zdCB4bWluID0gYWFiYlswXTtcbiAgICAgICAgY29uc3QgeW1pbiA9IGFhYmJbMV07XG4gICAgICAgIGNvbnN0IHptaW4gPSBhYWJiWzJdO1xuICAgICAgICBjb25zdCB4d2lkID0gYWFiYlszXSAtIHhtaW47XG4gICAgICAgIGNvbnN0IHl3aWQgPSBhYWJiWzRdIC0geW1pbjtcbiAgICAgICAgY29uc3QgendpZCA9IGFhYmJbNV0gLSB6bWluO1xuICAgICAgICBjb25zdCBtYXhJbnQgPSA2NTUzNTtcbiAgICAgICAgbWF0aC5pZGVudGl0eU1hdDQodHJhbnNsYXRlKTtcbiAgICAgICAgbWF0aC50cmFuc2xhdGlvbk1hdDR2KGFhYmIsIHRyYW5zbGF0ZSk7XG4gICAgICAgIG1hdGguaWRlbnRpdHlNYXQ0KHNjYWxlKTtcbiAgICAgICAgbWF0aC5zY2FsaW5nTWF0NHYoW3h3aWQgLyBtYXhJbnQsIHl3aWQgLyBtYXhJbnQsIHp3aWQgLyBtYXhJbnRdLCBzY2FsZSk7XG4gICAgICAgIG1hdGgubXVsTWF0NCh0cmFuc2xhdGUsIHNjYWxlLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zRGVjb2RlTWF0cml4O1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjb21wcmVzc1Bvc2l0aW9ucyA9IChmdW5jdGlvbiAoKSB7IC8vIGh0dHA6Ly9jZy5wb3N0ZWNoLmFjLmtyL3Jlc2VhcmNoL21lc2hfY29tcF9tb2JpbGUvbWVzaF9jb21wX21vYmlsZV9jb25mZXJlbmNlLnBkZlxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1hdGgubWF0NCgpO1xuICAgIGNvbnN0IHNjYWxlID0gbWF0aC5tYXQ0KCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgcXVhbnRpemVkID0gbmV3IFVpbnQxNkFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICBtYXhbMF0gIT09IG1pblswXSA/IDY1NTM1IC8gKG1heFswXSAtIG1pblswXSkgOiAwLFxuICAgICAgICAgICAgbWF4WzFdICE9PSBtaW5bMV0gPyA2NTUzNSAvIChtYXhbMV0gLSBtaW5bMV0pIDogMCxcbiAgICAgICAgICAgIG1heFsyXSAhPT0gbWluWzJdID8gNjU1MzUgLyAobWF4WzJdIC0gbWluWzJdKSA6IDBcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHF1YW50aXplZFtpICsgMF0gPSBNYXRoLmZsb29yKChhcnJheVtpICsgMF0gLSBtaW5bMF0pICogbXVsdGlwbGllclswXSk7XG4gICAgICAgICAgICBxdWFudGl6ZWRbaSArIDFdID0gTWF0aC5mbG9vcigoYXJyYXlbaSArIDFdIC0gbWluWzFdKSAqIG11bHRpcGxpZXJbMV0pO1xuICAgICAgICAgICAgcXVhbnRpemVkW2kgKyAyXSA9IE1hdGguZmxvb3IoKGFycmF5W2kgKyAyXSAtIG1pblsyXSkgKiBtdWx0aXBsaWVyWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLmlkZW50aXR5TWF0NCh0cmFuc2xhdGUpO1xuICAgICAgICBtYXRoLnRyYW5zbGF0aW9uTWF0NHYobWluLCB0cmFuc2xhdGUpO1xuICAgICAgICBtYXRoLmlkZW50aXR5TWF0NChzY2FsZSk7XG4gICAgICAgIG1hdGguc2NhbGluZ01hdDR2KFtcbiAgICAgICAgICAgIChtYXhbMF0gLSBtaW5bMF0pIC8gNjU1MzUsXG4gICAgICAgICAgICAobWF4WzFdIC0gbWluWzFdKSAvIDY1NTM1LFxuICAgICAgICAgICAgKG1heFsyXSAtIG1pblsyXSkgLyA2NTUzNVxuICAgICAgICBdLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGRlY29kZU1hdCA9IG1hdGgubXVsTWF0NCh0cmFuc2xhdGUsIHNjYWxlLCBtYXRoLmlkZW50aXR5TWF0NCgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1YW50aXplZDogcXVhbnRpemVkLFxuICAgICAgICAgICAgZGVjb2RlTWF0cml4OiBkZWNvZGVNYXRcbiAgICAgICAgfTtcbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gZGVjb21wcmVzc1Bvc2l0aW9uKHBvc2l0aW9uLCBkZWNvZGVNYXRyaXgsIGRlc3QpIHtcbiAgICBkZXN0WzBdID0gcG9zaXRpb25bMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbMTJdO1xuICAgIGRlc3RbMV0gPSBwb3NpdGlvblsxXSAqIGRlY29kZU1hdHJpeFs1XSArIGRlY29kZU1hdHJpeFsxM107XG4gICAgZGVzdFsyXSA9IHBvc2l0aW9uWzJdICogZGVjb2RlTWF0cml4WzEwXSArIGRlY29kZU1hdHJpeFsxNF07XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGRlY29tcHJlc3NBQUJCKGFhYmIsIGRlY29kZU1hdHJpeCwgZGVzdD1hYWJiKSB7XG4gICAgZGVzdFswXSA9IGFhYmJbMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbMTJdO1xuICAgIGRlc3RbMV0gPSBhYWJiWzFdICogZGVjb2RlTWF0cml4WzVdICsgZGVjb2RlTWF0cml4WzEzXTtcbiAgICBkZXN0WzJdID0gYWFiYlsyXSAqIGRlY29kZU1hdHJpeFsxMF0gKyBkZWNvZGVNYXRyaXhbMTRdO1xuICAgIGRlc3RbM10gPSBhYWJiWzNdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzEyXTtcbiAgICBkZXN0WzRdID0gYWFiYls0XSAqIGRlY29kZU1hdHJpeFs1XSArIGRlY29kZU1hdHJpeFsxM107XG4gICAgZGVzdFs1XSA9IGFhYmJbNV0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvbXByZXNzUG9zaXRpb25zKHBvc2l0aW9ucywgZGVjb2RlTWF0cml4LCBkZXN0ID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoKSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgZGVzdFtpICsgMF0gPSBwb3NpdGlvbnNbaSArIDBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzEyXTtcbiAgICAgICAgZGVzdFtpICsgMV0gPSBwb3NpdGlvbnNbaSArIDFdICogZGVjb2RlTWF0cml4WzVdICsgZGVjb2RlTWF0cml4WzEzXTtcbiAgICAgICAgZGVzdFtpICsgMl0gPSBwb3NpdGlvbnNbaSArIDJdICogZGVjb2RlTWF0cml4WzEwXSArIGRlY29kZU1hdHJpeFsxNF07XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLSBVVnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJucyB7e21pbjogRmxvYXQzMkFycmF5LCBtYXg6IEZsb2F0MzJBcnJheX19XG4gKi9cbmZ1bmN0aW9uIGdldFVWQm91bmRzKGFycmF5KSB7XG4gICAgY29uc3QgbWluID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBjb25zdCBtYXggPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgbWluW2ldID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgbWF4W2ldID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgICBtaW5bal0gPSBNYXRoLm1pbihtaW5bal0sIGFycmF5W2kgKyBqXSk7XG4gICAgICAgICAgICBtYXhbal0gPSBNYXRoLm1heChtYXhbal0sIGFycmF5W2kgKyBqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY29tcHJlc3NVVnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG1hdGgubWF0MygpO1xuICAgIGNvbnN0IHNjYWxlID0gbWF0aC5tYXQzKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgcXVhbnRpemVkID0gbmV3IFVpbnQxNkFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgIDY1NTM1IC8gKG1heFswXSAtIG1pblswXSksXG4gICAgICAgICAgICA2NTUzNSAvIChtYXhbMV0gLSBtaW5bMV0pXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBxdWFudGl6ZWRbaSArIDBdID0gTWF0aC5mbG9vcigoYXJyYXlbaSArIDBdIC0gbWluWzBdKSAqIG11bHRpcGxpZXJbMF0pO1xuICAgICAgICAgICAgcXVhbnRpemVkW2kgKyAxXSA9IE1hdGguZmxvb3IoKGFycmF5W2kgKyAxXSAtIG1pblsxXSkgKiBtdWx0aXBsaWVyWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLmlkZW50aXR5TWF0Myh0cmFuc2xhdGUpO1xuICAgICAgICBtYXRoLnRyYW5zbGF0aW9uTWF0M3YobWluLCB0cmFuc2xhdGUpO1xuICAgICAgICBtYXRoLmlkZW50aXR5TWF0MyhzY2FsZSk7XG4gICAgICAgIG1hdGguc2NhbGluZ01hdDN2KFtcbiAgICAgICAgICAgIChtYXhbMF0gLSBtaW5bMF0pIC8gNjU1MzUsXG4gICAgICAgICAgICAobWF4WzFdIC0gbWluWzFdKSAvIDY1NTM1XG4gICAgICAgIF0sIHNjYWxlKTtcbiAgICAgICAgY29uc3QgZGVjb2RlTWF0ID0gbWF0aC5tdWxNYXQzKHRyYW5zbGF0ZSwgc2NhbGUsIG1hdGguaWRlbnRpdHlNYXQzKCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVhbnRpemVkOiBxdWFudGl6ZWQsXG4gICAgICAgICAgICBkZWNvZGVNYXRyaXg6IGRlY29kZU1hdFxuICAgICAgICB9O1xuICAgIH07XG59KSgpO1xuXG5cbi8vLS0tLS0tLS0tLS0tLS0tIE5vcm1hbHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzTm9ybWFscyhhcnJheSkgeyAvLyBodHRwOi8vamNndC5vcmcvcHVibGlzaGVkLzAwMDMvMDIvMDEvXG5cbiAgICAvLyBOb3RlOiB0aHJlZSBlbGVtZW50cyBmb3IgZWFjaCBlbmNvZGVkIG5vcm1hbCwgaW4gd2hpY2ggdGhlIGxhc3QgZWxlbWVudCBpbiBlYWNoIHRyaXBsZXQgaXMgcmVkdW5kYW50LlxuICAgIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgYSBteXN0ZXJpb3VzIFdlYkdMIGlzc3VlIHdoZXJlIDItZWxlbWVudCBub3JtYWxzIGp1c3Qgd291bGRuJ3Qgd29yayBpbiB0aGUgc2hhZGVyIDovXG5cbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IEludDhBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIGxldCBvY3QsIGRlYywgYmVzdCwgY3VycmVudENvcywgYmVzdENvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIC8vIFRlc3QgdmFyaW91cyBjb21iaW5hdGlvbnMgb2YgY2VpbCBhbmQgZmxvb3JcbiAgICAgICAgLy8gdG8gbWluaW1pemUgcm91bmRpbmcgZXJyb3JzXG4gICAgICAgIGJlc3QgPSBvY3QgPSBvY3RFbmNvZGVWZWMzKGFycmF5LCBpLCBcImZsb29yXCIsIFwiZmxvb3JcIik7XG4gICAgICAgIGRlYyA9IG9jdERlY29kZVZlYzIob2N0KTtcbiAgICAgICAgY3VycmVudENvcyA9IGJlc3RDb3MgPSBkb3QoYXJyYXksIGksIGRlYyk7XG4gICAgICAgIG9jdCA9IG9jdEVuY29kZVZlYzMoYXJyYXksIGksIFwiY2VpbFwiLCBcImZsb29yXCIpO1xuICAgICAgICBkZWMgPSBvY3REZWNvZGVWZWMyKG9jdCk7XG4gICAgICAgIGN1cnJlbnRDb3MgPSBkb3QoYXJyYXksIGksIGRlYyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29zID4gYmVzdENvcykge1xuICAgICAgICAgICAgYmVzdCA9IG9jdDtcbiAgICAgICAgICAgIGJlc3RDb3MgPSBjdXJyZW50Q29zO1xuICAgICAgICB9XG4gICAgICAgIG9jdCA9IG9jdEVuY29kZVZlYzMoYXJyYXksIGksIFwiZmxvb3JcIiwgXCJjZWlsXCIpO1xuICAgICAgICBkZWMgPSBvY3REZWNvZGVWZWMyKG9jdCk7XG4gICAgICAgIGN1cnJlbnRDb3MgPSBkb3QoYXJyYXksIGksIGRlYyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29zID4gYmVzdENvcykge1xuICAgICAgICAgICAgYmVzdCA9IG9jdDtcbiAgICAgICAgICAgIGJlc3RDb3MgPSBjdXJyZW50Q29zO1xuICAgICAgICB9XG4gICAgICAgIG9jdCA9IG9jdEVuY29kZVZlYzMoYXJyYXksIGksIFwiY2VpbFwiLCBcImNlaWxcIik7XG4gICAgICAgIGRlYyA9IG9jdERlY29kZVZlYzIob2N0KTtcbiAgICAgICAgY3VycmVudENvcyA9IGRvdChhcnJheSwgaSwgZGVjKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb3MgPiBiZXN0Q29zKSB7XG4gICAgICAgICAgICBiZXN0ID0gb2N0O1xuICAgICAgICAgICAgYmVzdENvcyA9IGN1cnJlbnRDb3M7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZFtpXSA9IGJlc3RbMF07XG4gICAgICAgIGVuY29kZWRbaSArIDFdID0gYmVzdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb2N0RW5jb2RlVmVjMyhhcnJheSwgaSwgeGZ1bmMsIHlmdW5jKSB7IC8vIE9jdC1lbmNvZGUgc2luZ2xlIG5vcm1hbCB2ZWN0b3IgaW4gMiBieXRlc1xuICAgIGxldCB4ID0gYXJyYXlbaV0gLyAoTWF0aC5hYnMoYXJyYXlbaV0pICsgTWF0aC5hYnMoYXJyYXlbaSArIDFdKSArIE1hdGguYWJzKGFycmF5W2kgKyAyXSkpO1xuICAgIGxldCB5ID0gYXJyYXlbaSArIDFdIC8gKE1hdGguYWJzKGFycmF5W2ldKSArIE1hdGguYWJzKGFycmF5W2kgKyAxXSkgKyBNYXRoLmFicyhhcnJheVtpICsgMl0pKTtcbiAgICBpZiAoYXJyYXlbaSArIDJdIDwgMCkge1xuICAgICAgICBsZXQgdGVtcHggPSAoMSAtIE1hdGguYWJzKHkpKSAqICh4ID49IDAgPyAxIDogLTEpO1xuICAgICAgICBsZXQgdGVtcHkgPSAoMSAtIE1hdGguYWJzKHgpKSAqICh5ID49IDAgPyAxIDogLTEpO1xuICAgICAgICB4ID0gdGVtcHg7XG4gICAgICAgIHkgPSB0ZW1weTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoW1xuICAgICAgICBNYXRoW3hmdW5jXSh4ICogMTI3LjUgKyAoeCA8IDAgPyAtMSA6IDApKSxcbiAgICAgICAgTWF0aFt5ZnVuY10oeSAqIDEyNy41ICsgKHkgPCAwID8gLTEgOiAwKSlcbiAgICBdKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYW4gb2N0LWVuY29kZWQgbm9ybWFsXG4gKi9cbmZ1bmN0aW9uIG9jdERlY29kZVZlYzIob2N0KSB7XG4gICAgbGV0IHggPSBvY3RbMF07XG4gICAgbGV0IHkgPSBvY3RbMV07XG4gICAgeCAvPSB4IDwgMCA/IDEyNyA6IDEyODtcbiAgICB5IC89IHkgPCAwID8gMTI3IDogMTI4O1xuICAgIGNvbnN0IHogPSAxIC0gTWF0aC5hYnMoeCkgLSBNYXRoLmFicyh5KTtcbiAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgeCA9ICgxIC0gTWF0aC5hYnMoeSkpICogKHggPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgIHkgPSAoMSAtIE1hdGguYWJzKHgpKSAqICh5ID49IDAgPyAxIDogLTEpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICByZXR1cm4gW1xuICAgICAgICB4IC8gbGVuZ3RoLFxuICAgICAgICB5IC8gbGVuZ3RoLFxuICAgICAgICB6IC8gbGVuZ3RoXG4gICAgXTtcbn1cblxuLyoqXG4gKiBEb3QgcHJvZHVjdCBvZiBhIG5vcm1hbCBpbiBhbiBhcnJheSBhZ2FpbnN0IGEgY2FuZGlkYXRlIGRlY29kaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkb3QoYXJyYXksIGksIHZlYzMpIHtcbiAgICByZXR1cm4gYXJyYXlbaV0gKiB2ZWMzWzBdICsgYXJyYXlbaSArIDFdICogdmVjM1sxXSArIGFycmF5W2kgKyAyXSAqIHZlYzNbMl07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzc1VWKHV2LCBkZWNvZGVNYXRyaXgsIGRlc3QpIHtcbiAgICBkZXN0WzBdID0gdXZbMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbNl07XG4gICAgZGVzdFsxXSA9IHV2WzFdICogZGVjb2RlTWF0cml4WzRdICsgZGVjb2RlTWF0cml4WzddO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29tcHJlc3NVVnModXZzLCBkZWNvZGVNYXRyaXgsIGRlc3QgPSBuZXcgRmxvYXQzMkFycmF5KHV2cy5sZW5ndGgpKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHV2cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBkZXN0W2kgKyAwXSA9IHV2c1tpICsgMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbNl07XG4gICAgICAgIGRlc3RbaSArIDFdID0gdXZzW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs0XSArIGRlY29kZU1hdHJpeFs3XTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzc05vcm1hbChvY3QsIHJlc3VsdCkge1xuICAgIGxldCB4ID0gb2N0WzBdO1xuICAgIGxldCB5ID0gb2N0WzFdO1xuICAgIHggPSAoMiAqIHggKyAxKSAvIDI1NTtcbiAgICB5ID0gKDIgKiB5ICsgMSkgLyAyNTU7XG4gICAgY29uc3QgeiA9IDEgLSBNYXRoLmFicyh4KSAtIE1hdGguYWJzKHkpO1xuICAgIGlmICh6IDwgMCkge1xuICAgICAgICB4ID0gKDEgLSBNYXRoLmFicyh5KSkgKiAoeCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgeSA9ICgxIC0gTWF0aC5hYnMoeCkpICogKHkgPj0gMCA/IDEgOiAtMSk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIHJlc3VsdFswXSA9IHggLyBsZW5ndGg7XG4gICAgcmVzdWx0WzFdID0geSAvIGxlbmd0aDtcbiAgICByZXN1bHRbMl0gPSB6IC8gbGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzc05vcm1hbHMob2N0cywgcmVzdWx0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBsZW4gPSBvY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIGxldCB4ID0gb2N0c1tpICsgMF07XG4gICAgICAgIGxldCB5ID0gb2N0c1tpICsgMV07XG4gICAgICAgIHggPSAoMiAqIHggKyAxKSAvIDI1NTtcbiAgICAgICAgeSA9ICgyICogeSArIDEpIC8gMjU1O1xuICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgeCA9ICgxIC0gTWF0aC5hYnMoeSkpICogKHggPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgcmVzdWx0W2ogKyAwXSA9IHggLyBsZW5ndGg7XG4gICAgICAgIHJlc3VsdFtqICsgMV0gPSB5IC8gbGVuZ3RoO1xuICAgICAgICByZXN1bHRbaiArIDJdID0geiAvIGxlbmd0aDtcbiAgICAgICAgaiArPSAzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGdlb21ldHJ5Q29tcHJlc3Npb25VdGlscyA9IHtcblxuICAgIGdldFBvc2l0aW9uc0JvdW5kczogZ2V0UG9zaXRpb25zQm91bmRzLFxuICAgIGNyZWF0ZVBvc2l0aW9uc0RlY29kZU1hdHJpeDogY3JlYXRlUG9zaXRpb25zRGVjb2RlTWF0cml4LFxuICAgIGNvbXByZXNzUG9zaXRpb25zOiBjb21wcmVzc1Bvc2l0aW9ucyxcbiAgICBkZWNvbXByZXNzUG9zaXRpb25zOiBkZWNvbXByZXNzUG9zaXRpb25zLFxuICAgIGRlY29tcHJlc3NQb3NpdGlvbjogZGVjb21wcmVzc1Bvc2l0aW9uLFxuICAgIGRlY29tcHJlc3NBQUJCOiBkZWNvbXByZXNzQUFCQixcblxuICAgIGdldFVWQm91bmRzOiBnZXRVVkJvdW5kcyxcbiAgICBjb21wcmVzc1VWczogY29tcHJlc3NVVnMsXG4gICAgZGVjb21wcmVzc1VWczogZGVjb21wcmVzc1VWcyxcbiAgICBkZWNvbXByZXNzVVY6IGRlY29tcHJlc3NVVixcblxuICAgIGNvbXByZXNzTm9ybWFsczogY29tcHJlc3NOb3JtYWxzLFxuICAgIGRlY29tcHJlc3NOb3JtYWxzOiBkZWNvbXByZXNzTm9ybWFscyxcbiAgICBkZWNvbXByZXNzTm9ybWFsOiBkZWNvbXByZXNzTm9ybWFsXG59O1xuXG5leHBvcnQge2dlb21ldHJ5Q29tcHJlc3Npb25VdGlsc307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/geometryCompressionUtils.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js ***!
  \***********************************************************************/
/*! exports provided: math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"math\", function() { return math; });\n// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE: Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    unglobalizeObjectId(modelId, globalId) {\n        const idx = globalId.indexOf(\"#\");\n        return (idx === modelId.length && globalId.startsWith(modelId)) ? globalId.substring(idx + 1) : globalId;\n    },\n\n    globalizeObjectId(modelId, objectId) {\n        return (modelId + \"#\" + objectId)\n    },\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a list of double-precision values to a list of high-part floats and a list of low-part floats.\n     * @param doubleVals\n     * @param floatValsHigh\n     * @param floatValsLow\n     */\n    doublesToFloats(doubleVals, floatValsHigh, floatValsLow) {\n        const floatPair = new Float32Array(2);\n        for (let i = 0, len = doubleVals.length; i < len; i++) {\n            math.splitDouble(doubleVals[i], floatPair);\n            floatValsHigh[i] = floatPair[0];\n            floatValsLow[i] = floatPair[1];\n        }\n    },\n\n    /**\n     * Splits a double value into two floats.\n     * @param value\n     * @param floatPair\n     */\n    splitDouble(value, floatPair) {\n        const hi = Float32Array.from([value])[0];\n        const low = value - hi;\n        floatPair[0] = hi;\n        floatPair[1] = low;\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Returns true if the two 3-element vectors are the same.\n     * @param v1\n     * @param v2\n     * @returns {boolean}\n     */\n    compareVec3(v1, v2) {\n        return (v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2]);\n    },\n\n    /**\n     * Negates a three-element vector.\n     * @method negateVec3\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec3(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        return dest;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Get the geometric mean of the vectors.\n     * @method geometricMeanVec2\n     * @static\n     * @param {...Array(Number)} vectors Vec2 to mean\n     * @return {Array(Number)} The geometric mean vec2\n     */\n    geometricMeanVec2(...vectors) {\n        const geometricMean = new FloatArrayType(vectors[0]);\n        for (let i = 1; i < vectors.length; i++) {\n            geometricMean[0] += vectors[i][0];\n            geometricMean[1] += vectors[i][1];\n        }\n        geometricMean[0] /= vectors.length;\n        geometricMean[1] /= vectors.length;\n        return geometricMean;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n\n    /**\n     * Creates a new matrix that replaces the translation in the rightmost column of the given\n     * affine matrix with the given translation.\n     * @param m\n     * @param translation\n     * @param dest\n     * @returns {*}\n     */\n    setMat4Translation(m, translation, dest) {\n\n        dest[0] = m[0];\n        dest[1] = m[1];\n        dest[2] = m[2];\n        dest[3] = m[3];\n\n        dest[4] = m[4];\n        dest[5] = m[5];\n        dest[6] = m[6];\n        dest[7] = m[7];\n\n        dest[8] = m[8];\n        dest[9] = m[9];\n        dest[10] = m[10];\n        dest[11] = m[11];\n\n        dest[12] = translation[0];\n        dest[13] = translation[1];\n        dest[14] = translation[2];\n        dest[15] = m[15];\n\n        return dest;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /** @private */\n    getColMat4(mat, c) {\n        const i = c * 4;\n        return [mat[i], mat[i + 1], mat[i + 2], mat[i + 3]];\n    },\n\n    /** @private */\n    setRowMat4(mat, r, v) {\n        mat[r] = v[0];\n        mat[r + 4] = v[1];\n        mat[r + 8] = v[2];\n        mat[r + 12] = v[3];\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Returns true if the two 4x4 matrices are the same.\n     * @param m1\n     * @param m2\n     * @returns {boolean}\n     */\n    compareMat4(m1, m2) {\n        return m1[0] === m2[0] &&\n            m1[1] === m2[1] &&\n            m1[2] === m2[2] &&\n            m1[3] === m2[3] &&\n            m1[4] === m2[4] &&\n            m1[5] === m2[5] &&\n            m1[6] === m2[6] &&\n            m1[7] === m2[7] &&\n            m1[8] === m2[8] &&\n            m1[9] === m2[9] &&\n            m1[10] === m2[10] &&\n            m1[11] === m2[11] &&\n            m1[12] === m2[12] &&\n            m1[13] === m2[13] &&\n            m1[14] === m2[14] &&\n            m1[15] === m2[15];\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = p[0] * f;\n        q[1] = p[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n    /**\n     * Linearly interpolates between two 4x4 matrices.\n     * @method lerpMat4\n     * @static\n     */\n    lerpMat4(t, t1, t2, m1, m2, dest) {\n        const result = dest || math.mat4();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = m1[0] + (f * (m2[0] - m1[0]));\n        result[1] = m1[1] + (f * (m2[1] - m1[1]));\n        result[2] = m1[2] + (f * (m2[2] - m1[2]));\n        result[3] = m1[3] + (f * (m2[3] - m1[3]));\n        result[4] = m1[4] + (f * (m2[4] - m1[4]));\n        result[5] = m1[5] + (f * (m2[5] - m1[5]));\n        result[6] = m1[6] + (f * (m2[6] - m1[6]));\n        result[7] = m1[7] + (f * (m2[7] - m1[7]));\n        result[8] = m1[8] + (f * (m2[8] - m1[8]));\n        result[9] = m1[9] + (f * (m2[9] - m1[9]));\n        result[10] = m1[10] + (f * (m2[10] - m1[10]));\n        result[11] = m1[11] + (f * (m2[11] - m1[11]));\n        result[12] = m1[12] + (f * (m2[12] - m1[12]));\n        result[13] = m1[13] + (f * (m2[13] - m1[13]));\n        result[14] = m1[14] + (f * (m2[14] - m1[14]));\n        result[15] = m1[15] + (f * (m2[15] - m1[15]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the area of an AABB.\n     *\n     * @private\n     */\n    getAABB3Area(aabb) {\n        const width = (aabb[3] - aabb[0]);\n        const height = (aabb[4] - aabb[1]);\n        const depth = (aabb[5] - aabb[2]);\n        return (width * height * depth);\n    },\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n        aabb[4] = math.MIN_DOUBLE;\n        aabb[5] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new Float32Array(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = math.MIN_DOUBLE;\n            let ymax = math.MIN_DOUBLE;\n            let zmax = math.MIN_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n        let zmax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new Float32Array(3);\n        const tempVec3 = new Float32Array(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Gets the 3D center of the given flat array of 3D positions.\n     *\n     * @private\n     */\n    getPositionsCenter(positions, center = math.vec3()) {\n        let xCenter = 0;\n        let yCenter = 0;\n        let zCenter = 0;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            xCenter += positions[i + 0];\n            yCenter += positions[i + 1];\n            zCenter += positions[i + 2];\n        }\n        const numPositions = positions.length / 3;\n        center[0] = xCenter / numPositions;\n        center[1] = yCenter / numPositions;\n        center[2] = zCenter / numPositions;\n        return center;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n     *\n     * @private\n     */\n    expandAABB3Points3(aabb, positions) {\n        var x;\n        var y;\n        var z;\n        for (var i = 0, len = positions.length; i < len; i += 3) {\n            x = positions[i];\n            y = positions[i + 1];\n            z = positions[i + 2];\n            if (aabb[0] > x) {\n                aabb[0] = x;\n            }\n            if (aabb[1] > y) {\n                aabb[1] = y;\n            }\n            if (aabb[2] > z) {\n                aabb[2] = z;\n            }\n            if (aabb[3] < x) {\n                aabb[3] = x;\n            }\n            if (aabb[4] < y) {\n                aabb[4] = y;\n            }\n            if (aabb[5] < z) {\n                aabb[5] = z;\n            }\n        }\n        return aabb;\n    },\n\n    /**\n     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB2(aabb = math.AABB2()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MIN_DOUBLE;\n        aabb[3] = math.MIN_DOUBLE;\n\n        return aabb;\n    },\n\n    point3AABB3Intersect(aabb, p) {\n        return aabb[0] > p[0] || aabb[3] < p[0] || aabb[1] > p[1] || aabb[4] < p[1] || aabb[2] > p[2] || aabb[5] < p[2];\n    },\n\n    /**\n     *\n     * @param dir\n     * @param constant\n     * @param aabb\n     * @returns {number}\n     */\n    planeAABB3Intersect(dir, constant, aabb) {\n        let min, max;\n        if (dir[0] > 0) {\n            min = dir[0] * aabb[0];\n            max = dir[0] * aabb[3];\n        } else {\n            min = dir[0] * aabb[3];\n            max = dir[0] * aabb[0];\n        }\n        if (dir[1] > 0) {\n            min += dir[1] * aabb[1];\n            max += dir[1] * aabb[4];\n        } else {\n            min += dir[1] * aabb[4];\n            max += dir[1] * aabb[1];\n        }\n        if (dir[2] > 0) {\n            min += dir[2] * aabb[2];\n            max += dir[2] * aabb[5];\n        } else {\n            min += dir[2] * aabb[5];\n            max += dir[2] * aabb[2];\n        }\n        const outside = (min <= -constant) && (max <= -constant);\n        if (outside) {\n            return -1;\n        }\n\n        const inside = (min >= -constant) && (max >= -constant);\n        if (inside) {\n            return 1;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToAABB2(points, aabb = math.AABB2()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let xmax = math.MIN_DOUBLE;\n        let ymax = math.MIN_DOUBLE;\n\n        let x;\n        let y;\n        let w;\n        let f;\n\n        for (let i = 0, len = points.length; i < len; i += 4) {\n\n            x = points[i + 0];\n            y = points[i + 1];\n            w = points[i + 3] || 1.0;\n\n            f = 1.0 / w;\n\n            x *= f;\n            y *= f;\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = xmax;\n        aabb[3] = ymax;\n\n        return aabb;\n    },\n\n    /**\n     * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB2(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] < aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 2D boundary to enclose the given point, if required.\n     *\n     * @private\n     */\n    expandAABB2Point2(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] < p[0]) {\n            aabb[2] = p[0];\n        }\n\n        if (aabb[3] < p[1]) {\n            aabb[3] = p[1];\n        }\n\n        return aabb;\n    },\n\n    AABB2ToCanvas(aabb, canvasWidth, canvasHeight, aabb2 = aabb) {\n        const xmin = (aabb[0] + 1.0) * 0.5;\n        const ymin = (aabb[1] + 1.0) * 0.5;\n        const xmax = (aabb[2] + 1.0) * 0.5;\n        const ymax = (aabb[3] + 1.0) * 0.5;\n\n        aabb2[0] = Math.floor(xmin * canvasWidth);\n        aabb2[1] = canvasHeight - Math.floor(ymax * canvasHeight);\n        aabb2[2] = Math.floor(xmax * canvasWidth);\n        aabb2[3] = canvasHeight - Math.floor(ymin * canvasHeight);\n\n        return aabb2;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Curves\n    //------------------------------------------------------------------------------------------------------------------\n\n    tangentQuadraticBezier(t, p0, p1, p2) {\n        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n    },\n\n    tangentQuadraticBezier3(t, p0, p1, p2, p3) {\n        return -3 * p0 * (1 - t) * (1 - t) +\n            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\n            6 * t * p2 * (1 - t) - 3 * t * t * p2 +\n            3 * t * t * p3;\n    },\n\n    tangentSpline(t) {\n        const h00 = 6 * t * t - 6 * t;\n        const h10 = 3 * t * t - 4 * t + 1;\n        const h01 = -6 * t * t + 6 * t;\n        const h11 = 3 * t * t - 2 * t;\n        return h00 + h10 + h01 + h11;\n    },\n\n    catmullRomInterpolate(p0, p1, p2, p3, t) {\n        const v0 = (p2 - p0) * 0.5;\n        const v1 = (p3 - p1) * 0.5;\n        const t2 = t * t;\n        const t3 = t * t2;\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    },\n\n// Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n// Quad Bezier Functions\n\n    b2p0(t, p) {\n        const k = 1 - t;\n        return k * k * p;\n\n    },\n\n    b2p1(t, p) {\n        return 2 * (1 - t) * t * p;\n    },\n\n    b2p2(t, p) {\n        return t * t * p;\n    },\n\n    b2(t, p0, p1, p2) {\n        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);\n    },\n\n// Cubic Bezier Functions\n\n    b3p0(t, p) {\n        const k = 1 - t;\n        return k * k * k * p;\n    },\n\n    b3p1(t, p) {\n        const k = 1 - t;\n        return 3 * k * k * t * p;\n    },\n\n    b3p2(t, p) {\n        const k = 1 - t;\n        return 3 * k * t * t * p;\n    },\n\n    b3p3(t, p) {\n        return t * t * t * p;\n    },\n\n    b3(t, p0, p1, p2, p3) {\n        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Geometry\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    },\n\n    /**\n     * Finds the intersection of a 3D ray with a 3D triangle.\n     *\n     * @private\n     */\n    rayTriangleIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            const EPSILON = 0.000001;\n\n            const edge1 = math.subVec3(b, a, tempVec3);\n            const edge2 = math.subVec3(c, a, tempVec3b);\n\n            const pvec = math.cross3Vec3(dir, edge2, tempVec3c);\n            const det = math.dotVec3(edge1, pvec);\n            if (det < EPSILON) {\n                return null;\n            }\n\n            const tvec = math.subVec3(origin, a, tempVec3d);\n            const u = math.dotVec3(tvec, pvec);\n            if (u < 0 || u > det) {\n                return null;\n            }\n\n            const qvec = math.cross3Vec3(tvec, edge1, tempVec3e);\n            const v = math.dotVec3(dir, qvec);\n            if (v < 0 || u + v > det) {\n                return null;\n            }\n\n            const t = math.dotVec3(edge2, qvec) / det;\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Finds the intersection of a 3D ray with a plane defined by 3 points.\n     *\n     * @private\n     */\n    rayPlaneIntersect: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n\n        return (origin, dir, a, b, c, isect) => {\n\n            isect = isect || math.vec3();\n\n            dir = math.normalizeVec3(dir, tempVec3);\n\n            const edge1 = math.subVec3(b, a, tempVec3b);\n            const edge2 = math.subVec3(c, a, tempVec3c);\n\n            const n = math.cross3Vec3(edge1, edge2, tempVec3d);\n            math.normalizeVec3(n, n);\n\n            const d = -math.dotVec3(a, n);\n\n            const t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);\n\n            isect[0] = origin[0] + t * dir[0];\n            isect[1] = origin[1] + t * dir[1];\n            isect[2] = origin[2] + t * dir[2];\n\n            return isect;\n        };\n    }))(),\n\n    /**\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     * Gets barycentric coordinates from cartesian coordinates within a triangle.\n     *\n     * @private\n     */\n    cartesianToBarycentric: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n\n        return (cartesian, a, b, c, dest) => {\n\n            const v0 = math.subVec3(c, a, tempVec3);\n            const v1 = math.subVec3(b, a, tempVec3b);\n            const v2 = math.subVec3(cartesian, a, tempVec3c);\n\n            const dot00 = math.dotVec3(v0, v0);\n            const dot01 = math.dotVec3(v0, v1);\n            const dot02 = math.dotVec3(v0, v2);\n            const dot11 = math.dotVec3(v1, v1);\n            const dot12 = math.dotVec3(v1, v2);\n\n            const denom = (dot00 * dot11 - dot01 * dot01);\n\n            // Colinear or singular triangle\n\n            if (denom === 0) {\n\n                // Arbitrary location outside of triangle\n\n                return null;\n            }\n\n            const invDenom = 1 / denom;\n\n            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n            dest[0] = 1 - u - v;\n            dest[1] = v;\n            dest[2] = u;\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Returns true if the given barycentric coordinates are within their triangle.\n     *\n     * @private\n     */\n    barycentricInsideTriangle(bary) {\n\n        const v = bary[1];\n        const u = bary[2];\n\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    },\n\n    /**\n     * Gets cartesian coordinates from barycentric coordinates within a triangle.\n     *\n     * @private\n     */\n    barycentricToCartesian(bary, a, b, c, cartesian = math.vec3()) {\n        const u = bary[0];\n        const v = bary[1];\n        const w = bary[2];\n\n        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;\n        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;\n        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;\n\n        return cartesian;\n    },\n\n\n    /**\n     * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n     * modified arrays that have duplicate vertices removed.\n     *\n     * Note: does not work well when co-incident vertices have same positions but different normals and UVs.\n     *\n     * @param positions\n     * @param normals\n     * @param uv\n     * @param indices\n     * @returns {{positions: Array, indices: Array}}\n     * @private\n     */\n    mergeVertices(positions, normals, uv, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        const indicesLookup = [];\n        const uniquePositions = [];\n        const uniqueNormals = normals ? [] : null;\n        const uniqueUV = uv ? [] : null;\n        const indices2 = [];\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let i;\n        let len;\n        let uvi = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = uniquePositions.length / 3;\n                uniquePositions.push(vx);\n                uniquePositions.push(vy);\n                uniquePositions.push(vz);\n                if (normals) {\n                    uniqueNormals.push(normals[i]);\n                    uniqueNormals.push(normals[i + 1]);\n                    uniqueNormals.push(normals[i + 2]);\n                }\n                if (uv) {\n                    uniqueUV.push(uv[uvi]);\n                    uniqueUV.push(uv[uvi + 1]);\n                }\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n            uvi += 2;\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            indices2[i] = indicesLookup[indices[i]];\n        }\n        const result = {\n            positions: uniquePositions,\n            indices: indices2\n        };\n        if (uniqueNormals) {\n            result.normals = uniqueNormals;\n        }\n        if (uniqueUV) {\n            result.uv = uniqueUV;\n\n        }\n        return result;\n    },\n\n    /**\n     * Builds normal vectors from positions and indices.\n     *\n     * @private\n     */\n    buildNormals: ((() => {\n\n        const a = new Float32Array(3);\n        const b = new Float32Array(3);\n        const c = new Float32Array(3);\n        const ab = new Float32Array(3);\n        const ac = new Float32Array(3);\n        const crossVec = new Float32Array(3);\n\n        return (positions, indices, normals) => {\n\n            let i;\n            let len;\n            const nvecs = new Array(positions.length / 3);\n            let j0;\n            let j1;\n            let j2;\n\n            for (i = 0, len = indices.length; i < len; i += 3) {\n\n                j0 = indices[i];\n                j1 = indices[i + 1];\n                j2 = indices[i + 2];\n\n                a[0] = positions[j0 * 3];\n                a[1] = positions[j0 * 3 + 1];\n                a[2] = positions[j0 * 3 + 2];\n\n                b[0] = positions[j1 * 3];\n                b[1] = positions[j1 * 3 + 1];\n                b[2] = positions[j1 * 3 + 2];\n\n                c[0] = positions[j2 * 3];\n                c[1] = positions[j2 * 3 + 1];\n                c[2] = positions[j2 * 3 + 2];\n\n                math.subVec3(b, a, ab);\n                math.subVec3(c, a, ac);\n\n                const normVec = new Float32Array(3);\n\n                math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n                if (!nvecs[j0]) {\n                    nvecs[j0] = [];\n                }\n                if (!nvecs[j1]) {\n                    nvecs[j1] = [];\n                }\n                if (!nvecs[j2]) {\n                    nvecs[j2] = [];\n                }\n\n                nvecs[j0].push(normVec);\n                nvecs[j1].push(normVec);\n                nvecs[j2].push(normVec);\n            }\n\n            normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n            let count;\n            let x;\n            let y;\n            let z;\n\n            for (i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n                count = nvecs[i].length;\n\n                x = 0;\n                y = 0;\n                z = 0;\n\n                for (let j = 0; j < count; j++) {\n                    x += nvecs[i][j][0];\n                    y += nvecs[i][j][1];\n                    z += nvecs[i][j][2];\n                }\n\n                normals[i * 3] = (x / count);\n                normals[i * 3 + 1] = (y / count);\n                normals[i * 3 + 2] = (z / count);\n            }\n\n            return normals;\n        };\n    }))(),\n\n    /**\n     * Builds vertex tangent vectors from positions, UVs and indices.\n     *\n     * @private\n     */\n    buildTangents: ((() => {\n\n        const tempVec3 = new Float32Array(3);\n        const tempVec3b = new Float32Array(3);\n        const tempVec3c = new Float32Array(3);\n        const tempVec3d = new Float32Array(3);\n        const tempVec3e = new Float32Array(3);\n        const tempVec3f = new Float32Array(3);\n        const tempVec3g = new Float32Array(3);\n\n        return (positions, indices, uv) => {\n\n            const tangents = new Float32Array(positions.length);\n\n            // The vertex arrays needs to be calculated\n            // before the calculation of the tangents\n\n            for (let location = 0; location < indices.length; location += 3) {\n\n                // Recontructing each vertex and UV coordinate into the respective vectors\n\n                let index = indices[location];\n\n                const v0 = positions.subarray(index * 3, index * 3 + 3);\n                const uv0 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 1];\n\n                const v1 = positions.subarray(index * 3, index * 3 + 3);\n                const uv1 = uv.subarray(index * 2, index * 2 + 2);\n\n                index = indices[location + 2];\n\n                const v2 = positions.subarray(index * 3, index * 3 + 3);\n                const uv2 = uv.subarray(index * 2, index * 2 + 2);\n\n                const deltaPos1 = math.subVec3(v1, v0, tempVec3);\n                const deltaPos2 = math.subVec3(v2, v0, tempVec3b);\n\n                const deltaUV1 = math.subVec2(uv1, uv0, tempVec3c);\n                const deltaUV2 = math.subVec2(uv2, uv0, tempVec3d);\n\n                const r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));\n\n                const tangent = math.mulVec3Scalar(\n                    math.subVec3(\n                        math.mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),\n                        math.mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),\n                        tempVec3g\n                    ),\n                    r,\n                    tempVec3f\n                );\n\n                // Average the value of the vectors\n\n                let addTo;\n\n                for (let v = 0; v < 3; v++) {\n                    addTo = indices[location + v] * 3;\n                    tangents[addTo] += tangent[0];\n                    tangents[addTo + 1] += tangent[1];\n                    tangents[addTo + 2] += tangent[2];\n                }\n            }\n\n            return tangents;\n        };\n    }))(),\n\n    /**\n     * Builds vertex and index arrays needed by color-indexed triangle picking.\n     *\n     * @private\n     */\n    buildPickTriangles(positions, indices, compressGeometry) {\n\n        const numIndices = indices.length;\n        const pickPositions = compressGeometry ? new Uint16Array(numIndices * 9) : new Float32Array(numIndices * 9);\n        const pickColors = new Uint8Array(numIndices * 12);\n        let primIndex = 0;\n        let vi;// Positions array index\n        let pvi = 0;// Picking positions array index\n        let pci = 0; // Picking color array index\n\n        // Triangle indices\n        let i;\n        let r;\n        let g;\n        let b;\n        let a;\n\n        for (let location = 0; location < numIndices; location += 3) {\n\n            // Primitive-indexed triangle pick color\n\n            a = (primIndex >> 24 & 0xFF);\n            b = (primIndex >> 16 & 0xFF);\n            g = (primIndex >> 8 & 0xFF);\n            r = (primIndex & 0xFF);\n\n            // A\n\n            i = indices[location];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // B\n\n            i = indices[location + 1];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            // C\n\n            i = indices[location + 2];\n            vi = i * 3;\n\n            pickPositions[pvi++] = positions[vi];\n            pickPositions[pvi++] = positions[vi + 1];\n            pickPositions[pvi++] = positions[vi + 2];\n\n            pickColors[pci++] = r;\n            pickColors[pci++] = g;\n            pickColors[pci++] = b;\n            pickColors[pci++] = a;\n\n            primIndex++;\n        }\n\n        return {\n            positions: pickPositions,\n            colors: pickColors\n        };\n    },\n\n    /**\n     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n     * averaging their normal vectors.\n     *\n     * @returns {{positions: Array, normals: *}}\n     */\n    faceToVertexNormals(positions, normals, options = {}) {\n        const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n        const vertexMap = {};\n        const vertexNormals = [];\n        const vertexNormalAccum = {};\n        let acc;\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = 10 ** precisionPoints;\n        let posi;\n        let i;\n        let j;\n        let len;\n        let a;\n        let b;\n        let c;\n\n        for (i = 0, len = positions.length; i < len; i += 3) {\n\n            posi = i / 3;\n\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n\n            key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n            if (vertexMap[key] === undefined) {\n                vertexMap[key] = [posi];\n            } else {\n                vertexMap[key].push(posi);\n            }\n\n            const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n            vertexNormals[posi] = normal;\n\n            acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n            vertexNormalAccum[posi] = acc;\n        }\n\n        for (key in vertexMap) {\n\n            if (vertexMap.hasOwnProperty(key)) {\n\n                const vertices = vertexMap[key];\n                const numVerts = vertices.length;\n\n                for (i = 0; i < numVerts; i++) {\n\n                    const ii = vertices[i];\n\n                    acc = vertexNormalAccum[ii];\n\n                    for (j = 0; j < numVerts; j++) {\n\n                        if (i === j) {\n                            continue;\n                        }\n\n                        const jj = vertices[j];\n\n                        a = vertexNormals[ii];\n                        b = vertexNormals[jj];\n\n                        const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                        if (angle < smoothNormalsAngleThreshold) {\n\n                            acc[0] += b[0];\n                            acc[1] += b[1];\n                            acc[2] += b[2];\n                            acc[3] += 1.0;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0, len = normals.length; i < len; i += 3) {\n\n            acc = vertexNormalAccum[i / 3];\n\n            normals[i + 0] = acc[0] / acc[3];\n            normals[i + 1] = acc[1] / acc[3];\n            normals[i + 2] = acc[2] / acc[3];\n\n        }\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Ray casting\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.\n     @method canvasPosToWorldRay\n     @static\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     */\n    canvasPosToWorldRay: ((() => {\n\n        const tempMat4b = new Float32Array(16);\n        const tempMat4c = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n        const tempVec4c = new Float32Array(4);\n        const tempVec4d = new Float32Array(4);\n\n        return (canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir) => {\n\n            const pvMat = math.mulMat4(projMatrix, viewMatrix, tempMat4b);\n            const pvMatInverse = math.inverseMat4(pvMat, tempMat4c);\n\n            // Calculate clip space coordinates, which will be in range\n            // of x=[-1..1] and y=[-1..1], with y=(+1) at top\n\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n\n            const clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates\n            const clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);\n\n            tempVec4a[0] = clipX;\n            tempVec4a[1] = clipY;\n            tempVec4a[2] = -1;\n            tempVec4a[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4a, tempVec4b);\n            math.mulVec4Scalar(tempVec4b, 1 / tempVec4b[3]);\n\n            tempVec4c[0] = clipX;\n            tempVec4c[1] = clipY;\n            tempVec4c[2] = 1;\n            tempVec4c[3] = 1;\n\n            math.transformVec4(pvMatInverse, tempVec4c, tempVec4d);\n            math.mulVec4Scalar(tempVec4d, 1 / tempVec4d[3]);\n\n            worldRayOrigin[0] = tempVec4d[0];\n            worldRayOrigin[1] = tempVec4d[1];\n            worldRayOrigin[2] = tempVec4d[2];\n\n            math.subVec3(tempVec4d, tempVec4b, worldRayDir);\n\n            math.normalizeVec3(worldRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a Canvas-space position to a Mesh's Local-space coordinate system, in the context of a Camera.\n     @method canvasPosToLocalRay\n     @static\n     @param {Camera} camera The Camera.\n     @param {Mesh} mesh The Mesh.\n     @param {Number[]} viewMatrix View matrix\n     @param {Number[]} projMatrix Projection matrix\n     @param {Number[]} worldMatrix Modeling matrix\n     @param {Number[]} canvasPos The Canvas-space position.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    canvasPosToLocalRay: ((() => {\n\n        const worldRayOrigin = new Float32Array(3);\n        const worldRayDir = new Float32Array(3);\n\n        return (canvas, viewMatrix, projMatrix, worldMatrix, canvasPos, localRayOrigin, localRayDir) => {\n            math.canvasPosToWorldRay(canvas, viewMatrix, projMatrix, canvasPos, worldRayOrigin, worldRayDir);\n            math.worldRayToLocalRay(worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);\n        };\n    }))(),\n\n    /**\n     Transforms a ray from World-space to a Mesh's Local-space coordinate system.\n     @method worldRayToLocalRay\n     @static\n     @param {Number[]} worldMatrix The World transform matrix\n     @param {Number[]} worldRayOrigin The World-space ray origin.\n     @param {Number[]} worldRayDir The World-space ray direction.\n     @param {Number[]} localRayOrigin The Local-space ray origin.\n     @param {Number[]} localRayDir The Local-space ray direction.\n     */\n    worldRayToLocalRay: ((() => {\n\n        const tempMat4 = new Float32Array(16);\n        const tempVec4a = new Float32Array(4);\n        const tempVec4b = new Float32Array(4);\n\n        return (worldMatrix, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) => {\n\n            const modelMatInverse = math.inverseMat4(worldMatrix, tempMat4);\n\n            tempVec4a[0] = worldRayOrigin[0];\n            tempVec4a[1] = worldRayOrigin[1];\n            tempVec4a[2] = worldRayOrigin[2];\n            tempVec4a[3] = 1;\n\n            math.transformVec4(modelMatInverse, tempVec4a, tempVec4b);\n\n            localRayOrigin[0] = tempVec4b[0];\n            localRayOrigin[1] = tempVec4b[1];\n            localRayOrigin[2] = tempVec4b[2];\n\n            math.transformVec3(modelMatInverse, worldRayDir, localRayDir);\n        };\n    }))(),\n\n    buildKDTree: ((() => {\n\n        const KD_TREE_MAX_DEPTH = 10;\n        const KD_TREE_MIN_TRIANGLES = 20;\n\n        const dimLength = new Float32Array();\n\n        function buildNode(triangles, indices, positions, depth) {\n            const aabb = new Float32Array(6);\n\n            const node = {\n                triangles: null,\n                left: null,\n                right: null,\n                leaf: false,\n                splitDim: 0,\n                aabb\n            };\n\n            aabb[0] = aabb[1] = aabb[2] = Number.POSITIVE_INFINITY;\n            aabb[3] = aabb[4] = aabb[5] = Number.NEGATIVE_INFINITY;\n\n            let t;\n            let i;\n            let len;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n                var ii = triangles[t] * 3;\n                for (let j = 0; j < 3; ++j) {\n                    const pi = indices[ii + j] * 3;\n                    if (positions[pi] < aabb[0]) {\n                        aabb[0] = positions[pi]\n                    }\n                    if (positions[pi] > aabb[3]) {\n                        aabb[3] = positions[pi]\n                    }\n                    if (positions[pi + 1] < aabb[1]) {\n                        aabb[1] = positions[pi + 1]\n                    }\n                    if (positions[pi + 1] > aabb[4]) {\n                        aabb[4] = positions[pi + 1]\n                    }\n                    if (positions[pi + 2] < aabb[2]) {\n                        aabb[2] = positions[pi + 2]\n                    }\n                    if (positions[pi + 2] > aabb[5]) {\n                        aabb[5] = positions[pi + 2]\n                    }\n                }\n            }\n\n            if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {\n                node.triangles = triangles;\n                node.leaf = true;\n                return node;\n            }\n\n            dimLength[0] = aabb[3] - aabb[0];\n            dimLength[1] = aabb[4] - aabb[1];\n            dimLength[2] = aabb[5] - aabb[2];\n\n            let dim = 0;\n\n            if (dimLength[1] > dimLength[dim]) {\n                dim = 1;\n            }\n\n            if (dimLength[2] > dimLength[dim]) {\n                dim = 2;\n            }\n\n            node.splitDim = dim;\n\n            const mid = (aabb[dim] + aabb[dim + 3]) / 2;\n            const left = new Array(triangles.length);\n            let numLeft = 0;\n            const right = new Array(triangles.length);\n            let numRight = 0;\n\n            for (t = 0, len = triangles.length; t < len; ++t) {\n\n                var ii = triangles[t] * 3;\n                const i0 = indices[ii];\n                const i1 = indices[ii + 1];\n                const i2 = indices[ii + 2];\n\n                const pi0 = i0 * 3;\n                const pi1 = i1 * 3;\n                const pi2 = i2 * 3;\n\n                if (positions[pi0 + dim] <= mid || positions[pi1 + dim] <= mid || positions[pi2 + dim] <= mid) {\n                    left[numLeft++] = triangles[t];\n                } else {\n                    right[numRight++] = triangles[t];\n                }\n            }\n\n            left.length = numLeft;\n            right.length = numRight;\n\n            node.left = buildNode(left, indices, positions, depth + 1);\n            node.right = buildNode(right, indices, positions, depth + 1);\n\n            return node;\n        }\n\n        return (indices, positions) => {\n            const numTris = indices.length / 3;\n            const triangles = new Array(numTris);\n            for (let i = 0; i < numTris; ++i) {\n                triangles[i] = i;\n            }\n            return buildNode(triangles, indices, positions, 0);\n        };\n    }))(),\n\n\n    decompressPosition(position, decodeMatrix, dest) {\n        dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];\n        dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];\n        dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];\n    },\n\n    decompressPositions(positions, decodeMatrix, dest = new Float32Array(positions.length)) {\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];\n            dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];\n            dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];\n        }\n        return dest;\n    },\n\n    decompressUV(uv, decodeMatrix, dest) {\n        dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];\n        dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];\n    },\n\n    decompressUVs(uvs, decodeMatrix, dest = new Float32Array(uvs.length)) {\n        for (let i = 0, len = uvs.length; i < len; i += 3) {\n            dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];\n            dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];\n        }\n        return dest;\n    },\n\n    octDecodeVec2(oct, result) {\n        let x = oct[0];\n        let y = oct[1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[0] = x / length;\n        result[1] = y / length;\n        result[2] = z / length;\n        return result;\n    },\n\n    octDecodeVec2s(octs, result) {\n        for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n            let x = octs[i + 0];\n            let y = octs[i + 1];\n            x = (2 * x + 1) / 255;\n            y = (2 * y + 1) / 255;\n            const z = 1 - Math.abs(x) - Math.abs(y);\n            if (z < 0) {\n                x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n                y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n            }\n            const length = Math.sqrt(x * x + y * y + z * z);\n            result[j + 0] = x / length;\n            result[j + 1] = y / length;\n            result[j + 2] = z / length;\n            j += 3;\n        }\n        return result;\n    }\n};\n\nmath.buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n    // TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + \",\" + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                dot = math.dotVec3(normal1, normal2);\n                if (dot > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvbWF0aC5qcz9iNWU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1GQUFtRixHQUFHLGVBQWUsRUFBRSxvQkFBb0IsR0FBRyw0QkFBNEIsRUFBRSxxQkFBcUIsR0FBRyxzQkFBc0IsRUFBRSxvQkFBb0IsR0FBRyxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCO0FBQzFYO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrRUFBK0Usb0JBQW9CO0FBQ25HO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsU0FBUzs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0JBQWtCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxTQUFTLE9BQU87O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsMkJBQTJCOztBQUU3RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qix1QkFBdUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCOztBQUU1RztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjOztBQUV6Qzs7QUFFQTs7QUFFQSwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG9CQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tYXRoL21hdGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTb21lIHRlbXBvcmFyeSB2YXJzIHRvIGhlbHAgYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cbmNvbnN0IGRvdWJsZVByZWNpc2lvbiA9IHRydWU7XG5jb25zdCBGbG9hdEFycmF5VHlwZSA9IGRvdWJsZVByZWNpc2lvbiA/IEZsb2F0NjRBcnJheSA6IEZsb2F0MzJBcnJheTtcblxuY29uc3QgdGVtcE1hdDEgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcE1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuY29uc3QgdGVtcFZlYzQgPSBuZXcgRmxvYXRBcnJheVR5cGUoNCk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBtYXRoID0ge1xuXG4gICAgTUlOX0RPVUJMRTogLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIE1BWF9ET1VCTEU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByYWRpaWFucyBpbiBhIGRlZ3JlZSAoMC4wMTc0NTMyOTI1KS5cbiAgICAgKiBAcHJvcGVydHkgREVHVE9SQURcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIERFR1RPUkFEOiAwLjAxNzQ1MzI5MjUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlZ3JlZXMgaW4gYSByYWRpYW4uXG4gICAgICogQHByb3BlcnR5IFJBRFRPREVHXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBSQURUT0RFRzogNTcuMjk1Nzc5NTEzLFxuXG4gICAgdW5nbG9iYWxpemVPYmplY3RJZChtb2RlbElkLCBnbG9iYWxJZCkge1xuICAgICAgICBjb25zdCBpZHggPSBnbG9iYWxJZC5pbmRleE9mKFwiI1wiKTtcbiAgICAgICAgcmV0dXJuIChpZHggPT09IG1vZGVsSWQubGVuZ3RoICYmIGdsb2JhbElkLnN0YXJ0c1dpdGgobW9kZWxJZCkpID8gZ2xvYmFsSWQuc3Vic3RyaW5nKGlkeCArIDEpIDogZ2xvYmFsSWQ7XG4gICAgfSxcblxuICAgIGdsb2JhbGl6ZU9iamVjdElkKG1vZGVsSWQsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiAobW9kZWxJZCArIFwiI1wiICsgb2JqZWN0SWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjMlxuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgdmVjM1xuICAgICAqIEBwYXJhbSBbdmFsdWVzXSBJbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIHZlYzModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCB2ZWM0XG4gICAgICogQHBhcmFtIFt2YWx1ZXNdIEluaXRpYWwgdmFsdWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgdmVjNCh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgNCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM3gzIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDNcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzeDMgbWF0cml4IHRvIDR4NFxuICAgICAqIEBtZXRob2QgbWF0M1RvTWF0NFxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXguXG4gICAgICogQHBhcmFtIG1hdDQgNHg0IG1hdHJpeFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119XG4gICAgICovXG4gICAgbWF0M1RvTWF0NChtYXQzLCBtYXQ0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXQ0WzBdID0gbWF0M1swXTtcbiAgICAgICAgbWF0NFsxXSA9IG1hdDNbMV07XG4gICAgICAgIG1hdDRbMl0gPSBtYXQzWzJdO1xuICAgICAgICBtYXQ0WzNdID0gMDtcbiAgICAgICAgbWF0NFs0XSA9IG1hdDNbM107XG4gICAgICAgIG1hdDRbNV0gPSBtYXQzWzRdO1xuICAgICAgICBtYXQ0WzZdID0gbWF0M1s1XTtcbiAgICAgICAgbWF0NFs3XSA9IDA7XG4gICAgICAgIG1hdDRbOF0gPSBtYXQzWzZdO1xuICAgICAgICBtYXQ0WzldID0gbWF0M1s3XTtcbiAgICAgICAgbWF0NFsxMF0gPSBtYXQzWzhdO1xuICAgICAgICBtYXQ0WzExXSA9IDA7XG4gICAgICAgIG1hdDRbMTJdID0gMDtcbiAgICAgICAgbWF0NFsxM10gPSAwO1xuICAgICAgICBtYXQ0WzE0XSA9IDA7XG4gICAgICAgIG1hdDRbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG1hdDQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIG1hdDRcbiAgICAgKiBAcGFyYW0gW3ZhbHVlc10gSW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBtYXQ0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCAxNik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgNHg0IG1hdHJpeCB0byAzeDNcbiAgICAgKiBAbWV0aG9kIG1hdDRUb01hdDNcbiAgICAgKiBAcGFyYW0gbWF0NCA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtYXQzIDN4MyBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIG1hdDRUb01hdDMobWF0NCwgbWF0MykgeyAvLyBUT0RPXG4gICAgICAgIC8vcmV0dXJuIG5ldyBGbG9hdEFycmF5VHlwZSh2YWx1ZXMgfHwgOSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiBkb3VibGUtcHJlY2lzaW9uIHZhbHVlcyB0byBhIGxpc3Qgb2YgaGlnaC1wYXJ0IGZsb2F0cyBhbmQgYSBsaXN0IG9mIGxvdy1wYXJ0IGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gZG91YmxlVmFsc1xuICAgICAqIEBwYXJhbSBmbG9hdFZhbHNIaWdoXG4gICAgICogQHBhcmFtIGZsb2F0VmFsc0xvd1xuICAgICAqL1xuICAgIGRvdWJsZXNUb0Zsb2F0cyhkb3VibGVWYWxzLCBmbG9hdFZhbHNIaWdoLCBmbG9hdFZhbHNMb3cpIHtcbiAgICAgICAgY29uc3QgZmxvYXRQYWlyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRvdWJsZVZhbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGguc3BsaXREb3VibGUoZG91YmxlVmFsc1tpXSwgZmxvYXRQYWlyKTtcbiAgICAgICAgICAgIGZsb2F0VmFsc0hpZ2hbaV0gPSBmbG9hdFBhaXJbMF07XG4gICAgICAgICAgICBmbG9hdFZhbHNMb3dbaV0gPSBmbG9hdFBhaXJbMV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgZG91YmxlIHZhbHVlIGludG8gdHdvIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gZmxvYXRQYWlyXG4gICAgICovXG4gICAgc3BsaXREb3VibGUodmFsdWUsIGZsb2F0UGFpcikge1xuICAgICAgICBjb25zdCBoaSA9IEZsb2F0MzJBcnJheS5mcm9tKFt2YWx1ZV0pWzBdO1xuICAgICAgICBjb25zdCBsb3cgPSB2YWx1ZSAtIGhpO1xuICAgICAgICBmbG9hdFBhaXJbMF0gPSBoaTtcbiAgICAgICAgZmxvYXRQYWlyWzFdID0gbG93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFVVSUQuXG4gICAgICogQG1ldGhvZCBjcmVhdGVVVUlEXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4gc3RyaW5nIFRoZSBuZXcgVVVJRFxuICAgICAqL1xuICAgIGNyZWF0ZVVVSUQ6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxmID0ge307XG4gICAgICAgIGNvbnN0IGx1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBsdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgICAgICAgICAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gICAgICAgICAgICByZXR1cm4gYCR7bHV0W2QwICYgMHhmZl0gKyBsdXRbZDAgPj4gOCAmIDB4ZmZdICsgbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBsdXRbZDAgPj4gMjQgJiAweGZmXX0tJHtsdXRbZDEgJiAweGZmXX0ke2x1dFtkMSA+PiA4ICYgMHhmZl19LSR7bHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdfSR7bHV0W2QxID4+IDI0ICYgMHhmZl19LSR7bHV0W2QyICYgMHgzZiB8IDB4ODBdfSR7bHV0W2QyID4+IDggJiAweGZmXX0tJHtsdXRbZDIgPj4gMTYgJiAweGZmXX0ke2x1dFtkMiA+PiAyNCAmIDB4ZmZdfSR7bHV0W2QzICYgMHhmZl19JHtsdXRbZDMgPj4gOCAmIDB4ZmZdfSR7bHV0W2QzID4+IDE2ICYgMHhmZl19JHtsdXRbZDMgPj4gMjQgJiAweGZmXX1gO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgdG8gdGhlIGdpdmVuIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIExvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gQ2xhbXBlZCByZXN1bHQuXG4gICAgICovXG4gICAgY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmxvYXRpbmctcG9pbnQgbW9kdWx1c1xuICAgICAqIEBtZXRob2QgZm1vZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZm1vZChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIm1hdGguZm1vZCA6IEF0dGVtcHRpbmcgdG8gZmluZCBtb2R1bHVzIHdpdGhpbiBuZWdhdGl2ZSByYW5nZSAtIHdvdWxkIGJlIGluZmluaXRlIGxvb3AgLSBpZ25vcmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiIDw9IGEpIHtcbiAgICAgICAgICAgIGEgLT0gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gMy1lbGVtZW50IHZlY3RvcnMgYXJlIHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSB2MVxuICAgICAqIEBwYXJhbSB2MlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbXBhcmVWZWMzKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gKHYxWzBdID09PSB2MlswXSAmJiB2MVsxXSA9PT0gdjJbMV0gJiYgdjFbMl0gPT09IHYyWzJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbmVnYXRlVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVmVjdG9yIHRvIG5lZ2F0ZVxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBuZWdhdGVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gLXZbMF07XG4gICAgICAgIGRlc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IC12WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBuZWdhdGVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gbmVnYXRlXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG5lZ2F0ZVZlYzQodiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IC12WzFdO1xuICAgICAgICBkZXN0WzJdID0gLXZbMl07XG4gICAgICAgIGRlc3RbM10gPSAtdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgdG8gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICsgdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSArIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICsgdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzY2FsYXIgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICsgcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIHRvIGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBhZGRWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhZGRWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSArIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdICsgdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gKyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNjYWxhciB2YWx1ZSB0byBlYWNoIGVsZW1lbnQgb2YgYSB0aHJlZS1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGFkZFZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFkZFZlYzNTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICsgcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSArIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIGZvdXItZWxlbWVudCB2ZWN0b3IgZnJvbSBhbm90aGVyLlxuICAgICAqIEBtZXRob2Qgc3ViVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFZlY3RvciB0byBzdWJ0cmFjdFxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdWJWZWM0KHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAtIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC0gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLSB2WzJdO1xuICAgICAgICBkZXN0WzNdID0gdVszXSAtIHZbM107XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMyh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC0gdlsyXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBvbmUgdHdvLWVsZW1lbnQgdmVjdG9yIGZyb20gYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBWZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViVmVjMih1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAtIHZbMV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdlb21ldHJpYyBtZWFuIG9mIHRoZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZ2VvbWV0cmljTWVhblZlYzJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsuLi5BcnJheShOdW1iZXIpfSB2ZWN0b3JzIFZlYzIgdG8gbWVhblxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IFRoZSBnZW9tZXRyaWMgbWVhbiB2ZWMyXG4gICAgICovXG4gICAgZ2VvbWV0cmljTWVhblZlYzIoLi4udmVjdG9ycykge1xuICAgICAgICBjb25zdCBnZW9tZXRyaWNNZWFuID0gbmV3IEZsb2F0QXJyYXlUeXBlKHZlY3RvcnNbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMF0gKz0gdmVjdG9yc1tpXVswXTtcbiAgICAgICAgICAgIGdlb21ldHJpY01lYW5bMV0gKz0gdmVjdG9yc1tpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyaWNNZWFuWzBdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICBnZW9tZXRyaWNNZWFuWzFdIC89IHZlY3RvcnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cmljTWVhbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGEgc2NhbGFyIHZhbHVlIGZyb20gZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHN1YlZlYzRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN1YlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC0gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLSBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAtIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC0gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZWFjaCBlbGVtZW50IG9mIGEgNC1lbGVtZW50IHZlY3RvciB0byBhIHNjYWxhciB2YWx1ZSBtaW51cyB0aGUgdmFsdWUgb2YgdGhhdCBlbGVtZW50LlxuICAgICAqIEBtZXRob2Qgc3ViU2NhbGFyVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIFRoZSBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHYgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3ViU2NhbGFyVmVjNCh2LCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBvbmUgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYW5vdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB1IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzQodSwgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB1WzBdICogdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHVbMV0gKiB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gdVsyXSAqIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSB1WzNdICogdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgZm91ci1lbGVtZW50IHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAbWV0aG9kIG11bFZlYzM0Y2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgc2NhbGFyXG4gICAgICogQHBhcmFtICB7QXJyYXkoTnVtYmVyKX0gW2Rlc3RdIERlc3RpbmF0aW9uIHZlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5KE51bWJlcil9IGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIG11bFZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMzU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gKiBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBlYWNoIGVsZW1lbnQgb2YgYSB0d28tZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxWZWMyU2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgVGhlIHNjYWxhclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBtdWxWZWMyU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAqIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb25lIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGFub3RoZXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5KE51bWJlcil9IFtkZXN0XSBEZXN0aW5hdGlvbiB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheShOdW1iZXIpfSBkZXN0IGlmIHNwZWNpZmllZCwgdSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdVswXSAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSB1WzFdIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHVbMl0gLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgZm91ci1lbGVtZW50IHZlY3RvciBieSBhbm90aGVyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtBcnJheShOdW1iZXIpfSBbZGVzdF0gRGVzdGluYXRpb24gdmVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXkoTnVtYmVyKX0gZGVzdCBpZiBzcGVjaWZpZWQsIHUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZGl2VmVjNCh1LCB2LCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHVbMF0gLyB2WzBdO1xuICAgICAgICBkZXN0WzFdID0gdVsxXSAvIHZbMV07XG4gICAgICAgIGRlc3RbMl0gPSB1WzJdIC8gdlsyXTtcbiAgICAgICAgZGVzdFszXSA9IHVbM10gLyB2WzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLCByZXR1cm5pbmcgYSBuZXcgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgZGl2U2NhbGFyVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZTY2FsYXJWZWMzKHMsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gcyAvIHZbMF07XG4gICAgICAgIGRlc3RbMV0gPSBzIC8gdlsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHMgLyB2WzJdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2VmVjM1NjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIHMgc2NhbGFyXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBkaXZWZWMzU2NhbGFyKHYsIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gdlswXSAvIHM7XG4gICAgICAgIGRlc3RbMV0gPSB2WzFdIC8gcztcbiAgICAgICAgZGVzdFsyXSA9IHZbMl0gLyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaXZWZWM0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gcyBzY2FsYXJcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlZlYzRTY2FsYXIodiwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSB2WzBdIC8gcztcbiAgICAgICAgZGVzdFsxXSA9IHZbMV0gLyBzO1xuICAgICAgICBkZXN0WzJdID0gdlsyXSAvIHM7XG4gICAgICAgIGRlc3RbM10gPSB2WzNdIC8gcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHNjYWxhciBieSBhIGZvdXItZWxlbWVudCB2ZWN0b3IsIHJldHVybmluZyBhIG5ldyB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaXZTY2FsYXJWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSBzIHNjYWxhclxuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGRpdlNjYWxhclZlYzQocywgdiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBzIC8gdlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHMgLyB2WzFdO1xuICAgICAgICBkZXN0WzJdID0gcyAvIHZbMl07XG4gICAgICAgIGRlc3RbM10gPSBzIC8gdlszXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBmb3VyLWVsZW1lbnQgdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFZlYzRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB1IEZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBTZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBkb3RWZWM0KHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdICsgdVsyXSAqIHZbMl0gKyB1WzNdICogdlszXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIGZvdXItZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBjcm9zcyBwcm9kdWN0XG4gICAgICovXG4gICAgY3Jvc3MzVmVjNCh1LCB2KSB7XG4gICAgICAgIGNvbnN0IHUwID0gdVswXTtcbiAgICAgICAgY29uc3QgdTEgPSB1WzFdO1xuICAgICAgICBjb25zdCB1MiA9IHVbMl07XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB1MSAqIHYyIC0gdTIgKiB2MSxcbiAgICAgICAgICAgIHUyICogdjAgLSB1MCAqIHYyLFxuICAgICAgICAgICAgdTAgKiB2MSAtIHUxICogdjAsXG4gICAgICAgICAgICAwLjBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB0aHJlZS1lbGVtZW50IHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBjcm9zczNWZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdSBGaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgU2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGNyb3NzIHByb2R1Y3RcbiAgICAgKi9cbiAgICBjcm9zczNWZWMzKHUsIHYsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gdVswXTtcbiAgICAgICAgY29uc3QgeSA9IHVbMV07XG4gICAgICAgIGNvbnN0IHogPSB1WzJdO1xuICAgICAgICBjb25zdCB4MiA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkyID0gdlsxXTtcbiAgICAgICAgY29uc3QgejIgPSB2WzJdO1xuICAgICAgICBkZXN0WzBdID0geSAqIHoyIC0geiAqIHkyO1xuICAgICAgICBkZXN0WzFdID0geiAqIHgyIC0geCAqIHoyO1xuICAgICAgICBkZXN0WzJdID0geCAqIHkyIC0geSAqIHgyO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG5cbiAgICBzcUxlblZlYzQodikgeyAvLyBUT0RPXG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzQodiwgdik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjNCh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzQodikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdGhyZWUtZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzModSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0gKyB1WzJdICogdlsyXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB0d28tZWxlbWVudCB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90VmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHUgRmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheShOdW1iZXIpfSB2IFNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGRvdFZlYzIodSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pO1xuICAgIH0sXG5cblxuICAgIHNxTGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmRvdFZlYzModiwgdik7XG4gICAgfSxcblxuXG4gICAgc3FMZW5WZWMyKHYpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguZG90VmVjMih2LCB2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBsZW5WZWMzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXkoTnVtYmVyKX0gdiBUaGUgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgbGVuZ3RoXG4gICAgICovXG4gICAgbGVuVmVjMyh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcUxlblZlYzModikpO1xuICAgIH0sXG5cbiAgICBkaXN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh2LCB3KSA9PiBtYXRoLmxlblZlYzMobWF0aC5zdWJWZWMzKHYsIHcsIHZlYykpO1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgdHdvLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbGVuVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5KE51bWJlcil9IHYgVGhlIHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIGxlbmd0aFxuICAgICAqL1xuICAgIGxlblZlYzIodikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG1hdGguc3FMZW5WZWMyKHYpKTtcbiAgICB9LFxuXG4gICAgZGlzdFZlYzI6ICgoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ZWMgPSBuZXcgRmxvYXRBcnJheVR5cGUoMik7XG4gICAgICAgIHJldHVybiAodiwgdykgPT4gbWF0aC5sZW5WZWMyKG1hdGguc3ViVmVjMih2LCB3LCB2ZWMpKTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcmNwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gdiB2ZWMzXG4gICAgICogQHBhcmFtIGRlc3QgdmVjMyAtIG9wdGlvbmFsIGRlc3RpbmF0aW9uXG4gICAgICogQHJldHVybiBbXSBkZXN0IGlmIHNwZWNpZmllZCwgdiBvdGhlcndpc2VcbiAgICAgKlxuICAgICAqL1xuICAgIHJjcFZlYzModiwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5kaXZTY2FsYXJWZWMzKDEuMCwgdiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yXG4gICAgICogQG1ldGhvZCBub3JtYWxpemVWZWM0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB2IHZlYzRcbiAgICAgKiBAcGFyYW0gZGVzdCB2ZWM0IC0gb3B0aW9uYWwgZGVzdGluYXRpb25cbiAgICAgKiBAcmV0dXJuIFtdIGRlc3QgaWYgc3BlY2lmaWVkLCB2IG90aGVyd2lzZVxuICAgICAqXG4gICAgICovXG4gICAgbm9ybWFsaXplVmVjNCh2LCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IGYgPSAxLjAgLyBtYXRoLmxlblZlYzQodik7XG4gICAgICAgIHJldHVybiBtYXRoLm11bFZlYzRTY2FsYXIodiwgZiwgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB0aHJlZS1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMzKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMyh2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjM1NjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhIHR3by1lbGVtZW50IHZlY3RvclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplVmVjMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBub3JtYWxpemVWZWMyKHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIG1hdGgubGVuVmVjMih2KTtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsVmVjMlNjYWxhcih2LCBmLCBkZXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAqIEBtZXRob2QgYW5nbGVWZWMzXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcGFyYW0gd1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYW5nbGVWZWMzKHYsIHcpIHtcbiAgICAgICAgbGV0IHRoZXRhID0gbWF0aC5kb3RWZWMzKHYsIHcpIC8gKE1hdGguc3FydChtYXRoLnNxTGVuVmVjMyh2KSAqIG1hdGguc3FMZW5WZWMzKHcpKSk7XG4gICAgICAgIHRoZXRhID0gdGhldGEgPCAtMSA/IC0xIDogKHRoZXRhID4gMSA/IDEgOiB0aGV0YSk7ICAvLyBDbGFtcCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3ModGhldGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgZnJvbSB0aGUgcm90YXRpb24gcGFydCBvZiBhIHNpeHRlZW4tZWxlbWVudCBtYXRyaXguXG4gICAgICogQHBhcmFtIG1cbiAgICAgKiBAcGFyYW0gZGVzdFxuICAgICAqL1xuICAgIHZlYzNGcm9tTWF0NFNjYWxlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcblxuICAgICAgICByZXR1cm4gKG0sIGRlc3QpID0+IHtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzBdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzJdO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzRdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzVdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzZdO1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0aC5sZW5WZWMzKHRlbXBWZWMzKTtcblxuICAgICAgICAgICAgdGVtcFZlYzNbMF0gPSBtWzhdO1xuICAgICAgICAgICAgdGVtcFZlYzNbMV0gPSBtWzldO1xuICAgICAgICAgICAgdGVtcFZlYzNbMl0gPSBtWzEwXTtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdGgubGVuVmVjMyh0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gbi1lbGVtZW50IHZlY3RvciB0byBhIEpTT04tc2VyaWFsaXphYmxlXG4gICAgICogYXJyYXkgd2l0aCB2YWx1ZXMgcm91bmRlZCB0byB0d28gZGVjaW1hbCBwbGFjZXMuXG4gICAgICovXG4gICAgdmVjVG9BcnJheTogKCgoKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYgKiAxMDAwMDApIC8gMTAwMDAwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdiA9PiB7XG4gICAgICAgICAgICB2ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZbaV0gPSB0cnVuYyh2W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSAzLWVsZW1lbnQgdmVjdG9yIGZyb20gYW4gYXJyYXkgdG8gYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGBgYGB7eDo5OTksIHk6OTk5LCB6Ojk5OX1gYGBgLlxuICAgICAqIEBwYXJhbSBhcnJcbiAgICAgKiBAcmV0dXJucyB7e3g6ICosIHk6ICosIHo6ICp9fVxuICAgICAqL1xuICAgIHh5ekFycmF5VG9PYmplY3QoYXJyKSB7XG4gICAgICAgIHJldHVybiB7XCJ4XCI6IGFyclswXSwgXCJ5XCI6IGFyclsxXSwgXCJ6XCI6IGFyclsyXX07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgMy1lbGVtZW50IHZlY3RvciBvYmplY3Qgb2YgdGhlIGZvcm0gYGBgYHt4Ojk5OSwgeTo5OTksIHo6OTk5fWBgYGAgdG8gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSAgW2FycnldXG4gICAgICogQHJldHVybnMgeypbXX1cbiAgICAgKi9cbiAgICB4eXpPYmplY3RUb0FycmF5KHh5eiwgYXJyeSkge1xuICAgICAgICBhcnJ5ID0gYXJyeSB8fCBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGFycnlbMF0gPSB4eXoueDtcbiAgICAgICAgYXJyeVsxXSA9IHh5ei55O1xuICAgICAgICBhcnJ5WzJdID0geHl6Lno7XG4gICAgICAgIHJldHVybiBhcnJ5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEdXBsaWNhdGVzIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGR1cE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZHVwTWF0NChtKSB7XG4gICAgICAgIHJldHVybiBtLnNsaWNlKDAsIDE2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYSAzeDMgbWF0cml4IGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgbWF0NFRvM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBtYXQ0VG8zKG0pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sXG4gICAgICAgICAgICBtWzRdLCBtWzVdLCBtWzZdLFxuICAgICAgICAgICAgbVs4XSwgbVs5XSwgbVsxMF1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUuXG4gICAgICogQG1ldGhvZCBtNHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbTRzKHMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHMsIHMsIHMsIHMsXG4gICAgICAgICAgICBzLCBzLCBzLCBzLFxuICAgICAgICAgICAgcywgcywgcywgcyxcbiAgICAgICAgICAgIHMsIHMsIHMsIHNcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIHplcm8uXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9aZXJvZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvWmVyb2VzKCkge1xuICAgICAgICByZXR1cm4gbWF0aC5tNHMoMC4wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBtYXRyaXggd2l0aCBlYWNoIGVsZW1lbnQgc2V0IHRvIDEuMC5cbiAgICAgKiBAbWV0aG9kIHNldE1hdDRUb09uZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2V0TWF0NFRvT25lcygpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubTRzKDEuMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZWFjaCBlbGVtZW50IHNldCB0byAxLjAuXG4gICAgICogQG1ldGhvZCBzZXRNYXQ0VG9PbmVzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHYodikge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKFtcbiAgICAgICAgICAgIHZbMF0sIDAuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgICAwLjAsIHZbMV0sIDAuMCwgMC4wLFxuICAgICAgICAgICAgMC4wLCAwLjAsIHZbMl0sIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIHZbM11cbiAgICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NGMoeCwgeSwgeiwgdykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDR2KFt4LCB5LCB6LCB3XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgbWF0cml4IHdpdGggZGlhZ29uYWwgZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaWFnb25hbE1hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRpYWdvbmFsTWF0NHMocykge1xuICAgICAgICByZXR1cm4gbWF0aC5kaWFnb25hbE1hdDRjKHMsIHMsIHMsIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGlkZW50aXR5TWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpZGVudGl0eU1hdDQobWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuICAgICAgICBtYXRbM10gPSAwLjA7XG5cbiAgICAgICAgbWF0WzRdID0gMC4wO1xuICAgICAgICBtYXRbNV0gPSAxLjA7XG4gICAgICAgIG1hdFs2XSA9IDAuMDtcbiAgICAgICAgbWF0WzddID0gMC4wO1xuXG4gICAgICAgIG1hdFs4XSA9IDAuMDtcbiAgICAgICAgbWF0WzldID0gMC4wO1xuICAgICAgICBtYXRbMTBdID0gMS4wO1xuICAgICAgICBtYXRbMTFdID0gMC4wO1xuXG4gICAgICAgIG1hdFsxMl0gPSAwLjA7XG4gICAgICAgIG1hdFsxM10gPSAwLjA7XG4gICAgICAgIG1hdFsxNF0gPSAwLjA7XG4gICAgICAgIG1hdFsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG1hdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDN4MyBpZGVudGl0eSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBpZGVudGl0eU1hdDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaWRlbnRpdHlNYXQzKG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KSkge1xuICAgICAgICBtYXRbMF0gPSAxLjA7XG4gICAgICAgIG1hdFsxXSA9IDAuMDtcbiAgICAgICAgbWF0WzJdID0gMC4wO1xuXG4gICAgICAgIG1hdFszXSA9IDAuMDtcbiAgICAgICAgbWF0WzRdID0gMS4wO1xuICAgICAgICBtYXRbNV0gPSAwLjA7XG5cbiAgICAgICAgbWF0WzZdID0gMC4wO1xuICAgICAgICBtYXRbN10gPSAwLjA7XG4gICAgICAgIG1hdFs4XSA9IDEuMDtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeCBpcyB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqIEBtZXRob2QgaXNJZGVudGl0eU1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNJZGVudGl0eU1hdDQobSkge1xuICAgICAgICBpZiAobVswXSAhPT0gMS4wIHx8IG1bMV0gIT09IDAuMCB8fCBtWzJdICE9PSAwLjAgfHwgbVszXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzRdICE9PSAwLjAgfHwgbVs1XSAhPT0gMS4wIHx8IG1bNl0gIT09IDAuMCB8fCBtWzddICE9PSAwLjAgfHxcbiAgICAgICAgICAgIG1bOF0gIT09IDAuMCB8fCBtWzldICE9PSAwLjAgfHwgbVsxMF0gIT09IDEuMCB8fCBtWzExXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICBtWzEyXSAhPT0gMC4wIHx8IG1bMTNdICE9PSAwLjAgfHwgbVsxNF0gIT09IDAuMCB8fCBtWzE1XSAhPT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBuZWdhdGVNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG5lZ2F0ZU1hdDQobSwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSAtbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1tWzFdO1xuICAgICAgICBkZXN0WzJdID0gLW1bMl07XG4gICAgICAgIGRlc3RbM10gPSAtbVszXTtcbiAgICAgICAgZGVzdFs0XSA9IC1tWzRdO1xuICAgICAgICBkZXN0WzVdID0gLW1bNV07XG4gICAgICAgIGRlc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgZGVzdFs3XSA9IC1tWzddO1xuICAgICAgICBkZXN0WzhdID0gLW1bOF07XG4gICAgICAgIGRlc3RbOV0gPSAtbVs5XTtcbiAgICAgICAgZGVzdFsxMF0gPSAtbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gLW1bMTFdO1xuICAgICAgICBkZXN0WzEyXSA9IC1tWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSAtbVsxM107XG4gICAgICAgIGRlc3RbMTRdID0gLW1bMTRdO1xuICAgICAgICBkZXN0WzE1XSA9IC1tWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIDR4NCBtYXRyaWNlcyB0b2dldGhlci5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBkZXN0WzFdID0gYVsxXSArIGJbMV07XG4gICAgICAgIGRlc3RbMl0gPSBhWzJdICsgYlsyXTtcbiAgICAgICAgZGVzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICBkZXN0WzRdID0gYVs0XSArIGJbNF07XG4gICAgICAgIGRlc3RbNV0gPSBhWzVdICsgYls1XTtcbiAgICAgICAgZGVzdFs2XSA9IGFbNl0gKyBiWzZdO1xuICAgICAgICBkZXN0WzddID0gYVs3XSArIGJbN107XG4gICAgICAgIGRlc3RbOF0gPSBhWzhdICsgYls4XTtcbiAgICAgICAgZGVzdFs5XSA9IGFbOV0gKyBiWzldO1xuICAgICAgICBkZXN0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICAgICAgZGVzdFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gICAgICAgIGRlc3RbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICAgICAgZGVzdFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZE1hdDRTY2FsYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkTWF0NFNjYWxhcihtLCBzLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKyBzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSArIHM7XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdICsgcztcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKyBzO1xuICAgICAgICBkZXN0WzRdID0gbVs0XSArIHM7XG4gICAgICAgIGRlc3RbNV0gPSBtWzVdICsgcztcbiAgICAgICAgZGVzdFs2XSA9IG1bNl0gKyBzO1xuICAgICAgICBkZXN0WzddID0gbVs3XSArIHM7XG4gICAgICAgIGRlc3RbOF0gPSBtWzhdICsgcztcbiAgICAgICAgZGVzdFs5XSA9IG1bOV0gKyBzO1xuICAgICAgICBkZXN0WzEwXSA9IG1bMTBdICsgcztcbiAgICAgICAgZGVzdFsxMV0gPSBtWzExXSArIHM7XG4gICAgICAgIGRlc3RbMTJdID0gbVsxMl0gKyBzO1xuICAgICAgICBkZXN0WzEzXSA9IG1bMTNdICsgcztcbiAgICAgICAgZGVzdFsxNF0gPSBtWzE0XSArIHM7XG4gICAgICAgIGRlc3RbMTVdID0gbVsxNV0gKyBzO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGFkZFNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYWRkU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmFkZE1hdDRTY2FsYXIobSwgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgc2Vjb25kIDR4NCBtYXRyaXggZnJvbSB0aGUgZmlyc3QuXG4gICAgICogQG1ldGhvZCBzdWJNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN1Yk1hdDQoYSwgYiwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGRlc3RbM10gPSBhWzNdIC0gYlszXTtcbiAgICAgICAgZGVzdFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgICAgICBkZXN0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgICAgIGRlc3RbNl0gPSBhWzZdIC0gYls2XTtcbiAgICAgICAgZGVzdFs3XSA9IGFbN10gLSBiWzddO1xuICAgICAgICBkZXN0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgICAgIGRlc3RbOV0gPSBhWzldIC0gYls5XTtcbiAgICAgICAgZGVzdFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICAgICAgICBkZXN0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgICAgICAgZGVzdFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICAgICAgICBkZXN0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gc2NhbGFyIGZyb20gZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc3ViTWF0NFNjYWxhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdWJNYXQ0U2NhbGFyKG0sIHMsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0WzBdID0gbVswXSAtIHM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdIC0gcztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gLSBzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAtIHM7XG4gICAgICAgIGRlc3RbNF0gPSBtWzRdIC0gcztcbiAgICAgICAgZGVzdFs1XSA9IG1bNV0gLSBzO1xuICAgICAgICBkZXN0WzZdID0gbVs2XSAtIHM7XG4gICAgICAgIGRlc3RbN10gPSBtWzddIC0gcztcbiAgICAgICAgZGVzdFs4XSA9IG1bOF0gLSBzO1xuICAgICAgICBkZXN0WzldID0gbVs5XSAtIHM7XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF0gLSBzO1xuICAgICAgICBkZXN0WzExXSA9IG1bMTFdIC0gcztcbiAgICAgICAgZGVzdFsxMl0gPSBtWzEyXSAtIHM7XG4gICAgICAgIGRlc3RbMTNdID0gbVsxM10gLSBzO1xuICAgICAgICBkZXN0WzE0XSA9IG1bMTRdIC0gcztcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XSAtIHM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHN1YlNjYWxhck1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3ViU2NhbGFyTWF0NChzLCBtLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG07XG4gICAgICAgIH1cbiAgICAgICAgZGVzdFswXSA9IHMgLSBtWzBdO1xuICAgICAgICBkZXN0WzFdID0gcyAtIG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBzIC0gbVsyXTtcbiAgICAgICAgZGVzdFszXSA9IHMgLSBtWzNdO1xuICAgICAgICBkZXN0WzRdID0gcyAtIG1bNF07XG4gICAgICAgIGRlc3RbNV0gPSBzIC0gbVs1XTtcbiAgICAgICAgZGVzdFs2XSA9IHMgLSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gcyAtIG1bN107XG4gICAgICAgIGRlc3RbOF0gPSBzIC0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IHMgLSBtWzldO1xuICAgICAgICBkZXN0WzEwXSA9IHMgLSBtWzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBzIC0gbVsxMV07XG4gICAgICAgIGRlc3RbMTJdID0gcyAtIG1bMTJdO1xuICAgICAgICBkZXN0WzEzXSA9IHMgLSBtWzEzXTtcbiAgICAgICAgZGVzdFsxNF0gPSBzIC0gbVsxNF07XG4gICAgICAgIGRlc3RbMTVdID0gcyAtIG1bMTVdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgdHdvIGdpdmVuIDR4NCBtYXRyaXggYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NChhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gYVswXTtcblxuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzddO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzldO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdO1xuICAgICAgICBjb25zdCBiMDAgPSBiWzBdO1xuICAgICAgICBjb25zdCBiMDEgPSBiWzFdO1xuICAgICAgICBjb25zdCBiMDIgPSBiWzJdO1xuICAgICAgICBjb25zdCBiMDMgPSBiWzNdO1xuICAgICAgICBjb25zdCBiMTAgPSBiWzRdO1xuICAgICAgICBjb25zdCBiMTEgPSBiWzVdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzZdO1xuICAgICAgICBjb25zdCBiMTMgPSBiWzddO1xuICAgICAgICBjb25zdCBiMjAgPSBiWzhdO1xuICAgICAgICBjb25zdCBiMjEgPSBiWzldO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzEwXTtcbiAgICAgICAgY29uc3QgYjIzID0gYlsxMV07XG4gICAgICAgIGNvbnN0IGIzMCA9IGJbMTJdO1xuICAgICAgICBjb25zdCBiMzEgPSBiWzEzXTtcbiAgICAgICAgY29uc3QgYjMyID0gYlsxNF07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbMTVdO1xuXG4gICAgICAgIGRlc3RbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzA7XG4gICAgICAgIGRlc3RbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzE7XG4gICAgICAgIGRlc3RbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzI7XG4gICAgICAgIGRlc3RbM10gPSBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzM7XG4gICAgICAgIGRlc3RbNF0gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzA7XG4gICAgICAgIGRlc3RbNV0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzE7XG4gICAgICAgIGRlc3RbNl0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzI7XG4gICAgICAgIGRlc3RbN10gPSBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzM7XG4gICAgICAgIGRlc3RbOF0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzA7XG4gICAgICAgIGRlc3RbOV0gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzE7XG4gICAgICAgIGRlc3RbMTBdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyICsgYjIzICogYTMyO1xuICAgICAgICBkZXN0WzExXSA9IGIyMCAqIGEwMyArIGIyMSAqIGExMyArIGIyMiAqIGEyMyArIGIyMyAqIGEzMztcbiAgICAgICAgZGVzdFsxMl0gPSBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzA7XG4gICAgICAgIGRlc3RbMTNdID0gYjMwICogYTAxICsgYjMxICogYTExICsgYjMyICogYTIxICsgYjMzICogYTMxO1xuICAgICAgICBkZXN0WzE0XSA9IGIzMCAqIGEwMiArIGIzMSAqIGExMiArIGIzMiAqIGEyMiArIGIzMyAqIGEzMjtcbiAgICAgICAgZGVzdFsxNV0gPSBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIHR3byBnaXZlbiAzeDMgbWF0cmljZXMgYnkgZWFjaCBvdGhlci5cbiAgICAgKiBAbWV0aG9kIG11bE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0MyhhLCBiLCBkZXN0KSB7XG4gICAgICAgIGlmICghZGVzdCkge1xuICAgICAgICAgICAgZGVzdCA9IG5ldyBGbG9hdEFycmF5VHlwZSg5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGExMSA9IGFbMF07XG4gICAgICAgIGNvbnN0IGExMiA9IGFbM107XG4gICAgICAgIGNvbnN0IGExMyA9IGFbNl07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEyMiA9IGFbNF07XG4gICAgICAgIGNvbnN0IGEyMyA9IGFbN107XG4gICAgICAgIGNvbnN0IGEzMSA9IGFbMl07XG4gICAgICAgIGNvbnN0IGEzMiA9IGFbNV07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbOF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbMF07XG4gICAgICAgIGNvbnN0IGIxMiA9IGJbM107XG4gICAgICAgIGNvbnN0IGIxMyA9IGJbNl07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGIyMiA9IGJbNF07XG4gICAgICAgIGNvbnN0IGIyMyA9IGJbN107XG4gICAgICAgIGNvbnN0IGIzMSA9IGJbMl07XG4gICAgICAgIGNvbnN0IGIzMiA9IGJbNV07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbOF07XG5cbiAgICAgICAgZGVzdFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcbiAgICAgICAgZGVzdFszXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcbiAgICAgICAgZGVzdFs2XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMztcblxuICAgICAgICBkZXN0WzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xuICAgICAgICBkZXN0WzRdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuICAgICAgICBkZXN0WzddID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xuXG4gICAgICAgIGRlc3RbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG4gICAgICAgIGRlc3RbNV0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG4gICAgICAgIGRlc3RbOF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBnaXZlbiA0eDQgbWF0cml4IGJ5IHRoZSBnaXZlbiBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0U2NhbGFyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG11bE1hdDRTY2FsYXIobSwgcywgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogcztcbiAgICAgICAgZGVzdFsxXSA9IG1bMV0gKiBzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogcztcbiAgICAgICAgZGVzdFs0XSA9IG1bNF0gKiBzO1xuICAgICAgICBkZXN0WzVdID0gbVs1XSAqIHM7XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdICogcztcbiAgICAgICAgZGVzdFs3XSA9IG1bN10gKiBzO1xuICAgICAgICBkZXN0WzhdID0gbVs4XSAqIHM7XG4gICAgICAgIGRlc3RbOV0gPSBtWzldICogcztcbiAgICAgICAgZGVzdFsxMF0gPSBtWzEwXSAqIHM7XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV0gKiBzO1xuICAgICAgICBkZXN0WzEyXSA9IG1bMTJdICogcztcbiAgICAgICAgZGVzdFsxM10gPSBtWzEzXSAqIHM7XG4gICAgICAgIGRlc3RbMTRdID0gbVsxNF0gKiBzO1xuICAgICAgICBkZXN0WzE1XSA9IG1bMTVdICogcztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIDR4NCBtYXRyaXggYnkgdGhlIGdpdmVuIGZvdXItZWxlbWVudCB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBtdWxNYXQ0djRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgbXVsTWF0NHY0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIGRlc3RbMF0gPSBtWzBdICogdjAgKyBtWzRdICogdjEgKyBtWzhdICogdjIgKyBtWzEyXSAqIHYzO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHYwICsgbVs1XSAqIHYxICsgbVs5XSAqIHYyICsgbVsxM10gKiB2MztcbiAgICAgICAgZGVzdFsyXSA9IG1bMl0gKiB2MCArIG1bNl0gKiB2MSArIG1bMTBdICogdjIgKyBtWzE0XSAqIHYzO1xuICAgICAgICBkZXN0WzNdID0gbVszXSAqIHYwICsgbVs3XSAqIHYxICsgbVsxMV0gKiB2MiArIG1bMTVdICogdjM7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNwb3NlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc3Bvc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgICAgIGNvbnN0IG00ID0gbWF0WzRdO1xuXG4gICAgICAgIGNvbnN0IG0xNCA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IG04ID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbMTNdO1xuICAgICAgICBjb25zdCBtMTIgPSBtYXRbMTJdO1xuICAgICAgICBjb25zdCBtOSA9IG1hdFs5XTtcbiAgICAgICAgaWYgKCFkZXN0IHx8IG1hdCA9PT0gZGVzdCkge1xuICAgICAgICAgICAgY29uc3QgYTAxID0gbWF0WzFdO1xuICAgICAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICAgICAgY29uc3QgYTAzID0gbWF0WzNdO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gbWF0WzZdO1xuICAgICAgICAgICAgY29uc3QgYTEzID0gbWF0WzddO1xuICAgICAgICAgICAgY29uc3QgYTIzID0gbWF0WzExXTtcbiAgICAgICAgICAgIG1hdFsxXSA9IG00O1xuICAgICAgICAgICAgbWF0WzJdID0gbTg7XG4gICAgICAgICAgICBtYXRbM10gPSBtMTI7XG4gICAgICAgICAgICBtYXRbNF0gPSBhMDE7XG4gICAgICAgICAgICBtYXRbNl0gPSBtOTtcbiAgICAgICAgICAgIG1hdFs3XSA9IG0xMztcbiAgICAgICAgICAgIG1hdFs4XSA9IGEwMjtcbiAgICAgICAgICAgIG1hdFs5XSA9IGExMjtcbiAgICAgICAgICAgIG1hdFsxMV0gPSBtMTQ7XG4gICAgICAgICAgICBtYXRbMTJdID0gYTAzO1xuICAgICAgICAgICAgbWF0WzEzXSA9IGExMztcbiAgICAgICAgICAgIG1hdFsxNF0gPSBhMjM7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9XG4gICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgIGRlc3RbMV0gPSBtNDtcbiAgICAgICAgZGVzdFsyXSA9IG04O1xuICAgICAgICBkZXN0WzNdID0gbTEyO1xuICAgICAgICBkZXN0WzRdID0gbWF0WzFdO1xuICAgICAgICBkZXN0WzVdID0gbWF0WzVdO1xuICAgICAgICBkZXN0WzZdID0gbTk7XG4gICAgICAgIGRlc3RbN10gPSBtMTM7XG4gICAgICAgIGRlc3RbOF0gPSBtYXRbMl07XG4gICAgICAgIGRlc3RbOV0gPSBtYXRbNl07XG4gICAgICAgIGRlc3RbMTBdID0gbWF0WzEwXTtcbiAgICAgICAgZGVzdFsxMV0gPSBtMTQ7XG4gICAgICAgIGRlc3RbMTJdID0gbWF0WzNdO1xuICAgICAgICBkZXN0WzEzXSA9IG1hdFs3XTtcbiAgICAgICAgZGVzdFsxNF0gPSBtYXRbMTFdO1xuICAgICAgICBkZXN0WzE1XSA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiAzeDMgbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0cmFuc3Bvc2VNYXQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zcG9zZU1hdDMobWF0LCBkZXN0KSB7XG4gICAgICAgIGlmIChkZXN0ID09PSBtYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgICAgIGNvbnN0IGEwMiA9IG1hdFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IG1hdFs1XTtcbiAgICAgICAgICAgIGRlc3RbMV0gPSBtYXRbM107XG4gICAgICAgICAgICBkZXN0WzJdID0gbWF0WzZdO1xuICAgICAgICAgICAgZGVzdFszXSA9IGEwMTtcbiAgICAgICAgICAgIGRlc3RbNV0gPSBtYXRbN107XG4gICAgICAgICAgICBkZXN0WzZdID0gYTAyO1xuICAgICAgICAgICAgZGVzdFs3XSA9IGExMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RbMF0gPSBtYXRbMF07XG4gICAgICAgICAgICBkZXN0WzFdID0gbWF0WzNdO1xuICAgICAgICAgICAgZGVzdFsyXSA9IG1hdFs2XTtcbiAgICAgICAgICAgIGRlc3RbM10gPSBtYXRbMV07XG4gICAgICAgICAgICBkZXN0WzRdID0gbWF0WzRdO1xuICAgICAgICAgICAgZGVzdFs1XSA9IG1hdFs3XTtcbiAgICAgICAgICAgIGRlc3RbNl0gPSBtYXRbMl07XG4gICAgICAgICAgICBkZXN0WzddID0gbWF0WzVdO1xuICAgICAgICAgICAgZGVzdFs4XSA9IG1hdFs4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCBkZXRlcm1pbmFudE1hdDRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZGV0ZXJtaW5hbnRNYXQ0KG1hdCkge1xuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIHJldHVybiBhMzAgKiBhMjEgKiBhMTIgKiBhMDMgLSBhMjAgKiBhMzEgKiBhMTIgKiBhMDMgLSBhMzAgKiBhMTEgKiBhMjIgKiBhMDMgKyBhMTAgKiBhMzEgKiBhMjIgKiBhMDMgK1xuICAgICAgICAgICAgYTIwICogYTExICogYTMyICogYTAzIC0gYTEwICogYTIxICogYTMyICogYTAzIC0gYTMwICogYTIxICogYTAyICogYTEzICsgYTIwICogYTMxICogYTAyICogYTEzICtcbiAgICAgICAgICAgIGEzMCAqIGEwMSAqIGEyMiAqIGExMyAtIGEwMCAqIGEzMSAqIGEyMiAqIGExMyAtIGEyMCAqIGEwMSAqIGEzMiAqIGExMyArIGEwMCAqIGEyMSAqIGEzMiAqIGExMyArXG4gICAgICAgICAgICBhMzAgKiBhMTEgKiBhMDIgKiBhMjMgLSBhMTAgKiBhMzEgKiBhMDIgKiBhMjMgLSBhMzAgKiBhMDEgKiBhMTIgKiBhMjMgKyBhMDAgKiBhMzEgKiBhMTIgKiBhMjMgK1xuICAgICAgICAgICAgYTEwICogYTAxICogYTMyICogYTIzIC0gYTAwICogYTExICogYTMyICogYTIzIC0gYTIwICogYTExICogYTAyICogYTMzICsgYTEwICogYTIxICogYTAyICogYTMzICtcbiAgICAgICAgICAgIGEyMCAqIGEwMSAqIGExMiAqIGEzMyAtIGEwMCAqIGEyMSAqIGExMiAqIGEzMyAtIGExMCAqIGEwMSAqIGEyMiAqIGEzMyArIGEwMCAqIGExMSAqIGEyMiAqIGEzMztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGludmVyc2VNYXQ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGludmVyc2VNYXQ0KG1hdCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgbWF0cml4IHZhbHVlcyAobWFrZXMgZm9yIGh1Z2Ugc3BlZWQgaW5jcmVhc2VzISlcbiAgICAgICAgY29uc3QgYTAwID0gbWF0WzBdO1xuXG4gICAgICAgIGNvbnN0IGEwMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gbWF0WzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBtYXRbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG1hdFs0XTtcbiAgICAgICAgY29uc3QgYTExID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBtYXRbNl07XG4gICAgICAgIGNvbnN0IGExMyA9IG1hdFs3XTtcbiAgICAgICAgY29uc3QgYTIwID0gbWF0WzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG1hdFsxMF07XG4gICAgICAgIGNvbnN0IGEyMyA9IG1hdFsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IG1hdFsxMl07XG4gICAgICAgIGNvbnN0IGEzMSA9IG1hdFsxM107XG4gICAgICAgIGNvbnN0IGEzMiA9IG1hdFsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IG1hdFsxNV07XG4gICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCAoaW5saW5lZCB0byBhdm9pZCBkb3VibGUtY2FjaGluZylcbiAgICAgICAgY29uc3QgaW52RGV0ID0gMSAvIChiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgICAgIGRlc3RbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxXSA9ICgtYTAxICogYjExICsgYTAyICogYjEwIC0gYTAzICogYjA5KSAqIGludkRldDtcbiAgICAgICAgZGVzdFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzNdID0gKC1hMjEgKiBiMDUgKyBhMjIgKiBiMDQgLSBhMjMgKiBiMDMpICogaW52RGV0O1xuICAgICAgICBkZXN0WzRdID0gKC1hMTAgKiBiMTEgKyBhMTIgKiBiMDggLSBhMTMgKiBiMDcpICogaW52RGV0O1xuICAgICAgICBkZXN0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbNl0gPSAoLWEzMCAqIGIwNSArIGEzMiAqIGIwMiAtIGEzMyAqIGIwMSkgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGludkRldDtcbiAgICAgICAgZGVzdFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzldID0gKC1hMDAgKiBiMTAgKyBhMDEgKiBiMDggLSBhMDMgKiBiMDYpICogaW52RGV0O1xuICAgICAgICBkZXN0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzExXSA9ICgtYTIwICogYjA0ICsgYTIxICogYjAyIC0gYTIzICogYjAwKSAqIGludkRldDtcbiAgICAgICAgZGVzdFsxMl0gPSAoLWExMCAqIGIwOSArIGExMSAqIGIwNyAtIGExMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBpbnZEZXQ7XG4gICAgICAgIGRlc3RbMTRdID0gKC1hMzAgKiBiMDMgKyBhMzEgKiBiMDEgLSBhMzIgKiBiMDApICogaW52RGV0O1xuICAgICAgICBkZXN0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogaW52RGV0O1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFjZSBvZiB0aGUgZ2l2ZW4gNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYWNlTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFjZU1hdDQobSkge1xuICAgICAgICByZXR1cm4gKG1bMF0gKyBtWzVdICsgbVsxMF0gKyBtWzE1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDR2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgbVsxMl0gPSB2WzBdO1xuICAgICAgICBtWzEzXSA9IHZbMV07XG4gICAgICAgIG1bMTRdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0M1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDN2KHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgbSA9IGRlc3QgfHwgbWF0aC5pZGVudGl0eU1hdDMoKTtcbiAgICAgICAgbVs2XSA9IHZbMF07XG4gICAgICAgIG1bN10gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRpb25NYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2xhdGlvbk1hdDRjOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgeHl6ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICByZXR1cm4gKHgsIHksIHosIGRlc3QpID0+IHtcbiAgICAgICAgICAgIHh5elswXSA9IHg7XG4gICAgICAgICAgICB4eXpbMV0gPSB5O1xuICAgICAgICAgICAgeHl6WzJdID0gejtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0aW9uTWF0NHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNsYXRpb25NYXQ0cyhzLCBkZXN0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0aW9uTWF0NGMocywgcywgcywgZGVzdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWF0NHYoeHl6LCBtKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnRyYW5zbGF0ZU1hdDRjKHh5elswXSwgeHl6WzFdLCB4eXpbMl0sIG0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnRseSBwb3N0LWNvbmNhdGVuYXRlcyBhIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB6XG4gICAgICogQHBhcmFtIG1cbiAgICAgKi9cbiAgICBPTER0cmFuc2xhdGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIG1bMF0gKz0gbTEyICogeDtcbiAgICAgICAgbVs0XSArPSBtMTIgKiB5O1xuICAgICAgICBtWzhdICs9IG0xMiAqIHo7XG5cbiAgICAgICAgY29uc3QgbTEzID0gbVsxM107XG4gICAgICAgIG1bMV0gKz0gbTEzICogeDtcbiAgICAgICAgbVs1XSArPSBtMTMgKiB5O1xuICAgICAgICBtWzldICs9IG0xMyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIG1bMl0gKz0gbTE0ICogeDtcbiAgICAgICAgbVs2XSArPSBtMTQgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTQgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzNdICs9IG0xNSAqIHg7XG4gICAgICAgIG1bN10gKz0gbTE1ICogeTtcbiAgICAgICAgbVsxMV0gKz0gbTE1ICogejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlTWF0NGMoeCwgeSwgeiwgbSkge1xuXG4gICAgICAgIGNvbnN0IG0zID0gbVszXTtcbiAgICAgICAgbVswXSArPSBtMyAqIHg7XG4gICAgICAgIG1bMV0gKz0gbTMgKiB5O1xuICAgICAgICBtWzJdICs9IG0zICogejtcblxuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIG1bNF0gKz0gbTcgKiB4O1xuICAgICAgICBtWzVdICs9IG03ICogeTtcbiAgICAgICAgbVs2XSArPSBtNyAqIHo7XG5cbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIG1bOF0gKz0gbTExICogeDtcbiAgICAgICAgbVs5XSArPSBtMTEgKiB5O1xuICAgICAgICBtWzEwXSArPSBtMTEgKiB6O1xuXG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuICAgICAgICBtWzEyXSArPSBtMTUgKiB4O1xuICAgICAgICBtWzEzXSArPSBtMTUgKiB5O1xuICAgICAgICBtWzE0XSArPSBtMTUgKiB6O1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCB0aGF0IHJlcGxhY2VzIHRoZSB0cmFuc2xhdGlvbiBpbiB0aGUgcmlnaHRtb3N0IGNvbHVtbiBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBhZmZpbmUgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSBtXG4gICAgICogQHBhcmFtIHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIGRlc3RcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRNYXQ0VHJhbnNsYXRpb24obSwgdHJhbnNsYXRpb24sIGRlc3QpIHtcblxuICAgICAgICBkZXN0WzBdID0gbVswXTtcbiAgICAgICAgZGVzdFsxXSA9IG1bMV07XG4gICAgICAgIGRlc3RbMl0gPSBtWzJdO1xuICAgICAgICBkZXN0WzNdID0gbVszXTtcblxuICAgICAgICBkZXN0WzRdID0gbVs0XTtcbiAgICAgICAgZGVzdFs1XSA9IG1bNV07XG4gICAgICAgIGRlc3RbNl0gPSBtWzZdO1xuICAgICAgICBkZXN0WzddID0gbVs3XTtcblxuICAgICAgICBkZXN0WzhdID0gbVs4XTtcbiAgICAgICAgZGVzdFs5XSA9IG1bOV07XG4gICAgICAgIGRlc3RbMTBdID0gbVsxMF07XG4gICAgICAgIGRlc3RbMTFdID0gbVsxMV07XG5cbiAgICAgICAgZGVzdFsxMl0gPSB0cmFuc2xhdGlvblswXTtcbiAgICAgICAgZGVzdFsxM10gPSB0cmFuc2xhdGlvblsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB0cmFuc2xhdGlvblsyXTtcbiAgICAgICAgZGVzdFsxNV0gPSBtWzE1XTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgcm90YXRpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgcm90YXRpb25NYXQ0dlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICByb3RhdGlvbk1hdDR2KGFuZ2xlcmFkLCBheGlzLCBtKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gbWF0aC5ub3JtYWxpemVWZWM0KFtheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdLCAwLjBdLCBbXSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZXJhZCk7XG4gICAgICAgIGNvbnN0IHEgPSAxLjAgLSBjO1xuXG4gICAgICAgIGNvbnN0IHggPSBheFswXTtcbiAgICAgICAgY29uc3QgeSA9IGF4WzFdO1xuICAgICAgICBjb25zdCB6ID0gYXhbMl07XG5cbiAgICAgICAgbGV0IHh5O1xuICAgICAgICBsZXQgeXo7XG4gICAgICAgIGxldCB6eDtcbiAgICAgICAgbGV0IHhzO1xuICAgICAgICBsZXQgeXM7XG4gICAgICAgIGxldCB6cztcblxuICAgICAgICAvL3h4ID0geCAqIHg7IHVzZWQgb25jZVxuICAgICAgICAvL3l5ID0geSAqIHk7IHVzZWQgb25jZVxuICAgICAgICAvL3p6ID0geiAqIHo7IHVzZWQgb25jZVxuICAgICAgICB4eSA9IHggKiB5O1xuICAgICAgICB5eiA9IHkgKiB6O1xuICAgICAgICB6eCA9IHogKiB4O1xuICAgICAgICB4cyA9IHggKiBzO1xuICAgICAgICB5cyA9IHkgKiBzO1xuICAgICAgICB6cyA9IHogKiBzO1xuXG4gICAgICAgIG0gPSBtIHx8IG1hdGgubWF0NCgpO1xuXG4gICAgICAgIG1bMF0gPSAocSAqIHggKiB4KSArIGM7XG4gICAgICAgIG1bMV0gPSAocSAqIHh5KSArIHpzO1xuICAgICAgICBtWzJdID0gKHEgKiB6eCkgLSB5cztcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gKHEgKiB4eSkgLSB6cztcbiAgICAgICAgbVs1XSA9IChxICogeSAqIHkpICsgYztcbiAgICAgICAgbVs2XSA9IChxICogeXopICsgeHM7XG4gICAgICAgIG1bN10gPSAwLjA7XG5cbiAgICAgICAgbVs4XSA9IChxICogengpICsgeXM7XG4gICAgICAgIG1bOV0gPSAocSAqIHl6KSAtIHhzO1xuICAgICAgICBtWzEwXSA9IChxICogeiAqIHopICsgYztcbiAgICAgICAgbVsxMV0gPSAwLjA7XG5cbiAgICAgICAgbVsxMl0gPSAwLjA7XG4gICAgICAgIG1bMTNdID0gMC4wO1xuICAgICAgICBtWzE0XSA9IDAuMDtcbiAgICAgICAgbVsxNV0gPSAxLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgNHg0IHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHJvdGF0aW9uTWF0NGNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcm90YXRpb25NYXQ0YyhhbmdsZXJhZCwgeCwgeSwgeiwgbWF0KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnJvdGF0aW9uTWF0NHYoYW5nbGVyYWQsIFt4LCB5LCB6XSwgbWF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0dih2LCBtID0gbWF0aC5pZGVudGl0eU1hdDQoKSkge1xuICAgICAgICBtWzBdID0gdlswXTtcbiAgICAgICAgbVs1XSA9IHZbMV07XG4gICAgICAgIG1bMTBdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgM3gzIHNjYWxlIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHNjYWxpbmdNYXQzdlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzY2FsaW5nTWF0M3YodiwgbSA9IG1hdGguaWRlbnRpdHlNYXQzKCkpIHtcbiAgICAgICAgbVswXSA9IHZbMF07XG4gICAgICAgIG1bNF0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0YzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHh5eiA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgcmV0dXJuICh4LCB5LCB6LCBkZXN0KSA9PiB7XG4gICAgICAgICAgICB4eXpbMF0gPSB4O1xuICAgICAgICAgICAgeHl6WzFdID0geTtcbiAgICAgICAgICAgIHh5elsyXSA9IHo7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsaW5nTWF0NHYoeHl6LCBkZXN0KTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEVmZmljaWVudGx5IHBvc3QtY29uY2F0ZW5hdGVzIGEgc2NhbGluZyB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGVNYXQ0Y1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gelxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0Yyh4LCB5LCB6LCBtKSB7XG5cbiAgICAgICAgbVswXSAqPSB4O1xuICAgICAgICBtWzRdICo9IHk7XG4gICAgICAgIG1bOF0gKj0gejtcblxuICAgICAgICBtWzFdICo9IHg7XG4gICAgICAgIG1bNV0gKj0geTtcbiAgICAgICAgbVs5XSAqPSB6O1xuXG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuXG4gICAgICAgIG1bM10gKj0geDtcbiAgICAgICAgbVs3XSAqPSB5O1xuICAgICAgICBtWzExXSAqPSB6O1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRWZmaWNpZW50bHkgcG9zdC1jb25jYXRlbmF0ZXMgYSBzY2FsaW5nIHRvIHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBzY2FsZU1hdDRjXG4gICAgICogQHBhcmFtIHh5elxuICAgICAqIEBwYXJhbSBtXG4gICAgICovXG4gICAgc2NhbGVNYXQ0dih4eXosIG0pIHtcblxuICAgICAgICBjb25zdCB4ID0geHl6WzBdO1xuICAgICAgICBjb25zdCB5ID0geHl6WzFdO1xuICAgICAgICBjb25zdCB6ID0geHl6WzJdO1xuXG4gICAgICAgIG1bMF0gKj0geDtcbiAgICAgICAgbVs0XSAqPSB5O1xuICAgICAgICBtWzhdICo9IHo7XG4gICAgICAgIG1bMV0gKj0geDtcbiAgICAgICAgbVs1XSAqPSB5O1xuICAgICAgICBtWzldICo9IHo7XG4gICAgICAgIG1bMl0gKj0geDtcbiAgICAgICAgbVs2XSAqPSB5O1xuICAgICAgICBtWzEwXSAqPSB6O1xuICAgICAgICBtWzNdICo9IHg7XG4gICAgICAgIG1bN10gKj0geTtcbiAgICAgICAgbVsxMV0gKj0gejtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyA0eDQgc2NhbGUgbWF0cml4LlxuICAgICAqIEBtZXRob2Qgc2NhbGluZ01hdDRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNjYWxpbmdNYXQ0cyhzKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjYWxpbmdNYXQ0YyhzLCBzLCBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgRGVzdGluYXRpb24gbWF0cml4XG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICovXG4gICAgcm90YXRpb25UcmFuc2xhdGlvbk1hdDQocSwgdiwgZGVzdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIGNvbnN0IHggPSBxWzBdO1xuICAgICAgICBjb25zdCB5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcgPSBxWzNdO1xuXG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICAgICAgY29uc3QgeHogPSB4ICogejI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG5cbiAgICAgICAgZGVzdFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgICAgIGRlc3RbMV0gPSB4eSArIHd6O1xuICAgICAgICBkZXN0WzJdID0geHogLSB3eTtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSB4eSAtIHd6O1xuICAgICAgICBkZXN0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICAgICAgZGVzdFs2XSA9IHl6ICsgd3g7XG4gICAgICAgIGRlc3RbN10gPSAwO1xuICAgICAgICBkZXN0WzhdID0geHogKyB3eTtcbiAgICAgICAgZGVzdFs5XSA9IHl6IC0gd3g7XG4gICAgICAgIGRlc3RbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICAgICAgZGVzdFsxMV0gPSAwO1xuICAgICAgICBkZXN0WzEyXSA9IHZbMF07XG4gICAgICAgIGRlc3RbMTNdID0gdlsxXTtcbiAgICAgICAgZGVzdFsxNF0gPSB2WzJdO1xuICAgICAgICBkZXN0WzE1XSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgRXVsZXIgYW5nbGVzIGZyb20gYSA0eDQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0IFRoZSA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBEZXNpcmVkIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gRXVsZXIgYW5nbGVzLCBjcmVhdGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgRXVsZXIgYW5nbGVzLlxuICAgICAqL1xuICAgIG1hdDRUb0V1bGVyKG1hdCwgb3JkZXIsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBjbGFtcCA9IG1hdGguY2xhbXA7XG5cbiAgICAgICAgLy8gQXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgICAgICBjb25zdCBtMTEgPSBtYXRbMF07XG5cbiAgICAgICAgY29uc3QgbTEyID0gbWF0WzRdO1xuICAgICAgICBjb25zdCBtMTMgPSBtYXRbOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1hdFsxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbWF0WzVdO1xuICAgICAgICBjb25zdCBtMjMgPSBtYXRbOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1hdFsyXTtcbiAgICAgICAgY29uc3QgbTMyID0gbWF0WzZdO1xuICAgICAgICBjb25zdCBtMzMgPSBtYXRbMTBdO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMTMpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIoLW0xMiwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1lYWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMihtMTMsIG0zMyk7XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXRhbjIobTIxLCBtMjIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmFzaW4oY2xhbXAobTMyLCAtMSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hdGFuMigtbTMxLCBtMzMpO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuXG4gICAgICAgICAgICBkZXN0WzFdID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMzEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzJdID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSAwO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1laWCcpIHtcblxuICAgICAgICAgICAgZGVzdFsyXSA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OSkge1xuICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBNYXRoLmF0YW4yKC1tMjMsIG0yMik7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMl0gPSBNYXRoLmFzaW4oLWNsYW1wKG0xMiwgLTEsIDEpKTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgICAgIGRlc3RbMV0gPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgICAgICAgICBkZXN0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb21wb3NlTWF0NChwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUsIG1hdCA9IG1hdGgubWF0NCgpKSB7XG4gICAgICAgIG1hdGgucXVhdGVybmlvblRvUm90YXRpb25NYXQ0KHF1YXRlcm5pb24sIG1hdCk7XG4gICAgICAgIG1hdGguc2NhbGVNYXQ0dihzY2FsZSwgbWF0KTtcbiAgICAgICAgbWF0aC50cmFuc2xhdGVNYXQ0dihwb3NpdGlvbiwgbWF0KTtcblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH0sXG5cbiAgICBkZWNvbXBvc2VNYXQ0OiAoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZlYyA9IG5ldyBGbG9hdEFycmF5VHlwZSgzKTtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKG1hdCwgcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlKSB7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFswXTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFsxXTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFsyXTtcblxuICAgICAgICAgICAgbGV0IHN4ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIHZlY1swXSA9IG1hdFs0XTtcbiAgICAgICAgICAgIHZlY1sxXSA9IG1hdFs1XTtcbiAgICAgICAgICAgIHZlY1syXSA9IG1hdFs2XTtcblxuICAgICAgICAgICAgY29uc3Qgc3kgPSBtYXRoLmxlblZlYzModmVjKTtcblxuICAgICAgICAgICAgdmVjWzhdID0gbWF0WzhdO1xuICAgICAgICAgICAgdmVjWzldID0gbWF0WzldO1xuICAgICAgICAgICAgdmVjWzEwXSA9IG1hdFsxMF07XG5cbiAgICAgICAgICAgIGNvbnN0IHN6ID0gbWF0aC5sZW5WZWMzKHZlYyk7XG5cbiAgICAgICAgICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRldGVybWluYW50TWF0NChtYXQpO1xuXG4gICAgICAgICAgICBpZiAoZGV0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvblswXSA9IG1hdFsxMl07XG4gICAgICAgICAgICBwb3NpdGlvblsxXSA9IG1hdFsxM107XG4gICAgICAgICAgICBwb3NpdGlvblsyXSA9IG1hdFsxNF07XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgICAgICAgICBtYXRyaXguc2V0KG1hdCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xuICAgICAgICAgICAgY29uc3QgaW52U1kgPSAxIC8gc3k7XG4gICAgICAgICAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgICAgICAgICAgbWF0cml4WzBdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzFdICo9IGludlNYO1xuICAgICAgICAgICAgbWF0cml4WzJdICo9IGludlNYO1xuXG4gICAgICAgICAgICBtYXRyaXhbNF0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNV0gKj0gaW52U1k7XG4gICAgICAgICAgICBtYXRyaXhbNl0gKj0gaW52U1k7XG5cbiAgICAgICAgICAgIG1hdHJpeFs4XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFs5XSAqPSBpbnZTWjtcbiAgICAgICAgICAgIG1hdHJpeFsxMF0gKj0gaW52U1o7XG5cbiAgICAgICAgICAgIG1hdGgubWF0NFRvUXVhdGVybmlvbihtYXRyaXgsIHF1YXRlcm5pb24pO1xuXG4gICAgICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgICAgIHNjYWxlWzJdID0gc3o7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH07XG5cbiAgICB9KSgpLFxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZ2V0Q29sTWF0NChtYXQsIGMpIHtcbiAgICAgICAgY29uc3QgaSA9IGMgKiA0O1xuICAgICAgICByZXR1cm4gW21hdFtpXSwgbWF0W2kgKyAxXSwgbWF0W2kgKyAyXSwgbWF0W2kgKyAzXV07XG4gICAgfSxcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHNldFJvd01hdDQobWF0LCByLCB2KSB7XG4gICAgICAgIG1hdFtyXSA9IHZbMF07XG4gICAgICAgIG1hdFtyICsgNF0gPSB2WzFdO1xuICAgICAgICBtYXRbciArIDhdID0gdlsyXTtcbiAgICAgICAgbWF0W3IgKyAxMl0gPSB2WzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0ICdsb29rYXQnIHZpZXdpbmcgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIGxvb2tBdE1hdDR2XG4gICAgICogQHBhcmFtIHBvcyB2ZWMzIHBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHZlYzMgcG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gICAgICogQHBhcmFtIHVwIHZlYzMgcG9pbnRpbmcgXCJ1cFwiXG4gICAgICogQHBhcmFtIGRlc3QgbWF0NCBPcHRpb25hbCwgbWF0NCBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21hdDR9IGRlc3QgaWYgc3BlY2lmaWVkLCBhIG5ldyBtYXQ0IG90aGVyd2lzZVxuICAgICAqL1xuICAgIGxvb2tBdE1hdDR2KHBvcywgdGFyZ2V0LCB1cCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtYXRoLm1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc3ggPSBwb3NbMF07XG4gICAgICAgIGNvbnN0IHBvc3kgPSBwb3NbMV07XG4gICAgICAgIGNvbnN0IHBvc3ogPSBwb3NbMl07XG4gICAgICAgIGNvbnN0IHVweCA9IHVwWzBdO1xuICAgICAgICBjb25zdCB1cHkgPSB1cFsxXTtcbiAgICAgICAgY29uc3QgdXB6ID0gdXBbMl07XG4gICAgICAgIGNvbnN0IHRhcmdldHggPSB0YXJnZXRbMF07XG4gICAgICAgIGNvbnN0IHRhcmdldHkgPSB0YXJnZXRbMV07XG4gICAgICAgIGNvbnN0IHRhcmdldHogPSB0YXJnZXRbMl07XG5cbiAgICAgICAgaWYgKHBvc3ggPT09IHRhcmdldHggJiYgcG9zeSA9PT0gdGFyZ2V0eSAmJiBwb3N6ID09PSB0YXJnZXR6KSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5pZGVudGl0eU1hdDQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB6MDtcbiAgICAgICAgbGV0IHoxO1xuICAgICAgICBsZXQgejI7XG4gICAgICAgIGxldCB4MDtcbiAgICAgICAgbGV0IHgxO1xuICAgICAgICBsZXQgeDI7XG4gICAgICAgIGxldCB5MDtcbiAgICAgICAgbGV0IHkxO1xuICAgICAgICBsZXQgeTI7XG4gICAgICAgIGxldCBsZW47XG5cbiAgICAgICAgLy92ZWMzLmRpcmVjdGlvbihleWUsIGNlbnRlciwgeik7XG4gICAgICAgIHowID0gcG9zeCAtIHRhcmdldHg7XG4gICAgICAgIHoxID0gcG9zeSAtIHRhcmdldHk7XG4gICAgICAgIHoyID0gcG9zeiAtIHRhcmdldHo7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIChubyBjaGVjayBuZWVkZWQgZm9yIDAgYmVjYXVzZSBvZiBlYXJseSByZXR1cm4pXG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICAgICAgejAgKj0gbGVuO1xuICAgICAgICB6MSAqPSBsZW47XG4gICAgICAgIHoyICo9IGxlbjtcblxuICAgICAgICAvL3ZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHosIHgpKTtcbiAgICAgICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICB4MCA9IDA7XG4gICAgICAgICAgICB4MSA9IDA7XG4gICAgICAgICAgICB4MiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICAgICAgeDIgKj0gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy92ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHosIHgsIHkpKTtcbiAgICAgICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICAgICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICAgICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHkwID0gMDtcbiAgICAgICAgICAgIHkxID0gMDtcbiAgICAgICAgICAgIHkyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgICAgICB5MiAqPSBsZW47XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzBdID0geDA7XG4gICAgICAgIGRlc3RbMV0gPSB5MDtcbiAgICAgICAgZGVzdFsyXSA9IHowO1xuICAgICAgICBkZXN0WzNdID0gMDtcbiAgICAgICAgZGVzdFs0XSA9IHgxO1xuICAgICAgICBkZXN0WzVdID0geTE7XG4gICAgICAgIGRlc3RbNl0gPSB6MTtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSB4MjtcbiAgICAgICAgZGVzdFs5XSA9IHkyO1xuICAgICAgICBkZXN0WzEwXSA9IHoyO1xuICAgICAgICBkZXN0WzExXSA9IDA7XG4gICAgICAgIGRlc3RbMTJdID0gLSh4MCAqIHBvc3ggKyB4MSAqIHBvc3kgKyB4MiAqIHBvc3opO1xuICAgICAgICBkZXN0WzEzXSA9IC0oeTAgKiBwb3N4ICsgeTEgKiBwb3N5ICsgeTIgKiBwb3N6KTtcbiAgICAgICAgZGVzdFsxNF0gPSAtKHowICogcG9zeCArIHoxICogcG9zeSArIHoyICogcG9zeik7XG4gICAgICAgIGRlc3RbMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCAnbG9va2F0JyB2aWV3aW5nIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICogQG1ldGhvZCBsb29rQXRNYXQ0Y1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsb29rQXRNYXQ0Yyhwb3N4LCBwb3N5LCBwb3N6LCB0YXJnZXR4LCB0YXJnZXR5LCB0YXJnZXR6LCB1cHgsIHVweSwgdXB6KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmxvb2tBdE1hdDR2KFtwb3N4LCBwb3N5LCBwb3N6XSwgW3RhcmdldHgsIHRhcmdldHksIHRhcmdldHpdLCBbdXB4LCB1cHksIHVwel0sIFtdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDR4NCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBvcnRob01hdDRjXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG9ydGhvTWF0NGMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG5cbiAgICAgICAgZGVzdFswXSA9IDIuMCAvIHJsO1xuICAgICAgICBkZXN0WzFdID0gMC4wO1xuICAgICAgICBkZXN0WzJdID0gMC4wO1xuICAgICAgICBkZXN0WzNdID0gMC4wO1xuXG4gICAgICAgIGRlc3RbNF0gPSAwLjA7XG4gICAgICAgIGRlc3RbNV0gPSAyLjAgLyB0YjtcbiAgICAgICAgZGVzdFs2XSA9IDAuMDtcbiAgICAgICAgZGVzdFs3XSA9IDAuMDtcblxuICAgICAgICBkZXN0WzhdID0gMC4wO1xuICAgICAgICBkZXN0WzldID0gMC4wO1xuICAgICAgICBkZXN0WzEwXSA9IC0yLjAgLyBmbjtcbiAgICAgICAgZGVzdFsxMV0gPSAwLjA7XG5cbiAgICAgICAgZGVzdFsxMl0gPSAtKGxlZnQgKyByaWdodCkgLyBybDtcbiAgICAgICAgZGVzdFsxM10gPSAtKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxNF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMS4wO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNHg0IHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqIEBtZXRob2QgZnJ1c3R1bU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGZydXN0dW1NYXQ0dihmbWluLCBmbWF4LCBtKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IG1hdGgubWF0NCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm1pbjQgPSBbZm1pblswXSwgZm1pblsxXSwgZm1pblsyXSwgMC4wXTtcbiAgICAgICAgY29uc3QgZm1heDQgPSBbZm1heFswXSwgZm1heFsxXSwgZm1heFsyXSwgMC4wXTtcblxuICAgICAgICBtYXRoLmFkZFZlYzQoZm1heDQsIGZtaW40LCB0ZW1wTWF0MSk7XG4gICAgICAgIG1hdGguc3ViVmVjNChmbWF4NCwgZm1pbjQsIHRlbXBNYXQyKTtcblxuICAgICAgICBjb25zdCB0ID0gMi4wICogZm1pbjRbMl07XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDIwID0gdGVtcE1hdDJbMF07XG4gICAgICAgIGNvbnN0IHRlbXBNYXQyMSA9IHRlbXBNYXQyWzFdO1xuICAgICAgICBjb25zdCB0ZW1wTWF0MjIgPSB0ZW1wTWF0MlsyXTtcblxuICAgICAgICBtWzBdID0gdCAvIHRlbXBNYXQyMDtcbiAgICAgICAgbVsxXSA9IDAuMDtcbiAgICAgICAgbVsyXSA9IDAuMDtcbiAgICAgICAgbVszXSA9IDAuMDtcblxuICAgICAgICBtWzRdID0gMC4wO1xuICAgICAgICBtWzVdID0gdCAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVs2XSA9IDAuMDtcbiAgICAgICAgbVs3XSA9IDAuMDtcblxuICAgICAgICBtWzhdID0gdGVtcE1hdDFbMF0gLyB0ZW1wTWF0MjA7XG4gICAgICAgIG1bOV0gPSB0ZW1wTWF0MVsxXSAvIHRlbXBNYXQyMTtcbiAgICAgICAgbVsxMF0gPSAtdGVtcE1hdDFbMl0gLyB0ZW1wTWF0MjI7XG4gICAgICAgIG1bMTFdID0gLTEuMDtcblxuICAgICAgICBtWzEyXSA9IDAuMDtcbiAgICAgICAgbVsxM10gPSAwLjA7XG4gICAgICAgIG1bMTRdID0gLXQgKiBmbWF4NFsyXSAvIHRlbXBNYXQyMjtcbiAgICAgICAgbVsxNV0gPSAwLjA7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBmcnVzdHVtTWF0NHZcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZnJ1c3R1bU1hdDQobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmwgPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgdGIgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZm4gPSAoZmFyIC0gbmVhcik7XG4gICAgICAgIGRlc3RbMF0gPSAobmVhciAqIDIpIC8gcmw7XG4gICAgICAgIGRlc3RbMV0gPSAwO1xuICAgICAgICBkZXN0WzJdID0gMDtcbiAgICAgICAgZGVzdFszXSA9IDA7XG4gICAgICAgIGRlc3RbNF0gPSAwO1xuICAgICAgICBkZXN0WzVdID0gKG5lYXIgKiAyKSAvIHRiO1xuICAgICAgICBkZXN0WzZdID0gMDtcbiAgICAgICAgZGVzdFs3XSA9IDA7XG4gICAgICAgIGRlc3RbOF0gPSAocmlnaHQgKyBsZWZ0KSAvIHJsO1xuICAgICAgICBkZXN0WzldID0gKHRvcCArIGJvdHRvbSkgLyB0YjtcbiAgICAgICAgZGVzdFsxMF0gPSAtKGZhciArIG5lYXIpIC8gZm47XG4gICAgICAgIGRlc3RbMTFdID0gLTE7XG4gICAgICAgIGRlc3RbMTJdID0gMDtcbiAgICAgICAgZGVzdFsxM10gPSAwO1xuICAgICAgICBkZXN0WzE0XSA9IC0oZmFyICogbmVhciAqIDIpIC8gZm47XG4gICAgICAgIGRlc3RbMTVdID0gMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSA0eDQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQG1ldGhvZCBwZXJzcGVjdGl2ZU1hdDR2XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHBlcnNwZWN0aXZlTWF0NChmb3Z5cmFkLCBhc3BlY3RyYXRpbywgem5lYXIsIHpmYXIsIG0pIHtcbiAgICAgICAgY29uc3QgcG1pbiA9IFtdO1xuICAgICAgICBjb25zdCBwbWF4ID0gW107XG5cbiAgICAgICAgcG1pblsyXSA9IHpuZWFyO1xuICAgICAgICBwbWF4WzJdID0gemZhcjtcblxuICAgICAgICBwbWF4WzFdID0gcG1pblsyXSAqIE1hdGgudGFuKGZvdnlyYWQgLyAyLjApO1xuICAgICAgICBwbWluWzFdID0gLXBtYXhbMV07XG5cbiAgICAgICAgcG1heFswXSA9IHBtYXhbMV0gKiBhc3BlY3RyYXRpbztcbiAgICAgICAgcG1pblswXSA9IC1wbWF4WzBdO1xuXG4gICAgICAgIHJldHVybiBtYXRoLmZydXN0dW1NYXQ0dihwbWluLCBwbWF4LCBtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gNHg0IG1hdHJpY2VzIGFyZSB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gbTFcbiAgICAgKiBAcGFyYW0gbTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wYXJlTWF0NChtMSwgbTIpIHtcbiAgICAgICAgcmV0dXJuIG0xWzBdID09PSBtMlswXSAmJlxuICAgICAgICAgICAgbTFbMV0gPT09IG0yWzFdICYmXG4gICAgICAgICAgICBtMVsyXSA9PT0gbTJbMl0gJiZcbiAgICAgICAgICAgIG0xWzNdID09PSBtMlszXSAmJlxuICAgICAgICAgICAgbTFbNF0gPT09IG0yWzRdICYmXG4gICAgICAgICAgICBtMVs1XSA9PT0gbTJbNV0gJiZcbiAgICAgICAgICAgIG0xWzZdID09PSBtMls2XSAmJlxuICAgICAgICAgICAgbTFbN10gPT09IG0yWzddICYmXG4gICAgICAgICAgICBtMVs4XSA9PT0gbTJbOF0gJiZcbiAgICAgICAgICAgIG0xWzldID09PSBtMls5XSAmJlxuICAgICAgICAgICAgbTFbMTBdID09PSBtMlsxMF0gJiZcbiAgICAgICAgICAgIG0xWzExXSA9PT0gbTJbMTFdICYmXG4gICAgICAgICAgICBtMVsxMl0gPT09IG0yWzEyXSAmJlxuICAgICAgICAgICAgbTFbMTNdID09PSBtMlsxM10gJiZcbiAgICAgICAgICAgIG0xWzE0XSA9PT0gbTJbMTRdICYmXG4gICAgICAgICAgICBtMVsxNV0gPT09IG0yWzE1XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIHRocmVlLWVsZW1lbnQgcG9zaXRpb24gYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9pbnQzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50MyhtLCBwLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcblxuICAgICAgICBjb25zdCB4ID0gcFswXTtcbiAgICAgICAgY29uc3QgeSA9IHBbMV07XG4gICAgICAgIGNvbnN0IHogPSBwWzJdO1xuXG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHgpICsgKG1bNF0gKiB5KSArIChtWzhdICogeikgKyBtWzEyXTtcbiAgICAgICAgZGVzdFsxXSA9IChtWzFdICogeCkgKyAobVs1XSAqIHkpICsgKG1bOV0gKiB6KSArIG1bMTNdO1xuICAgICAgICBkZXN0WzJdID0gKG1bMl0gKiB4KSArIChtWzZdICogeSkgKyAobVsxMF0gKiB6KSArIG1bMTRdO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgaG9tb2dlbmVvdXMgY29vcmRpbmF0ZSBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludDNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ0KG0sIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBkZXN0WzBdID0gbVswXSAqIHZbMF0gKyBtWzRdICogdlsxXSArIG1bOF0gKiB2WzJdICsgbVsxMl0gKiB2WzNdO1xuICAgICAgICBkZXN0WzFdID0gbVsxXSAqIHZbMF0gKyBtWzVdICogdlsxXSArIG1bOV0gKiB2WzJdICsgbVsxM10gKiB2WzNdO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHZbMF0gKyBtWzZdICogdlsxXSArIG1bMTBdICogdlsyXSArIG1bMTRdICogdlszXTtcbiAgICAgICAgZGVzdFszXSA9IG1bM10gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzExXSAqIHZbMl0gKyBtWzE1XSAqIHZbM107XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiB0aHJlZS1lbGVtZW50IHBvc2l0aW9ucyBieSBhIDR4NCBtYXRyaXguXG4gICAgICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludHMzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50czMobSwgcG9pbnRzLCBwb2ludHMyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBvaW50czIgfHwgW107XG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCBwMDtcbiAgICAgICAgbGV0IHAxO1xuICAgICAgICBsZXQgcDI7XG4gICAgICAgIGxldCBwaTtcblxuICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuXG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgbGV0IHI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgICAgICAvLyBjYWNoZSB2YWx1ZXNcbiAgICAgICAgICAgIHBpID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBwMCA9IHBpWzBdO1xuICAgICAgICAgICAgcDEgPSBwaVsxXTtcbiAgICAgICAgICAgIHAyID0gcGlbMl07XG5cbiAgICAgICAgICAgIHIgPSByZXN1bHRbaV0gfHwgKHJlc3VsdFtpXSA9IFswLCAwLCAwXSk7XG5cbiAgICAgICAgICAgIHJbMF0gPSAobTAgKiBwMCkgKyAobTQgKiBwMSkgKyAobTggKiBwMikgKyBtMTI7XG4gICAgICAgICAgICByWzFdID0gKG0xICogcDApICsgKG01ICogcDEpICsgKG05ICogcDIpICsgbTEzO1xuICAgICAgICAgICAgclsyXSA9IChtMiAqIHAwKSArIChtNiAqIHAxKSArIChtMTAgKiBwMikgKyBtMTQ7XG4gICAgICAgICAgICByWzNdID0gKG0zICogcDApICsgKG03ICogcDEpICsgKG0xMSAqIHAyKSArIG0xNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW47XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtUG9zaXRpb25zM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1Qb3NpdGlvbnMzKG0sIHAsIHAyID0gcCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgbGVuID0gcC5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgejtcblxuICAgICAgICBjb25zdCBtMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG00ID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTUgPSBtWzVdO1xuICAgICAgICBjb25zdCBtNiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTggPSBtWzhdO1xuICAgICAgICBjb25zdCBtOSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzExXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMTNdO1xuICAgICAgICBjb25zdCBtMTQgPSBtWzE0XTtcbiAgICAgICAgY29uc3QgbTE1ID0gbVsxNV07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHggPSBwW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBwW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwW2kgKyAyXTtcblxuICAgICAgICAgICAgcDJbaSArIDBdID0gKG0wICogeCkgKyAobTQgKiB5KSArIChtOCAqIHopICsgbTEyO1xuICAgICAgICAgICAgcDJbaSArIDFdID0gKG0xICogeCkgKyAobTUgKiB5KSArIChtOSAqIHopICsgbTEzO1xuICAgICAgICAgICAgcDJbaSArIDJdID0gKG0yICogeCkgKyAobTYgKiB5KSArIChtMTAgKiB6KSArIG0xNDtcbiAgICAgICAgICAgIHAyW2kgKyAzXSA9IChtMyAqIHgpICsgKG03ICogeSkgKyAobTExICogeikgKyBtMTU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgcG9zaXRpb25zIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKiBAbWV0aG9kIHRyYW5zZm9ybVBvc2l0aW9uczRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9zaXRpb25zNChtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgdGhyZWUtZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWMzKG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgZGVzdCA9IGRlc3QgfHwgdGhpcy52ZWMzKCk7XG4gICAgICAgIGRlc3RbMF0gPSAobVswXSAqIHYwKSArIChtWzRdICogdjEpICsgKG1bOF0gKiB2Mik7XG4gICAgICAgIGRlc3RbMV0gPSAobVsxXSAqIHYwKSArIChtWzVdICogdjEpICsgKG1bOV0gKiB2Mik7XG4gICAgICAgIGRlc3RbMl0gPSAobVsyXSAqIHYwKSArIChtWzZdICogdjEpICsgKG1bMTBdICogdjIpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGZvdXItZWxlbWVudCB2ZWN0b3IgYnkgYSA0eDQgbWF0cml4LlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtVmVjNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WZWM0KG0sIHYsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICBkZXN0ID0gZGVzdCB8fCBtYXRoLnZlYzQoKTtcbiAgICAgICAgZGVzdFswXSA9IG1bMF0gKiB2MCArIG1bNF0gKiB2MSArIG1bOF0gKiB2MiArIG1bMTJdICogdjM7XG4gICAgICAgIGRlc3RbMV0gPSBtWzFdICogdjAgKyBtWzVdICogdjEgKyBtWzldICogdjIgKyBtWzEzXSAqIHYzO1xuICAgICAgICBkZXN0WzJdID0gbVsyXSAqIHYwICsgbVs2XSAqIHYxICsgbVsxMF0gKiB2MiArIG1bMTRdICogdjM7XG4gICAgICAgIGRlc3RbM10gPSBtWzNdICogdjAgKyBtWzddICogdjEgKyBtWzExXSAqIHYyICsgbVsxNV0gKiB2MztcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNYKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXTtcbiAgICAgICAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhjKSAtIHBbMl0gKiBNYXRoLnNpbihjKTtcbiAgICAgICAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihjKSArIHBbMl0gKiBNYXRoLmNvcyhjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNZKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFsyXSAqIE1hdGguc2luKGMpICsgcFswXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzFdID0gcFsxXTtcbiAgICAgICAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhjKSAtIHBbMF0gKiBNYXRoLnNpbihjKTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICAgICAqXG4gICAgICogQG1ldGhvZCByb3RhdGVWZWMzWlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGRlc3QgVGhlIHJlY2VpdmluZyB2ZWMzXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBkZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHJvdGF0ZVZlYzNaKGEsIGIsIGMsIGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFswXSAqIE1hdGguY29zKGMpIC0gcFsxXSAqIE1hdGguc2luKGMpO1xuICAgICAgICByWzFdID0gcFswXSAqIE1hdGguc2luKGMpICsgcFsxXSAqIE1hdGguY29zKGMpO1xuICAgICAgICByWzJdID0gcFsyXTtcblxuICAgICAgICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIGRlc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgZGVzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBkZXN0WzJdID0gclsyXSArIGJbMl07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBmb3VyLWVsZW1lbnQgdmVjdG9yIGJ5IGEgNHg0IHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcm9qZWN0VmVjNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHAgM0QgVmlldy1zcGFjZSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcSAyRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gMkQgUHJvamVjdGVkIGNvb3JkaW5hdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcHJvamVjdFZlYzQocCwgcSkge1xuICAgICAgICBjb25zdCBmID0gMS4wIC8gcFszXTtcbiAgICAgICAgcSA9IHEgfHwgbWF0aC52ZWMyKCk7XG4gICAgICAgIHFbMF0gPSBwWzBdICogZjtcbiAgICAgICAgcVsxXSA9IHBbMV0gKiBmO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5wcm9qZWN0cyBhIHRocmVlLWVsZW1lbnQgdmVjdG9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnByb2plY3RWZWMzXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcCAzRCBQcm9qZWN0ZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXQgVmlldyBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IHByb2pNYXQgUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdW5wcm9qZWN0VmVjMzogKCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBGbG9hdEFycmF5VHlwZSgxNik7XG4gICAgICAgIGNvbnN0IG1hdDIgPSBuZXcgRmxvYXRBcnJheVR5cGUoMTYpO1xuICAgICAgICBjb25zdCBtYXQzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwLCB2aWV3TWF0LCBwcm9qTWF0LCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1WZWMzKHRoaXMubXVsTWF0NCh0aGlzLmludmVyc2VNYXQ0KHZpZXdNYXQsIG1hdCksIHRoaXMuaW52ZXJzZU1hdDQocHJvak1hdCwgbWF0MiksIG1hdDMpLCBwLCBxKVxuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIDNEIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBsZXJwVmVjM1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwVmVjMyh0LCB0MSwgdDIsIHAxLCBwMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgudmVjMygpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IHAxWzBdICsgKGYgKiAocDJbMF0gLSBwMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBwMVsxXSArIChmICogKHAyWzFdIC0gcDFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gcDFbMl0gKyAoZiAqIChwMlsyXSAtIHAxWzJdKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHR3byA0eDQgbWF0cmljZXMuXG4gICAgICogQG1ldGhvZCBsZXJwTWF0NFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBsZXJwTWF0NCh0LCB0MSwgdDIsIG0xLCBtMiwgZGVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG1hdGgubWF0NCgpO1xuICAgICAgICBjb25zdCBmID0gKHQgLSB0MSkgLyAodDIgLSB0MSk7XG4gICAgICAgIHJlc3VsdFswXSA9IG0xWzBdICsgKGYgKiAobTJbMF0gLSBtMVswXSkpO1xuICAgICAgICByZXN1bHRbMV0gPSBtMVsxXSArIChmICogKG0yWzFdIC0gbTFbMV0pKTtcbiAgICAgICAgcmVzdWx0WzJdID0gbTFbMl0gKyAoZiAqIChtMlsyXSAtIG0xWzJdKSk7XG4gICAgICAgIHJlc3VsdFszXSA9IG0xWzNdICsgKGYgKiAobTJbM10gLSBtMVszXSkpO1xuICAgICAgICByZXN1bHRbNF0gPSBtMVs0XSArIChmICogKG0yWzRdIC0gbTFbNF0pKTtcbiAgICAgICAgcmVzdWx0WzVdID0gbTFbNV0gKyAoZiAqIChtMls1XSAtIG0xWzVdKSk7XG4gICAgICAgIHJlc3VsdFs2XSA9IG0xWzZdICsgKGYgKiAobTJbNl0gLSBtMVs2XSkpO1xuICAgICAgICByZXN1bHRbN10gPSBtMVs3XSArIChmICogKG0yWzddIC0gbTFbN10pKTtcbiAgICAgICAgcmVzdWx0WzhdID0gbTFbOF0gKyAoZiAqIChtMls4XSAtIG0xWzhdKSk7XG4gICAgICAgIHJlc3VsdFs5XSA9IG0xWzldICsgKGYgKiAobTJbOV0gLSBtMVs5XSkpO1xuICAgICAgICByZXN1bHRbMTBdID0gbTFbMTBdICsgKGYgKiAobTJbMTBdIC0gbTFbMTBdKSk7XG4gICAgICAgIHJlc3VsdFsxMV0gPSBtMVsxMV0gKyAoZiAqIChtMlsxMV0gLSBtMVsxMV0pKTtcbiAgICAgICAgcmVzdWx0WzEyXSA9IG0xWzEyXSArIChmICogKG0yWzEyXSAtIG0xWzEyXSkpO1xuICAgICAgICByZXN1bHRbMTNdID0gbTFbMTNdICsgKGYgKiAobTJbMTNdIC0gbTFbMTNdKSk7XG4gICAgICAgIHJlc3VsdFsxNF0gPSBtMVsxNF0gKyAoZiAqIChtMlsxNF0gLSBtMVsxNF0pKTtcbiAgICAgICAgcmVzdWx0WzE1XSA9IG0xWzE1XSArIChmICogKG0yWzE1XSAtIG0xWzE1XSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGludG8gYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZsYXR0ZW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheSBvZiBBcnJheXN9IGEgQSAyRCBhcnJheVxuICAgICAqIEByZXR1cm5zIEZsYXR0ZW5lZCAxRCBhcnJheVxuICAgICAqL1xuICAgIGZsYXR0ZW4oYSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW5qO1xuICAgICAgICBsZXQgaXRlbTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5pID0gYS5sZW5ndGg7IGkgPCBsZW5pOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuaiA9IGl0ZW0ubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIGlkZW50aXR5UXVhdGVybmlvbihkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgZGVzdFswXSA9IDAuMDtcbiAgICAgICAgZGVzdFsxXSA9IDAuMDtcbiAgICAgICAgZGVzdFsyXSA9IDAuMDtcbiAgICAgICAgZGVzdFszXSA9IDEuMDtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgcXVhdGVybmlvbiBmcm9tIEV1bGVyIGFuZ2xlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGV1bGVyIFRoZSBFdWxlciBhbmdsZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIEV1bGVyIGFuZ2xlIG9yZGVyOiBcIlhZWlwiLCBcIllYWlwiLCBcIlpYWVwiIGV0Yy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbZGVzdF0gRGVzdGluYXRpb24gcXVhdGVybmlvbiwgY3JlYXRlZCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgZXVsZXJUb1F1YXRlcm5pb24oZXVsZXIsIG9yZGVyLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuICAgICAgICAvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuICAgICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICAgICAgY29uc3QgYSA9IChldWxlclswXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYiA9IChldWxlclsxXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcbiAgICAgICAgY29uc3QgYyA9IChldWxlclsyXSAqIG1hdGguREVHVE9SQUQpIC8gMjtcblxuICAgICAgICBjb25zdCBjMSA9IE1hdGguY29zKGEpO1xuICAgICAgICBjb25zdCBjMiA9IE1hdGguY29zKGIpO1xuICAgICAgICBjb25zdCBjMyA9IE1hdGguY29zKGMpO1xuICAgICAgICBjb25zdCBzMSA9IE1hdGguc2luKGEpO1xuICAgICAgICBjb25zdCBzMiA9IE1hdGguc2luKGIpO1xuICAgICAgICBjb25zdCBzMyA9IE1hdGguc2luKGMpO1xuXG4gICAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcblxuICAgICAgICAgICAgZGVzdFswXSA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMV0gPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICBkZXN0WzJdID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgIGRlc3RbMl0gPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICBkZXN0WzNdID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG5cbiAgICAgICAgICAgIGRlc3RbMF0gPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICBkZXN0WzFdID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgICAgIGRlc3RbM10gPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgbWF0NFRvUXVhdGVybmlvbihtLCBkZXN0ID0gbWF0aC52ZWM0KCkpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgICAgICAvLyBBc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMTBdO1xuICAgICAgICBsZXQgcztcblxuICAgICAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuICAgICAgICBpZiAodHJhY2UgPiAwKSB7XG5cbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuXG4gICAgICAgICAgICBkZXN0WzNdID0gMC4yNSAvIHM7XG4gICAgICAgICAgICBkZXN0WzBdID0gKG0zMiAtIG0yMykgKiBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IChtMTMgLSBtMzEpICogcztcbiAgICAgICAgICAgIGRlc3RbMl0gPSAobTIxIC0gbTEyKSAqIHM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTExIC0gbTIyIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMzIgLSBtMjMpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAwLjI1ICogcztcbiAgICAgICAgICAgIGRlc3RbMV0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0xMyArIG0zMSkgLyBzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobTIyID4gbTMzKSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMTMgLSBtMzEpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG0yMyArIG0zMikgLyBzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcblxuICAgICAgICAgICAgZGVzdFszXSA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobTEzICsgbTMxKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gKG0yMyArIG0zMikgLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IDAuMjUgKiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNQYWlyVG9RdWF0ZXJuaW9uKHUsIHYsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBub3JtX3Vfbm9ybV92ID0gTWF0aC5zcXJ0KG1hdGguZG90VmVjMyh1LCB1KSAqIG1hdGguZG90VmVjMyh2LCB2KSk7XG4gICAgICAgIGxldCByZWFsX3BhcnQgPSBub3JtX3Vfbm9ybV92ICsgbWF0aC5kb3RWZWMzKHUsIHYpO1xuXG4gICAgICAgIGlmIChyZWFsX3BhcnQgPCAwLjAwMDAwMDAxICogbm9ybV91X25vcm1fdikge1xuXG4gICAgICAgICAgICAvLyBJZiB1IGFuZCB2IGFyZSBleGFjdGx5IG9wcG9zaXRlLCByb3RhdGUgMTgwIGRlZ3JlZXNcbiAgICAgICAgICAgIC8vIGFyb3VuZCBhbiBhcmJpdHJhcnkgb3J0aG9nb25hbCBheGlzLiBBeGlzIG5vcm1hbGlzYXRpb25cbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gbGF0ZXIsIHdoZW4gd2Ugbm9ybWFsaXNlIHRoZSBxdWF0ZXJuaW9uLlxuXG4gICAgICAgICAgICByZWFsX3BhcnQgPSAwLjA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh1WzBdKSA+IE1hdGguYWJzKHVbMl0pKSB7XG5cbiAgICAgICAgICAgICAgICBkZXN0WzBdID0gLXVbMV07XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IHVbMF07XG4gICAgICAgICAgICAgICAgZGVzdFsyXSA9IDA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZGVzdFsxXSA9IC11WzJdO1xuICAgICAgICAgICAgICAgIGRlc3RbMl0gPSB1WzFdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBxdWF0ZXJuaW9uIHRoZSBzdGFuZGFyZCB3YXkuXG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzModSwgdiwgZGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0WzNdID0gcmVhbF9wYXJ0O1xuXG4gICAgICAgIHJldHVybiBtYXRoLm5vcm1hbGl6ZVF1YXRlcm5pb24oZGVzdCk7XG4gICAgfSxcblxuICAgIGFuZ2xlQXhpc1RvUXVhdGVybmlvbihhbmdsZUF4aXMsIGRlc3QgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUF4aXNbM10gLyAyLjA7XG4gICAgICAgIGNvbnN0IGZzaW4gPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBkZXN0WzBdID0gZnNpbiAqIGFuZ2xlQXhpc1swXTtcbiAgICAgICAgZGVzdFsxXSA9IGZzaW4gKiBhbmdsZUF4aXNbMV07XG4gICAgICAgIGRlc3RbMl0gPSBmc2luICogYW5nbGVBeGlzWzJdO1xuICAgICAgICBkZXN0WzNdID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0V1bGVyOiAoKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IEZsb2F0QXJyYXlUeXBlKDE2KTtcbiAgICAgICAgcmV0dXJuIChxLCBvcmRlciwgZGVzdCkgPT4ge1xuICAgICAgICAgICAgZGVzdCA9IGRlc3QgfHwgbWF0aC52ZWMzKCk7XG4gICAgICAgICAgICBtYXRoLnF1YXRlcm5pb25Ub1JvdGF0aW9uTWF0NChxLCBtYXQpO1xuICAgICAgICAgICAgbWF0aC5tYXQ0VG9FdWxlcihtYXQsIG9yZGVyLCBkZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgbXVsUXVhdGVybmlvbnMocCwgcSwgZGVzdCA9IG1hdGgudmVjNCgpKSB7XG4gICAgICAgIGNvbnN0IHAwID0gcFswXTtcbiAgICAgICAgY29uc3QgcDEgPSBwWzFdO1xuICAgICAgICBjb25zdCBwMiA9IHBbMl07XG4gICAgICAgIGNvbnN0IHAzID0gcFszXTtcbiAgICAgICAgY29uc3QgcTAgPSBxWzBdO1xuICAgICAgICBjb25zdCBxMSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBkZXN0WzBdID0gcDMgKiBxMCArIHAwICogcTMgKyBwMSAqIHEyIC0gcDIgKiBxMTtcbiAgICAgICAgZGVzdFsxXSA9IHAzICogcTEgKyBwMSAqIHEzICsgcDIgKiBxMCAtIHAwICogcTI7XG4gICAgICAgIGRlc3RbMl0gPSBwMyAqIHEyICsgcDIgKiBxMyArIHAwICogcTEgLSBwMSAqIHEwO1xuICAgICAgICBkZXN0WzNdID0gcDMgKiBxMyAtIHAwICogcTAgLSBwMSAqIHExIC0gcDIgKiBxMjtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHZlYzNBcHBseVF1YXRlcm5pb24ocSwgdmVjLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgeCA9IHZlY1swXTtcbiAgICAgICAgY29uc3QgeSA9IHZlY1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHZlY1syXTtcblxuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gICAgICAgIGRlc3RbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgICBkZXN0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICAgICAgZGVzdFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub01hdDQocSwgZGVzdCkge1xuXG4gICAgICAgIGRlc3QgPSBtYXRoLmlkZW50aXR5TWF0NChkZXN0KTtcblxuICAgICAgICBjb25zdCBxMCA9IHFbMF07ICAvL3hcbiAgICAgICAgY29uc3QgcTEgPSBxWzFdOyAgLy95XG4gICAgICAgIGNvbnN0IHEyID0gcVsyXTsgIC8velxuICAgICAgICBjb25zdCBxMyA9IHFbM107ICAvL3dcblxuICAgICAgICBjb25zdCB0eCA9IDIuMCAqIHEwO1xuICAgICAgICBjb25zdCB0eSA9IDIuMCAqIHExO1xuICAgICAgICBjb25zdCB0eiA9IDIuMCAqIHEyO1xuXG4gICAgICAgIGNvbnN0IHR3eCA9IHR4ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eSA9IHR5ICogcTM7XG4gICAgICAgIGNvbnN0IHR3eiA9IHR6ICogcTM7XG5cbiAgICAgICAgY29uc3QgdHh4ID0gdHggKiBxMDtcbiAgICAgICAgY29uc3QgdHh5ID0gdHkgKiBxMDtcbiAgICAgICAgY29uc3QgdHh6ID0gdHogKiBxMDtcblxuICAgICAgICBjb25zdCB0eXkgPSB0eSAqIHExO1xuICAgICAgICBjb25zdCB0eXogPSB0eiAqIHExO1xuICAgICAgICBjb25zdCB0enogPSB0eiAqIHEyO1xuXG4gICAgICAgIGRlc3RbMF0gPSAxLjAgLSAodHl5ICsgdHp6KTtcbiAgICAgICAgZGVzdFsxXSA9IHR4eSArIHR3ejtcbiAgICAgICAgZGVzdFsyXSA9IHR4eiAtIHR3eTtcblxuICAgICAgICBkZXN0WzRdID0gdHh5IC0gdHd6O1xuICAgICAgICBkZXN0WzVdID0gMS4wIC0gKHR4eCArIHR6eik7XG4gICAgICAgIGRlc3RbNl0gPSB0eXogKyB0d3g7XG5cbiAgICAgICAgZGVzdFs4XSA9IHR4eiArIHR3eTtcbiAgICAgICAgZGVzdFs5XSA9IHR5eiAtIHR3eDtcblxuICAgICAgICBkZXN0WzEwXSA9IDEuMCAtICh0eHggKyB0eXkpO1xuXG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBxdWF0ZXJuaW9uVG9Sb3RhdGlvbk1hdDQocSwgbSkge1xuICAgICAgICBjb25zdCB4ID0gcVswXTtcbiAgICAgICAgY29uc3QgeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHogPSBxWzJdO1xuICAgICAgICBjb25zdCB3ID0gcVszXTtcblxuICAgICAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgICAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICAgICAgY29uc3QgeHkgPSB4ICogeTI7XG4gICAgICAgIGNvbnN0IHh6ID0geCAqIHoyO1xuICAgICAgICBjb25zdCB5eSA9IHkgKiB5MjtcbiAgICAgICAgY29uc3QgeXogPSB5ICogejI7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xuICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xuXG4gICAgICAgIG1bMF0gPSAxIC0gKHl5ICsgenopO1xuICAgICAgICBtWzRdID0geHkgLSB3ejtcbiAgICAgICAgbVs4XSA9IHh6ICsgd3k7XG5cbiAgICAgICAgbVsxXSA9IHh5ICsgd3o7XG4gICAgICAgIG1bNV0gPSAxIC0gKHh4ICsgenopO1xuICAgICAgICBtWzldID0geXogLSB3eDtcblxuICAgICAgICBtWzJdID0geHogLSB3eTtcbiAgICAgICAgbVs2XSA9IHl6ICsgd3g7XG4gICAgICAgIG1bMTBdID0gMSAtICh4eCArIHl5KTtcblxuICAgICAgICAvLyBsYXN0IGNvbHVtblxuICAgICAgICBtWzNdID0gMDtcbiAgICAgICAgbVs3XSA9IDA7XG4gICAgICAgIG1bMTFdID0gMDtcblxuICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgIG1bMTJdID0gMDtcbiAgICAgICAgbVsxM10gPSAwO1xuICAgICAgICBtWzE0XSA9IDA7XG4gICAgICAgIG1bMTVdID0gMTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplUXVhdGVybmlvbihxLCBkZXN0ID0gcSkge1xuICAgICAgICBjb25zdCBsZW4gPSBtYXRoLmxlblZlYzQoW3FbMF0sIHFbMV0sIHFbMl0sIHFbM11dKTtcbiAgICAgICAgZGVzdFswXSA9IHFbMF0gLyBsZW47XG4gICAgICAgIGRlc3RbMV0gPSBxWzFdIC8gbGVuO1xuICAgICAgICBkZXN0WzJdID0gcVsyXSAvIGxlbjtcbiAgICAgICAgZGVzdFszXSA9IHFbM10gLyBsZW47XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH0sXG5cbiAgICBjb25qdWdhdGVRdWF0ZXJuaW9uKHEsIGRlc3QgPSBxKSB7XG4gICAgICAgIGRlc3RbMF0gPSAtcVswXTtcbiAgICAgICAgZGVzdFsxXSA9IC1xWzFdO1xuICAgICAgICBkZXN0WzJdID0gLXFbMl07XG4gICAgICAgIGRlc3RbM10gPSBxWzNdO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgaW52ZXJzZVF1YXRlcm5pb24ocSwgZGVzdCkge1xuICAgICAgICByZXR1cm4gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKG1hdGguY29uanVnYXRlUXVhdGVybmlvbihxLCBkZXN0KSk7XG4gICAgfSxcblxuICAgIHF1YXRlcm5pb25Ub0FuZ2xlQXhpcyhxLCBhbmdsZUF4aXMgPSBtYXRoLnZlYzQoKSkge1xuICAgICAgICBxID0gbWF0aC5ub3JtYWxpemVRdWF0ZXJuaW9uKHEsIHRlbXBWZWM0KTtcbiAgICAgICAgY29uc3QgcTMgPSBxWzNdO1xuICAgICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3MocTMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KDEgLSBxMyAqIHEzKTtcbiAgICAgICAgaWYgKHMgPCAwLjAwMSkgeyAvLyB0ZXN0IHRvIGF2b2lkIGRpdmlkZSBieSB6ZXJvLCBzIGlzIGFsd2F5cyBwb3NpdGl2ZSBkdWUgdG8gc3FydFxuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXTtcbiAgICAgICAgICAgIGFuZ2xlQXhpc1sxXSA9IHFbMV07XG4gICAgICAgICAgICBhbmdsZUF4aXNbMl0gPSBxWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGVBeGlzWzBdID0gcVswXSAvIHM7XG4gICAgICAgICAgICBhbmdsZUF4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgICAgIGFuZ2xlQXhpc1syXSA9IHFbMl0gLyBzO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlQXhpc1szXSA9IGFuZ2xlOyAvLyAqIDU3LjI5NTc3OTU3OTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlQXhpcztcbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb3VuZGFyaWVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIHVuaW5pdGlhbGl6ZWQgM0QgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQUFCQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3LCB1bmluaXRpYWxpemVkIDJEIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEFBQkIyKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0QXJyYXlUeXBlKHZhbHVlcyB8fCA0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAzRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDMyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldywgdW5pbml0aWFsaXplZCAyRCBvcmllbnRlZCBib3VuZGluZyBib3ggKE9CQikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjIodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUodmFsdWVzIHx8IDE2KTtcbiAgICB9LFxuXG4gICAgLyoqIFJldHVybnMgYSBuZXcgM0QgYm91bmRpbmcgc3BoZXJlICovXG4gICAgU3BoZXJlMyh4LCB5LCB6LCByKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXRBcnJheVR5cGUoW3gsIHksIHosIHJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBPQkIzIGJ5IGEgNHg0IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJhbnNmb3JtT0JCMyhtLCBwLCBwMiA9IHApIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHAubGVuZ3RoO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgY29uc3QgbTAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0yID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtNCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG01ID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTYgPSBtWzZdO1xuICAgICAgICBjb25zdCBtNyA9IG1bN107XG4gICAgICAgIGNvbnN0IG04ID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTkgPSBtWzldO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMTJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEzXTtcbiAgICAgICAgY29uc3QgbTE0ID0gbVsxNF07XG4gICAgICAgIGNvbnN0IG0xNSA9IG1bMTVdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gcFtpICsgMF07XG4gICAgICAgICAgICB5ID0gcFtpICsgMV07XG4gICAgICAgICAgICB6ID0gcFtpICsgMl07XG5cbiAgICAgICAgICAgIHAyW2kgKyAwXSA9IChtMCAqIHgpICsgKG00ICogeSkgKyAobTggKiB6KSArIG0xMjtcbiAgICAgICAgICAgIHAyW2kgKyAxXSA9IChtMSAqIHgpICsgKG01ICogeSkgKyAobTkgKiB6KSArIG0xMztcbiAgICAgICAgICAgIHAyW2kgKyAyXSA9IChtMiAqIHgpICsgKG02ICogeSkgKyAobTEwICogeikgKyBtMTQ7XG4gICAgICAgICAgICBwMltpICsgM10gPSAobTMgKiB4KSArIChtNyAqIHkpICsgKG0xMSAqIHopICsgbTE1O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHAyO1xuICAgIH0sXG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBBQUJCIGNvbnRhaW5zIHRoZSBzZWNvbmQgQUFCQi5cbiAgICAgKiBAcGFyYW0gYWFiYjFcbiAgICAgKiBAcGFyYW0gYWFiYjJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc0FBQkIzOiBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChcbiAgICAgICAgICAgIGFhYmIxWzBdIDw9IGFhYmIyWzBdICYmIGFhYmIyWzNdIDw9IGFhYmIxWzNdICYmXG4gICAgICAgICAgICBhYWJiMVsxXSA8PSBhYWJiMlsxXSAmJiBhYWJiMls0XSA8PSBhYWJiMVs0XSAmJlxuICAgICAgICAgICAgYWFiYjFbMl0gPD0gYWFiYjJbMl0gJiYgYWFiYjJbNV0gPD0gYWFiYjFbNV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpYWdvbmFsIHNpemUgb2YgYW4gQUFCQjMgZ2l2ZW4gYXMgbWluaW1hIGFuZCBtYXhpbWEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzRGlhZzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiBhYWJiID0+IHtcblxuICAgICAgICAgICAgbWluWzBdID0gYWFiYlswXTtcbiAgICAgICAgICAgIG1pblsxXSA9IGFhYmJbMV07XG4gICAgICAgICAgICBtaW5bMl0gPSBhYWJiWzJdO1xuXG4gICAgICAgICAgICBtYXhbMF0gPSBhYWJiWzNdO1xuICAgICAgICAgICAgbWF4WzFdID0gYWFiYls0XTtcbiAgICAgICAgICAgIG1heFsyXSA9IGFhYmJbNV07XG5cbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF0aC5sZW5WZWMzKHRlbXBWZWMzKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkaWFnb25hbCBib3VuZGFyeSBzaXplIHRoYXQgaXMgc3ltbWV0cmljYWwgYWJvdXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCM0RpYWdQb2ludDogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbWluID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgRmxvYXRBcnJheVR5cGUoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0QXJyYXlUeXBlKDMpO1xuXG4gICAgICAgIHJldHVybiAoYWFiYiwgcCkgPT4ge1xuXG4gICAgICAgICAgICBtaW5bMF0gPSBhYWJiWzBdO1xuICAgICAgICAgICAgbWluWzFdID0gYWFiYlsxXTtcbiAgICAgICAgICAgIG1pblsyXSA9IGFhYmJbMl07XG5cbiAgICAgICAgICAgIG1heFswXSA9IGFhYmJbM107XG4gICAgICAgICAgICBtYXhbMV0gPSBhYWJiWzRdO1xuICAgICAgICAgICAgbWF4WzJdID0gYWFiYls1XTtcblxuICAgICAgICAgICAgY29uc3QgZGlhZ1ZlYyA9IG1hdGguc3ViVmVjMyhtYXgsIG1pbiwgdGVtcFZlYzMpO1xuXG4gICAgICAgICAgICBjb25zdCB4bmVnID0gcFswXSAtIGFhYmJbMF07XG4gICAgICAgICAgICBjb25zdCB4cG9zID0gYWFiYlszXSAtIHBbMF07XG4gICAgICAgICAgICBjb25zdCB5bmVnID0gcFsxXSAtIGFhYmJbMV07XG4gICAgICAgICAgICBjb25zdCB5cG9zID0gYWFiYls0XSAtIHBbMV07XG4gICAgICAgICAgICBjb25zdCB6bmVnID0gcFsyXSAtIGFhYmJbMl07XG4gICAgICAgICAgICBjb25zdCB6cG9zID0gYWFiYls1XSAtIHBbMl07XG5cbiAgICAgICAgICAgIGRpYWdWZWNbMF0gKz0gKHhuZWcgPiB4cG9zKSA/IHhuZWcgOiB4cG9zO1xuICAgICAgICAgICAgZGlhZ1ZlY1sxXSArPSAoeW5lZyA+IHlwb3MpID8geW5lZyA6IHlwb3M7XG4gICAgICAgICAgICBkaWFnVmVjWzJdICs9ICh6bmVnID4genBvcykgPyB6bmVnIDogenBvcztcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1hdGgubGVuVmVjMyhkaWFnVmVjKSk7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmVhIG9mIGFuIEFBQkIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEFBQkIzQXJlYShhYWJiKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKGFhYmJbM10gLSBhYWJiWzBdKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGFhYmJbNF0gLSBhYWJiWzFdKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSAoYWFiYls1XSAtIGFhYmJbMl0pO1xuICAgICAgICByZXR1cm4gKHdpZHRoICogaGVpZ2h0ICogZGVwdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYW4gQUFCQi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QUFCQjNDZW50ZXIoYWFiYiwgZGVzdCkge1xuICAgICAgICBjb25zdCByID0gZGVzdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICByWzBdID0gKGFhYmJbMF0gKyBhYWJiWzNdKSAvIDI7XG4gICAgICAgIHJbMV0gPSAoYWFiYlsxXSArIGFhYmJbNF0pIC8gMjtcbiAgICAgICAgclsyXSA9IChhYWJiWzJdICsgYWFiYls1XSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSAyRCBBQUJCLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBQUJCMkNlbnRlcihhYWJiLCBkZXN0KSB7XG4gICAgICAgIGNvbnN0IHIgPSBkZXN0IHx8IG1hdGgudmVjMigpO1xuXG4gICAgICAgIHJbMF0gPSAoYWFiYlsyXSArIGFhYmJbMF0pIC8gMjtcbiAgICAgICAgclsxXSA9IChhYWJiWzNdICsgYWFiYlsxXSkgLyAyO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAzRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgM0QgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMyhhYWJiID0gbWF0aC5BQUJCMygpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNF0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbNV0gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBpbnRvIGFuIG9yaWVudGVkIGJvdW5kYXJ5IGNvbnNpc3Rpbmcgb2ZcbiAgICAgKiBhbiBhcnJheSBvZiBlaWdodCAzRCBwb3NpdGlvbnMsIG9uZSBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGJvdW5kYXJ5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBBQUJCM1RvT0JCMyhhYWJiLCBvYmIgPSBtYXRoLk9CQjMoKSkge1xuICAgICAgICBvYmJbMF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMV0gPSBhYWJiWzFdO1xuICAgICAgICBvYmJbMl0gPSBhYWJiWzJdO1xuICAgICAgICBvYmJbM10gPSAxO1xuXG4gICAgICAgIG9iYls0XSA9IGFhYmJbM107XG4gICAgICAgIG9iYls1XSA9IGFhYmJbMV07XG4gICAgICAgIG9iYls2XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYls3XSA9IDE7XG5cbiAgICAgICAgb2JiWzhdID0gYWFiYlszXTtcbiAgICAgICAgb2JiWzldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzEwXSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxMV0gPSAxO1xuXG4gICAgICAgIG9iYlsxMl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTNdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzE0XSA9IGFhYmJbMl07XG4gICAgICAgIG9iYlsxNV0gPSAxO1xuXG4gICAgICAgIG9iYlsxNl0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMTddID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzE4XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsxOV0gPSAxO1xuXG4gICAgICAgIG9iYlsyMF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjFdID0gYWFiYlsxXTtcbiAgICAgICAgb2JiWzIyXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyM10gPSAxO1xuXG4gICAgICAgIG9iYlsyNF0gPSBhYWJiWzNdO1xuICAgICAgICBvYmJbMjVdID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzI2XSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlsyN10gPSAxO1xuXG4gICAgICAgIG9iYlsyOF0gPSBhYWJiWzBdO1xuICAgICAgICBvYmJbMjldID0gYWFiYls0XTtcbiAgICAgICAgb2JiWzMwXSA9IGFhYmJbNV07XG4gICAgICAgIG9iYlszMV0gPSAxO1xuXG4gICAgICAgIHJldHVybiBvYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvc2l0aW9uczNUb0FBQkIzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBwID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgYWFiYiwgcG9zaXRpb25zRGVjb2RlTWF0cml4KSA9PiB7XG4gICAgICAgICAgICBhYWJiID0gYWFiYiB8fCBtYXRoLkFBQkIzKCk7XG5cbiAgICAgICAgICAgIGxldCB4bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgICAgICBsZXQgem1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGxldCB6O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHBvc2l0aW9uc1tpICsgMF07XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gcG9zaXRpb25zW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICBtYXRoLmRlY29tcHJlc3NQb3NpdGlvbihwLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIHggPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHBbMl07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcG9zaXRpb25zW2kgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgeW1pbiA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHptaW4gPSB6O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgICAgICB4bWF4ID0geDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgeW1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHptYXggPSB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgICAgICBhYWJiWzFdID0geW1pbjtcbiAgICAgICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICAgICAgYWFiYlszXSA9IHhtYXg7XG4gICAgICAgICAgICBhYWJiWzRdID0geW1heDtcbiAgICAgICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgICAgICByZXR1cm4gYWFiYjtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSBlbmNsb3NpbmcgdGhlIGhvbW9nZW5lb3VzIDNEIHBvaW50cyAoeCx5LHosdykgZ2l2ZW4gaW4gYSBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIzKG9iYiwgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9iYi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgICAgICB4ID0gb2JiW2kgKyAwXTtcbiAgICAgICAgICAgIHkgPSBvYmJbaSArIDFdO1xuICAgICAgICAgICAgeiA9IG9iYltpICsgMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb0FBQkIzKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjMoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB6bWluID0gbWF0aC5NQVhfRE9VQkxFO1xuICAgICAgICBsZXQgeG1heCA9IG1hdGguTUlOX0RPVUJMRTtcbiAgICAgICAgbGV0IHltYXggPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGxldCB6bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHo7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICB4ID0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpXVsxXTtcbiAgICAgICAgICAgIHogPSBwb2ludHNbaV1bMl07XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPCB6bWluKSB7XG4gICAgICAgICAgICAgICAgem1pbiA9IHo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4ID4geG1heCkge1xuICAgICAgICAgICAgICAgIHhtYXggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IHltYXgpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHogPiB6bWF4KSB7XG4gICAgICAgICAgICAgICAgem1heCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhYWJiWzBdID0geG1pbjtcbiAgICAgICAgYWFiYlsxXSA9IHltaW47XG4gICAgICAgIGFhYmJbMl0gPSB6bWluO1xuICAgICAgICBhYWJiWzNdID0geG1heDtcbiAgICAgICAgYWFiYls0XSA9IHltYXg7XG4gICAgICAgIGFhYmJbNV0gPSB6bWF4O1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50czNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvaW50cywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHkgKz0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9pbnRzW2ldWzJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzMocG9pbnRzW2ldLCBzcGhlcmUsIHRlbXBWZWMzKSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gZGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNwaGVyZVszXSA9IHJhZGl1cztcblxuICAgICAgICAgICAgcmV0dXJuIHNwaGVyZTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIGJvdW5kYXJ5IHNwaGVyZSBlbmNsb3NpbmcgdGhlIGdpdmVuIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcG9zaXRpb25zM1RvU3BoZXJlMzogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcFZlYzNhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKHBvc2l0aW9ucywgc3BoZXJlKSA9PiB7XG5cbiAgICAgICAgICAgIHNwaGVyZSA9IHNwaGVyZSB8fCBtYXRoLnZlYzQoKTtcblxuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgbGV0IHogPSAwO1xuXG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGxlblBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgeCArPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgeSArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHogKz0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbnVtUG9zaXRpb25zID0gbGVuUG9zaXRpb25zIC8gMztcblxuICAgICAgICAgICAgc3BoZXJlWzBdID0geCAvIG51bVBvc2l0aW9ucztcbiAgICAgICAgICAgIHNwaGVyZVsxXSA9IHkgLyBudW1Qb3NpdGlvbnM7XG4gICAgICAgICAgICBzcGhlcmVbMl0gPSB6IC8gbnVtUG9zaXRpb25zO1xuXG4gICAgICAgICAgICBsZXQgZGlzdDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlblBvc2l0aW9uczsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdGVtcFZlYzNhWzFdID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB0ZW1wVmVjM2FbMl0gPSBwb3NpdGlvbnNbaSArIDJdO1xuXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguYWJzKG1hdGgubGVuVmVjMyhtYXRoLnN1YlZlYzModGVtcFZlYzNhLCBzcGhlcmUsIHRlbXBWZWMzYikpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSBib3VuZGFyeSBzcGhlcmUgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb1NwaGVyZTM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9pbnRzLCBzcGhlcmUpID0+IHtcblxuICAgICAgICAgICAgc3BoZXJlID0gc3BoZXJlIHx8IG1hdGgudmVjNCgpO1xuXG4gICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBsZXQgeiA9IDA7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgbGVuUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IGxlblBvaW50cyAvIDQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICB5ICs9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgeiArPSBwb2ludHNbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbMF0gPSB4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgc3BoZXJlWzFdID0geSAvIG51bVBvaW50cztcbiAgICAgICAgICAgIHNwaGVyZVsyXSA9IHogLyBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGxldCByYWRpdXMgPSAwO1xuICAgICAgICAgICAgbGV0IGRpc3Q7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5Qb2ludHM7IGkgKz0gNCkge1xuXG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBwb2ludFsyXSA9IHBvaW50c1tpICsgMl07XG5cbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMobWF0aC5sZW5WZWMzKG1hdGguc3ViVmVjMyhwb2ludCwgc3BoZXJlLCB0ZW1wVmVjMykpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGhlcmVbM10gPSByYWRpdXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzcGhlcmU7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgYSBib3VuZGluZyBzcGhlcmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNwaGVyZTNDZW50ZXIoc3BoZXJlLCBkZXN0ID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgZGVzdFswXSA9IHNwaGVyZVswXTtcbiAgICAgICAgZGVzdFsxXSA9IHNwaGVyZVsxXTtcbiAgICAgICAgZGVzdFsyXSA9IHNwaGVyZVsyXTtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgM0QgY2VudGVyIG9mIHRoZSBnaXZlbiBmbGF0IGFycmF5IG9mIDNEIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25zQ2VudGVyKHBvc2l0aW9ucywgY2VudGVyID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgbGV0IHhDZW50ZXIgPSAwO1xuICAgICAgICBsZXQgeUNlbnRlciA9IDA7XG4gICAgICAgIGxldCB6Q2VudGVyID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgeENlbnRlciArPSBwb3NpdGlvbnNbaSArIDBdO1xuICAgICAgICAgICAgeUNlbnRlciArPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgekNlbnRlciArPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuICAgICAgICBjZW50ZXJbMF0gPSB4Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMV0gPSB5Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICBjZW50ZXJbMl0gPSB6Q2VudGVyIC8gbnVtUG9zaXRpb25zO1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBmaXJzdCBheGlzLWFsaWduZWQgM0QgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgc2Vjb25kLCBpZiByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhwYW5kQUFCQjMoYWFiYjEsIGFhYmIyKSB7XG5cbiAgICAgICAgaWYgKGFhYmIxWzBdID4gYWFiYjJbMF0pIHtcbiAgICAgICAgICAgIGFhYmIxWzBdID0gYWFiYjJbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbMV0gPiBhYWJiMlsxXSkge1xuICAgICAgICAgICAgYWFiYjFbMV0gPSBhYWJiMlsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsyXSA+IGFhYmIyWzJdKSB7XG4gICAgICAgICAgICBhYWJiMVsyXSA9IGFhYmIyWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzNdIDwgYWFiYjJbM10pIHtcbiAgICAgICAgICAgIGFhYmIxWzNdID0gYWFiYjJbM107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbNF0gPCBhYWJiMls0XSkge1xuICAgICAgICAgICAgYWFiYjFbNF0gPSBhYWJiMls0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVs1XSA8IGFhYmIyWzVdKSB7XG4gICAgICAgICAgICBhYWJiMVs1XSA9IGFhYmIyWzVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmIxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFuIGF4aXMtYWxpZ25lZCAzRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBnaXZlbiBwb2ludCwgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50MyhhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA+IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzRdIDwgcFsxXSkge1xuICAgICAgICAgICAgYWFiYls0XSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYls1XSA8IHBbMl0pIHtcbiAgICAgICAgICAgIGFhYmJbNV0gPSBwWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYW4gYXhpcy1hbGlnbmVkIDNEIGJvdW5kYXJ5IHRvIGVuY2xvc2UgdGhlIGdpdmVuIHBvaW50cywgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCM1BvaW50czMoYWFiYiwgcG9zaXRpb25zKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgaWYgKGFhYmJbMF0gPiB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlswXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYlsxXSA+IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzJdID4geikge1xuICAgICAgICAgICAgICAgIGFhYmJbMl0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhYmJbM10gPCB4KSB7XG4gICAgICAgICAgICAgICAgYWFiYlszXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWFiYls0XSA8IHkpIHtcbiAgICAgICAgICAgICAgICBhYWJiWzRdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYWJiWzVdIDwgeikge1xuICAgICAgICAgICAgICAgIGFhYmJbNV0gPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSAyRCBheGlzLWFsaWduZWQgYm91bmRhcnksIHJlYWR5IHRvIGV4cGFuZCB0byBmaXQgMkQgcG9pbnRzLlxuICAgICAqIENyZWF0ZXMgbmV3IEFBQkIgaWYgbm9uZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBQUJCMihhYWJiID0gbWF0aC5BQUJCMigpKSB7XG4gICAgICAgIGFhYmJbMF0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMV0gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGFhYmJbMl0gPSBtYXRoLk1JTl9ET1VCTEU7XG4gICAgICAgIGFhYmJbM10gPSBtYXRoLk1JTl9ET1VCTEU7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIHBvaW50M0FBQkIzSW50ZXJzZWN0KGFhYmIsIHApIHtcbiAgICAgICAgcmV0dXJuIGFhYmJbMF0gPiBwWzBdIHx8IGFhYmJbM10gPCBwWzBdIHx8IGFhYmJbMV0gPiBwWzFdIHx8IGFhYmJbNF0gPCBwWzFdIHx8IGFhYmJbMl0gPiBwWzJdIHx8IGFhYmJbNV0gPCBwWzJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXJcbiAgICAgKiBAcGFyYW0gY29uc3RhbnRcbiAgICAgKiBAcGFyYW0gYWFiYlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGxhbmVBQUJCM0ludGVyc2VjdChkaXIsIGNvbnN0YW50LCBhYWJiKSB7XG4gICAgICAgIGxldCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRpclswXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgICAgICBtYXggPSBkaXJbMF0gKiBhYWJiWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluID0gZGlyWzBdICogYWFiYlszXTtcbiAgICAgICAgICAgIG1heCA9IGRpclswXSAqIGFhYmJbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclsxXSA+IDApIHtcbiAgICAgICAgICAgIG1pbiArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICAgICAgbWF4ICs9IGRpclsxXSAqIGFhYmJbNF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzFdICogYWFiYls0XTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMV0gKiBhYWJiWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJbMl0gPiAwKSB7XG4gICAgICAgICAgICBtaW4gKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgICAgIG1heCArPSBkaXJbMl0gKiBhYWJiWzVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluICs9IGRpclsyXSAqIGFhYmJbNV07XG4gICAgICAgICAgICBtYXggKz0gZGlyWzJdICogYWFiYlsyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRzaWRlID0gKG1pbiA8PSAtY29uc3RhbnQpICYmIChtYXggPD0gLWNvbnN0YW50KTtcbiAgICAgICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluc2lkZSA9IChtaW4gPj0gLWNvbnN0YW50KSAmJiAobWF4ID49IC1jb25zdGFudCk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtaW5pbXVtIDJEIHByb2plY3RlZCBheGlzLWFsaWduZWQgYm91bmRhcnkgZW5jbG9zaW5nIHRoZSBnaXZlbiAzRCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE9CQjNUb0FBQkIyKHBvaW50cywgYWFiYiA9IG1hdGguQUFCQjIoKSkge1xuICAgICAgICBsZXQgeG1pbiA9IG1hdGguTUFYX0RPVUJMRTtcbiAgICAgICAgbGV0IHltaW4gPSBtYXRoLk1BWF9ET1VCTEU7XG4gICAgICAgIGxldCB4bWF4ID0gbWF0aC5NSU5fRE9VQkxFO1xuICAgICAgICBsZXQgeW1heCA9IG1hdGguTUlOX0RPVUJMRTtcblxuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCB3O1xuICAgICAgICBsZXQgZjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgICAgIHggPSBwb2ludHNbaSArIDBdO1xuICAgICAgICAgICAgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB3ID0gcG9pbnRzW2kgKyAzXSB8fCAxLjA7XG5cbiAgICAgICAgICAgIGYgPSAxLjAgLyB3O1xuXG4gICAgICAgICAgICB4ICo9IGY7XG4gICAgICAgICAgICB5ICo9IGY7XG5cbiAgICAgICAgICAgIGlmICh4IDwgeG1pbikge1xuICAgICAgICAgICAgICAgIHhtaW4gPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHltaW4pIHtcbiAgICAgICAgICAgICAgICB5bWluID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPiB4bWF4KSB7XG4gICAgICAgICAgICAgICAgeG1heCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5ID4geW1heCkge1xuICAgICAgICAgICAgICAgIHltYXggPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWFiYlswXSA9IHhtaW47XG4gICAgICAgIGFhYmJbMV0gPSB5bWluO1xuICAgICAgICBhYWJiWzJdID0geG1heDtcbiAgICAgICAgYWFiYlszXSA9IHltYXg7XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIGZpcnN0IGF4aXMtYWxpZ25lZCAyRCBib3VuZGFyeSB0byBlbmNsb3NlIHRoZSBzZWNvbmQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMihhYWJiMSwgYWFiYjIpIHtcblxuICAgICAgICBpZiAoYWFiYjFbMF0gPiBhYWJiMlswXSkge1xuICAgICAgICAgICAgYWFiYjFbMF0gPSBhYWJiMlswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiMVsxXSA+IGFhYmIyWzFdKSB7XG4gICAgICAgICAgICBhYWJiMVsxXSA9IGFhYmIyWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmIxWzJdIDwgYWFiYjJbMl0pIHtcbiAgICAgICAgICAgIGFhYmIxWzJdID0gYWFiYjJbMl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYjFbM10gPCBhYWJiMlszXSkge1xuICAgICAgICAgICAgYWFiYjFbM10gPSBhYWJiMlszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbiBheGlzLWFsaWduZWQgMkQgYm91bmRhcnkgdG8gZW5jbG9zZSB0aGUgZ2l2ZW4gcG9pbnQsIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBQUJCMlBvaW50MihhYWJiLCBwKSB7XG5cbiAgICAgICAgaWYgKGFhYmJbMF0gPiBwWzBdKSB7XG4gICAgICAgICAgICBhYWJiWzBdID0gcFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYWJiWzFdID4gcFsxXSkge1xuICAgICAgICAgICAgYWFiYlsxXSA9IHBbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWFiYlsyXSA8IHBbMF0pIHtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBwWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFhYmJbM10gPCBwWzFdKSB7XG4gICAgICAgICAgICBhYWJiWzNdID0gcFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH0sXG5cbiAgICBBQUJCMlRvQ2FudmFzKGFhYmIsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIGFhYmIyID0gYWFiYikge1xuICAgICAgICBjb25zdCB4bWluID0gKGFhYmJbMF0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWluID0gKGFhYmJbMV0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB4bWF4ID0gKGFhYmJbMl0gKyAxLjApICogMC41O1xuICAgICAgICBjb25zdCB5bWF4ID0gKGFhYmJbM10gKyAxLjApICogMC41O1xuXG4gICAgICAgIGFhYmIyWzBdID0gTWF0aC5mbG9vcih4bWluICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlsxXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1heCAqIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGFhYmIyWzJdID0gTWF0aC5mbG9vcih4bWF4ICogY2FudmFzV2lkdGgpO1xuICAgICAgICBhYWJiMlszXSA9IGNhbnZhc0hlaWdodCAtIE1hdGguZmxvb3IoeW1pbiAqIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIGFhYmIyO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEN1cnZlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0YW5nZW50UXVhZHJhdGljQmV6aWVyKHQsIHAwLCBwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogKHAxIC0gcDApICsgMiAqIHQgKiAocDIgLSBwMSk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRRdWFkcmF0aWNCZXppZXIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgK1xuICAgICAgICAgICAgMyAqIHAxICogKDEgLSB0KSAqICgxIC0gdCkgLSA2ICogdCAqIHAxICogKDEgLSB0KSArXG4gICAgICAgICAgICA2ICogdCAqIHAyICogKDEgLSB0KSAtIDMgKiB0ICogdCAqIHAyICtcbiAgICAgICAgICAgIDMgKiB0ICogdCAqIHAzO1xuICAgIH0sXG5cbiAgICB0YW5nZW50U3BsaW5lKHQpIHtcbiAgICAgICAgY29uc3QgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7XG4gICAgICAgIGNvbnN0IGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTtcbiAgICAgICAgY29uc3QgaDAxID0gLTYgKiB0ICogdCArIDYgKiB0O1xuICAgICAgICBjb25zdCBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcbiAgICAgICAgcmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcbiAgICB9LFxuXG4gICAgY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIGNvbnN0IHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICBjb25zdCB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICAgICAgY29uc3QgdDMgPSB0ICogdDI7XG4gICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICB9LFxuXG4vLyBCZXppZXIgQ3VydmUgZm9ybXVsaWkgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cbi8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjJwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogcDtcblxuICAgIH0sXG5cbiAgICBiMnAxKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIDIgKiAoMSAtIHQpICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIycDIodCwgcCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiMih0LCBwMCwgcDEsIHAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIycDAodCwgcDApICsgdGhpcy5iMnAxKHQsIHAxKSArIHRoaXMuYjJwMih0LCBwMik7XG4gICAgfSxcblxuLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgYjNwMCh0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG4gICAgfSxcblxuICAgIGIzcDEodCwgcCkge1xuICAgICAgICBjb25zdCBrID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcbiAgICB9LFxuXG4gICAgYjNwMih0LCBwKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuICAgIH0sXG5cbiAgICBiM3AzKHQsIHApIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG4gICAgfSxcblxuICAgIGIzKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmIzcDAodCwgcDApICsgdGhpcy5iM3AxKHQsIHAxKSArIHRoaXMuYjNwMih0LCBwMikgKyB0aGlzLmIzcDModCwgcDMpO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdlb21ldHJ5XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbCB2ZWN0b3Igb2YgYSB0cmlhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdHJpYW5nbGVOb3JtYWwoYSwgYiwgYywgbm9ybWFsID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgcDF4ID0gYlswXSAtIGFbMF07XG4gICAgICAgIGNvbnN0IHAxeSA9IGJbMV0gLSBhWzFdO1xuICAgICAgICBjb25zdCBwMXogPSBiWzJdIC0gYVsyXTtcblxuICAgICAgICBjb25zdCBwMnggPSBjWzBdIC0gYVswXTtcbiAgICAgICAgY29uc3QgcDJ5ID0gY1sxXSAtIGFbMV07XG4gICAgICAgIGNvbnN0IHAyeiA9IGNbMl0gLSBhWzJdO1xuXG4gICAgICAgIGNvbnN0IHAzeCA9IHAxeSAqIHAyeiAtIHAxeiAqIHAyeTtcbiAgICAgICAgY29uc3QgcDN5ID0gcDF6ICogcDJ4IC0gcDF4ICogcDJ6O1xuICAgICAgICBjb25zdCBwM3ogPSBwMXggKiBwMnkgLSBwMXkgKiBwMng7XG5cbiAgICAgICAgY29uc3QgbWFnID0gTWF0aC5zcXJ0KHAzeCAqIHAzeCArIHAzeSAqIHAzeSArIHAzeiAqIHAzeik7XG4gICAgICAgIGlmIChtYWcgPT09IDApIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IDA7XG4gICAgICAgICAgICBub3JtYWxbMV0gPSAwO1xuICAgICAgICAgICAgbm9ybWFsWzJdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFswXSA9IHAzeCAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsxXSA9IHAzeSAvIG1hZztcbiAgICAgICAgICAgIG5vcm1hbFsyXSA9IHAzeiAvIG1hZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgM0QgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJheVRyaWFuZ2xlSW50ZXJzZWN0OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChvcmlnaW4sIGRpciwgYSwgYiwgYywgaXNlY3QpID0+IHtcblxuICAgICAgICAgICAgaXNlY3QgPSBpc2VjdCB8fCBtYXRoLnZlYzMoKTtcblxuICAgICAgICAgICAgY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG4gICAgICAgICAgICBjb25zdCBlZGdlMSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2IpO1xuXG4gICAgICAgICAgICBjb25zdCBwdmVjID0gbWF0aC5jcm9zczNWZWMzKGRpciwgZWRnZTIsIHRlbXBWZWMzYyk7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSBtYXRoLmRvdFZlYzMoZWRnZTEsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKGRldCA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHZlYyA9IG1hdGguc3ViVmVjMyhvcmlnaW4sIGEsIHRlbXBWZWMzZCk7XG4gICAgICAgICAgICBjb25zdCB1ID0gbWF0aC5kb3RWZWMzKHR2ZWMsIHB2ZWMpO1xuICAgICAgICAgICAgaWYgKHUgPCAwIHx8IHUgPiBkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcXZlYyA9IG1hdGguY3Jvc3MzVmVjMyh0dmVjLCBlZGdlMSwgdGVtcFZlYzNlKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtYXRoLmRvdFZlYzMoZGlyLCBxdmVjKTtcbiAgICAgICAgICAgIGlmICh2IDwgMCB8fCB1ICsgdiA+IGRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ID0gbWF0aC5kb3RWZWMzKGVkZ2UyLCBxdmVjKSAvIGRldDtcbiAgICAgICAgICAgIGlzZWN0WzBdID0gb3JpZ2luWzBdICsgdCAqIGRpclswXTtcbiAgICAgICAgICAgIGlzZWN0WzFdID0gb3JpZ2luWzFdICsgdCAqIGRpclsxXTtcbiAgICAgICAgICAgIGlzZWN0WzJdID0gb3JpZ2luWzJdICsgdCAqIGRpclsyXTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzZWN0O1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGludGVyc2VjdGlvbiBvZiBhIDNEIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSAzIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmF5UGxhbmVJbnRlcnNlY3Q6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNkID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKG9yaWdpbiwgZGlyLCBhLCBiLCBjLCBpc2VjdCkgPT4ge1xuXG4gICAgICAgICAgICBpc2VjdCA9IGlzZWN0IHx8IG1hdGgudmVjMygpO1xuXG4gICAgICAgICAgICBkaXIgPSBtYXRoLm5vcm1hbGl6ZVZlYzMoZGlyLCB0ZW1wVmVjMyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVkZ2UxID0gbWF0aC5zdWJWZWMzKGIsIGEsIHRlbXBWZWMzYik7XG4gICAgICAgICAgICBjb25zdCBlZGdlMiA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBuID0gbWF0aC5jcm9zczNWZWMzKGVkZ2UxLCBlZGdlMiwgdGVtcFZlYzNkKTtcbiAgICAgICAgICAgIG1hdGgubm9ybWFsaXplVmVjMyhuLCBuKTtcblxuICAgICAgICAgICAgY29uc3QgZCA9IC1tYXRoLmRvdFZlYzMoYSwgbik7XG5cbiAgICAgICAgICAgIGNvbnN0IHQgPSAtKG1hdGguZG90VmVjMyhvcmlnaW4sIG4pICsgZCkgLyBtYXRoLmRvdFZlYzMoZGlyLCBuKTtcblxuICAgICAgICAgICAgaXNlY3RbMF0gPSBvcmlnaW5bMF0gKyB0ICogZGlyWzBdO1xuICAgICAgICAgICAgaXNlY3RbMV0gPSBvcmlnaW5bMV0gKyB0ICogZGlyWzFdO1xuICAgICAgICAgICAgaXNlY3RbMl0gPSBvcmlnaW5bMl0gKyB0ICogZGlyWzJdO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNlY3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGZyb20gY2FydGVzaWFuIGNvb3JkaW5hdGVzIHdpdGhpbiBhIHRyaWFuZ2xlLlxuICAgICAqIEdldHMgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgZnJvbSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhcnRlc2lhblRvQmFyeWNlbnRyaWM6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBWZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgdGVtcFZlYzNjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhcnRlc2lhbiwgYSwgYiwgYywgZGVzdCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB2MCA9IG1hdGguc3ViVmVjMyhjLCBhLCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBjb25zdCB2MSA9IG1hdGguc3ViVmVjMyhiLCBhLCB0ZW1wVmVjM2IpO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBtYXRoLnN1YlZlYzMoY2FydGVzaWFuLCBhLCB0ZW1wVmVjM2MpO1xuXG4gICAgICAgICAgICBjb25zdCBkb3QwMCA9IG1hdGguZG90VmVjMyh2MCwgdjApO1xuICAgICAgICAgICAgY29uc3QgZG90MDEgPSBtYXRoLmRvdFZlYzModjAsIHYxKTtcbiAgICAgICAgICAgIGNvbnN0IGRvdDAyID0gbWF0aC5kb3RWZWMzKHYwLCB2Mik7XG4gICAgICAgICAgICBjb25zdCBkb3QxMSA9IG1hdGguZG90VmVjMyh2MSwgdjEpO1xuICAgICAgICAgICAgY29uc3QgZG90MTIgPSBtYXRoLmRvdFZlYzModjEsIHYyKTtcblxuICAgICAgICAgICAgY29uc3QgZGVub20gPSAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuXG4gICAgICAgICAgICAvLyBDb2xpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXG4gICAgICAgICAgICBpZiAoZGVub20gPT09IDApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cbiAgICAgICAgICAgIGNvbnN0IHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgICAgICBjb25zdCB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgICAgICBkZXN0WzBdID0gMSAtIHUgLSB2O1xuICAgICAgICAgICAgZGVzdFsxXSA9IHY7XG4gICAgICAgICAgICBkZXN0WzJdID0gdTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlaXIgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljSW5zaWRlVHJpYW5nbGUoYmFyeSkge1xuXG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB1ID0gYmFyeVsyXTtcblxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FydGVzaWFuIGNvb3JkaW5hdGVzIGZyb20gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgd2l0aGluIGEgdHJpYW5nbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhcnljZW50cmljVG9DYXJ0ZXNpYW4oYmFyeSwgYSwgYiwgYywgY2FydGVzaWFuID0gbWF0aC52ZWMzKCkpIHtcbiAgICAgICAgY29uc3QgdSA9IGJhcnlbMF07XG4gICAgICAgIGNvbnN0IHYgPSBiYXJ5WzFdO1xuICAgICAgICBjb25zdCB3ID0gYmFyeVsyXTtcblxuICAgICAgICBjYXJ0ZXNpYW5bMF0gPSBhWzBdICogdSArIGJbMF0gKiB2ICsgY1swXSAqIHc7XG4gICAgICAgIGNhcnRlc2lhblsxXSA9IGFbMV0gKiB1ICsgYlsxXSAqIHYgKyBjWzFdICogdztcbiAgICAgICAgY2FydGVzaWFuWzJdID0gYVsyXSAqIHUgKyBiWzJdICogdiArIGNbMl0gKiB3O1xuXG4gICAgICAgIHJldHVybiBjYXJ0ZXNpYW47XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gZ2VvbWV0cnkgZGVmaW5lZCBhcyBhbiBhcnJheSBvZiBwb3NpdGlvbnMsIG9wdGlvbmFsIG5vcm1hbHMsIG9wdGlvbiB1diBhbmQgYW4gYXJyYXkgb2YgaW5kaWNlcywgcmV0dXJuc1xuICAgICAqIG1vZGlmaWVkIGFycmF5cyB0aGF0IGhhdmUgZHVwbGljYXRlIHZlcnRpY2VzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBkb2VzIG5vdCB3b3JrIHdlbGwgd2hlbiBjby1pbmNpZGVudCB2ZXJ0aWNlcyBoYXZlIHNhbWUgcG9zaXRpb25zIGJ1dCBkaWZmZXJlbnQgbm9ybWFscyBhbmQgVVZzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSBub3JtYWxzXG4gICAgICogQHBhcmFtIHV2XG4gICAgICogQHBhcmFtIGluZGljZXNcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIGluZGljZXM6IEFycmF5fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1lcmdlVmVydGljZXMocG9zaXRpb25zLCBub3JtYWxzLCB1diwgaW5kaWNlcykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICAgICAgY29uc3QgaW5kaWNlc0xvb2t1cCA9IFtdO1xuICAgICAgICBjb25zdCB1bmlxdWVQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5pcXVlTm9ybWFscyA9IG5vcm1hbHMgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVVWID0gdXYgPyBbXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGluZGljZXMyID0gW107XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgdXZpID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zTWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc01hcFtrZXldID0gdW5pcXVlUG9zaXRpb25zLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zLnB1c2godngpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9ucy5wdXNoKHZ5KTtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnMucHVzaCh2eik7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlTm9ybWFscy5wdXNoKG5vcm1hbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOb3JtYWxzLnB1c2gobm9ybWFsc1tpICsgMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmldKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVVYucHVzaCh1dlt1dmkgKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgICAgIHV2aSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGluZGljZXMyW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHVuaXF1ZVBvc2l0aW9ucyxcbiAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMyXG4gICAgICAgIH07XG4gICAgICAgIGlmICh1bmlxdWVOb3JtYWxzKSB7XG4gICAgICAgICAgICByZXN1bHQubm9ybWFscyA9IHVuaXF1ZU5vcm1hbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXF1ZVVWKSB7XG4gICAgICAgICAgICByZXN1bHQudXYgPSB1bmlxdWVVVjtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBub3JtYWwgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucyBhbmQgaW5kaWNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGROb3JtYWxzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBjb25zdCBhYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY29uc3QgY3Jvc3NWZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgIHJldHVybiAocG9zaXRpb25zLCBpbmRpY2VzLCBub3JtYWxzKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgICAgIGNvbnN0IG52ZWNzID0gbmV3IEFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzKTtcbiAgICAgICAgICAgIGxldCBqMDtcbiAgICAgICAgICAgIGxldCBqMTtcbiAgICAgICAgICAgIGxldCBqMjtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuXG4gICAgICAgICAgICAgICAgajAgPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGoxID0gaW5kaWNlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgajIgPSBpbmRpY2VzW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgIGFbMF0gPSBwb3NpdGlvbnNbajAgKiAzXTtcbiAgICAgICAgICAgICAgICBhWzFdID0gcG9zaXRpb25zW2owICogMyArIDFdO1xuICAgICAgICAgICAgICAgIGFbMl0gPSBwb3NpdGlvbnNbajAgKiAzICsgMl07XG5cbiAgICAgICAgICAgICAgICBiWzBdID0gcG9zaXRpb25zW2oxICogM107XG4gICAgICAgICAgICAgICAgYlsxXSA9IHBvc2l0aW9uc1tqMSAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICBiWzJdID0gcG9zaXRpb25zW2oxICogMyArIDJdO1xuXG4gICAgICAgICAgICAgICAgY1swXSA9IHBvc2l0aW9uc1tqMiAqIDNdO1xuICAgICAgICAgICAgICAgIGNbMV0gPSBwb3NpdGlvbnNbajIgKiAzICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHBvc2l0aW9uc1tqMiAqIDMgKyAyXTtcblxuICAgICAgICAgICAgICAgIG1hdGguc3ViVmVjMyhiLCBhLCBhYik7XG4gICAgICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGEsIGFjKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1WZWMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuXG4gICAgICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKG1hdGguY3Jvc3MzVmVjMyhhYiwgYWMsIGNyb3NzVmVjKSwgbm9ybVZlYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW52ZWNzW2owXSkge1xuICAgICAgICAgICAgICAgICAgICBudmVjc1tqMF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFudmVjc1tqMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnZlY3NbajFdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbnZlY3NbajJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG52ZWNzW2oyXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG52ZWNzW2owXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oxXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgICAgIG52ZWNzW2oyXS5wdXNoKG5vcm1WZWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub3JtYWxzID0gKG5vcm1hbHMgJiYgbm9ybWFscy5sZW5ndGggPT09IHBvc2l0aW9ucy5sZW5ndGgpID8gbm9ybWFscyA6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGxldCBjb3VudDtcbiAgICAgICAgICAgIGxldCB4O1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgejtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbnZlY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgIC8vIE5vdyBnbyB0aHJvdWdoIGFuZCBhdmVyYWdlIG91dCBldmVyeXRoaW5nXG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IG52ZWNzW2ldLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIHogPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbnZlY3NbaV1bal1bMF07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbnZlY3NbaV1bal1bMV07XG4gICAgICAgICAgICAgICAgICAgIHogKz0gbnZlY3NbaV1bal1bMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9ybWFsc1tpICogM10gPSAoeCAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMV0gPSAoeSAvIGNvdW50KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzW2kgKiAzICsgMl0gPSAoeiAvIGNvdW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IHRhbmdlbnQgdmVjdG9ycyBmcm9tIHBvc2l0aW9ucywgVVZzIGFuZCBpbmRpY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFRhbmdlbnRzOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB0ZW1wVmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWMzZyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbnMsIGluZGljZXMsIHV2KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gVGhlIHZlcnRleCBhcnJheXMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgdGFuZ2VudHNcblxuICAgICAgICAgICAgZm9yIChsZXQgbG9jYXRpb24gPSAwOyBsb2NhdGlvbiA8IGluZGljZXMubGVuZ3RoOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWNvbnRydWN0aW5nIGVhY2ggdmVydGV4IGFuZCBVViBjb29yZGluYXRlIGludG8gdGhlIHJlc3BlY3RpdmUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHBvc2l0aW9ucy5zdWJhcnJheShpbmRleCAqIDMsIGluZGV4ICogMyArIDMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHV2MCA9IHV2LnN1YmFycmF5KGluZGV4ICogMiwgaW5kZXggKiAyICsgMik7XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gcG9zaXRpb25zLnN1YmFycmF5KGluZGV4ICogMywgaW5kZXggKiAzICsgMyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXYxID0gdXYuc3ViYXJyYXkoaW5kZXggKiAyLCBpbmRleCAqIDIgKyAyKTtcblxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1tsb2NhdGlvbiArIDJdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdjIgPSBwb3NpdGlvbnMuc3ViYXJyYXkoaW5kZXggKiAzLCBpbmRleCAqIDMgKyAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1djIgPSB1di5zdWJhcnJheShpbmRleCAqIDIsIGluZGV4ICogMiArIDIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFQb3MxID0gbWF0aC5zdWJWZWMzKHYxLCB2MCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhUG9zMiA9IG1hdGguc3ViVmVjMyh2MiwgdjAsIHRlbXBWZWMzYik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMSA9IG1hdGguc3ViVmVjMih1djEsIHV2MCwgdGVtcFZlYzNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVVWMiA9IG1hdGguc3ViVmVjMih1djIsIHV2MCwgdGVtcFZlYzNkKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSAxIC8gKChkZWx0YVVWMVswXSAqIGRlbHRhVVYyWzFdKSAtIChkZWx0YVVWMVsxXSAqIGRlbHRhVVYyWzBdKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gbWF0aC5tdWxWZWMzU2NhbGFyKFxuICAgICAgICAgICAgICAgICAgICBtYXRoLnN1YlZlYzMoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm11bFZlYzNTY2FsYXIoZGVsdGFQb3MxLCBkZWx0YVVWMlsxXSwgdGVtcFZlYzNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubXVsVmVjM1NjYWxhcihkZWx0YVBvczIsIGRlbHRhVVYxWzFdLCB0ZW1wVmVjM2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFZlYzNnXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZWMzZlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBdmVyYWdlIHRoZSB2YWx1ZSBvZiB0aGUgdmVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbGV0IGFkZFRvO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCAzOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG8gPSBpbmRpY2VzW2xvY2F0aW9uICsgdl0gKiAzO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUb10gKz0gdGFuZ2VudFswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudHNbYWRkVG8gKyAxXSArPSB0YW5nZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50c1thZGRUbyArIDJdICs9IHRhbmdlbnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFuZ2VudHM7XG4gICAgICAgIH07XG4gICAgfSkpKCksXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdmVydGV4IGFuZCBpbmRleCBhcnJheXMgbmVlZGVkIGJ5IGNvbG9yLWluZGV4ZWQgdHJpYW5nbGUgcGlja2luZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRQaWNrVHJpYW5nbGVzKHBvc2l0aW9ucywgaW5kaWNlcywgY29tcHJlc3NHZW9tZXRyeSkge1xuXG4gICAgICAgIGNvbnN0IG51bUluZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGlja1Bvc2l0aW9ucyA9IGNvbXByZXNzR2VvbWV0cnkgPyBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcyAqIDkpIDogbmV3IEZsb2F0MzJBcnJheShudW1JbmRpY2VzICogOSk7XG4gICAgICAgIGNvbnN0IHBpY2tDb2xvcnMgPSBuZXcgVWludDhBcnJheShudW1JbmRpY2VzICogMTIpO1xuICAgICAgICBsZXQgcHJpbUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHZpOy8vIFBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcHZpID0gMDsvLyBQaWNraW5nIHBvc2l0aW9ucyBhcnJheSBpbmRleFxuICAgICAgICBsZXQgcGNpID0gMDsgLy8gUGlja2luZyBjb2xvciBhcnJheSBpbmRleFxuXG4gICAgICAgIC8vIFRyaWFuZ2xlIGluZGljZXNcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCByO1xuICAgICAgICBsZXQgZztcbiAgICAgICAgbGV0IGI7XG4gICAgICAgIGxldCBhO1xuXG4gICAgICAgIGZvciAobGV0IGxvY2F0aW9uID0gMDsgbG9jYXRpb24gPCBudW1JbmRpY2VzOyBsb2NhdGlvbiArPSAzKSB7XG5cbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZS1pbmRleGVkIHRyaWFuZ2xlIHBpY2sgY29sb3JcblxuICAgICAgICAgICAgYSA9IChwcmltSW5kZXggPj4gMjQgJiAweEZGKTtcbiAgICAgICAgICAgIGIgPSAocHJpbUluZGV4ID4+IDE2ICYgMHhGRik7XG4gICAgICAgICAgICBnID0gKHByaW1JbmRleCA+PiA4ICYgMHhGRik7XG4gICAgICAgICAgICByID0gKHByaW1JbmRleCAmIDB4RkYpO1xuXG4gICAgICAgICAgICAvLyBBXG5cbiAgICAgICAgICAgIGkgPSBpbmRpY2VzW2xvY2F0aW9uXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIEJcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAxXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIC8vIENcblxuICAgICAgICAgICAgaSA9IGluZGljZXNbbG9jYXRpb24gKyAyXTtcbiAgICAgICAgICAgIHZpID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpXTtcbiAgICAgICAgICAgIHBpY2tQb3NpdGlvbnNbcHZpKytdID0gcG9zaXRpb25zW3ZpICsgMV07XG4gICAgICAgICAgICBwaWNrUG9zaXRpb25zW3B2aSsrXSA9IHBvc2l0aW9uc1t2aSArIDJdO1xuXG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IHI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGc7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGI7XG4gICAgICAgICAgICBwaWNrQ29sb3JzW3BjaSsrXSA9IGE7XG5cbiAgICAgICAgICAgIHByaW1JbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogcGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGNvbG9yczogcGlja0NvbG9yc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBzdXJmYWNlLXBlcnBlbmRpY3VsYXIgZmFjZSBub3JtYWxzIHRvIHZlcnRleCBub3JtYWxzLiBBc3N1bWVzIHRoYXQgdGhlIG1lc2ggY29udGFpbnMgZGlzam9pbnQgdHJpYW5nbGVzXG4gICAgICogdGhhdCBkb24ndCBzaGFyZSB2ZXJ0ZXggYXJyYXkgZWxlbWVudHMuIFdvcmtzIGJ5IGZpbmRpbmcgZ3JvdXBzIG9mIHZlcnRpY2VzIHRoYXQgaGF2ZSB0aGUgc2FtZSBsb2NhdGlvbiBhbmRcbiAgICAgKiBhdmVyYWdpbmcgdGhlaXIgbm9ybWFsIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uczogQXJyYXksIG5vcm1hbHM6ICp9fVxuICAgICAqL1xuICAgIGZhY2VUb1ZlcnRleE5vcm1hbHMocG9zaXRpb25zLCBub3JtYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc21vb3RoTm9ybWFsc0FuZ2xlVGhyZXNob2xkID0gb3B0aW9ucy5zbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQgfHwgMjA7XG4gICAgICAgIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJ0ZXhOb3JtYWxzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnRleE5vcm1hbEFjY3VtID0ge307XG4gICAgICAgIGxldCBhY2M7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgbGV0IHZ5O1xuICAgICAgICBsZXQgdno7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAxMCAqKiBwcmVjaXNpb25Qb2ludHM7XG4gICAgICAgIGxldCBwb3NpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBsZW47XG4gICAgICAgIGxldCBhO1xuICAgICAgICBsZXQgYjtcbiAgICAgICAgbGV0IGM7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIHBvc2kgPSBpIC8gMztcblxuICAgICAgICAgICAgdnggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB2eSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICB2eiA9IHBvc2l0aW9uc1tpICsgMl07XG5cbiAgICAgICAgICAgIGtleSA9IGAke01hdGgucm91bmQodnggKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnkgKiBwcmVjaXNpb24pfV8ke01hdGgucm91bmQodnogKiBwcmVjaXNpb24pfWA7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4TWFwW2tleV0gPSBbcG9zaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRleE1hcFtrZXldLnB1c2gocG9zaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IG1hdGgubm9ybWFsaXplVmVjMyhbbm9ybWFsc1tpXSwgbm9ybWFsc1tpICsgMV0sIG5vcm1hbHNbaSArIDJdXSk7XG5cbiAgICAgICAgICAgIHZlcnRleE5vcm1hbHNbcG9zaV0gPSBub3JtYWw7XG5cbiAgICAgICAgICAgIGFjYyA9IG1hdGgudmVjNChbbm9ybWFsWzBdLCBub3JtYWxbMV0sIG5vcm1hbFsyXSwgMV0pO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxBY2N1bVtwb3NpXSA9IGFjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHZlcnRleE1hcCkge1xuXG4gICAgICAgICAgICBpZiAodmVydGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdmVydGV4TWFwW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtVmVydHMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlpID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgYWNjID0gdmVydGV4Tm9ybWFsQWNjdW1baWldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1WZXJ0czsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpqID0gdmVydGljZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB2ZXJ0ZXhOb3JtYWxzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB2ZXJ0ZXhOb3JtYWxzW2pqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhtYXRoLmFuZ2xlVmVjMyhhLCBiKSAvIG1hdGguREVHVE9SQUQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCBzbW9vdGhOb3JtYWxzQW5nbGVUaHJlc2hvbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1swXSArPSBiWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1sxXSArPSBiWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1syXSArPSBiWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1szXSArPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub3JtYWxzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgIGFjYyA9IHZlcnRleE5vcm1hbEFjY3VtW2kgLyAzXTtcblxuICAgICAgICAgICAgbm9ybWFsc1tpICsgMF0gPSBhY2NbMF0gLyBhY2NbM107XG4gICAgICAgICAgICBub3JtYWxzW2kgKyAxXSA9IGFjY1sxXSAvIGFjY1szXTtcbiAgICAgICAgICAgIG5vcm1hbHNbaSArIDJdID0gYWNjWzJdIC8gYWNjWzNdO1xuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSYXkgY2FzdGluZ1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgVHJhbnNmb3JtcyBhIENhbnZhcy1zcGFjZSBwb3NpdGlvbiBpbnRvIGEgV29ybGQtc3BhY2UgcmF5LCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb1dvcmxkUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gdmlld01hdHJpeCBWaWV3IG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSBwcm9qTWF0cml4IFByb2plY3Rpb24gbWF0cml4XG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGNhbnZhc1BvcyBUaGUgQ2FudmFzLXNwYWNlIHBvc2l0aW9uLlxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgY2FudmFzUG9zVG9Xb3JsZFJheTogKCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdGVtcE1hdDRiID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0YyA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGIgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGMgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCB0ZW1wVmVjNGQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgICAgIHJldHVybiAoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBwdk1hdCA9IG1hdGgubXVsTWF0NChwcm9qTWF0cml4LCB2aWV3TWF0cml4LCB0ZW1wTWF0NGIpO1xuICAgICAgICAgICAgY29uc3QgcHZNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NChwdk1hdCwgdGVtcE1hdDRjKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNsaXAgc3BhY2UgY29vcmRpbmF0ZXMsIHdoaWNoIHdpbGwgYmUgaW4gcmFuZ2VcbiAgICAgICAgICAgIC8vIG9mIHg9Wy0xLi4xXSBhbmQgeT1bLTEuLjFdLCB3aXRoIHk9KCsxKSBhdCB0b3BcblxuICAgICAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCBjbGlwWCA9IChjYW52YXNQb3NbMF0gLSBjYW52YXNXaWR0aCAvIDIpIC8gKGNhbnZhc1dpZHRoIC8gMik7ICAvLyBDYWxjdWxhdGUgY2xpcCBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29uc3QgY2xpcFkgPSAtKGNhbnZhc1Bvc1sxXSAtIGNhbnZhc0hlaWdodCAvIDIpIC8gKGNhbnZhc0hlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSBjbGlwWDtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IGNsaXBZO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gLTE7XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRiLCAxIC8gdGVtcFZlYzRiWzNdKTtcblxuICAgICAgICAgICAgdGVtcFZlYzRjWzBdID0gY2xpcFg7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbMV0gPSBjbGlwWTtcbiAgICAgICAgICAgIHRlbXBWZWM0Y1syXSA9IDE7XG4gICAgICAgICAgICB0ZW1wVmVjNGNbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQocHZNYXRJbnZlcnNlLCB0ZW1wVmVjNGMsIHRlbXBWZWM0ZCk7XG4gICAgICAgICAgICBtYXRoLm11bFZlYzRTY2FsYXIodGVtcFZlYzRkLCAxIC8gdGVtcFZlYzRkWzNdKTtcblxuICAgICAgICAgICAgd29ybGRSYXlPcmlnaW5bMF0gPSB0ZW1wVmVjNGRbMF07XG4gICAgICAgICAgICB3b3JsZFJheU9yaWdpblsxXSA9IHRlbXBWZWM0ZFsxXTtcbiAgICAgICAgICAgIHdvcmxkUmF5T3JpZ2luWzJdID0gdGVtcFZlYzRkWzJdO1xuXG4gICAgICAgICAgICBtYXRoLnN1YlZlYzModGVtcFZlYzRkLCB0ZW1wVmVjNGIsIHdvcmxkUmF5RGlyKTtcblxuICAgICAgICAgICAgbWF0aC5ub3JtYWxpemVWZWMzKHdvcmxkUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIC8qKlxuICAgICBUcmFuc2Zvcm1zIGEgQ2FudmFzLXNwYWNlIHBvc2l0aW9uIHRvIGEgTWVzaCdzIExvY2FsLXNwYWNlIGNvb3JkaW5hdGUgc3lzdGVtLCBpbiB0aGUgY29udGV4dCBvZiBhIENhbWVyYS5cbiAgICAgQG1ldGhvZCBjYW52YXNQb3NUb0xvY2FsUmF5XG4gICAgIEBzdGF0aWNcbiAgICAgQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBUaGUgQ2FtZXJhLlxuICAgICBAcGFyYW0ge01lc2h9IG1lc2ggVGhlIE1lc2guXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IHZpZXdNYXRyaXggVmlldyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gcHJvak1hdHJpeCBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBNb2RlbGluZyBtYXRyaXhcbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gY2FudmFzUG9zIFRoZSBDYW52YXMtc3BhY2UgcG9zaXRpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBjYW52YXNQb3NUb0xvY2FsUmF5OiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCB3b3JsZFJheU9yaWdpbiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGNvbnN0IHdvcmxkUmF5RGlyID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcblxuICAgICAgICByZXR1cm4gKGNhbnZhcywgdmlld01hdHJpeCwgcHJvak1hdHJpeCwgd29ybGRNYXRyaXgsIGNhbnZhc1BvcywgbG9jYWxSYXlPcmlnaW4sIGxvY2FsUmF5RGlyKSA9PiB7XG4gICAgICAgICAgICBtYXRoLmNhbnZhc1Bvc1RvV29ybGRSYXkoY2FudmFzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBjYW52YXNQb3MsIHdvcmxkUmF5T3JpZ2luLCB3b3JsZFJheURpcik7XG4gICAgICAgICAgICBtYXRoLndvcmxkUmF5VG9Mb2NhbFJheSh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG4gICAgLyoqXG4gICAgIFRyYW5zZm9ybXMgYSByYXkgZnJvbSBXb3JsZC1zcGFjZSB0byBhIE1lc2gncyBMb2NhbC1zcGFjZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgQG1ldGhvZCB3b3JsZFJheVRvTG9jYWxSYXlcbiAgICAgQHN0YXRpY1xuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZE1hdHJpeCBUaGUgV29ybGQgdHJhbnNmb3JtIG1hdHJpeFxuICAgICBAcGFyYW0ge051bWJlcltdfSB3b3JsZFJheU9yaWdpbiBUaGUgV29ybGQtc3BhY2UgcmF5IG9yaWdpbi5cbiAgICAgQHBhcmFtIHtOdW1iZXJbXX0gd29ybGRSYXlEaXIgVGhlIFdvcmxkLXNwYWNlIHJheSBkaXJlY3Rpb24uXG4gICAgIEBwYXJhbSB7TnVtYmVyW119IGxvY2FsUmF5T3JpZ2luIFRoZSBMb2NhbC1zcGFjZSByYXkgb3JpZ2luLlxuICAgICBAcGFyYW0ge051bWJlcltdfSBsb2NhbFJheURpciBUaGUgTG9jYWwtc3BhY2UgcmF5IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB3b3JsZFJheVRvTG9jYWxSYXk6ICgoKCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRlbXBNYXQ0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IHRlbXBWZWM0YiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAgICAgcmV0dXJuICh3b3JsZE1hdHJpeCwgd29ybGRSYXlPcmlnaW4sIHdvcmxkUmF5RGlyLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbW9kZWxNYXRJbnZlcnNlID0gbWF0aC5pbnZlcnNlTWF0NCh3b3JsZE1hdHJpeCwgdGVtcE1hdDQpO1xuXG4gICAgICAgICAgICB0ZW1wVmVjNGFbMF0gPSB3b3JsZFJheU9yaWdpblswXTtcbiAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IHdvcmxkUmF5T3JpZ2luWzFdO1xuICAgICAgICAgICAgdGVtcFZlYzRhWzJdID0gd29ybGRSYXlPcmlnaW5bMl07XG4gICAgICAgICAgICB0ZW1wVmVjNGFbM10gPSAxO1xuXG4gICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQobW9kZWxNYXRJbnZlcnNlLCB0ZW1wVmVjNGEsIHRlbXBWZWM0Yik7XG5cbiAgICAgICAgICAgIGxvY2FsUmF5T3JpZ2luWzBdID0gdGVtcFZlYzRiWzBdO1xuICAgICAgICAgICAgbG9jYWxSYXlPcmlnaW5bMV0gPSB0ZW1wVmVjNGJbMV07XG4gICAgICAgICAgICBsb2NhbFJheU9yaWdpblsyXSA9IHRlbXBWZWM0YlsyXTtcblxuICAgICAgICAgICAgbWF0aC50cmFuc2Zvcm1WZWMzKG1vZGVsTWF0SW52ZXJzZSwgd29ybGRSYXlEaXIsIGxvY2FsUmF5RGlyKTtcbiAgICAgICAgfTtcbiAgICB9KSkoKSxcblxuICAgIGJ1aWxkS0RUcmVlOiAoKCgpID0+IHtcblxuICAgICAgICBjb25zdCBLRF9UUkVFX01BWF9ERVBUSCA9IDEwO1xuICAgICAgICBjb25zdCBLRF9UUkVFX01JTl9UUklBTkdMRVMgPSAyMDtcblxuICAgICAgICBjb25zdCBkaW1MZW5ndGggPSBuZXcgRmxvYXQzMkFycmF5KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGROb2RlKHRyaWFuZ2xlcywgaW5kaWNlcywgcG9zaXRpb25zLCBkZXB0aCkge1xuICAgICAgICAgICAgY29uc3QgYWFiYiA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGVhZjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3BsaXREaW06IDAsXG4gICAgICAgICAgICAgICAgYWFiYlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWFiYlswXSA9IGFhYmJbMV0gPSBhYWJiWzJdID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgYWFiYlszXSA9IGFhYmJbNF0gPSBhYWJiWzVdID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IGxlbjtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlpID0gdHJpYW5nbGVzW3RdICogMztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IGluZGljZXNbaWkgKyBqXSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGldIDwgYWFiYlswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlswXSA9IHBvc2l0aW9uc1twaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW3BpXSA+IGFhYmJbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhYmJbM10gPSBwb3NpdGlvbnNbcGldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdIDwgYWFiYlsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsxXSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDFdID4gYWFiYls0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls0XSA9IHBvc2l0aW9uc1twaSArIDFdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdIDwgYWFiYlsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYlsyXSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1twaSArIDJdID4gYWFiYls1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYls1XSA9IHBvc2l0aW9uc1twaSArIDJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmlhbmdsZXMubGVuZ3RoIDwgS0RfVFJFRV9NSU5fVFJJQU5HTEVTIHx8IGRlcHRoID4gS0RfVFJFRV9NQVhfREVQVEgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcbiAgICAgICAgICAgICAgICBub2RlLmxlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaW1MZW5ndGhbMF0gPSBhYWJiWzNdIC0gYWFiYlswXTtcbiAgICAgICAgICAgIGRpbUxlbmd0aFsxXSA9IGFhYmJbNF0gLSBhYWJiWzFdO1xuICAgICAgICAgICAgZGltTGVuZ3RoWzJdID0gYWFiYls1XSAtIGFhYmJbMl07XG5cbiAgICAgICAgICAgIGxldCBkaW0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzFdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGltTGVuZ3RoWzJdID4gZGltTGVuZ3RoW2RpbV0pIHtcbiAgICAgICAgICAgICAgICBkaW0gPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLnNwbGl0RGltID0gZGltO1xuXG4gICAgICAgICAgICBjb25zdCBtaWQgPSAoYWFiYltkaW1dICsgYWFiYltkaW0gKyAzXSkgLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG5ldyBBcnJheSh0cmlhbmdsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBudW1MZWZ0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbmV3IEFycmF5KHRyaWFuZ2xlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IG51bVJpZ2h0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh0ID0gMCwgbGVuID0gdHJpYW5nbGVzLmxlbmd0aDsgdCA8IGxlbjsgKyt0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWkgPSB0cmlhbmdsZXNbdF0gKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkwID0gaW5kaWNlc1tpaV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTEgPSBpbmRpY2VzW2lpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaTIgPSBpbmRpY2VzW2lpICsgMl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwaTAgPSBpMCAqIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGkxID0gaTEgKiAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpMiA9IGkyICogMztcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbcGkwICsgZGltXSA8PSBtaWQgfHwgcG9zaXRpb25zW3BpMSArIGRpbV0gPD0gbWlkIHx8IHBvc2l0aW9uc1twaTIgKyBkaW1dIDw9IG1pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0W251bUxlZnQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRbbnVtUmlnaHQrK10gPSB0cmlhbmdsZXNbdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0Lmxlbmd0aCA9IG51bUxlZnQ7XG4gICAgICAgICAgICByaWdodC5sZW5ndGggPSBudW1SaWdodDtcblxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gYnVpbGROb2RlKGxlZnQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSBidWlsZE5vZGUocmlnaHQsIGluZGljZXMsIHBvc2l0aW9ucywgZGVwdGggKyAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGluZGljZXMsIHBvc2l0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbnVtVHJpcyA9IGluZGljZXMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IG5ldyBBcnJheShudW1UcmlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJpczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZE5vZGUodHJpYW5nbGVzLCBpbmRpY2VzLCBwb3NpdGlvbnMsIDApO1xuICAgICAgICB9O1xuICAgIH0pKSgpLFxuXG5cbiAgICBkZWNvbXByZXNzUG9zaXRpb24ocG9zaXRpb24sIGRlY29kZU1hdHJpeCwgZGVzdCkge1xuICAgICAgICBkZXN0WzBdID0gcG9zaXRpb25bMF0gKiBkZWNvZGVNYXRyaXhbMF0gKyBkZWNvZGVNYXRyaXhbMTJdO1xuICAgICAgICBkZXN0WzFdID0gcG9zaXRpb25bMV0gKiBkZWNvZGVNYXRyaXhbNV0gKyBkZWNvZGVNYXRyaXhbMTNdO1xuICAgICAgICBkZXN0WzJdID0gcG9zaXRpb25bMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1Bvc2l0aW9ucyhwb3NpdGlvbnMsIGRlY29kZU1hdHJpeCwgZGVzdCA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgZGVzdFtpICsgMF0gPSBwb3NpdGlvbnNbaSArIDBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzEyXTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gcG9zaXRpb25zW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs1XSArIGRlY29kZU1hdHJpeFsxM107XG4gICAgICAgICAgICBkZXN0W2kgKyAyXSA9IHBvc2l0aW9uc1tpICsgMl0gKiBkZWNvZGVNYXRyaXhbMTBdICsgZGVjb2RlTWF0cml4WzE0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgZGVjb21wcmVzc1VWKHV2LCBkZWNvZGVNYXRyaXgsIGRlc3QpIHtcbiAgICAgICAgZGVzdFswXSA9IHV2WzBdICogZGVjb2RlTWF0cml4WzBdICsgZGVjb2RlTWF0cml4WzZdO1xuICAgICAgICBkZXN0WzFdID0gdXZbMV0gKiBkZWNvZGVNYXRyaXhbNF0gKyBkZWNvZGVNYXRyaXhbN107XG4gICAgfSxcblxuICAgIGRlY29tcHJlc3NVVnModXZzLCBkZWNvZGVNYXRyaXgsIGRlc3QgPSBuZXcgRmxvYXQzMkFycmF5KHV2cy5sZW5ndGgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB1dnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGRlc3RbaSArIDBdID0gdXZzW2kgKyAwXSAqIGRlY29kZU1hdHJpeFswXSArIGRlY29kZU1hdHJpeFs2XTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gdXZzW2kgKyAxXSAqIGRlY29kZU1hdHJpeFs0XSArIGRlY29kZU1hdHJpeFs3XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMihvY3QsIHJlc3VsdCkge1xuICAgICAgICBsZXQgeCA9IG9jdFswXTtcbiAgICAgICAgbGV0IHkgPSBvY3RbMV07XG4gICAgICAgIHggPSAoMiAqIHggKyAxKSAvIDI1NTtcbiAgICAgICAgeSA9ICgyICogeSArIDEpIC8gMjU1O1xuICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgeCA9ICgxIC0gTWF0aC5hYnMoeSkpICogKHggPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgcmVzdWx0WzBdID0geCAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgcmVzdWx0WzJdID0geiAvIGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgb2N0RGVjb2RlVmVjMnMob2N0cywgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbGVuID0gb2N0cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHggPSBvY3RzW2kgKyAwXTtcbiAgICAgICAgICAgIGxldCB5ID0gb2N0c1tpICsgMV07XG4gICAgICAgICAgICB4ID0gKDIgKiB4ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICB5ID0gKDIgKiB5ICsgMSkgLyAyNTU7XG4gICAgICAgICAgICBjb25zdCB6ID0gMSAtIE1hdGguYWJzKHgpIC0gTWF0aC5hYnMoeSk7XG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gKDEgLSBNYXRoLmFicyh5KSkgKiAoeCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICB5ID0gKDEgLSBNYXRoLmFicyh4KSkgKiAoeSA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICAgICAgcmVzdWx0W2ogKyAwXSA9IHggLyBsZW5ndGg7XG4gICAgICAgICAgICByZXN1bHRbaiArIDFdID0geSAvIGxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdFtqICsgMl0gPSB6IC8gbGVuZ3RoO1xuICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubWF0aC5idWlsZEVkZ2VJbmRpY2VzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHVuaXF1ZVBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXNMb29rdXAgPSBbXTtcbiAgICBjb25zdCBpbmRpY2VzUmV2ZXJzZUxvb2t1cCA9IFtdO1xuICAgIGNvbnN0IHdlbGRlZEluZGljZXMgPSBbXTtcblxuICAgIC8vIFRPRE86IE9wdGltaXplIHdpdGggY2FjaGluZywgYnV0IG5lZWQgdG8gY2F0ZXIgdG8gYm90aCBjb21wcmVzc2VkIGFuZCB1bmNvbXByZXNzZWQgcG9zaXRpb25zXG5cbiAgICBjb25zdCBmYWNlcyA9IFtdO1xuICAgIGxldCBudW1GYWNlcyA9IDA7XG4gICAgY29uc3QgY29tcGEgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGIgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgY29tcGMgPSBuZXcgVWludDE2QXJyYXkoMyk7XG4gICAgY29uc3QgYSA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBjID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgY2IgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBhYiA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IGNyb3NzID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3Qgbm9ybWFsID0gbWF0aC52ZWMzKCk7XG5cbiAgICBmdW5jdGlvbiB3ZWxkVmVydGljZXMocG9zaXRpb25zLCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuICAgICAgICBsZXQgdng7XG4gICAgICAgIGxldCB2eTtcbiAgICAgICAgbGV0IHZ6O1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBjb25zdCBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvblBvaW50cyk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBsZXQgbGVuVW5pcXVlUG9zaXRpb25zID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2eCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIHZ5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHZ6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIGtleSA9IE1hdGgucm91bmQodnggKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2eSAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZ6ICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbnNNYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zTWFwW2tleV0gPSBsZW5VbmlxdWVQb3NpdGlvbnMgLyAzO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVBvc2l0aW9uc1tsZW5VbmlxdWVQb3NpdGlvbnMrK10gPSB2eDtcbiAgICAgICAgICAgICAgICB1bmlxdWVQb3NpdGlvbnNbbGVuVW5pcXVlUG9zaXRpb25zKytdID0gdnk7XG4gICAgICAgICAgICAgICAgdW5pcXVlUG9zaXRpb25zW2xlblVuaXF1ZVBvc2l0aW9ucysrXSA9IHZ6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc0xvb2t1cFtpIC8gM10gPSBwb3NpdGlvbnNNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB3ZWxkZWRJbmRpY2VzW2ldID0gaW5kaWNlc0xvb2t1cFtpbmRpY2VzW2ldXTtcbiAgICAgICAgICAgIGluZGljZXNSZXZlcnNlTG9va3VwW3dlbGRlZEluZGljZXNbaV1dID0gaW5kaWNlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmFjZXMobnVtSW5kaWNlcywgcG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgIG51bUZhY2VzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG51bUluZGljZXM7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgaWEgPSAoKHdlbGRlZEluZGljZXNbaV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYiA9ICgod2VsZGVkSW5kaWNlc1tpICsgMV0pICogMyk7XG4gICAgICAgICAgICBjb25zdCBpYyA9ICgod2VsZGVkSW5kaWNlc1tpICsgMl0pICogMyk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgY29tcGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGNvbXBhWzFdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMV07XG4gICAgICAgICAgICAgICAgY29tcGFbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAyXTtcbiAgICAgICAgICAgICAgICBjb21wYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgY29tcGJbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb21wYlsyXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDJdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjb21wY1sxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDFdO1xuICAgICAgICAgICAgICAgIGNvbXBjWzJdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMl07XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlXG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGEsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYSk7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGIsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYik7XG4gICAgICAgICAgICAgICAgbWF0aC5kZWNvbXByZXNzUG9zaXRpb24oY29tcGMsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFbMF0gPSB1bmlxdWVQb3NpdGlvbnNbaWFdO1xuICAgICAgICAgICAgICAgIGFbMV0gPSB1bmlxdWVQb3NpdGlvbnNbaWEgKyAxXTtcbiAgICAgICAgICAgICAgICBhWzJdID0gdW5pcXVlUG9zaXRpb25zW2lhICsgMl07XG4gICAgICAgICAgICAgICAgYlswXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYl07XG4gICAgICAgICAgICAgICAgYlsxXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYiArIDFdO1xuICAgICAgICAgICAgICAgIGJbMl0gPSB1bmlxdWVQb3NpdGlvbnNbaWIgKyAyXTtcbiAgICAgICAgICAgICAgICBjWzBdID0gdW5pcXVlUG9zaXRpb25zW2ljXTtcbiAgICAgICAgICAgICAgICBjWzFdID0gdW5pcXVlUG9zaXRpb25zW2ljICsgMV07XG4gICAgICAgICAgICAgICAgY1syXSA9IHVuaXF1ZVBvc2l0aW9uc1tpYyArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0aC5zdWJWZWMzKGMsIGIsIGNiKTtcbiAgICAgICAgICAgIG1hdGguc3ViVmVjMyhhLCBiLCBhYik7XG4gICAgICAgICAgICBtYXRoLmNyb3NzM1ZlYzMoY2IsIGFiLCBjcm9zcyk7XG4gICAgICAgICAgICBtYXRoLm5vcm1hbGl6ZVZlYzMoY3Jvc3MsIG5vcm1hbCk7XG4gICAgICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbbnVtRmFjZXNdIHx8IChmYWNlc1tudW1GYWNlc10gPSB7bm9ybWFsOiBtYXRoLnZlYzMoKX0pO1xuICAgICAgICAgICAgZmFjZS5ub3JtYWxbMF0gPSBub3JtYWxbMF07XG4gICAgICAgICAgICBmYWNlLm5vcm1hbFsxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICAgIGZhY2Uubm9ybWFsWzJdID0gbm9ybWFsWzJdO1xuICAgICAgICAgICAgbnVtRmFjZXMrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocG9zaXRpb25zLCBpbmRpY2VzLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGVkZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgd2VsZFZlcnRpY2VzKHBvc2l0aW9ucywgaW5kaWNlcyk7XG4gICAgICAgIGJ1aWxkRmFjZXMoaW5kaWNlcy5sZW5ndGgsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgIGNvbnN0IGVkZ2VJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKG1hdGguREVHVE9SQUQgKiBlZGdlVGhyZXNob2xkKTtcbiAgICAgICAgY29uc3QgZWRnZXMgPSB7fTtcbiAgICAgICAgbGV0IGVkZ2UxO1xuICAgICAgICBsZXQgZWRnZTI7XG4gICAgICAgIGxldCBpbmRleDE7XG4gICAgICAgIGxldCBpbmRleDI7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCBsYXJnZUluZGV4ID0gZmFsc2U7XG4gICAgICAgIGxldCBlZGdlO1xuICAgICAgICBsZXQgbm9ybWFsMTtcbiAgICAgICAgbGV0IG5vcm1hbDI7XG4gICAgICAgIGxldCBkb3Q7XG4gICAgICAgIGxldCBpYTtcbiAgICAgICAgbGV0IGliO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgZmFjZUluZGV4ID0gaSAvIDM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgIGVkZ2UxID0gd2VsZGVkSW5kaWNlc1tpICsgal07XG4gICAgICAgICAgICAgICAgZWRnZTIgPSB3ZWxkZWRJbmRpY2VzW2kgKyAoKGogKyAxKSAlIDMpXTtcbiAgICAgICAgICAgICAgICBpbmRleDEgPSBNYXRoLm1pbihlZGdlMSwgZWRnZTIpO1xuICAgICAgICAgICAgICAgIGluZGV4MiA9IE1hdGgubWF4KGVkZ2UxLCBlZGdlMik7XG4gICAgICAgICAgICAgICAga2V5ID0gaW5kZXgxICsgXCIsXCIgKyBpbmRleDI7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlZGdlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxOiBpbmRleDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDI6IGluZGV4MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UxOiBmYWNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlMjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNba2V5XS5mYWNlMiA9IGZhY2VJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gZWRnZXMpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1trZXldO1xuICAgICAgICAgICAgLy8gYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXG4gICAgICAgICAgICBpZiAoZWRnZS5mYWNlMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsMSA9IGZhY2VzW2VkZ2UuZmFjZTFdLm5vcm1hbDtcbiAgICAgICAgICAgICAgICBub3JtYWwyID0gZmFjZXNbZWRnZS5mYWNlMl0ubm9ybWFsO1xuICAgICAgICAgICAgICAgIGRvdCA9IG1hdGguZG90VmVjMyhub3JtYWwxLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gdGhyZXNob2xkRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlhID0gaW5kaWNlc1JldmVyc2VMb29rdXBbZWRnZS5pbmRleDFdO1xuICAgICAgICAgICAgaWIgPSBpbmRpY2VzUmV2ZXJzZUxvb2t1cFtlZGdlLmluZGV4Ml07XG4gICAgICAgICAgICBpZiAoIWxhcmdlSW5kZXggJiYgaWEgPiA2NTUzNSB8fCBpYiA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgbGFyZ2VJbmRleCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGdlSW5kaWNlcy5wdXNoKGlhKTtcbiAgICAgICAgICAgIGVkZ2VJbmRpY2VzLnB1c2goaWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobGFyZ2VJbmRleCkgPyBuZXcgVWludDMyQXJyYXkoZWRnZUluZGljZXMpIDogbmV3IFVpbnQxNkFycmF5KGVkZ2VJbmRpY2VzKTtcbiAgICB9O1xufSkoKTtcblxuXG5leHBvcnQge21hdGh9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js ***!
  \****************************************************************************/
/*! exports provided: createRTCViewMat, worldToRTCPos, worldToRTCPositions, rtcToWorldPos, getPlaneRTCPos */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRTCViewMat\", function() { return createRTCViewMat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"worldToRTCPos\", function() { return worldToRTCPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"worldToRTCPositions\", function() { return worldToRTCPositions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rtcToWorldPos\", function() { return rtcToWorldPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPlaneRTCPos\", function() { return getPlaneRTCPos; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n\n\nconst tempVec3a = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\nconst tempAABB3 = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].AABB3();\n\n/**\n * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix\n * to transform RTC coordinates to View-space.\n *\n * The returned view matrix is\n *\n * @private\n */\nconst createRTCViewMat = (function () {\n\n    const tempMat = new Float32Array(16);\n    const rtcCenterWorld = new Float64Array(4);\n    const rtcCenterView = new Float64Array(4);\n\n    return function (viewMat, rtcCenter, rtcViewMat = tempMat) {\n        rtcCenterWorld[0] = rtcCenter[0];\n        rtcCenterWorld[1] = rtcCenter[1];\n        rtcCenterWorld[2] = rtcCenter[2];\n        rtcCenterWorld[3] = 1;\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformVec4(viewMat, rtcCenterWorld, rtcCenterView);\n        _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].setMat4Translation(viewMat, rtcCenterView, rtcViewMat);\n        return rtcViewMat;\n    }\n}());\n\n/**\n * Converts a World-space 3D position to RTC.\n *\n * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos\n * and a single-precision offset fom that center.\n *\n * @param {Float64Array} worldPos The World-space position.\n * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param {Float32Array} rtcPos Single-precision offset fom that center.\n */\nfunction worldToRTCPos(worldPos, rtcCenter, rtcPos) {\n\n    const xHigh = Float32Array.from([worldPos[0]])[0];\n    const xLow = worldPos[0] - xHigh;\n\n    const yHigh = Float32Array.from([worldPos[1]])[0];\n    const yLow = worldPos[1] - yHigh;\n\n    const zHigh = Float32Array.from([worldPos[2]])[0];\n    const zLow = worldPos[2] - zHigh;\n\n    rtcCenter[0] = xHigh;\n    rtcCenter[1] = yHigh;\n    rtcCenter[2] = zHigh;\n\n    rtcPos[0] = xLow;\n    rtcPos[1] = yLow;\n    rtcPos[2] = zLow;\n}\n\n\n/**\n * Converts a flat array of double-precision positions to RTC positions.\n *\n * Returns the RTC positions, along with a computed RTC center for those positions.\n *\n * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,\n * identical RTC positions are reused for different positions arrays.\n *\n * @param {Float64Array} worldPositions Flat array of World-space 3D positions.\n * @param {Float64Array} rtcPositions Outputs the computed flat array of 3D RTC positions.\n * @param {Float64Array} rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.\n * @param {Number} [cellSize=10000000] The size of each coordinate cell within the RTC coordinate system.\n * @returns {Boolean} ````True```` if the positions actually needed conversion to RTC, else ````false````. When\n * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,\n * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.\n */\nfunction worldToRTCPositions(worldPositions, rtcPositions, rtcCenter, cellSize = 10000000) {\n\n    const center = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].getPositionsCenter(worldPositions, tempVec3a);\n\n    const rtcCenterX = Math.round(center[0] / cellSize) * cellSize;\n    const rtcCenterY = Math.round(center[1] / cellSize) * cellSize;\n    const rtcCenterZ = Math.round(center[2] / cellSize) * cellSize;\n\n    for (let i = 0, len = worldPositions.length; i < len; i += 3) {\n        rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;\n        rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;\n        rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;\n    }\n\n    rtcCenter[0] = rtcCenterX;\n    rtcCenter[1] = rtcCenterY;\n    rtcCenter[2] = rtcCenterZ;\n\n    const rtcNeeded = (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0);\n\n    return rtcNeeded;\n}\n\n/**\n * Converts an RTC 3D position to World-space.\n *\n * @param {Float64Array} rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param {Float32Array} rtcPos Single-precision offset fom that center.\n * @param {Float64Array} worldPos The World-space position.\n */\nfunction rtcToWorldPos(rtcCenter, rtcPos, worldPos) {\n    worldPos[0] = rtcCenter[0] + rtcPos[0];\n    worldPos[1] = rtcCenter[1] + rtcPos[1];\n    worldPos[2] = rtcCenter[2] + rtcPos[2];\n    return worldPos;\n}\n\n/**\n * Given a 3D plane defined by distance from origin and direction, and an RTC center position,\n * return a plane position that is relative to the RTC center.\n *\n * @param dist\n * @param dir\n * @param rtcCenter\n * @param rtcPlanePos\n * @returns {*}\n */\nfunction getPlaneRTCPos(dist, dir, rtcCenter, rtcPlanePos) {\n    const rtcCenterToPlaneDist = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].dotVec3(dir, rtcCenter) + dist;\n    const dirNormalized = _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].normalizeVec3(dir, tempVec3a);\n    _math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);\n    return rtcPlanePos;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21hdGgvcnRjQ29vcmRzLmpzP2E1NTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7O0FBRS9CLGtCQUFrQiw2Q0FBSTtBQUN0QixrQkFBa0IsNkNBQUk7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQUk7QUFDWixRQUFRLDZDQUFJO0FBQ1o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw2Q0FBSTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBSTtBQUNyQywwQkFBMEIsNkNBQUk7QUFDOUIsSUFBSSw2Q0FBSTtBQUNSO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWF0aC9ydGNDb29yZHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge21hdGh9IGZyb20gJy4vbWF0aC5qcyc7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuY29uc3QgdGVtcEFBQkIzID0gbWF0aC5BQUJCMygpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmlldyBtYXRyaXggYW5kIGEgcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNvb3JkaW5hdGUgb3JpZ2luLCByZXR1cm5zIGEgdmlldyBtYXRyaXhcbiAqIHRvIHRyYW5zZm9ybSBSVEMgY29vcmRpbmF0ZXMgdG8gVmlldy1zcGFjZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgdmlldyBtYXRyaXggaXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjcmVhdGVSVENWaWV3TWF0ID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHRlbXBNYXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBjb25zdCBydGNDZW50ZXJXb3JsZCA9IG5ldyBGbG9hdDY0QXJyYXkoNCk7XG4gICAgY29uc3QgcnRjQ2VudGVyVmlldyA9IG5ldyBGbG9hdDY0QXJyYXkoNCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXdNYXQsIHJ0Y0NlbnRlciwgcnRjVmlld01hdCA9IHRlbXBNYXQpIHtcbiAgICAgICAgcnRjQ2VudGVyV29ybGRbMF0gPSBydGNDZW50ZXJbMF07XG4gICAgICAgIHJ0Y0NlbnRlcldvcmxkWzFdID0gcnRjQ2VudGVyWzFdO1xuICAgICAgICBydGNDZW50ZXJXb3JsZFsyXSA9IHJ0Y0NlbnRlclsyXTtcbiAgICAgICAgcnRjQ2VudGVyV29ybGRbM10gPSAxO1xuICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQodmlld01hdCwgcnRjQ2VudGVyV29ybGQsIHJ0Y0NlbnRlclZpZXcpO1xuICAgICAgICBtYXRoLnNldE1hdDRUcmFuc2xhdGlvbih2aWV3TWF0LCBydGNDZW50ZXJWaWV3LCBydGNWaWV3TWF0KTtcbiAgICAgICAgcmV0dXJuIHJ0Y1ZpZXdNYXQ7XG4gICAgfVxufSgpKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFdvcmxkLXNwYWNlIDNEIHBvc2l0aW9uIHRvIFJUQy5cbiAqXG4gKiBHaXZlbiBhIGRvdWJsZS1wcmVjaXNpb24gV29ybGQtc3BhY2UgcG9zaXRpb24sIHJldHVybnMgYSBkb3VibGUtcHJlY2lzaW9uIHJlbGF0aXZlLXRvLWNlbnRlciAoUlRDKSBjZW50ZXIgcG9zXG4gKiBhbmQgYSBzaW5nbGUtcHJlY2lzaW9uIG9mZnNldCBmb20gdGhhdCBjZW50ZXIuXG4gKlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHdvcmxkUG9zIFRoZSBXb3JsZC1zcGFjZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBydGNDZW50ZXIgRG91YmxlLXByZWNpc2lvbiByZWxhdGl2ZS10by1jZW50ZXIgKFJUQykgY2VudGVyIHBvcy5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBydGNQb3MgU2luZ2xlLXByZWNpc2lvbiBvZmZzZXQgZm9tIHRoYXQgY2VudGVyLlxuICovXG5mdW5jdGlvbiB3b3JsZFRvUlRDUG9zKHdvcmxkUG9zLCBydGNDZW50ZXIsIHJ0Y1Bvcykge1xuXG4gICAgY29uc3QgeEhpZ2ggPSBGbG9hdDMyQXJyYXkuZnJvbShbd29ybGRQb3NbMF1dKVswXTtcbiAgICBjb25zdCB4TG93ID0gd29ybGRQb3NbMF0gLSB4SGlnaDtcblxuICAgIGNvbnN0IHlIaWdoID0gRmxvYXQzMkFycmF5LmZyb20oW3dvcmxkUG9zWzFdXSlbMF07XG4gICAgY29uc3QgeUxvdyA9IHdvcmxkUG9zWzFdIC0geUhpZ2g7XG5cbiAgICBjb25zdCB6SGlnaCA9IEZsb2F0MzJBcnJheS5mcm9tKFt3b3JsZFBvc1syXV0pWzBdO1xuICAgIGNvbnN0IHpMb3cgPSB3b3JsZFBvc1syXSAtIHpIaWdoO1xuXG4gICAgcnRjQ2VudGVyWzBdID0geEhpZ2g7XG4gICAgcnRjQ2VudGVyWzFdID0geUhpZ2g7XG4gICAgcnRjQ2VudGVyWzJdID0gekhpZ2g7XG5cbiAgICBydGNQb3NbMF0gPSB4TG93O1xuICAgIHJ0Y1Bvc1sxXSA9IHlMb3c7XG4gICAgcnRjUG9zWzJdID0gekxvdztcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGEgZmxhdCBhcnJheSBvZiBkb3VibGUtcHJlY2lzaW9uIHBvc2l0aW9ucyB0byBSVEMgcG9zaXRpb25zLlxuICpcbiAqIFJldHVybnMgdGhlIFJUQyBwb3NpdGlvbnMsIGFsb25nIHdpdGggYSBjb21wdXRlZCBSVEMgY2VudGVyIGZvciB0aG9zZSBwb3NpdGlvbnMuXG4gKlxuICogV2hlbiBjb21wdXRpbmcgdGhlIFJUQyBwb3NpdGlvbiwgdGhpcyBmdW5jdGlvbiB1c2VzIGEgbW9kdWx1cyBvcGVyYXRpb24gdG8gZW5zdXJlIHRoYXQsIHdoZW5ldmVyIHBvc3NpYmxlLFxuICogaWRlbnRpY2FsIFJUQyBwb3NpdGlvbnMgYXJlIHJldXNlZCBmb3IgZGlmZmVyZW50IHBvc2l0aW9ucyBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHdvcmxkUG9zaXRpb25zIEZsYXQgYXJyYXkgb2YgV29ybGQtc3BhY2UgM0QgcG9zaXRpb25zLlxuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHJ0Y1Bvc2l0aW9ucyBPdXRwdXRzIHRoZSBjb21wdXRlZCBmbGF0IGFycmF5IG9mIDNEIFJUQyBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gcnRjQ2VudGVyIE91dHB1dHMgdGhlIGNvbXB1dGVkIGRvdWJsZS1wcmVjaXNpb24gcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNlbnRlciBwb3MuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NlbGxTaXplPTEwMDAwMDAwXSBUaGUgc2l6ZSBvZiBlYWNoIGNvb3JkaW5hdGUgY2VsbCB3aXRoaW4gdGhlIFJUQyBjb29yZGluYXRlIHN5c3RlbS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgYGBgVHJ1ZWBgYGAgaWYgdGhlIHBvc2l0aW9ucyBhY3R1YWxseSBuZWVkZWQgY29udmVyc2lvbiB0byBSVEMsIGVsc2UgYGBgYGZhbHNlYGBgYC4gV2hlblxuICogYGBgYGZhbHNlYGBgYCwgd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIGRhdGEgcmV0dXJuZWQgaW4gYGBgYHJ0Y1Bvc2l0aW9uc2BgYGAgYW5kIGBgYGBydGNDZW50ZXJgYGBgLFxuICogc2luY2UgYGBgYHJ0Y0NlbnRlcmBgYGAgd2lsbCBlcXVhbCBgYGBgWzAsMCwwXWBgYGAsIGFuZCBgYGBgcnRjUG9zaXRpb25zYGBgYCB3aWxsIGNvbnRhaW4gaWRlbnRpY2FsIHZhbHVlcyB0byBgYGBgcG9zaXRpb25zYGBgYC5cbiAqL1xuZnVuY3Rpb24gd29ybGRUb1JUQ1Bvc2l0aW9ucyh3b3JsZFBvc2l0aW9ucywgcnRjUG9zaXRpb25zLCBydGNDZW50ZXIsIGNlbGxTaXplID0gMTAwMDAwMDApIHtcblxuICAgIGNvbnN0IGNlbnRlciA9IG1hdGguZ2V0UG9zaXRpb25zQ2VudGVyKHdvcmxkUG9zaXRpb25zLCB0ZW1wVmVjM2EpO1xuXG4gICAgY29uc3QgcnRjQ2VudGVyWCA9IE1hdGgucm91bmQoY2VudGVyWzBdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gICAgY29uc3QgcnRjQ2VudGVyWSA9IE1hdGgucm91bmQoY2VudGVyWzFdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG4gICAgY29uc3QgcnRjQ2VudGVyWiA9IE1hdGgucm91bmQoY2VudGVyWzJdIC8gY2VsbFNpemUpICogY2VsbFNpemU7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gd29ybGRQb3NpdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICAgICAgcnRjUG9zaXRpb25zW2kgKyAwXSA9IHdvcmxkUG9zaXRpb25zW2kgKyAwXSAtIHJ0Y0NlbnRlclg7XG4gICAgICAgIHJ0Y1Bvc2l0aW9uc1tpICsgMV0gPSB3b3JsZFBvc2l0aW9uc1tpICsgMV0gLSBydGNDZW50ZXJZO1xuICAgICAgICBydGNQb3NpdGlvbnNbaSArIDJdID0gd29ybGRQb3NpdGlvbnNbaSArIDJdIC0gcnRjQ2VudGVyWjtcbiAgICB9XG5cbiAgICBydGNDZW50ZXJbMF0gPSBydGNDZW50ZXJYO1xuICAgIHJ0Y0NlbnRlclsxXSA9IHJ0Y0NlbnRlclk7XG4gICAgcnRjQ2VudGVyWzJdID0gcnRjQ2VudGVyWjtcblxuICAgIGNvbnN0IHJ0Y05lZWRlZCA9IChydGNDZW50ZXJbMF0gIT09IDAgfHwgcnRjQ2VudGVyWzFdICE9PSAwIHx8IHJ0Y0NlbnRlclsyXSAhPT0gMCk7XG5cbiAgICByZXR1cm4gcnRjTmVlZGVkO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJUQyAzRCBwb3NpdGlvbiB0byBXb3JsZC1zcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gcnRjQ2VudGVyIERvdWJsZS1wcmVjaXNpb24gcmVsYXRpdmUtdG8tY2VudGVyIChSVEMpIGNlbnRlciBwb3MuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gcnRjUG9zIFNpbmdsZS1wcmVjaXNpb24gb2Zmc2V0IGZvbSB0aGF0IGNlbnRlci5cbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSB3b3JsZFBvcyBUaGUgV29ybGQtc3BhY2UgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJ0Y1RvV29ybGRQb3MocnRjQ2VudGVyLCBydGNQb3MsIHdvcmxkUG9zKSB7XG4gICAgd29ybGRQb3NbMF0gPSBydGNDZW50ZXJbMF0gKyBydGNQb3NbMF07XG4gICAgd29ybGRQb3NbMV0gPSBydGNDZW50ZXJbMV0gKyBydGNQb3NbMV07XG4gICAgd29ybGRQb3NbMl0gPSBydGNDZW50ZXJbMl0gKyBydGNQb3NbMl07XG4gICAgcmV0dXJuIHdvcmxkUG9zO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgM0QgcGxhbmUgZGVmaW5lZCBieSBkaXN0YW5jZSBmcm9tIG9yaWdpbiBhbmQgZGlyZWN0aW9uLCBhbmQgYW4gUlRDIGNlbnRlciBwb3NpdGlvbixcbiAqIHJldHVybiBhIHBsYW5lIHBvc2l0aW9uIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIFJUQyBjZW50ZXIuXG4gKlxuICogQHBhcmFtIGRpc3RcbiAqIEBwYXJhbSBkaXJcbiAqIEBwYXJhbSBydGNDZW50ZXJcbiAqIEBwYXJhbSBydGNQbGFuZVBvc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldFBsYW5lUlRDUG9zKGRpc3QsIGRpciwgcnRjQ2VudGVyLCBydGNQbGFuZVBvcykge1xuICAgIGNvbnN0IHJ0Y0NlbnRlclRvUGxhbmVEaXN0ID0gbWF0aC5kb3RWZWMzKGRpciwgcnRjQ2VudGVyKSArIGRpc3Q7XG4gICAgY29uc3QgZGlyTm9ybWFsaXplZCA9IG1hdGgubm9ybWFsaXplVmVjMyhkaXIsIHRlbXBWZWMzYSk7XG4gICAgbWF0aC5tdWxWZWMzU2NhbGFyKGRpck5vcm1hbGl6ZWQsIC1ydGNDZW50ZXJUb1BsYW5lRGlzdCwgcnRjUGxhbmVQb3MpO1xuICAgIHJldHVybiBydGNQbGFuZVBvcztcbn1cblxuZXhwb3J0IHtjcmVhdGVSVENWaWV3TWF0LCB3b3JsZFRvUlRDUG9zLCB3b3JsZFRvUlRDUG9zaXRpb25zLCBydGNUb1dvcmxkUG9zLCBnZXRQbGFuZVJUQ1Bvc307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/Mesh.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/Mesh.js ***!
  \***********************************************************************/
/*! exports provided: Mesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/Component.js\");\n/* harmony import */ var _webgl_RenderState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/RenderState.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js\");\n/* harmony import */ var _draw_DrawRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draw/DrawRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawRenderer.js\");\n/* harmony import */ var _emphasis_EmphasisFillRenderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./emphasis/EmphasisFillRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillRenderer.js\");\n/* harmony import */ var _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./emphasis/EmphasisEdgesRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesRenderer.js\");\n/* harmony import */ var _pick_PickMeshRenderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pick/PickMeshRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshRenderer.js\");\n/* harmony import */ var _pick_PickTriangleRenderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pick/PickTriangleRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleRenderer.js\");\n/* harmony import */ var _occlusion_OcclusionRenderer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./occlusion/OcclusionRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionRenderer.js\");\n/* harmony import */ var _shadow_ShadowRenderer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shadow/ShadowRenderer.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowRenderer.js\");\n/* harmony import */ var _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/geometryCompressionUtils.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/geometryCompressionUtils.js\");\n/* harmony import */ var _webgl_RenderFlags_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../webgl/RenderFlags.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderFlags.js\");\n/**\n Fired when this Mesh is picked via a call to {@link Scene/pick:method\"}}Scene#pick(){{/crossLink}}.\n\n The event parameters will be the hit result returned by the {@link Scene/pick:method\"}}Scene#pick(){{/crossLink}} method.\n @event picked\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst obb = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].OBB3();\nconst angleAxis = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\nconst q1 = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\nconst q2 = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\nconst xAxis = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3([1, 0, 0]);\nconst yAxis = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3([0, 1, 0]);\nconst zAxis = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3([0, 0, 1]);\n\nconst veca = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3(3);\nconst vecb = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3(3);\n\nconst identityMat = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4();\n\n/**\n * @desc An {@link Entity} that is a drawable element, with a {@link Geometry} and a {@link Material}, that can be\n * connected into a scene graph using {@link Node}s.\n *\n * ## Usage\n *\n * The example below is the same as the one given for {@link Node}, since the two classes work together.  In this example,\n * we'll create a scene graph in which a root {@link Node} represents a group and the Meshes are leaves.\n *\n * Since {@link Node} implements {@link Entity}, we can designate the root {@link Node} as a model, causing it to be registered by its\n * ID in {@link Scene#models}.\n *\n * Since Mesh also implements {@link Entity}, we can designate the leaf Meshes as objects, causing them to\n * be registered by their IDs in {@link Scene#objects}.\n *\n * We can then find those {@link Entity} types in {@link Scene#models} and {@link Scene#objects}.\n *\n * We can also update properties of our object-Meshes via calls to {@link Scene#setObjectsHighlighted} etc.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#sceneRepresentation_SceneGraph)]\n *\n * ````javascript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {Mesh} from \"../src/scene/mesh/Mesh.js\";\n * import {Node} from \"../src/scene/nodes/Node.js\";\n * import {PhongMaterial} from \"../src/scene/materials/PhongMaterial.js\";\n * import {buildBoxGeometry} from \"../src/viewer/scene/geometry/builders/buildBoxGeometry.js\";\n * import {ReadableGeometry} from \"../src/viewer/scene/geometry/ReadableGeometry.js\";\n *\n * const viewer = new Viewer({\n *     canvasId: \"myCanvas\"\n * });\n *\n * viewer.scene.camera.eye = [-21.80, 4.01, 6.56];\n * viewer.scene.camera.look = [0, -5.75, 0];\n * viewer.scene.camera.up = [0.37, 0.91, -0.11];\n *\n * const boxGeometry = new ReadableGeometry(viewer.scene, buildBoxGeometry({\n *      xSize: 1,\n *      ySize: 1,\n *      zSize: 1\n * }));\n *\n * new Node(viewer.scene, {\n *      id: \"table\",\n *      isModel: true, // <---------- Node represents a model, so is registered by ID in viewer.scene.models\n *      rotation: [0, 50, 0],\n *      position: [0, 0, 0],\n *      scale: [1, 1, 1],\n *\n *      children: [\n *\n *          new Mesh(viewer.scene, { // Red table leg\n *              id: \"redLeg\",\n *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects\n *              position: [-4, -6, -4],\n *              scale: [1, 3, 1],\n *              rotation: [0, 0, 0],\n *              material: new PhongMaterial(viewer.scene, {\n *                  diffuse: [1, 0.3, 0.3]\n *              }),\n *              geometry: boxGeometry\n *          }),\n *\n *          new Mesh(viewer.scene, { // Green table leg\n *              id: \"greenLeg\",\n *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects\n *              position: [4, -6, -4],\n *              scale: [1, 3, 1],\n *              rotation: [0, 0, 0],\n *              material: new PhongMaterial(viewer.scene, {\n *                  diffuse: [0.3, 1.0, 0.3]\n *              }),\n *              geometry: boxGeometry\n *          }),\n *\n *          new Mesh(viewer.scene, {// Blue table leg\n *              id: \"blueLeg\",\n *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects\n *              position: [4, -6, 4],\n *              scale: [1, 3, 1],\n *              rotation: [0, 0, 0],\n *              material: new PhongMaterial(viewer.scene, {\n *                  diffuse: [0.3, 0.3, 1.0]\n *              }),\n *              geometry: boxGeometry\n *          }),\n *\n *          new Mesh(viewer.scene, {  // Yellow table leg\n *              id: \"yellowLeg\",\n *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects\n *              position: [-4, -6, 4],\n *              scale: [1, 3, 1],\n *              rotation: [0, 0, 0],\n *              material: new PhongMaterial(viewer.scene, {\n *                   diffuse: [1.0, 1.0, 0.0]\n *              }),\n *              geometry: boxGeometry\n *          }),\n *\n *          new Mesh(viewer.scene, { // Purple table top\n *              id: \"tableTop\",\n *              isObject: true, // <------ Node represents an object, so is registered by ID in viewer.scene.objects\n *              position: [0, -3, 0],\n *              scale: [6, 0.5, 6],\n *              rotation: [0, 0, 0],\n *              material: new PhongMaterial(viewer.scene, {\n *                  diffuse: [1.0, 0.3, 1.0]\n *              }),\n *              geometry: boxGeometry\n *          })\n *      ]\n *  });\n *\n * // Find Nodes and Meshes by their IDs\n *\n * var table = viewer.scene.models[\"table\"];                // Since table Node has isModel == true\n *\n * var redLeg = viewer.scene.objects[\"redLeg\"];             // Since the Meshes have isObject == true\n * var greenLeg = viewer.scene.objects[\"greenLeg\"];\n * var blueLeg = viewer.scene.objects[\"blueLeg\"];\n *\n * // Highlight one of the table leg Meshes\n *\n * viewer.scene.setObjectsHighlighted([\"redLeg\"], true);    // Since the Meshes have isObject == true\n *\n * // Periodically update transforms on our Nodes and Meshes\n *\n * viewer.scene.on(\"tick\", function () {\n *\n *       // Rotate legs\n *       redLeg.rotateY(0.5);\n *       greenLeg.rotateY(0.5);\n *       blueLeg.rotateY(0.5);\n *\n *       // Rotate table\n *       table.rotateY(0.5);\n *       table.rotateX(0.3);\n *   });\n * ````\n *\n * ## Metadata\n *\n * As mentioned, we can also associate {@link MetaModel}s and {@link MetaObject}s with our {@link Node}s and Meshes,\n * within a {@link MetaScene}. See {@link MetaScene} for an example.\n *\n * @implements {Entity}\n * @implements {Drawable}\n */\nclass Mesh extends _Component_js__WEBPACK_IMPORTED_MODULE_1__[\"Component\"] {\n\n    /**\n     @private\n     */\n    get type() {\n        return \"Mesh\";\n    }\n\n    /**\n     * @constructor\n     * @param {Component} owner Owner component. When destroyed, the owner will destroy this component as well.\n     * @param {*} [cfg] Configs\n     * @param {String} [cfg.id] Optional ID, unique among all components in the parent scene, generated automatically when omitted.\n     * @param {String} [cfg.originalSystemId] ID of the corresponding object within the originating system, if any.\n     * @param {Boolean} [cfg.isModel] Specify ````true```` if this Mesh represents a model, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and may also have a corresponding {@link MetaModel} with matching {@link MetaModel#id}, registered by that ID in {@link MetaScene#metaModels}.\n     * @param {Boolean} [cfg.isObject] Specify ````true```` if this Mesh represents an object, in which case the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and may also have a corresponding {@link MetaObject} with matching {@link MetaObject#id}, registered by that ID in {@link MetaScene#metaObjects}.\n     * @param {Node} [cfg.parent] The parent Node.\n     * @param {Number[]} [cfg.rtcCenter] Relative-to-center (RTC) coordinate system center for this Mesh. When this is given, then ````matrix````, ````position```` and ````geometry```` are all assumed to be relative to this center.\n     * @param {Number[]} [cfg.position=[0,0,0]] Local 3D position.\n     * @param {Number[]} [cfg.scale=[1,1,1]] Local scale.\n     * @param {Number[]} [cfg.rotation=[0,0,0]] Local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.\n     * @param {Number[]} [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]] Local modelling transform matrix. Overrides the position, scale and rotation parameters.\n     * @param {Number[]} [cfg.offset=[0,0,0]] World-space 3D translation offset. Translates the Mesh in World space, after modelling transforms.\n     * @param {Boolean} [cfg.visible=true] Indicates if the Mesh is initially visible.\n     * @param {Boolean} [cfg.culled=false] Indicates if the Mesh is initially culled from view.\n     * @param {Boolean} [cfg.pickable=true] Indicates if the Mesh is initially pickable.\n     * @param {Boolean} [cfg.clippable=true] Indicates if the Mesh is initially clippable.\n     * @param {Boolean} [cfg.collidable=true] Indicates if the Mesh is initially included in boundary calculations.\n     * @param {Boolean} [cfg.castsShadow=true] Indicates if the Mesh initially casts shadows.\n     * @param {Boolean} [cfg.receivesShadow=true]  Indicates if the Mesh initially receives shadows.\n     * @param {Boolean} [cfg.xrayed=false] Indicates if the Mesh is initially xrayed.\n     * @param {Boolean} [cfg.highlighted=false] Indicates if the Mesh is initially highlighted.\n     * @param {Boolean} [cfg.selected=false] Indicates if the Mesh is initially selected.\n     * @param {Boolean} [cfg.edges=false] Indicates if the Mesh's edges are initially emphasized.\n     * @param {Number[]} [cfg.colorize=[1.0,1.0,1.0]] Mesh's initial RGB colorize color, multiplies by the rendered fragment colors.\n     * @param {Number} [cfg.opacity=1.0] Mesh's initial opacity factor, multiplies by the rendered fragment alpha.\n     * @param {String} [cfg.billboard=\"none\"] Mesh's billboarding behaviour. Options are \"none\" for no billboarding, \"spherical\" to always directly face {@link Camera.eye}, rotating both vertically and horizontally, or \"cylindrical\" to face the {@link Camera#eye} while rotating only about its vertically axis (use that mode for things like trees on a landscape).\n     * @param {Geometry} [cfg.geometry] {@link Geometry} to define the shape of this Mesh. Inherits {@link Scene#geometry} by default.\n     * @param {Material} [cfg.material] {@link Material} to define the normal rendered appearance for this Mesh. Inherits {@link Scene#material} by default.\n     * @param {EmphasisMaterial} [cfg.xrayMaterial] {@link EmphasisMaterial} to define the xrayed appearance for this Mesh. Inherits {@link Scene#xrayMaterial} by default.\n     * @param {EmphasisMaterial} [cfg.highlightMaterial] {@link EmphasisMaterial} to define the xrayed appearance for this Mesh. Inherits {@link Scene#highlightMaterial} by default.\n     * @param {EmphasisMaterial} [cfg.selectedMaterial] {@link EmphasisMaterial} to define the selected appearance for this Mesh. Inherits {@link Scene#selectedMaterial} by default.\n     * @param {EmphasisMaterial} [cfg.edgeMaterial] {@link EdgeMaterial} to define the appearance of enhanced edges for this Mesh. Inherits {@link Scene#edgeMaterial} by default.\n     */\n    constructor(owner, cfg = {}) {\n\n        super(owner, cfg);\n\n        /**\n         * ID of the corresponding object within the originating system, if any.\n         *\n         * @type {String}\n         * @abstract\n         */\n        this.originalSystemId = (cfg.originalSystemId || this.id);\n\n        /** @private **/\n        this.renderFlags = new _webgl_RenderFlags_js__WEBPACK_IMPORTED_MODULE_11__[\"RenderFlags\"]();\n\n        this._state = new _webgl_RenderState_js__WEBPACK_IMPORTED_MODULE_2__[\"RenderState\"]({ // NOTE: Renderer gets modeling and normal matrices from Mesh#matrix and Mesh.#normalWorldMatrix\n            visible: true,\n            culled: false,\n            pickable: null,\n            clippable: null,\n            collidable: null,\n            castsShadow: null,\n            receivesShadow: null,\n            xrayed: false,\n            highlighted: false,\n            selected: false,\n            edges: false,\n            stationary: !!cfg.stationary,\n            billboard: this._checkBillboard(cfg.billboard),\n            layer: null,\n            colorize: null,\n            pickID: this.scene._renderer.getPickID(this),\n            drawHash: \"\",\n            pickHash: \"\",\n            offset: _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3(),\n            rtcCenter: null,\n            rtcCenterHash: null\n        });\n\n        this._drawRenderer = null;\n        this._shadowRenderer = null;\n        this._emphasisFillRenderer = null;\n        this._emphasisEdgesRenderer = null;\n        this._pickMeshRenderer = null;\n        this._pickTriangleRenderer = null;\n        this._occlusionRenderer = null;\n\n        this._geometry = cfg.geometry ? this._checkComponent2([\"ReadableGeometry\", \"VBOGeometry\"], cfg.geometry) : this.scene.geometry;\n        this._material = cfg.material ? this._checkComponent2([\"PhongMaterial\", \"MetallicMaterial\", \"SpecularMaterial\", \"LambertMaterial\"], cfg.material) : this.scene.material;\n        this._xrayMaterial = cfg.xrayMaterial ? this._checkComponent(\"EmphasisMaterial\", cfg.xrayMaterial) : this.scene.xrayMaterial;\n        this._highlightMaterial = cfg.highlightMaterial ? this._checkComponent(\"EmphasisMaterial\", cfg.highlightMaterial) : this.scene.highlightMaterial;\n        this._selectedMaterial = cfg.selectedMaterial ? this._checkComponent(\"EmphasisMaterial\", cfg.selectedMaterial) : this.scene.selectedMaterial;\n        this._edgeMaterial = cfg.edgeMaterial ? this._checkComponent(\"EdgeMaterial\", cfg.edgeMaterial) : this.scene.edgeMaterial;\n\n        this._parentNode = null;\n\n        this._aabb = null;\n        this._aabbDirty = true;\n\n        this._numTriangles = (this._geometry ? this._geometry.numTriangles : 0);\n\n        this.scene._aabbDirty = true;\n\n        this._scale = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._quaternion = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityQuaternion();\n        this._rotation = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n        this._position = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n\n        this._worldMatrix = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4();\n        this._worldNormalMatrix = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4();\n\n        this._localMatrixDirty = true;\n        this._worldMatrixDirty = true;\n        this._worldNormalMatrixDirty = true;\n\n        if (cfg.rtcCenter) {\n            this._state.rtcCenter = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3(cfg.rtcCenter);\n            this._state.rtcCenterHash = cfg.rtcCenter.join();\n        }\n\n        if (cfg.matrix) {\n            this.matrix = cfg.matrix;\n        } else {\n            this.scale = cfg.scale;\n            this.position = cfg.position;\n            if (cfg.quaternion) {\n            } else {\n                this.rotation = cfg.rotation;\n            }\n        }\n\n        this._isObject = cfg.isObject;\n        if (this._isObject) {\n            this.scene._registerObject(this);\n        }\n\n        this._isModel = cfg.isModel;\n        if (this._isModel) {\n            this.scene._registerModel(this);\n        }\n\n        this.visible = cfg.visible;\n        this.culled = cfg.culled;\n        this.pickable = cfg.pickable;\n        this.clippable = cfg.clippable;\n        this.collidable = cfg.collidable;\n        this.castsShadow = cfg.castsShadow;\n        this.receivesShadow = cfg.receivesShadow;\n        this.xrayed = cfg.xrayed;\n        this.highlighted = cfg.highlighted;\n        this.selected = cfg.selected;\n        this.edges = cfg.edges;\n        this.layer = cfg.layer;\n        this.colorize = cfg.colorize;\n        this.opacity = cfg.opacity;\n        this.offset = cfg.offset;\n\n        if (cfg.parentId) {\n            const parentNode = this.scene.components[cfg.parentId];\n            if (!parentNode) {\n                this.error(\"Parent not found: '\" + cfg.parentId + \"'\");\n            } else if (!parentNode.isNode) {\n                this.error(\"Parent is not a Node: '\" + cfg.parentId + \"'\");\n            } else {\n                parentNode.addChild(this);\n            }\n            this._parentNode = parentNode;\n        } else if (cfg.parent) {\n            if (!cfg.parent.isNode) {\n                this.error(\"Parent is not a Node\");\n            }\n            cfg.parent.addChild(this);\n            this._parentNode = cfg.parent;\n        }\n\n        this.compile();\n    }\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Mesh members\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns true to indicate that this Component is a Mesh.\n     * @final\n     * @type {Boolean}\n     */\n    get isMesh() {\n        return true;\n    }\n\n    /**\n     * The parent Node.\n     *\n     * The parent Node may also be set by passing the Mesh to the parent's {@link Node#addChild} method.\n     *\n     * @type {Node}\n     */\n    get parent() {\n        return this._parentNode;\n    }\n\n    _checkBillboard(value) {\n        value = value || \"none\";\n        if (value !== \"spherical\" && value !== \"cylindrical\" && value !== \"none\") {\n            this.error(\"Unsupported value for 'billboard': \" + value + \" - accepted values are \" +\n                \"'spherical', 'cylindrical' and 'none' - defaulting to 'none'.\");\n            value = \"none\";\n        }\n        return value;\n    }\n\n    /**\n     * Called by xeokit to compile shaders for this Mesh.\n     * @private\n     */\n    compile() {\n        const drawHash = this._makeDrawHash();\n        if (this._state.drawHash !== drawHash) {\n            this._state.drawHash = drawHash;\n            this._putDrawRenderers();\n            this._drawRenderer = _draw_DrawRenderer_js__WEBPACK_IMPORTED_MODULE_3__[\"DrawRenderer\"].get(this);\n            // this._shadowRenderer = ShadowRenderer.get(this);\n            this._emphasisFillRenderer = _emphasis_EmphasisFillRenderer_js__WEBPACK_IMPORTED_MODULE_4__[\"EmphasisFillRenderer\"].get(this);\n            this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this);\n        }\n        const pickHash = this._makePickHash();\n        if (this._state.pickHash !== pickHash) {\n            this._state.pickHash = pickHash;\n            this._putPickRenderers();\n            this._pickMeshRenderer = _pick_PickMeshRenderer_js__WEBPACK_IMPORTED_MODULE_6__[\"PickMeshRenderer\"].get(this);\n        }\n        const occlusionHash = this._makeOcclusionHash();\n        if (this._state.occlusionHash !== occlusionHash) {\n            this._state.occlusionHash = occlusionHash;\n            this._putOcclusionRenderer();\n            this._occlusionRenderer = _occlusion_OcclusionRenderer_js__WEBPACK_IMPORTED_MODULE_8__[\"OcclusionRenderer\"].get(this);\n        }\n    }\n\n    _setLocalMatrixDirty() {\n        this._localMatrixDirty = true;\n        this._setWorldMatrixDirty();\n    }\n\n    _setWorldMatrixDirty() {\n        this._worldMatrixDirty = true;\n        this._worldNormalMatrixDirty = true;\n    }\n\n    _buildWorldMatrix() {\n        const localMatrix = this.matrix;\n        if (!this._parentNode) {\n            for (let i = 0, len = localMatrix.length; i < len; i++) {\n                this._worldMatrix[i] = localMatrix[i];\n            }\n        } else {\n            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulMat4(this._parentNode.worldMatrix, localMatrix, this._worldMatrix);\n        }\n        this._worldMatrixDirty = false;\n    }\n\n    _buildWorldNormalMatrix() {\n        if (this._worldMatrixDirty) {\n            this._buildWorldMatrix();\n        }\n        if (!this._worldNormalMatrix) {\n            this._worldNormalMatrix = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mat4();\n        }\n        // Note: order of inverse and transpose doesn't matter\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transposeMat4(this._worldMatrix, this._worldNormalMatrix);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].inverseMat4(this._worldNormalMatrix);\n        this._worldNormalMatrixDirty = false;\n    }\n\n    _setAABBDirty() {\n        if (this.collidable) {\n            for (let node = this; node; node = node._parentNode) {\n                node._aabbDirty = true;\n            }\n        }\n    }\n\n    _updateAABB() {\n        this.scene._aabbDirty = true;\n        if (!this._aabb) {\n            this._aabb = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].AABB3();\n        }\n        this._buildAABB(this.worldMatrix, this._aabb); // Mesh or PerformanceModel\n        this._aabbDirty = false;\n    }\n\n    _webglContextRestored() {\n        if (this._drawRenderer) {\n            this._drawRenderer.webglContextRestored();\n        }\n        if (this._shadowRenderer) {\n            this._shadowRenderer.webglContextRestored();\n        }\n        if (this._emphasisFillRenderer) {\n            this._emphasisFillRenderer.webglContextRestored();\n        }\n        if (this._emphasisEdgesRenderer) {\n            this._emphasisEdgesRenderer.webglContextRestored();\n        }\n        if (this._pickMeshRenderer) {\n            this._pickMeshRenderer.webglContextRestored();\n        }\n        if (this._pickTriangleRenderer) {\n            this._pickMeshRenderer.webglContextRestored();\n        }\n        if (this._occlusionRenderer) {\n            this._occlusionRenderer.webglContextRestored();\n        }\n    }\n\n    _makeDrawHash() {\n        const scene = this.scene;\n        const hash = [\n            scene.canvas.canvas.id,\n            (scene.gammaInput ? \"gi;\" : \";\") + (scene.gammaOutput ? \"go\" : \"\"),\n            scene._lightsState.getHash(),\n            scene._sectionPlanesState.getHash()\n        ];\n        const state = this._state;\n        if (state.stationary) {\n            hash.push(\"/s\");\n        }\n        if (state.billboard === \"none\") {\n            hash.push(\"/n\");\n        } else if (state.billboard === \"spherical\") {\n            hash.push(\"/s\");\n        } else if (state.billboard === \"cylindrical\") {\n            hash.push(\"/c\");\n        }\n        if (state.receivesShadow) {\n            hash.push(\"/rs\");\n        }\n        hash.push(\";\");\n        return hash.join(\"\");\n    }\n\n    _makePickHash() {\n        const scene = this.scene;\n        const hash = [\n            scene.canvas.canvas.id,\n            scene._sectionPlanesState.getHash()\n        ];\n        const state = this._state;\n        if (state.stationary) {\n            hash.push(\"/s\");\n        }\n        if (state.billboard === \"none\") {\n            hash.push(\"/n\");\n        } else if (state.billboard === \"spherical\") {\n            hash.push(\"/s\");\n        } else if (state.billboard === \"cylindrical\") {\n            hash.push(\"/c\");\n        }\n        hash.push(\";\");\n        return hash.join(\"\");\n    }\n\n    _makeOcclusionHash() {\n        const scene = this.scene;\n        const hash = [\n            scene.canvas.canvas.id,\n            scene._sectionPlanesState.getHash()\n        ];\n        const state = this._state;\n        if (state.stationary) {\n            hash.push(\"/s\");\n        }\n        if (state.billboard === \"none\") {\n            hash.push(\"/n\");\n        } else if (state.billboard === \"spherical\") {\n            hash.push(\"/s\");\n        } else if (state.billboard === \"cylindrical\") {\n            hash.push(\"/c\");\n        }\n        hash.push(\";\");\n        return hash.join(\"\");\n    }\n\n    _buildAABB(worldMatrix, aabb) {\n\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformOBB3(worldMatrix, this._geometry.obb, obb);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].OBB3ToAABB3(obb, aabb);\n\n        const offset = this._state.offset;\n\n        aabb[0] += offset[0];\n        aabb[1] += offset[1];\n        aabb[2] += offset[2];\n        aabb[3] += offset[0];\n        aabb[4] += offset[1];\n        aabb[5] += offset[2];\n\n        if (this._state.rtcCenter) {\n            const rtcCenter = this._state.rtcCenter;\n            aabb[0] += rtcCenter[0];\n            aabb[1] += rtcCenter[1];\n            aabb[2] += rtcCenter[2];\n            aabb[3] += rtcCenter[0];\n            aabb[4] += rtcCenter[1];\n            aabb[5] += rtcCenter[2];\n        }\n    }\n\n    /**\n     * Defines the shape of this Mesh.\n     *\n     * Set to {@link Scene#geometry} by default.\n     *\n     * @type {Geometry}\n     */\n    get geometry() {\n        return this._geometry;\n    }\n\n    /**\n     * Defines the appearance of this Mesh when rendering normally, ie. when not xrayed, highlighted or selected.\n     *\n     * Set to {@link Scene#material} by default.\n     *\n     * @type {Material}\n     */\n    get material() {\n        return this._material;\n    }\n\n    /**\n     * Sets the Mesh's local translation.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    set position(value) {\n        this._position.set(value || [0, 0, 0]);\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's local translation.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    get position() {\n        return this._position;\n    }\n\n    /**\n     * Sets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    set rotation(value) {\n        this._rotation.set(value || [0, 0, 0]);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].eulerToQuaternion(this._rotation, \"XYZ\", this._quaternion);\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    get rotation() {\n        return this._rotation;\n    }\n\n    /**\n     * Sets the Mesh's local rotation quaternion.\n     *\n     * Default value is ````[0,0,0,1]````.\n     *\n     * @type {Number[]}\n     */\n    set quaternion(value) {\n        this._quaternion.set(value || [0, 0, 0, 1]);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].quaternionToEuler(this._quaternion, \"XYZ\", this._rotation);\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's local rotation quaternion.\n     *\n     * Default value is ````[0,0,0,1]````.\n     *\n     * @type {Number[]}\n     */\n    get quaternion() {\n        return this._quaternion;\n    }\n\n    /**\n     * Sets the Mesh's local scale.\n     *\n     * Default value is ````[1,1,1]````.\n     *\n     * @type {Number[]}\n     */\n    set scale(value) {\n        this._scale.set(value || [1, 1, 1]);\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's local scale.\n     *\n     * Default value is ````[1,1,1]````.\n     *\n     * @type {Number[]}\n     */\n    get scale() {\n        return this._scale;\n    }\n\n    /**\n     * Sets the Mesh's local modeling transform matrix.\n     *\n     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.\n     *\n     * @type {Number[]}\n     */\n    set matrix(value) {\n        if (!this.__localMatrix) {\n            this.__localMatrix = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4();\n        }\n        this.__localMatrix.set(value || identityMat);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].decomposeMat4(this.__localMatrix, this._position, this._quaternion, this._scale);\n        this._localMatrixDirty = false;\n        this._setWorldMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's local modeling transform matrix.\n     *\n     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.\n     *\n     * @type {Number[]}\n     */\n    get matrix() {\n        if (this._localMatrixDirty) {\n            if (!this.__localMatrix) {\n                this.__localMatrix = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].identityMat4();\n            }\n            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].composeMat4(this._position, this._quaternion, this._scale, this.__localMatrix);\n            this._localMatrixDirty = false;\n        }\n        return this.__localMatrix;\n    }\n\n    /**\n     * Gets the Mesh's World matrix.\n     *\n     * @property worldMatrix\n     * @type {Number[]}\n     */\n    get worldMatrix() {\n        if (this._worldMatrixDirty) {\n            this._buildWorldMatrix();\n        }\n        return this._worldMatrix;\n    }\n\n    /**\n     * Gets the Mesh's World normal matrix.\n     *\n     * @type {Number[]}\n     */\n    get worldNormalMatrix() {\n        if (this._worldNormalMatrixDirty) {\n            this._buildWorldNormalMatrix();\n        }\n        return this._worldNormalMatrix;\n    }\n\n    /**\n     * Rotates the Mesh about the given local axis by the given increment.\n     *\n     * @param {Number[]} axis Local axis about which to rotate.\n     * @param {Number} angle Angle increment in degrees.\n     */\n    rotate(axis, angle) {\n        angleAxis[0] = axis[0];\n        angleAxis[1] = axis[1];\n        angleAxis[2] = axis[2];\n        angleAxis[3] = angle * _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].DEGTORAD;\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].angleAxisToQuaternion(angleAxis, q1);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulQuaternions(this.quaternion, q1, q2);\n        this.quaternion = q2;\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n        return this;\n    }\n\n    /**\n     * Rotates the Mesh about the given World-space axis by the given increment.\n     *\n     * @param {Number[]} axis Local axis about which to rotate.\n     * @param {Number} angle Angle increment in degrees.\n     */\n    rotateOnWorldAxis(axis, angle) {\n        angleAxis[0] = axis[0];\n        angleAxis[1] = axis[1];\n        angleAxis[2] = axis[2];\n        angleAxis[3] = angle * _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].DEGTORAD;\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].angleAxisToQuaternion(angleAxis, q1);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulQuaternions(q1, this.quaternion, q1);\n        //this.quaternion.premultiply(q1);\n        return this;\n    }\n\n    /**\n     * Rotates the Mesh about the local X-axis by the given increment.\n     *\n     * @param {Number} angle Angle increment in degrees.\n     */\n    rotateX(angle) {\n        return this.rotate(xAxis, angle);\n    }\n\n    /**\n     * Rotates the Mesh about the local Y-axis by the given increment.\n     *\n     * @param {Number} angle Angle increment in degrees.\n     */\n    rotateY(angle) {\n        return this.rotate(yAxis, angle);\n    }\n\n    /**\n     * Rotates the Mesh about the local Z-axis by the given increment.\n     *\n     * @param {Number} angle Angle increment in degrees.\n     */\n    rotateZ(angle) {\n        return this.rotate(zAxis, angle);\n    }\n\n    /**\n     * Translates the Mesh along local space vector by the given increment.\n     *\n     * @param {Number[]} axis Normalized local space 3D vector along which to translate.\n     * @param {Number} distance Distance to translate along  the vector.\n     */\n    translate(axis, distance) {\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3ApplyQuaternion(this.quaternion, axis, veca);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(veca, distance, vecb);\n        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].addVec3(this.position, vecb, this.position);\n        this._setLocalMatrixDirty();\n        this._setAABBDirty();\n        this.glRedraw();\n        return this;\n    }\n\n    /**\n     * Translates the Mesh along the local X-axis by the given increment.\n     *\n     * @param {Number} distance Distance to translate along  the X-axis.\n     */\n    translateX(distance) {\n        return this.translate(xAxis, distance);\n    }\n\n    /**\n     * Translates the Mesh along the local Y-axis by the given increment.\n     *\n     * @param {Number} distance Distance to translate along  the Y-axis.\n     */\n    translateY(distance) {\n        return this.translate(yAxis, distance);\n    }\n\n    /**\n     * Translates the Mesh along the local Z-axis by the given increment.\n     *\n     * @param {Number} distance Distance to translate along  the Z-axis.\n     */\n    translateZ(distance) {\n        return this.translate(zAxis, distance);\n    }\n\n    _putDrawRenderers() {\n        if (this._drawRenderer) {\n            this._drawRenderer.put();\n            this._drawRenderer = null;\n        }\n        if (this._shadowRenderer) {\n            this._shadowRenderer.put();\n            this._shadowRenderer = null;\n        }\n        if (this._emphasisFillRenderer) {\n            this._emphasisFillRenderer.put();\n            this._emphasisFillRenderer = null;\n        }\n        if (this._emphasisEdgesRenderer) {\n            this._emphasisEdgesRenderer.put();\n            this._emphasisEdgesRenderer = null;\n        }\n    }\n\n    _putPickRenderers() {\n        if (this._pickMeshRenderer) {\n            this._pickMeshRenderer.put();\n            this._pickMeshRenderer = null;\n        }\n        if (this._pickTriangleRenderer) {\n            this._pickTriangleRenderer.put();\n            this._pickTriangleRenderer = null;\n        }\n    }\n\n    _putOcclusionRenderer() {\n        if (this._occlusionRenderer) {\n            this._occlusionRenderer.put();\n            this._occlusionRenderer = null;\n        }\n    }\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Entity members\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns true to indicate that Mesh implements {@link Entity}.\n     *\n     * @returns {Boolean}\n     */\n    get isEntity() {\n        return true;\n    }\n\n    /**\n     * Returns ````true```` if this Mesh represents a model.\n     *\n     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#models} and\n     * may also have a corresponding {@link MetaModel}.\n     *\n     * @type {Boolean}\n     */\n    get isModel() {\n        return this._isModel;\n    }\n\n    /**\n     * Returns ````true```` if this Mesh represents an object.\n     *\n     * When this returns ````true````, the Mesh will be registered by {@link Mesh#id} in {@link Scene#objects} and\n     * may also have a corresponding {@link MetaObject}.\n     *\n     * @type {Boolean}\n     */\n    get isObject() {\n        return this._isObject;\n    }\n\n    /**\n     * Gets the Mesh's World-space 3D axis-aligned bounding box.\n     *\n     * Represented by a six-element Float64Array containing the min/max extents of the\n     * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.\n     *\n     * @type {Number[]}\n     */\n    get aabb() {\n        if (this._aabbDirty) {\n            this._updateAABB();\n        }\n        return this._aabb;\n    }\n\n    /**\n     * Center of the relative-to-center (RTC) coordinate system for this Mesh.\n     *\n     * When this is given, then {@link Mesh#matrix}, {@link Mesh#position} and {@link Mesh#geometry} are all assumed to be relative to this center position.\n     *\n     * @type {Float64Array}\n     */\n    set rtcCenter(rtcCenter) {\n        if (rtcCenter) {\n            if (!this._state.rtcCenter) {\n                this._state.rtcCenter = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n            }\n            this._state.rtcCenter.set(rtcCenter);\n            this._state.rtcCenterHash = rtcCenter.join();\n            this._setAABBDirty();\n            this.scene._aabbDirty = true;\n        } else {\n            if (this._state.rtcCenter) {\n                this._state.rtcCenter = null;\n                this._state.rtcCenterHash = null;\n                this._setAABBDirty();\n                this.scene._aabbDirty = true;\n            }\n        }\n    }\n\n    /**\n     * 3D origin of the Mesh's {@link Geometry}'s vertex positions.\n     *\n     * When this is defined, then the positions are RTC, which means that they are relative to this position.\n     *\n     * @type {Float64Array}\n     */\n    get rtcCenter() {\n        return this._state.rtcCenter;\n    }\n\n    /**\n     * The approximate number of triangles in this Mesh.\n     *\n     * @type {Number}\n     */\n    get numTriangles() {\n        return this._numTriangles;\n    }\n\n    /**\n     * Sets if this Mesh is visible.\n     *\n     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.\n     *\n     * @type {Boolean}\n     */\n    set visible(visible) {\n        visible = visible !== false;\n        this._state.visible = visible;\n        if (this._isObject) {\n            this.scene._objectVisibilityUpdated(this);\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is visible.\n     *\n     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#visible} are both ````true```` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#visibleObjects}.\n     *\n     * @type {Boolean}\n     */\n    get visible() {\n        return this._state.visible;\n    }\n\n    /**\n     * Sets if this Mesh is xrayed.\n     *\n     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set xrayed(xrayed) {\n        xrayed = !!xrayed;\n        if (this._state.xrayed === xrayed) {\n            return;\n        }\n        this._state.xrayed = xrayed;\n        if (this._isObject) {\n            this.scene._objectXRayedUpdated(this);\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is xrayed.\n     *\n     * XRayed appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#xrayMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#xrayed} are both ````true``` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#xrayedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get xrayed() {\n        return this._state.xrayed;\n    }\n\n    /**\n     * Sets if this Mesh is highlighted.\n     *\n     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set highlighted(highlighted) {\n        highlighted = !!highlighted;\n        if (highlighted === this._state.highlighted) {\n            return;\n        }\n        this._state.highlighted = highlighted;\n        if (this._isObject) {\n            this.scene._objectHighlightedUpdated(this);\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is highlighted.\n     *\n     * Highlighted appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#highlightMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#highlighted} are both ````true```` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#highlightedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get highlighted() {\n        return this._state.highlighted;\n    }\n\n    /**\n     * Sets if this Mesh is selected.\n     *\n     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.\n     *\n     * @type {Boolean}\n     */\n    set selected(selected) {\n        selected = !!selected;\n        if (selected === this._state.selected) {\n            return;\n        }\n        this._state.selected = selected;\n        if (this._isObject) {\n            this.scene._objectSelectedUpdated(this);\n        }\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is selected.\n     *\n     * Selected appearance is configured by the {@link EmphasisMaterial} referenced by {@link Mesh#selectedMaterial}.\n     *\n     * When {@link Mesh#isObject} and {@link Mesh#selected} are both ````true``` the Mesh will be\n     * registered by {@link Mesh#id} in {@link Scene#selectedObjects}.\n     *\n     * @type {Boolean}\n     */\n    get selected() {\n        return this._state.selected;\n    }\n\n    /**\n     * Sets if this Mesh is edge-enhanced.\n     *\n     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.\n     *\n     * @type {Boolean}\n     */\n    set edges(edges) {\n        edges = !!edges;\n        if (edges === this._state.edges) {\n            return;\n        }\n        this._state.edges = edges;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is edge-enhanced.\n     *\n     * Edge appearance is configured by the {@link EdgeMaterial} referenced by {@link Mesh#edgeMaterial}.\n     *\n     * @type {Boolean}\n     */\n    get edges() {\n        return this._state.edges;\n    }\n\n    /**\n     * Sets if this Mesh is culled.\n     *\n     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.\n     *\n     * @type {Boolean}\n     */\n    set culled(value) {\n        this._state.culled = !!value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is culled.\n     *\n     * Only rendered when {@link Mesh#visible} is ````true```` and {@link Mesh#culled} is ````false````.\n     *\n     * @type {Boolean}\n     */\n    get culled() {\n        return this._state.culled;\n    }\n\n    /**\n     * Sets if this Mesh is clippable.\n     *\n     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.\n     *\n     * @type {Boolean}\n     */\n    set clippable(value) {\n        value = value !== false;\n        if (this._state.clippable === value) {\n            return;\n        }\n        this._state.clippable = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh is clippable.\n     *\n     * Clipping is done by the {@link SectionPlane}s in {@link Scene#sectionPlanes}.\n     *\n     * @type {Boolean}\n     */\n    get clippable() {\n        return this._state.clippable;\n    }\n\n    /**\n     * Sets if this Mesh included in boundary calculations.\n     *\n     * @type {Boolean}\n     */\n    set collidable(value) {\n        value = value !== false;\n        if (value === this._state.collidable) {\n            return;\n        }\n        this._state.collidable = value;\n        this._setAABBDirty();\n        this.scene._aabbDirty = true;\n\n    }\n\n    /**\n     * Gets if this Mesh included in boundary calculations.\n     *\n     * @type {Boolean}\n     */\n    get collidable() {\n        return this._state.collidable;\n    }\n\n    /**\n     * Sets if this Mesh is pickable.\n     *\n     * Picking is done via calls to {@link Scene#pick}.\n     *\n     * @type {Boolean}\n     */\n    set pickable(value) {\n        value = value !== false;\n        if (this._state.pickable === value) {\n            return;\n        }\n        this._state.pickable = value;\n        // No need to trigger a render;\n        // state is only used when picking\n    }\n\n    /**\n     * Gets if this Mesh is pickable.\n     *\n     * Picking is done via calls to {@link Scene#pick}.\n     *\n     * @type {Boolean}\n     */\n    get pickable() {\n        return this._state.pickable;\n    }\n\n    /**\n     * Sets if this Mesh casts shadows.\n     *\n     * @type {Boolean}\n     */\n    set castsShadow(value) {\n        value = value !== false;\n        if (value === this._state.castsShadow) {\n            return;\n        }\n        this._state.castsShadow = value;\n        this.glRedraw();\n    }\n\n    /**\n     * Gets if this Mesh casts shadows.\n     *\n     * @type {Boolean}\n     */\n    get castsShadow() {\n        return this._state.castsShadow;\n    }\n\n    /**\n     * Sets if this Mesh can have shadows cast upon it.\n     *\n     * @type {Boolean}\n     */\n    set receivesShadow(value) {\n        value = value !== false;\n        if (value === this._state.receivesShadow) {\n            return;\n        }\n        this._state.receivesShadow = value;\n        this._state.hash = value ? \"/mod/rs;\" : \"/mod;\";\n        this.fire(\"dirty\", this); // Now need to (re)compile objectRenderers to include/exclude shadow mapping\n    }\n\n    /**\n     * Gets if this Mesh can have shadows cast upon it.\n     *\n     * @type {Boolean}\n     */\n    get receivesShadow() {\n        return this._state.receivesShadow;\n    }\n\n    /**\n     * Gets if this Mesh can have Scalable Ambient Obscurance (SAO) applied to it.\n     *\n     * SAO is configured by {@link SAO}.\n     *\n     * @type {Boolean}\n     * @abstract\n     */\n    get saoEnabled() {\n        return false; // TODO: Support SAO on Meshes\n    }\n\n    /**\n     * Sets the RGB colorize color for this Mesh.\n     *\n     * Multiplies by rendered fragment colors.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     *\n     * @type {Number[]}\n     */\n    set colorize(value) {\n        let colorize = this._state.colorize;\n        if (!colorize) {\n            colorize = this._state.colorize = new Float32Array(4);\n            colorize[3] = 1;\n        }\n        if (value) {\n            colorize[0] = value[0];\n            colorize[1] = value[1];\n            colorize[2] = value[2];\n        } else {\n            colorize[0] = 1;\n            colorize[1] = 1;\n            colorize[2] = 1;\n        }\n        const colorized = (!!value);\n        this.scene._objectColorizeUpdated(this, colorized);\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the RGB colorize color for this Mesh.\n     *\n     * Multiplies by rendered fragment colors.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     *\n     * @type {Number[]}\n     */\n    get colorize() {\n        return this._state.colorize;\n    }\n\n    /**\n     * Sets the opacity factor for this Mesh.\n     *\n     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.\n     *\n     * @type {Number}\n     */\n    set opacity(opacity) {\n        let colorize = this._state.colorize;\n        if (!colorize) {\n            colorize = this._state.colorize = new Float32Array(4);\n            colorize[0] = 1;\n            colorize[1] = 1;\n            colorize[2] = 1;\n        }\n        const opacityUpdated = (opacity !== null && opacity !== undefined);\n        colorize[3] = opacityUpdated ? opacity : 1.0;\n        this.scene._objectOpacityUpdated(this, opacityUpdated);\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the opacity factor for this Mesh.\n     *\n     * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.\n     *\n     * @type {Number}\n     */\n    get opacity() {\n        return this._state.colorize[3];\n    }\n\n    /**\n     * Gets if this Mesh is transparent.\n     * @returns {Boolean}\n     */\n    get transparent() {\n        return this._material.alphaMode === 2 /* blend */ || this._state.colorize[3] < 1\n    }\n\n    /**\n     * Sets the Mesh's rendering order relative to other Meshes.\n     *\n     * Default value is ````0````.\n     *\n     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.\n     *\n     * @type {Number}\n     */\n    set layer(value) {\n        // TODO: Only accept rendering layer in range [0...MAX_layer]\n        value = value || 0;\n        value = Math.round(value);\n        if (value === this._state.layer) {\n            return;\n        }\n        this._state.layer = value;\n        this._renderer.needStateSort();\n    }\n\n    /**\n     * Gets the Mesh's rendering order relative to other Meshes.\n     *\n     * Default value is ````0````.\n     *\n     * This can be set on multiple transparent Meshes, to make them render in a specific order for correct alpha blending.\n     *\n     * @type {Number}\n     */\n    get layer() {\n        return this._state.layer;\n    }\n\n    /**\n     * Gets if the Node's position is stationary.\n     *\n     * When true, will disable the effect of {@link Camera} translations for this Mesh, while still allowing it to rotate. This is useful for skyboxes.\n     *\n     * @type {Boolean}\n     */\n    get stationary() {\n        return this._state.stationary;\n    }\n\n    /**\n     * Gets the Node's billboarding behaviour.\n     *\n     * Options are:\n     * * ````\"none\"```` -  (default) - No billboarding.\n     * * ````\"spherical\"```` - Mesh is billboarded to face the viewpoint, rotating both vertically and horizontally.\n     * * ````\"cylindrical\"```` - Mesh is billboarded to face the viewpoint, rotating only about its vertically axis. Use this mode for things like trees on a landscape.\n     * @type {String}\n     */\n    get billboard() {\n        return this._state.billboard;\n    }\n\n    /**\n     * Sets the Mesh's 3D World-space offset.\n     *\n     * The offset dynamically translates the Mesh in World-space.\n     *\n     * Default value is ````[0, 0, 0]````.\n     *\n     * Provide a null or undefined value to reset to the default value.\n     *\n     * @type {Number[]}\n     */\n    set offset(value) {\n        this._state.offset.set(value || [0, 0, 0]);\n        this._setAABBDirty();\n        this.glRedraw();\n    }\n\n    /**\n     * Gets the Mesh's 3D World-space offset.\n     *\n     * Default value is ````[0,0,0]````.\n     *\n     * @type {Number[]}\n     */\n    get offset() {\n        return this._state.offset;\n    }\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Drawable members\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns true to indicate that Mesh implements {@link Drawable}.\n     * @final\n     * @type {Boolean}\n     */\n    get isDrawable() {\n        return true;\n    }\n\n    /**\n     * Property with final value ````true```` to indicate that xeokit should render this Mesh in sorted order, relative to other Meshes.\n     *\n     * The sort order is determined by {@link Mesh#stateSortCompare}.\n     *\n     * Sorting is essential for rendering performance, so that xeokit is able to avoid applying runs of the same state changes to the GPU, ie. can collapse them.\n     *\n     * @type {Boolean}\n     */\n    get isStateSortable() {\n        return true;\n    }\n\n    /**\n     * Comparison function used by the renderer to determine the order in which xeokit should render the Mesh, relative to to other Meshes.\n     *\n     * xeokit requires this method because Mesh implements {@link Drawable}.\n     *\n     * Sorting is essential for rendering performance, so that xeokit is able to avoid needlessly applying runs of the same rendering state changes to the GPU, ie. can collapse them.\n     *\n     * @param {Mesh} mesh1\n     * @param {Mesh} mesh2\n     * @returns {number}\n     */\n    stateSortCompare(mesh1, mesh2) {\n        return (mesh1._state.layer - mesh2._state.layer)\n            || (mesh1._drawRenderer.id - mesh2._drawRenderer.id) // Program state\n            || (mesh1._material._state.id - mesh2._material._state.id) // Material state\n            || (mesh1._geometry._state.id - mesh2._geometry._state.id); // Geometry state\n    }\n\n    /** @private */\n    rebuildRenderFlags() {\n        this.renderFlags.reset();\n        if (!this._getActiveSectionPlanes()) {\n            this.renderFlags.culled = true;\n            return;\n        }\n        this.renderFlags.numLayers = 1;\n        this.renderFlags.numVisibleLayers = 1;\n        this.renderFlags.visibleLayers[0] = 0;\n        this._updateRenderFlags();\n    }\n\n    /**\n     * @private\n     */\n    _updateRenderFlags() {\n\n        const renderFlags = this.renderFlags;\n        const state = this._state;\n\n        if (state.xrayed) {\n            const xrayMaterial = this._xrayMaterial._state;\n            if (xrayMaterial.fill) {\n                if (xrayMaterial.fillAlpha < 1.0) {\n                    renderFlags.xrayedSilhouetteTransparent = true;\n                } else {\n                    renderFlags.xrayedSilhouetteOpaque = true;\n                }\n            }\n            if (xrayMaterial.edges) {\n                if (xrayMaterial.edgeAlpha < 1.0) {\n                    renderFlags.xrayedEdgesTransparent = true;\n                } else {\n                    renderFlags.xrayedEdgesOpaque = true;\n                }\n            }\n        } else {\n            const normalMaterial = this._material._state;\n            if (normalMaterial.alpha < 1.0 || state.colorize[3] < 1.0) {\n                renderFlags.colorTransparent = true;\n            } else {\n                renderFlags.colorOpaque = true;\n            }\n            if (state.edges) {\n                const edgeMaterial = this._edgeMaterial._state;\n                if (edgeMaterial.alpha < 1.0) {\n                    renderFlags.edgesTransparent = true;\n                } else {\n                    renderFlags.edgesOpaque = true;\n                }\n            }\n            if (state.selected) {\n                const selectedMaterial = this._selectedMaterial._state;\n                if (selectedMaterial.fill) {\n                    if (selectedMaterial.fillAlpha < 1.0) {\n                        renderFlags.selectedSilhouetteTransparent = true;\n                    } else {\n                        renderFlags.selectedSilhouetteOpaque = true;\n                    }\n                }\n                if (selectedMaterial.edges) {\n                    if (selectedMaterial.edgeAlpha < 1.0) {\n                        renderFlags.selectedEdgesTransparent = true;\n                    } else {\n                        renderFlags.selectedEdgesOpaque = true;\n                    }\n                }\n            } else if (state.highlighted) {\n                const highlightMaterial = this._highlightMaterial._state;\n                if (highlightMaterial.fill) {\n                    if (highlightMaterial.fillAlpha < 1.0) {\n                        renderFlags.highlightedSilhouetteTransparent = true;\n                    } else {\n                        renderFlags.highlightedSilhouetteOpaque = true;\n                    }\n                }\n                if (highlightMaterial.edges) {\n                    if (highlightMaterial.edgeAlpha < 1.0) {\n                        renderFlags.highlightedEdgesTransparent = true;\n                    } else {\n                        renderFlags.highlightedEdgesOpaque = true;\n                    }\n                }\n            }\n        }\n    }\n\n    _getActiveSectionPlanes() {\n\n        if (this._state.clippable) {\n\n            const sectionPlanes = this.scene._sectionPlanesState.sectionPlanes;\n            const numSectionPlanes = sectionPlanes.length;\n\n            if (numSectionPlanes > 0) {\n                for (let i = 0; i < numSectionPlanes; i++) {\n\n                    const sectionPlane = sectionPlanes[i];\n                    const renderFlags = this.renderFlags;\n\n                    if (!sectionPlane.active) {\n                        renderFlags.sectionPlanesActivePerLayer[i] = false;\n\n                    } else {\n\n                        if (this._state.rtcCenter) {\n\n                            const intersect = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].planeAABB3Intersect(sectionPlane.dir, sectionPlane.dist, this.aabb);\n                            const outside = (intersect === -1);\n\n                            if (outside) {\n                                return false;\n                            }\n\n                            const intersecting = (intersect === 0);\n                            renderFlags.sectionPlanesActivePerLayer[i] = intersecting;\n\n                        } else {\n                            renderFlags.sectionPlanesActivePerLayer[i] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Defines the appearance of this Mesh when xrayed.\n     *\n     * Mesh is xrayed when {@link Mesh#xrayed} is ````true````.\n     *\n     * Set to {@link Scene#xrayMaterial} by default.\n     *\n     * @type {EmphasisMaterial}\n     */\n    get xrayMaterial() {\n        return this._xrayMaterial;\n    }\n\n    /**\n     * Defines the appearance of this Mesh when highlighted.\n     *\n     * Mesh is xrayed when {@link Mesh#highlighted} is ````true````.\n     *\n     * Set to {@link Scene#highlightMaterial} by default.\n     *\n     * @type {EmphasisMaterial}\n     */\n    get highlightMaterial() {\n        return this._highlightMaterial;\n    }\n\n    /**\n     * Defines the appearance of this Mesh when selected.\n     *\n     * Mesh is xrayed when {@link Mesh#selected} is ````true````.\n     *\n     * Set to {@link Scene#selectedMaterial} by default.\n     *\n     * @type {EmphasisMaterial}\n     */\n    get selectedMaterial() {\n        return this._selectedMaterial;\n    }\n\n    /**\n     * Defines the appearance of this Mesh when edges are enhanced.\n     *\n     * Mesh is xrayed when {@link Mesh#edges} is ````true````.\n     *\n     * Set to {@link Scene#edgeMaterial} by default.\n     *\n     * @type {EdgeMaterial}\n     */\n    get edgeMaterial() {\n        return this._edgeMaterial;\n    }\n\n    // ---------------------- NORMAL RENDERING -----------------------------------\n\n    /** @private  */\n    drawColorOpaque(frameCtx) {\n        if (this._drawRenderer || (this._drawRenderer = _draw_DrawRenderer_js__WEBPACK_IMPORTED_MODULE_3__[\"DrawRenderer\"].get(this))) {\n            this._drawRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    /** @private  */\n    drawColorTransparent(frameCtx) {\n        if (this._drawRenderer || (this._drawRenderer = _draw_DrawRenderer_js__WEBPACK_IMPORTED_MODULE_3__[\"DrawRenderer\"].get(this))) {\n            this._drawRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    // ---------------------- RENDERING SAO POST EFFECT TARGETS --------------\n\n    // TODO\n\n    // ---------------------- EMPHASIS RENDERING -----------------------------------\n\n    /** @private  */\n    drawSilhouetteXRayed(frameCtx) {\n        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = _emphasis_EmphasisFillRenderer_js__WEBPACK_IMPORTED_MODULE_4__[\"EmphasisFillRenderer\"].get(this))) {\n            this._emphasisFillRenderer.drawMesh(frameCtx, this, 0); // 0 == xray\n        }\n    }\n\n    /** @private  */\n    drawSilhouetteHighlighted(frameCtx) {\n        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = _emphasis_EmphasisFillRenderer_js__WEBPACK_IMPORTED_MODULE_4__[\"EmphasisFillRenderer\"].get(this))) {\n            this._emphasisFillRenderer.drawMesh(frameCtx, this, 1); // 1 == highlight\n        }\n    }\n\n    /** @private  */\n    drawSilhouetteSelected(frameCtx) {\n        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = _emphasis_EmphasisFillRenderer_js__WEBPACK_IMPORTED_MODULE_4__[\"EmphasisFillRenderer\"].get(this))) {\n            this._emphasisFillRenderer.drawMesh(frameCtx, this, 2); // 2 == selected\n        }\n    }\n\n    // ---------------------- EDGES RENDERING -----------------------------------\n\n    /** @private  */\n    drawEdgesColorOpaque(frameCtx) {\n        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this))) {\n            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 3); // 3 == edges\n        }\n    }\n\n    /** @private  */\n    drawEdgesColorTransparent(frameCtx) {\n        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this))) {\n            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 3); // 3 == edges\n        }\n    }\n\n    /** @private  */\n    drawEdgesXRayed(frameCtx) {\n        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this))) {\n            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 0); // 0 == xray\n        }\n    }\n\n    /** @private  */\n    drawEdgesHighlighted(frameCtx) {\n        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this))) {\n            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 1); // 1 == highlight\n        }\n    }\n\n    /** @private  */\n    drawEdgesSelected(frameCtx) {\n        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = _emphasis_EmphasisEdgesRenderer_js__WEBPACK_IMPORTED_MODULE_5__[\"EmphasisEdgesRenderer\"].get(this))) {\n            this._emphasisEdgesRenderer.drawMesh(frameCtx, this, 2); // 2 == selected\n        }\n    }\n\n    // ---------------------- OCCLUSION CULL RENDERING -----------------------------------\n\n    /** @private  */\n    drawOcclusion(frameCtx) {\n        if (this._occlusionRenderer || (this._occlusionRenderer = _occlusion_OcclusionRenderer_js__WEBPACK_IMPORTED_MODULE_8__[\"OcclusionRenderer\"].get(this))) {\n            this._occlusionRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    // ---------------------- SHADOW BUFFER RENDERING -----------------------------------\n\n    /** @private  */\n    drawShadow(frameCtx) {\n        if (this._shadowRenderer || (this._shadowRenderer = _shadow_ShadowRenderer_js__WEBPACK_IMPORTED_MODULE_9__[\"ShadowRenderer\"].get(this))) {\n            this._shadowRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    // ---------------------- PICKING RENDERING ----------------------------------\n\n    /** @private  */\n    drawPickMesh(frameCtx) {\n        if (this._pickMeshRenderer || (this._pickMeshRenderer = _pick_PickMeshRenderer_js__WEBPACK_IMPORTED_MODULE_6__[\"PickMeshRenderer\"].get(this))) {\n            this._pickMeshRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    /** @private\n     */\n    canPickTriangle() {\n        return this._geometry.isReadableGeometry; // VBOGeometry does not support surface picking because it has no geometry data in browser memory\n    }\n\n    /** @private  */\n    drawPickTriangles(frameCtx) {\n        if (this._pickTriangleRenderer || (this._pickTriangleRenderer = _pick_PickTriangleRenderer_js__WEBPACK_IMPORTED_MODULE_7__[\"PickTriangleRenderer\"].get(this))) {\n            this._pickTriangleRenderer.drawMesh(frameCtx, this);\n        }\n    }\n\n    /** @private */\n    pickTriangleSurface(pickViewMatrix, pickProjMatrix, pickResult) {\n        pickTriangleSurface(this, pickViewMatrix, pickProjMatrix, pickResult);\n    }\n\n    /** @private  */\n    drawPickVertices(frameCtx) {\n\n    }\n\n    /**\n     * @private\n     * @returns {PerformanceNode}\n     */\n    delegatePickedEntity() {\n        return this;\n    }\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Component members\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Destroys this Mesh.\n     */\n    destroy() {\n        super.destroy(); // xeokit.Object\n        this._putDrawRenderers();\n        this._putPickRenderers();\n        this._putOcclusionRenderer();\n        this.scene._renderer.putPickID(this._state.pickID); // TODO: somehow puch this down into xeokit framework?\n        if (this._isObject) {\n            this.scene._deregisterObject(this);\n            if (this._visible) {\n                this.scene._objectVisibilityUpdated(this, false);\n            }\n            if (this._xrayed) {\n                this.scene._objectXRayedUpdated(this, false);\n            }\n            if (this._selected) {\n                this.scene._objectSelectedUpdated(this, false);\n            }\n            if (this._highlighted) {\n                this.scene._objectHighlightedUpdated(this, false);\n            }\n            this.scene._objectColorizeUpdated(this, false);\n            this.scene._objectOpacityUpdated(this, false);\n            this.scene._objectOffsetUpdated(this, false);\n        }\n        if (this._isModel) {\n            this.scene._deregisterModel(this);\n        }\n        this.glRedraw();\n    }\n\n}\n\n\nconst pickTriangleSurface = (function () {\n\n    // Cached vars to avoid garbage collection\n\n    const localRayOrigin = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const localRayDir = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const positionA = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const positionB = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const positionC = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const triangleVertices = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const position = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\n    const worldPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const viewPos = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const bary = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const normalA = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const normalB = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const normalC = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const uva = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const uvb = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const uvc = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec4a = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\n    const tempVec4b = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\n    const tempVec4c = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec4();\n    const tempVec3 = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3b = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3c = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3d = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3e = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3f = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3g = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3h = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3i = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3j = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n    const tempVec3k = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].vec3();\n\n    return function (mesh, pickViewMatrix, pickProjMatrix, pickResult) {\n\n        var primIndex = pickResult.primIndex;\n\n        if (primIndex !== undefined && primIndex !== null && primIndex > -1) {\n\n            const geometry = mesh.geometry._state;\n            const scene = mesh.scene;\n            const camera = scene.camera;\n            const canvas = scene.canvas;\n\n            if (geometry.primitiveName === \"triangles\") {\n\n                // Triangle picked; this only happens when the\n                // Mesh has a Geometry that has primitives of type \"triangle\"\n\n                pickResult.primitive = \"triangle\";\n\n                // Get the World-space positions of the triangle's vertices\n\n                const i = primIndex; // Indicates the first triangle index in the indices array\n\n                const indices = geometry.indices; // Indices into geometry arrays, not into shared VertexBufs\n                const positions = geometry.positions;\n\n                let ia3;\n                let ib3;\n                let ic3;\n\n                if (indices) {\n\n                    var ia = indices[i + 0];\n                    var ib = indices[i + 1];\n                    var ic = indices[i + 2];\n\n                    triangleVertices[0] = ia;\n                    triangleVertices[1] = ib;\n                    triangleVertices[2] = ic;\n\n                    pickResult.indices = triangleVertices;\n\n                    ia3 = ia * 3;\n                    ib3 = ib * 3;\n                    ic3 = ic * 3;\n\n                } else {\n\n                    ia3 = i * 3;\n                    ib3 = ia3 + 3;\n                    ic3 = ib3 + 3;\n                }\n\n                positionA[0] = positions[ia3 + 0];\n                positionA[1] = positions[ia3 + 1];\n                positionA[2] = positions[ia3 + 2];\n\n                positionB[0] = positions[ib3 + 0];\n                positionB[1] = positions[ib3 + 1];\n                positionB[2] = positions[ib3 + 2];\n\n                positionC[0] = positions[ic3 + 0];\n                positionC[1] = positions[ic3 + 1];\n                positionC[2] = positions[ic3 + 2];\n\n                if (geometry.compressGeometry) {\n\n                    // Decompress vertex positions\n\n                    const positionsDecodeMatrix = geometry.positionsDecodeMatrix;\n                    if (positionsDecodeMatrix) {\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressPosition(positionA, positionsDecodeMatrix, positionA);\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressPosition(positionB, positionsDecodeMatrix, positionB);\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressPosition(positionC, positionsDecodeMatrix, positionC);\n                    }\n                }\n\n                // Attempt to ray-pick the triangle in local space\n\n                let canvasPos;\n\n                if (pickResult.canvasPos) {\n                    canvasPos = pickResult.canvasPos;\n                    _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].canvasPosToLocalRay(canvas.canvas, pickViewMatrix, pickProjMatrix, mesh.worldMatrix, canvasPos, localRayOrigin, localRayDir);\n\n                } else if (pickResult.origin && pickResult.direction) {\n                    _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].worldRayToLocalRay(mesh.worldMatrix, pickResult.origin, pickResult.direction, localRayOrigin, localRayDir);\n                }\n\n                _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].normalizeVec3(localRayDir);\n                _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].rayPlaneIntersect(localRayOrigin, localRayDir, positionA, positionB, positionC, position);\n\n                // Get Local-space cartesian coordinates of the ray-triangle intersection\n\n                pickResult.localPos = position;\n                pickResult.position = position;\n\n                // Get interpolated World-space coordinates\n\n                // Need to transform homogeneous coords\n\n                tempVec4a[0] = position[0];\n                tempVec4a[1] = position[1];\n                tempVec4a[2] = position[2];\n                tempVec4a[3] = 1;\n\n                // Get World-space cartesian coordinates of the ray-triangle intersection\n\n                _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformVec4(mesh.worldMatrix, tempVec4a, tempVec4b);\n\n                worldPos[0] = tempVec4b[0];\n                worldPos[1] = tempVec4b[1];\n                worldPos[2] = tempVec4b[2];\n\n                pickResult.worldPos = worldPos;\n\n                // Get View-space cartesian coordinates of the ray-triangle intersection\n\n                _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformVec4(camera.matrix, tempVec4b, tempVec4c);\n\n                viewPos[0] = tempVec4c[0];\n                viewPos[1] = tempVec4c[1];\n                viewPos[2] = tempVec4c[2];\n\n                pickResult.viewPos = viewPos;\n\n                // Get barycentric coordinates of the ray-triangle intersection\n\n                _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].cartesianToBarycentric(position, positionA, positionB, positionC, bary);\n\n                pickResult.bary = bary;\n\n                // Get interpolated normal vector\n\n                const normals = geometry.normals;\n\n                if (normals) {\n\n                    if (geometry.compressGeometry) {\n\n                        // Decompress vertex normals\n\n                        const ia2 = ia * 3;\n                        const ib2 = ib * 3;\n                        const ic2 = ic * 3;\n\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressNormal(normals.subarray(ia2, ia2 + 2), normalA);\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressNormal(normals.subarray(ib2, ib2 + 2), normalB);\n                        _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressNormal(normals.subarray(ic2, ic2 + 2), normalC);\n\n                    } else {\n\n                        normalA[0] = normals[ia3];\n                        normalA[1] = normals[ia3 + 1];\n                        normalA[2] = normals[ia3 + 2];\n\n                        normalB[0] = normals[ib3];\n                        normalB[1] = normals[ib3 + 1];\n                        normalB[2] = normals[ib3 + 2];\n\n                        normalC[0] = normals[ic3];\n                        normalC[1] = normals[ic3 + 1];\n                        normalC[2] = normals[ic3 + 2];\n                    }\n\n                    const normal = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].addVec3(_math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].addVec3(\n                        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(normalA, bary[0], tempVec3),\n                        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(normalB, bary[1], tempVec3b), tempVec3c),\n                        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec3Scalar(normalC, bary[2], tempVec3d), tempVec3e);\n\n                    pickResult.worldNormal = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].normalizeVec3(_math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].transformVec3(mesh.worldNormalMatrix, normal, tempVec3f));\n                }\n\n                // Get interpolated UV coordinates\n\n                const uvs = geometry.uv;\n\n                if (uvs) {\n\n                    uva[0] = uvs[(ia * 2)];\n                    uva[1] = uvs[(ia * 2) + 1];\n\n                    uvb[0] = uvs[(ib * 2)];\n                    uvb[1] = uvs[(ib * 2) + 1];\n\n                    uvc[0] = uvs[(ic * 2)];\n                    uvc[1] = uvs[(ic * 2) + 1];\n\n                    if (geometry.compressGeometry) {\n\n                        // Decompress vertex UVs\n\n                        const uvDecodeMatrix = geometry.uvDecodeMatrix;\n                        if (uvDecodeMatrix) {\n                            _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressUV(uva, uvDecodeMatrix, uva);\n                            _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressUV(uvb, uvDecodeMatrix, uvb);\n                            _math_geometryCompressionUtils_js__WEBPACK_IMPORTED_MODULE_10__[\"geometryCompressionUtils\"].decompressUV(uvc, uvDecodeMatrix, uvc);\n                        }\n                    }\n\n                    pickResult.uv = _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].addVec3(\n                        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].addVec3(\n                            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec2Scalar(uva, bary[0], tempVec3g),\n                            _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec2Scalar(uvb, bary[1], tempVec3h), tempVec3i),\n                        _math_math_js__WEBPACK_IMPORTED_MODULE_0__[\"math\"].mulVec2Scalar(uvc, bary[2], tempVec3j), tempVec3k);\n                }\n            }\n        }\n    }\n})();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvTWVzaC5qcz9mMWE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLCtDQUErQywwQkFBMEIsY0FBYyxZQUFZOztBQUVuRyw4REFBOEQsMEJBQTBCLGNBQWMsWUFBWTtBQUNsSDtBQUNBO0FBQ3FDO0FBQ0s7QUFDVTtBQUNBO0FBQ29CO0FBQ0U7QUFDZDtBQUNRO0FBQ0Q7QUFDVDs7QUFFbUI7QUFDekI7O0FBRXBELFlBQVksa0RBQUk7QUFDaEIsa0JBQWtCLGtEQUFJO0FBQ3RCLFdBQVcsa0RBQUk7QUFDZixXQUFXLGtEQUFJO0FBQ2YsY0FBYyxrREFBSTtBQUNsQixjQUFjLGtEQUFJO0FBQ2xCLGNBQWMsa0RBQUk7O0FBRWxCLGFBQWEsa0RBQUk7QUFDakIsYUFBYSxrREFBSTs7QUFFakIsb0JBQW9CLGtEQUFJOztBQUV4QjtBQUNBLGFBQWEsYUFBYSxxQ0FBcUMsZUFBZSxRQUFRLGVBQWU7QUFDckcsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEUsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQSxVQUFVLFdBQVcsYUFBYSxhQUFhLDZCQUE2QixXQUFXO0FBQ3ZGLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUMsa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBLDJCQUEyQixhQUFhLFdBQVcsbUJBQW1CLE1BQU0sb0JBQW9CO0FBQ2hHO0FBQ0Esb0VBQW9FLGtDQUFrQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixPQUFPLGlCQUFpQixZQUFZLFdBQVc7QUFDdkcsYUFBYSxnQkFBZ0IsT0FBTyxnQkFBZ0I7QUFDcEQ7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUJBQW1CLHVEQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVEsbUhBQW1ILGNBQWMsS0FBSyxtQkFBbUIsb0NBQW9DLGdCQUFnQixnQkFBZ0IsbUJBQW1CLDRCQUE0QiwyQkFBMkI7QUFDOVQsZUFBZSxRQUFRLHNIQUFzSCxjQUFjLEtBQUssb0JBQW9CLG9DQUFvQyxpQkFBaUIsZ0JBQWdCLG9CQUFvQiw0QkFBNEIsNEJBQTRCO0FBQ3JVLGVBQWUsS0FBSztBQUNwQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPLG9JQUFvSSxpQkFBaUIsMkVBQTJFLGlCQUFpQjtBQUN2USxlQUFlLFNBQVMsaUJBQWlCLGVBQWUsNkNBQTZDLHFCQUFxQjtBQUMxSCxlQUFlLFNBQVMsaUJBQWlCLGVBQWUsbUVBQW1FLHFCQUFxQjtBQUNoSixlQUFlLGlCQUFpQixxQkFBcUIsdUJBQXVCLDBEQUEwRCx5QkFBeUI7QUFDL0osZUFBZSxpQkFBaUIsMEJBQTBCLHVCQUF1QiwwREFBMEQsOEJBQThCO0FBQ3pLLGVBQWUsaUJBQWlCLHlCQUF5Qix1QkFBdUIsNERBQTRELDZCQUE2QjtBQUN6SyxlQUFlLGlCQUFpQixxQkFBcUIsbUJBQW1CLHFFQUFxRSx5QkFBeUI7QUFDdEs7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isa0VBQVc7O0FBRTFDLDBCQUEwQixpRUFBVyxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBSTtBQUN4QjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0RBQUk7QUFDMUIsMkJBQTJCLGtEQUFJO0FBQy9CLHlCQUF5QixrREFBSTtBQUM3Qix5QkFBeUIsa0RBQUk7O0FBRTdCLDRCQUE0QixrREFBSTtBQUNoQyxrQ0FBa0Msa0RBQUk7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxrREFBSTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLG9CQUFvQjtBQUNoRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtFQUFZO0FBQzdDO0FBQ0EseUNBQXlDLHNGQUFvQjtBQUM3RCwwQ0FBMEMsd0ZBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEVBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUZBQWlCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZLGtEQUFJO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFJO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLGtEQUFJO0FBQ1osUUFBUSxrREFBSTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBSTtBQUM3QjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLGtEQUFJO0FBQ1osUUFBUSxrREFBSTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQUk7QUFDckM7QUFDQTtBQUNBLFFBQVEsa0RBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0RBQUk7QUFDekM7QUFDQSxZQUFZLGtEQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQUk7QUFDbkMsUUFBUSxrREFBSTtBQUNaLFFBQVEsa0RBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFJO0FBQ25DLFFBQVEsa0RBQUk7QUFDWixRQUFRLGtEQUFJO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLFFBQVEsa0RBQUk7QUFDWixRQUFRLGtEQUFJO0FBQ1osUUFBUSxrREFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYyxLQUFLLG1CQUFtQjtBQUM3RyxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLEtBQUssb0JBQW9CO0FBQzlHLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0IsR0FBRyxvQkFBb0IsTUFBTSxvQkFBb0I7QUFDcEc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0RBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CLHNCQUFzQixrQkFBa0I7QUFDdEY7QUFDQSxhQUFhLG9CQUFvQixNQUFNLG1CQUFtQjtBQUMxRCxzQkFBc0IsY0FBYyxLQUFLLDJCQUEyQjtBQUNwRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixzQkFBc0Isa0JBQWtCO0FBQ3RGO0FBQ0EsYUFBYSxvQkFBb0IsTUFBTSxtQkFBbUI7QUFDMUQsc0JBQXNCLGNBQWMsS0FBSywyQkFBMkI7QUFDcEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QixnQkFBZ0Isd0JBQXdCO0FBQzlHO0FBQ0EsYUFBYSxvQkFBb0IsTUFBTSxrQkFBa0I7QUFDekQsc0JBQXNCLGNBQWMsS0FBSywwQkFBMEI7QUFDbkU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUIsZ0JBQWdCLHdCQUF3QjtBQUM5RztBQUNBLGFBQWEsb0JBQW9CLE1BQU0sa0JBQWtCO0FBQ3pELHNCQUFzQixjQUFjLEtBQUssMEJBQTBCO0FBQ25FO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUIsZ0JBQWdCLDZCQUE2QjtBQUN4SDtBQUNBLGFBQWEsb0JBQW9CLE1BQU0sdUJBQXVCO0FBQzlELHNCQUFzQixjQUFjLEtBQUssK0JBQStCO0FBQ3hFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCLGdCQUFnQiw2QkFBNkI7QUFDeEg7QUFDQSxhQUFhLG9CQUFvQixNQUFNLHVCQUF1QjtBQUM5RCxzQkFBc0IsY0FBYyxLQUFLLCtCQUErQjtBQUN4RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdUJBQXVCLGdCQUFnQiw0QkFBNEI7QUFDcEg7QUFDQSxhQUFhLG9CQUFvQixNQUFNLG9CQUFvQjtBQUMzRCxzQkFBc0IsY0FBYyxLQUFLLDRCQUE0QjtBQUNyRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QixnQkFBZ0IsNEJBQTRCO0FBQ3BIO0FBQ0EsYUFBYSxvQkFBb0IsTUFBTSxvQkFBb0I7QUFDM0Qsc0JBQXNCLGNBQWMsS0FBSyw0QkFBNEI7QUFDckU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQixnQkFBZ0Isd0JBQXdCO0FBQ3hHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CLGdCQUFnQix3QkFBd0I7QUFDeEc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixzQkFBc0Isa0JBQWtCO0FBQ3RGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixzQkFBc0Isa0JBQWtCO0FBQ3RGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUIsTUFBTSwwQkFBMEI7QUFDbkY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUIsTUFBTSwwQkFBMEI7QUFDbkY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3RELGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBLDhDQUE4QyxrREFBSTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Qsa0VBQVk7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Qsa0VBQVk7QUFDcEU7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0Usc0ZBQW9CO0FBQzVGLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0Usc0ZBQW9CO0FBQzVGLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0Usc0ZBQW9CO0FBQzVGLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsd0ZBQXFCO0FBQy9GLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsd0ZBQXFCO0FBQy9GLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsd0ZBQXFCO0FBQy9GLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsd0ZBQXFCO0FBQy9GLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsd0ZBQXFCO0FBQy9GLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0UsaUZBQWlCO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELHdFQUFjO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFLDBFQUFnQjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0Usa0ZBQW9CO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0RBQUk7QUFDL0Isd0JBQXdCLGtEQUFJO0FBQzVCLHNCQUFzQixrREFBSTtBQUMxQixzQkFBc0Isa0RBQUk7QUFDMUIsc0JBQXNCLGtEQUFJO0FBQzFCLDZCQUE2QixrREFBSTtBQUNqQyxxQkFBcUIsa0RBQUk7QUFDekIscUJBQXFCLGtEQUFJO0FBQ3pCLG9CQUFvQixrREFBSTtBQUN4QixpQkFBaUIsa0RBQUk7QUFDckIsb0JBQW9CLGtEQUFJO0FBQ3hCLG9CQUFvQixrREFBSTtBQUN4QixvQkFBb0Isa0RBQUk7QUFDeEIsZ0JBQWdCLGtEQUFJO0FBQ3BCLGdCQUFnQixrREFBSTtBQUNwQixnQkFBZ0Isa0RBQUk7QUFDcEIsc0JBQXNCLGtEQUFJO0FBQzFCLHNCQUFzQixrREFBSTtBQUMxQixzQkFBc0Isa0RBQUk7QUFDMUIscUJBQXFCLGtEQUFJO0FBQ3pCLHNCQUFzQixrREFBSTtBQUMxQixzQkFBc0Isa0RBQUk7QUFDMUIsc0JBQXNCLGtEQUFJO0FBQzFCLHNCQUFzQixrREFBSTtBQUMxQixzQkFBc0Isa0RBQUk7QUFDMUIsc0JBQXNCLGtEQUFJO0FBQzFCLHNCQUFzQixrREFBSTtBQUMxQixzQkFBc0Isa0RBQUk7QUFDMUIsc0JBQXNCLGtEQUFJO0FBQzFCLHNCQUFzQixrREFBSTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEMsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsMkZBQXdCO0FBQ2hELHdCQUF3QiwyRkFBd0I7QUFDaEQsd0JBQXdCLDJGQUF3QjtBQUNoRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQUk7O0FBRXhCLGlCQUFpQjtBQUNqQixvQkFBb0Isa0RBQUk7QUFDeEI7O0FBRUEsZ0JBQWdCLGtEQUFJO0FBQ3BCLGdCQUFnQixrREFBSTs7QUFFcEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0Isa0RBQUk7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0Isa0RBQUk7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0Isa0RBQUk7O0FBRXBCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkZBQXdCO0FBQ2hELHdCQUF3QiwyRkFBd0I7QUFDaEQsd0JBQXdCLDJGQUF3Qjs7QUFFaEQscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxrREFBSSxTQUFTLGtEQUFJO0FBQ3BELHdCQUF3QixrREFBSTtBQUM1Qix3QkFBd0Isa0RBQUk7QUFDNUIsd0JBQXdCLGtEQUFJOztBQUU1Qiw2Q0FBNkMsa0RBQUksZUFBZSxrREFBSTtBQUNwRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLDJGQUF3QjtBQUNwRCw0QkFBNEIsMkZBQXdCO0FBQ3BELDRCQUE0QiwyRkFBd0I7QUFDcEQ7QUFDQTs7QUFFQSxvQ0FBb0Msa0RBQUk7QUFDeEMsd0JBQXdCLGtEQUFJO0FBQzVCLDRCQUE0QixrREFBSTtBQUNoQyw0QkFBNEIsa0RBQUk7QUFDaEMsd0JBQXdCLGtEQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL01lc2guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiBGaXJlZCB3aGVuIHRoaXMgTWVzaCBpcyBwaWNrZWQgdmlhIGEgY2FsbCB0byB7QGxpbmsgU2NlbmUvcGljazptZXRob2RcIn19U2NlbmUjcGljaygpe3svY3Jvc3NMaW5rfX0uXG5cbiBUaGUgZXZlbnQgcGFyYW1ldGVycyB3aWxsIGJlIHRoZSBoaXQgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSB7QGxpbmsgU2NlbmUvcGljazptZXRob2RcIn19U2NlbmUjcGljaygpe3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuIEBldmVudCBwaWNrZWRcbiAqL1xuaW1wb3J0IHttYXRofSBmcm9tICcuLi9tYXRoL21hdGguanMnO1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJy4uL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQge1JlbmRlclN0YXRlfSBmcm9tICcuLi93ZWJnbC9SZW5kZXJTdGF0ZS5qcyc7XG5pbXBvcnQge0RyYXdSZW5kZXJlcn0gZnJvbSBcIi4vZHJhdy9EcmF3UmVuZGVyZXIuanNcIjtcbmltcG9ydCB7RW1waGFzaXNGaWxsUmVuZGVyZXJ9IGZyb20gXCIuL2VtcGhhc2lzL0VtcGhhc2lzRmlsbFJlbmRlcmVyLmpzXCI7XG5pbXBvcnQge0VtcGhhc2lzRWRnZXNSZW5kZXJlcn0gZnJvbSBcIi4vZW1waGFzaXMvRW1waGFzaXNFZGdlc1JlbmRlcmVyLmpzXCI7XG5pbXBvcnQge1BpY2tNZXNoUmVuZGVyZXJ9IGZyb20gXCIuL3BpY2svUGlja01lc2hSZW5kZXJlci5qc1wiO1xuaW1wb3J0IHtQaWNrVHJpYW5nbGVSZW5kZXJlcn0gZnJvbSBcIi4vcGljay9QaWNrVHJpYW5nbGVSZW5kZXJlci5qc1wiO1xuaW1wb3J0IHtPY2NsdXNpb25SZW5kZXJlcn0gZnJvbSBcIi4vb2NjbHVzaW9uL09jY2x1c2lvblJlbmRlcmVyLmpzXCI7XG5pbXBvcnQge1NoYWRvd1JlbmRlcmVyfSBmcm9tIFwiLi9zaGFkb3cvU2hhZG93UmVuZGVyZXIuanNcIjtcblxuaW1wb3J0IHtnZW9tZXRyeUNvbXByZXNzaW9uVXRpbHN9IGZyb20gJy4uL21hdGgvZ2VvbWV0cnlDb21wcmVzc2lvblV0aWxzLmpzJztcbmltcG9ydCB7UmVuZGVyRmxhZ3N9IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJGbGFncy5qc1wiO1xuXG5jb25zdCBvYmIgPSBtYXRoLk9CQjMoKTtcbmNvbnN0IGFuZ2xlQXhpcyA9IG1hdGgudmVjNCgpO1xuY29uc3QgcTEgPSBtYXRoLnZlYzQoKTtcbmNvbnN0IHEyID0gbWF0aC52ZWM0KCk7XG5jb25zdCB4QXhpcyA9IG1hdGgudmVjMyhbMSwgMCwgMF0pO1xuY29uc3QgeUF4aXMgPSBtYXRoLnZlYzMoWzAsIDEsIDBdKTtcbmNvbnN0IHpBeGlzID0gbWF0aC52ZWMzKFswLCAwLCAxXSk7XG5cbmNvbnN0IHZlY2EgPSBtYXRoLnZlYzMoMyk7XG5jb25zdCB2ZWNiID0gbWF0aC52ZWMzKDMpO1xuXG5jb25zdCBpZGVudGl0eU1hdCA9IG1hdGguaWRlbnRpdHlNYXQ0KCk7XG5cbi8qKlxuICogQGRlc2MgQW4ge0BsaW5rIEVudGl0eX0gdGhhdCBpcyBhIGRyYXdhYmxlIGVsZW1lbnQsIHdpdGggYSB7QGxpbmsgR2VvbWV0cnl9IGFuZCBhIHtAbGluayBNYXRlcmlhbH0sIHRoYXQgY2FuIGJlXG4gKiBjb25uZWN0ZWQgaW50byBhIHNjZW5lIGdyYXBoIHVzaW5nIHtAbGluayBOb2RlfXMuXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBpcyB0aGUgc2FtZSBhcyB0aGUgb25lIGdpdmVuIGZvciB7QGxpbmsgTm9kZX0sIHNpbmNlIHRoZSB0d28gY2xhc3NlcyB3b3JrIHRvZ2V0aGVyLiAgSW4gdGhpcyBleGFtcGxlLFxuICogd2UnbGwgY3JlYXRlIGEgc2NlbmUgZ3JhcGggaW4gd2hpY2ggYSByb290IHtAbGluayBOb2RlfSByZXByZXNlbnRzIGEgZ3JvdXAgYW5kIHRoZSBNZXNoZXMgYXJlIGxlYXZlcy5cbiAqXG4gKiBTaW5jZSB7QGxpbmsgTm9kZX0gaW1wbGVtZW50cyB7QGxpbmsgRW50aXR5fSwgd2UgY2FuIGRlc2lnbmF0ZSB0aGUgcm9vdCB7QGxpbmsgTm9kZX0gYXMgYSBtb2RlbCwgY2F1c2luZyBpdCB0byBiZSByZWdpc3RlcmVkIGJ5IGl0c1xuICogSUQgaW4ge0BsaW5rIFNjZW5lI21vZGVsc30uXG4gKlxuICogU2luY2UgTWVzaCBhbHNvIGltcGxlbWVudHMge0BsaW5rIEVudGl0eX0sIHdlIGNhbiBkZXNpZ25hdGUgdGhlIGxlYWYgTWVzaGVzIGFzIG9iamVjdHMsIGNhdXNpbmcgdGhlbSB0b1xuICogYmUgcmVnaXN0ZXJlZCBieSB0aGVpciBJRHMgaW4ge0BsaW5rIFNjZW5lI29iamVjdHN9LlxuICpcbiAqIFdlIGNhbiB0aGVuIGZpbmQgdGhvc2Uge0BsaW5rIEVudGl0eX0gdHlwZXMgaW4ge0BsaW5rIFNjZW5lI21vZGVsc30gYW5kIHtAbGluayBTY2VuZSNvYmplY3RzfS5cbiAqXG4gKiBXZSBjYW4gYWxzbyB1cGRhdGUgcHJvcGVydGllcyBvZiBvdXIgb2JqZWN0LU1lc2hlcyB2aWEgY2FsbHMgdG8ge0BsaW5rIFNjZW5lI3NldE9iamVjdHNIaWdobGlnaHRlZH0gZXRjLlxuICpcbiAqIFtbUnVuIHRoaXMgZXhhbXBsZV0oaHR0cDovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jc2NlbmVSZXByZXNlbnRhdGlvbl9TY2VuZUdyYXBoKV1cbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHtWaWV3ZXJ9IGZyb20gXCIuLi9zcmMvdmlld2VyL1ZpZXdlci5qc1wiO1xuICogaW1wb3J0IHtNZXNofSBmcm9tIFwiLi4vc3JjL3NjZW5lL21lc2gvTWVzaC5qc1wiO1xuICogaW1wb3J0IHtOb2RlfSBmcm9tIFwiLi4vc3JjL3NjZW5lL25vZGVzL05vZGUuanNcIjtcbiAqIGltcG9ydCB7UGhvbmdNYXRlcmlhbH0gZnJvbSBcIi4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvUGhvbmdNYXRlcmlhbC5qc1wiO1xuICogaW1wb3J0IHtidWlsZEJveEdlb21ldHJ5fSBmcm9tIFwiLi4vc3JjL3ZpZXdlci9zY2VuZS9nZW9tZXRyeS9idWlsZGVycy9idWlsZEJveEdlb21ldHJ5LmpzXCI7XG4gKiBpbXBvcnQge1JlYWRhYmxlR2VvbWV0cnl9IGZyb20gXCIuLi9zcmMvdmlld2VyL3NjZW5lL2dlb21ldHJ5L1JlYWRhYmxlR2VvbWV0cnkuanNcIjtcbiAqXG4gKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlld2VyKHtcbiAqICAgICBjYW52YXNJZDogXCJteUNhbnZhc1wiXG4gKiB9KTtcbiAqXG4gKiB2aWV3ZXIuc2NlbmUuY2FtZXJhLmV5ZSA9IFstMjEuODAsIDQuMDEsIDYuNTZdO1xuICogdmlld2VyLnNjZW5lLmNhbWVyYS5sb29rID0gWzAsIC01Ljc1LCAwXTtcbiAqIHZpZXdlci5zY2VuZS5jYW1lcmEudXAgPSBbMC4zNywgMC45MSwgLTAuMTFdO1xuICpcbiAqIGNvbnN0IGJveEdlb21ldHJ5ID0gbmV3IFJlYWRhYmxlR2VvbWV0cnkodmlld2VyLnNjZW5lLCBidWlsZEJveEdlb21ldHJ5KHtcbiAqICAgICAgeFNpemU6IDEsXG4gKiAgICAgIHlTaXplOiAxLFxuICogICAgICB6U2l6ZTogMVxuICogfSkpO1xuICpcbiAqIG5ldyBOb2RlKHZpZXdlci5zY2VuZSwge1xuICogICAgICBpZDogXCJ0YWJsZVwiLFxuICogICAgICBpc01vZGVsOiB0cnVlLCAvLyA8LS0tLS0tLS0tLSBOb2RlIHJlcHJlc2VudHMgYSBtb2RlbCwgc28gaXMgcmVnaXN0ZXJlZCBieSBJRCBpbiB2aWV3ZXIuc2NlbmUubW9kZWxzXG4gKiAgICAgIHJvdGF0aW9uOiBbMCwgNTAsIDBdLFxuICogICAgICBwb3NpdGlvbjogWzAsIDAsIDBdLFxuICogICAgICBzY2FsZTogWzEsIDEsIDFdLFxuICpcbiAqICAgICAgY2hpbGRyZW46IFtcbiAqXG4gKiAgICAgICAgICBuZXcgTWVzaCh2aWV3ZXIuc2NlbmUsIHsgLy8gUmVkIHRhYmxlIGxlZ1xuICogICAgICAgICAgICAgIGlkOiBcInJlZExlZ1wiLFxuICogICAgICAgICAgICAgIGlzT2JqZWN0OiB0cnVlLCAvLyA8LS0tLS0tIE5vZGUgcmVwcmVzZW50cyBhbiBvYmplY3QsIHNvIGlzIHJlZ2lzdGVyZWQgYnkgSUQgaW4gdmlld2VyLnNjZW5lLm9iamVjdHNcbiAqICAgICAgICAgICAgICBwb3NpdGlvbjogWy00LCAtNiwgLTRdLFxuICogICAgICAgICAgICAgIHNjYWxlOiBbMSwgMywgMV0sXG4gKiAgICAgICAgICAgICAgcm90YXRpb246IFswLCAwLCAwXSxcbiAqICAgICAgICAgICAgICBtYXRlcmlhbDogbmV3IFBob25nTWF0ZXJpYWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgICAgIGRpZmZ1c2U6IFsxLCAwLjMsIDAuM11cbiAqICAgICAgICAgICAgICB9KSxcbiAqICAgICAgICAgICAgICBnZW9tZXRyeTogYm94R2VvbWV0cnlcbiAqICAgICAgICAgIH0pLFxuICpcbiAqICAgICAgICAgIG5ldyBNZXNoKHZpZXdlci5zY2VuZSwgeyAvLyBHcmVlbiB0YWJsZSBsZWdcbiAqICAgICAgICAgICAgICBpZDogXCJncmVlbkxlZ1wiLFxuICogICAgICAgICAgICAgIGlzT2JqZWN0OiB0cnVlLCAvLyA8LS0tLS0tIE5vZGUgcmVwcmVzZW50cyBhbiBvYmplY3QsIHNvIGlzIHJlZ2lzdGVyZWQgYnkgSUQgaW4gdmlld2VyLnNjZW5lLm9iamVjdHNcbiAqICAgICAgICAgICAgICBwb3NpdGlvbjogWzQsIC02LCAtNF0sXG4gKiAgICAgICAgICAgICAgc2NhbGU6IFsxLCAzLCAxXSxcbiAqICAgICAgICAgICAgICByb3RhdGlvbjogWzAsIDAsIDBdLFxuICogICAgICAgICAgICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgICAgICAgICAgZGlmZnVzZTogWzAuMywgMS4wLCAwLjNdXG4gKiAgICAgICAgICAgICAgfSksXG4gKiAgICAgICAgICAgICAgZ2VvbWV0cnk6IGJveEdlb21ldHJ5XG4gKiAgICAgICAgICB9KSxcbiAqXG4gKiAgICAgICAgICBuZXcgTWVzaCh2aWV3ZXIuc2NlbmUsIHsvLyBCbHVlIHRhYmxlIGxlZ1xuICogICAgICAgICAgICAgIGlkOiBcImJsdWVMZWdcIixcbiAqICAgICAgICAgICAgICBpc09iamVjdDogdHJ1ZSwgLy8gPC0tLS0tLSBOb2RlIHJlcHJlc2VudHMgYW4gb2JqZWN0LCBzbyBpcyByZWdpc3RlcmVkIGJ5IElEIGluIHZpZXdlci5zY2VuZS5vYmplY3RzXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFs0LCAtNiwgNF0sXG4gKiAgICAgICAgICAgICAgc2NhbGU6IFsxLCAzLCAxXSxcbiAqICAgICAgICAgICAgICByb3RhdGlvbjogWzAsIDAsIDBdLFxuICogICAgICAgICAgICAgIG1hdGVyaWFsOiBuZXcgUGhvbmdNYXRlcmlhbCh2aWV3ZXIuc2NlbmUsIHtcbiAqICAgICAgICAgICAgICAgICAgZGlmZnVzZTogWzAuMywgMC4zLCAxLjBdXG4gKiAgICAgICAgICAgICAgfSksXG4gKiAgICAgICAgICAgICAgZ2VvbWV0cnk6IGJveEdlb21ldHJ5XG4gKiAgICAgICAgICB9KSxcbiAqXG4gKiAgICAgICAgICBuZXcgTWVzaCh2aWV3ZXIuc2NlbmUsIHsgIC8vIFllbGxvdyB0YWJsZSBsZWdcbiAqICAgICAgICAgICAgICBpZDogXCJ5ZWxsb3dMZWdcIixcbiAqICAgICAgICAgICAgICBpc09iamVjdDogdHJ1ZSwgLy8gPC0tLS0tLSBOb2RlIHJlcHJlc2VudHMgYW4gb2JqZWN0LCBzbyBpcyByZWdpc3RlcmVkIGJ5IElEIGluIHZpZXdlci5zY2VuZS5vYmplY3RzXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFstNCwgLTYsIDRdLFxuICogICAgICAgICAgICAgIHNjYWxlOiBbMSwgMywgMV0sXG4gKiAgICAgICAgICAgICAgcm90YXRpb246IFswLCAwLCAwXSxcbiAqICAgICAgICAgICAgICBtYXRlcmlhbDogbmV3IFBob25nTWF0ZXJpYWwodmlld2VyLnNjZW5lLCB7XG4gKiAgICAgICAgICAgICAgICAgICBkaWZmdXNlOiBbMS4wLCAxLjAsIDAuMF1cbiAqICAgICAgICAgICAgICB9KSxcbiAqICAgICAgICAgICAgICBnZW9tZXRyeTogYm94R2VvbWV0cnlcbiAqICAgICAgICAgIH0pLFxuICpcbiAqICAgICAgICAgIG5ldyBNZXNoKHZpZXdlci5zY2VuZSwgeyAvLyBQdXJwbGUgdGFibGUgdG9wXG4gKiAgICAgICAgICAgICAgaWQ6IFwidGFibGVUb3BcIixcbiAqICAgICAgICAgICAgICBpc09iamVjdDogdHJ1ZSwgLy8gPC0tLS0tLSBOb2RlIHJlcHJlc2VudHMgYW4gb2JqZWN0LCBzbyBpcyByZWdpc3RlcmVkIGJ5IElEIGluIHZpZXdlci5zY2VuZS5vYmplY3RzXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFswLCAtMywgMF0sXG4gKiAgICAgICAgICAgICAgc2NhbGU6IFs2LCAwLjUsIDZdLFxuICogICAgICAgICAgICAgIHJvdGF0aW9uOiBbMCwgMCwgMF0sXG4gKiAgICAgICAgICAgICAgbWF0ZXJpYWw6IG5ldyBQaG9uZ01hdGVyaWFsKHZpZXdlci5zY2VuZSwge1xuICogICAgICAgICAgICAgICAgICBkaWZmdXNlOiBbMS4wLCAwLjMsIDEuMF1cbiAqICAgICAgICAgICAgICB9KSxcbiAqICAgICAgICAgICAgICBnZW9tZXRyeTogYm94R2VvbWV0cnlcbiAqICAgICAgICAgIH0pXG4gKiAgICAgIF1cbiAqICB9KTtcbiAqXG4gKiAvLyBGaW5kIE5vZGVzIGFuZCBNZXNoZXMgYnkgdGhlaXIgSURzXG4gKlxuICogdmFyIHRhYmxlID0gdmlld2VyLnNjZW5lLm1vZGVsc1tcInRhYmxlXCJdOyAgICAgICAgICAgICAgICAvLyBTaW5jZSB0YWJsZSBOb2RlIGhhcyBpc01vZGVsID09IHRydWVcbiAqXG4gKiB2YXIgcmVkTGVnID0gdmlld2VyLnNjZW5lLm9iamVjdHNbXCJyZWRMZWdcIl07ICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBNZXNoZXMgaGF2ZSBpc09iamVjdCA9PSB0cnVlXG4gKiB2YXIgZ3JlZW5MZWcgPSB2aWV3ZXIuc2NlbmUub2JqZWN0c1tcImdyZWVuTGVnXCJdO1xuICogdmFyIGJsdWVMZWcgPSB2aWV3ZXIuc2NlbmUub2JqZWN0c1tcImJsdWVMZWdcIl07XG4gKlxuICogLy8gSGlnaGxpZ2h0IG9uZSBvZiB0aGUgdGFibGUgbGVnIE1lc2hlc1xuICpcbiAqIHZpZXdlci5zY2VuZS5zZXRPYmplY3RzSGlnaGxpZ2h0ZWQoW1wicmVkTGVnXCJdLCB0cnVlKTsgICAgLy8gU2luY2UgdGhlIE1lc2hlcyBoYXZlIGlzT2JqZWN0ID09IHRydWVcbiAqXG4gKiAvLyBQZXJpb2RpY2FsbHkgdXBkYXRlIHRyYW5zZm9ybXMgb24gb3VyIE5vZGVzIGFuZCBNZXNoZXNcbiAqXG4gKiB2aWV3ZXIuc2NlbmUub24oXCJ0aWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAqXG4gKiAgICAgICAvLyBSb3RhdGUgbGVnc1xuICogICAgICAgcmVkTGVnLnJvdGF0ZVkoMC41KTtcbiAqICAgICAgIGdyZWVuTGVnLnJvdGF0ZVkoMC41KTtcbiAqICAgICAgIGJsdWVMZWcucm90YXRlWSgwLjUpO1xuICpcbiAqICAgICAgIC8vIFJvdGF0ZSB0YWJsZVxuICogICAgICAgdGFibGUucm90YXRlWSgwLjUpO1xuICogICAgICAgdGFibGUucm90YXRlWCgwLjMpO1xuICogICB9KTtcbiAqIGBgYGBcbiAqXG4gKiAjIyBNZXRhZGF0YVxuICpcbiAqIEFzIG1lbnRpb25lZCwgd2UgY2FuIGFsc28gYXNzb2NpYXRlIHtAbGluayBNZXRhTW9kZWx9cyBhbmQge0BsaW5rIE1ldGFPYmplY3R9cyB3aXRoIG91ciB7QGxpbmsgTm9kZX1zIGFuZCBNZXNoZXMsXG4gKiB3aXRoaW4gYSB7QGxpbmsgTWV0YVNjZW5lfS4gU2VlIHtAbGluayBNZXRhU2NlbmV9IGZvciBhbiBleGFtcGxlLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtFbnRpdHl9XG4gKiBAaW1wbGVtZW50cyB7RHJhd2FibGV9XG4gKi9cbmNsYXNzIE1lc2ggZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgLyoqXG4gICAgIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcIk1lc2hcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb3duZXIgT3duZXIgY29tcG9uZW50LiBXaGVuIGRlc3Ryb3llZCwgdGhlIG93bmVyIHdpbGwgZGVzdHJveSB0aGlzIGNvbXBvbmVudCBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gW2NmZ10gQ29uZmlnc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2ZnLmlkXSBPcHRpb25hbCBJRCwgdW5pcXVlIGFtb25nIGFsbCBjb21wb25lbnRzIGluIHRoZSBwYXJlbnQgc2NlbmUsIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NmZy5vcmlnaW5hbFN5c3RlbUlkXSBJRCBvZiB0aGUgY29ycmVzcG9uZGluZyBvYmplY3Qgd2l0aGluIHRoZSBvcmlnaW5hdGluZyBzeXN0ZW0sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuaXNNb2RlbF0gU3BlY2lmeSBgYGBgdHJ1ZWBgYGAgaWYgdGhpcyBNZXNoIHJlcHJlc2VudHMgYSBtb2RlbCwgaW4gd2hpY2ggY2FzZSB0aGUgTWVzaCB3aWxsIGJlIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNtb2RlbHN9IGFuZCBtYXkgYWxzbyBoYXZlIGEgY29ycmVzcG9uZGluZyB7QGxpbmsgTWV0YU1vZGVsfSB3aXRoIG1hdGNoaW5nIHtAbGluayBNZXRhTW9kZWwjaWR9LCByZWdpc3RlcmVkIGJ5IHRoYXQgSUQgaW4ge0BsaW5rIE1ldGFTY2VuZSNtZXRhTW9kZWxzfS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuaXNPYmplY3RdIFNwZWNpZnkgYGBgYHRydWVgYGBgIGlmIHRoaXMgTWVzaCByZXByZXNlbnRzIGFuIG9iamVjdCwgaW4gd2hpY2ggY2FzZSB0aGUgTWVzaCB3aWxsIGJlIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNvYmplY3RzfSBhbmQgbWF5IGFsc28gaGF2ZSBhIGNvcnJlc3BvbmRpbmcge0BsaW5rIE1ldGFPYmplY3R9IHdpdGggbWF0Y2hpbmcge0BsaW5rIE1ldGFPYmplY3QjaWR9LCByZWdpc3RlcmVkIGJ5IHRoYXQgSUQgaW4ge0BsaW5rIE1ldGFTY2VuZSNtZXRhT2JqZWN0c30uXG4gICAgICogQHBhcmFtIHtOb2RlfSBbY2ZnLnBhcmVudF0gVGhlIHBhcmVudCBOb2RlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtjZmcucnRjQ2VudGVyXSBSZWxhdGl2ZS10by1jZW50ZXIgKFJUQykgY29vcmRpbmF0ZSBzeXN0ZW0gY2VudGVyIGZvciB0aGlzIE1lc2guIFdoZW4gdGhpcyBpcyBnaXZlbiwgdGhlbiBgYGBgbWF0cml4YGBgYCwgYGBgYHBvc2l0aW9uYGBgYCBhbmQgYGBgYGdlb21ldHJ5YGBgYCBhcmUgYWxsIGFzc3VtZWQgdG8gYmUgcmVsYXRpdmUgdG8gdGhpcyBjZW50ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW2NmZy5wb3NpdGlvbj1bMCwwLDBdXSBMb2NhbCAzRCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLnNjYWxlPVsxLDEsMV1dIExvY2FsIHNjYWxlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtjZmcucm90YXRpb249WzAsMCwwXV0gTG9jYWwgcm90YXRpb24sIGFzIEV1bGVyIGFuZ2xlcyBnaXZlbiBpbiBkZWdyZWVzLCBmb3IgZWFjaCBvZiB0aGUgWCwgWSBhbmQgWiBheGlzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtjZmcubWF0cml4PVsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXV0gTG9jYWwgbW9kZWxsaW5nIHRyYW5zZm9ybSBtYXRyaXguIE92ZXJyaWRlcyB0aGUgcG9zaXRpb24sIHNjYWxlIGFuZCByb3RhdGlvbiBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtjZmcub2Zmc2V0PVswLDAsMF1dIFdvcmxkLXNwYWNlIDNEIHRyYW5zbGF0aW9uIG9mZnNldC4gVHJhbnNsYXRlcyB0aGUgTWVzaCBpbiBXb3JsZCBzcGFjZSwgYWZ0ZXIgbW9kZWxsaW5nIHRyYW5zZm9ybXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLnZpc2libGU9dHJ1ZV0gSW5kaWNhdGVzIGlmIHRoZSBNZXNoIGlzIGluaXRpYWxseSB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NmZy5jdWxsZWQ9ZmFsc2VdIEluZGljYXRlcyBpZiB0aGUgTWVzaCBpcyBpbml0aWFsbHkgY3VsbGVkIGZyb20gdmlldy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcucGlja2FibGU9dHJ1ZV0gSW5kaWNhdGVzIGlmIHRoZSBNZXNoIGlzIGluaXRpYWxseSBwaWNrYWJsZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuY2xpcHBhYmxlPXRydWVdIEluZGljYXRlcyBpZiB0aGUgTWVzaCBpcyBpbml0aWFsbHkgY2xpcHBhYmxlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NmZy5jb2xsaWRhYmxlPXRydWVdIEluZGljYXRlcyBpZiB0aGUgTWVzaCBpcyBpbml0aWFsbHkgaW5jbHVkZWQgaW4gYm91bmRhcnkgY2FsY3VsYXRpb25zLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NmZy5jYXN0c1NoYWRvdz10cnVlXSBJbmRpY2F0ZXMgaWYgdGhlIE1lc2ggaW5pdGlhbGx5IGNhc3RzIHNoYWRvd3MuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLnJlY2VpdmVzU2hhZG93PXRydWVdICBJbmRpY2F0ZXMgaWYgdGhlIE1lc2ggaW5pdGlhbGx5IHJlY2VpdmVzIHNoYWRvd3MuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLnhyYXllZD1mYWxzZV0gSW5kaWNhdGVzIGlmIHRoZSBNZXNoIGlzIGluaXRpYWxseSB4cmF5ZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLmhpZ2hsaWdodGVkPWZhbHNlXSBJbmRpY2F0ZXMgaWYgdGhlIE1lc2ggaXMgaW5pdGlhbGx5IGhpZ2hsaWdodGVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NmZy5zZWxlY3RlZD1mYWxzZV0gSW5kaWNhdGVzIGlmIHRoZSBNZXNoIGlzIGluaXRpYWxseSBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuZWRnZXM9ZmFsc2VdIEluZGljYXRlcyBpZiB0aGUgTWVzaCdzIGVkZ2VzIGFyZSBpbml0aWFsbHkgZW1waGFzaXplZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbY2ZnLmNvbG9yaXplPVsxLjAsMS4wLDEuMF1dIE1lc2gncyBpbml0aWFsIFJHQiBjb2xvcml6ZSBjb2xvciwgbXVsdGlwbGllcyBieSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgY29sb3JzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2ZnLm9wYWNpdHk9MS4wXSBNZXNoJ3MgaW5pdGlhbCBvcGFjaXR5IGZhY3RvciwgbXVsdGlwbGllcyBieSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgYWxwaGEuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjZmcuYmlsbGJvYXJkPVwibm9uZVwiXSBNZXNoJ3MgYmlsbGJvYXJkaW5nIGJlaGF2aW91ci4gT3B0aW9ucyBhcmUgXCJub25lXCIgZm9yIG5vIGJpbGxib2FyZGluZywgXCJzcGhlcmljYWxcIiB0byBhbHdheXMgZGlyZWN0bHkgZmFjZSB7QGxpbmsgQ2FtZXJhLmV5ZX0sIHJvdGF0aW5nIGJvdGggdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5LCBvciBcImN5bGluZHJpY2FsXCIgdG8gZmFjZSB0aGUge0BsaW5rIENhbWVyYSNleWV9IHdoaWxlIHJvdGF0aW5nIG9ubHkgYWJvdXQgaXRzIHZlcnRpY2FsbHkgYXhpcyAodXNlIHRoYXQgbW9kZSBmb3IgdGhpbmdzIGxpa2UgdHJlZXMgb24gYSBsYW5kc2NhcGUpLlxuICAgICAqIEBwYXJhbSB7R2VvbWV0cnl9IFtjZmcuZ2VvbWV0cnldIHtAbGluayBHZW9tZXRyeX0gdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGlzIE1lc2guIEluaGVyaXRzIHtAbGluayBTY2VuZSNnZW9tZXRyeX0gYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbY2ZnLm1hdGVyaWFsXSB7QGxpbmsgTWF0ZXJpYWx9IHRvIGRlZmluZSB0aGUgbm9ybWFsIHJlbmRlcmVkIGFwcGVhcmFuY2UgZm9yIHRoaXMgTWVzaC4gSW5oZXJpdHMge0BsaW5rIFNjZW5lI21hdGVyaWFsfSBieSBkZWZhdWx0LlxuICAgICAqIEBwYXJhbSB7RW1waGFzaXNNYXRlcmlhbH0gW2NmZy54cmF5TWF0ZXJpYWxdIHtAbGluayBFbXBoYXNpc01hdGVyaWFsfSB0byBkZWZpbmUgdGhlIHhyYXllZCBhcHBlYXJhbmNlIGZvciB0aGlzIE1lc2guIEluaGVyaXRzIHtAbGluayBTY2VuZSN4cmF5TWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHtFbXBoYXNpc01hdGVyaWFsfSBbY2ZnLmhpZ2hsaWdodE1hdGVyaWFsXSB7QGxpbmsgRW1waGFzaXNNYXRlcmlhbH0gdG8gZGVmaW5lIHRoZSB4cmF5ZWQgYXBwZWFyYW5jZSBmb3IgdGhpcyBNZXNoLiBJbmhlcml0cyB7QGxpbmsgU2NlbmUjaGlnaGxpZ2h0TWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHtFbXBoYXNpc01hdGVyaWFsfSBbY2ZnLnNlbGVjdGVkTWF0ZXJpYWxdIHtAbGluayBFbXBoYXNpc01hdGVyaWFsfSB0byBkZWZpbmUgdGhlIHNlbGVjdGVkIGFwcGVhcmFuY2UgZm9yIHRoaXMgTWVzaC4gSW5oZXJpdHMge0BsaW5rIFNjZW5lI3NlbGVjdGVkTWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHtFbXBoYXNpc01hdGVyaWFsfSBbY2ZnLmVkZ2VNYXRlcmlhbF0ge0BsaW5rIEVkZ2VNYXRlcmlhbH0gdG8gZGVmaW5lIHRoZSBhcHBlYXJhbmNlIG9mIGVuaGFuY2VkIGVkZ2VzIGZvciB0aGlzIE1lc2guIEluaGVyaXRzIHtAbGluayBTY2VuZSNlZGdlTWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXIsIGNmZyA9IHt9KSB7XG5cbiAgICAgICAgc3VwZXIob3duZXIsIGNmZyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoZSBjb3JyZXNwb25kaW5nIG9iamVjdCB3aXRoaW4gdGhlIG9yaWdpbmF0aW5nIHN5c3RlbSwgaWYgYW55LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luYWxTeXN0ZW1JZCA9IChjZmcub3JpZ2luYWxTeXN0ZW1JZCB8fCB0aGlzLmlkKTtcblxuICAgICAgICAvKiogQHByaXZhdGUgKiovXG4gICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgPSBuZXcgUmVuZGVyRmxhZ3MoKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZSh7IC8vIE5PVEU6IFJlbmRlcmVyIGdldHMgbW9kZWxpbmcgYW5kIG5vcm1hbCBtYXRyaWNlcyBmcm9tIE1lc2gjbWF0cml4IGFuZCBNZXNoLiNub3JtYWxXb3JsZE1hdHJpeFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN1bGxlZDogZmFsc2UsXG4gICAgICAgICAgICBwaWNrYWJsZTogbnVsbCxcbiAgICAgICAgICAgIGNsaXBwYWJsZTogbnVsbCxcbiAgICAgICAgICAgIGNvbGxpZGFibGU6IG51bGwsXG4gICAgICAgICAgICBjYXN0c1NoYWRvdzogbnVsbCxcbiAgICAgICAgICAgIHJlY2VpdmVzU2hhZG93OiBudWxsLFxuICAgICAgICAgICAgeHJheWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXRpb25hcnk6ICEhY2ZnLnN0YXRpb25hcnksXG4gICAgICAgICAgICBiaWxsYm9hcmQ6IHRoaXMuX2NoZWNrQmlsbGJvYXJkKGNmZy5iaWxsYm9hcmQpLFxuICAgICAgICAgICAgbGF5ZXI6IG51bGwsXG4gICAgICAgICAgICBjb2xvcml6ZTogbnVsbCxcbiAgICAgICAgICAgIHBpY2tJRDogdGhpcy5zY2VuZS5fcmVuZGVyZXIuZ2V0UGlja0lEKHRoaXMpLFxuICAgICAgICAgICAgZHJhd0hhc2g6IFwiXCIsXG4gICAgICAgICAgICBwaWNrSGFzaDogXCJcIixcbiAgICAgICAgICAgIG9mZnNldDogbWF0aC52ZWMzKCksXG4gICAgICAgICAgICBydGNDZW50ZXI6IG51bGwsXG4gICAgICAgICAgICBydGNDZW50ZXJIYXNoOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2RyYXdSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NoYWRvd1JlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZW1waGFzaXNGaWxsUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9waWNrTWVzaFJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGlja1RyaWFuZ2xlUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9vY2NsdXNpb25SZW5kZXJlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBjZmcuZ2VvbWV0cnkgPyB0aGlzLl9jaGVja0NvbXBvbmVudDIoW1wiUmVhZGFibGVHZW9tZXRyeVwiLCBcIlZCT0dlb21ldHJ5XCJdLCBjZmcuZ2VvbWV0cnkpIDogdGhpcy5zY2VuZS5nZW9tZXRyeTtcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBjZmcubWF0ZXJpYWwgPyB0aGlzLl9jaGVja0NvbXBvbmVudDIoW1wiUGhvbmdNYXRlcmlhbFwiLCBcIk1ldGFsbGljTWF0ZXJpYWxcIiwgXCJTcGVjdWxhck1hdGVyaWFsXCIsIFwiTGFtYmVydE1hdGVyaWFsXCJdLCBjZmcubWF0ZXJpYWwpIDogdGhpcy5zY2VuZS5tYXRlcmlhbDtcbiAgICAgICAgdGhpcy5feHJheU1hdGVyaWFsID0gY2ZnLnhyYXlNYXRlcmlhbCA/IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRW1waGFzaXNNYXRlcmlhbFwiLCBjZmcueHJheU1hdGVyaWFsKSA6IHRoaXMuc2NlbmUueHJheU1hdGVyaWFsO1xuICAgICAgICB0aGlzLl9oaWdobGlnaHRNYXRlcmlhbCA9IGNmZy5oaWdobGlnaHRNYXRlcmlhbCA/IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRW1waGFzaXNNYXRlcmlhbFwiLCBjZmcuaGlnaGxpZ2h0TWF0ZXJpYWwpIDogdGhpcy5zY2VuZS5oaWdobGlnaHRNYXRlcmlhbDtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRNYXRlcmlhbCA9IGNmZy5zZWxlY3RlZE1hdGVyaWFsID8gdGhpcy5fY2hlY2tDb21wb25lbnQoXCJFbXBoYXNpc01hdGVyaWFsXCIsIGNmZy5zZWxlY3RlZE1hdGVyaWFsKSA6IHRoaXMuc2NlbmUuc2VsZWN0ZWRNYXRlcmlhbDtcbiAgICAgICAgdGhpcy5fZWRnZU1hdGVyaWFsID0gY2ZnLmVkZ2VNYXRlcmlhbCA/IHRoaXMuX2NoZWNrQ29tcG9uZW50KFwiRWRnZU1hdGVyaWFsXCIsIGNmZy5lZGdlTWF0ZXJpYWwpIDogdGhpcy5zY2VuZS5lZGdlTWF0ZXJpYWw7XG5cbiAgICAgICAgdGhpcy5fcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fYWFiYiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FhYmJEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fbnVtVHJpYW5nbGVzID0gKHRoaXMuX2dlb21ldHJ5ID8gdGhpcy5fZ2VvbWV0cnkubnVtVHJpYW5nbGVzIDogMCk7XG5cbiAgICAgICAgdGhpcy5zY2VuZS5fYWFiYkRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9zY2FsZSA9IG1hdGgudmVjMygpO1xuICAgICAgICB0aGlzLl9xdWF0ZXJuaW9uID0gbWF0aC5pZGVudGl0eVF1YXRlcm5pb24oKTtcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSBtYXRoLnZlYzMoKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBtYXRoLnZlYzMoKTtcblxuICAgICAgICB0aGlzLl93b3JsZE1hdHJpeCA9IG1hdGguaWRlbnRpdHlNYXQ0KCk7XG4gICAgICAgIHRoaXMuX3dvcmxkTm9ybWFsTWF0cml4ID0gbWF0aC5pZGVudGl0eU1hdDQoKTtcblxuICAgICAgICB0aGlzLl9sb2NhbE1hdHJpeERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fd29ybGRNYXRyaXhEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3dvcmxkTm9ybWFsTWF0cml4RGlydHkgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjZmcucnRjQ2VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5ydGNDZW50ZXIgPSBtYXRoLnZlYzMoY2ZnLnJ0Y0NlbnRlcik7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5ydGNDZW50ZXJIYXNoID0gY2ZnLnJ0Y0NlbnRlci5qb2luKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ZnLm1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBjZmcubWF0cml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IGNmZy5zY2FsZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBjZmcucG9zaXRpb247XG4gICAgICAgICAgICBpZiAoY2ZnLnF1YXRlcm5pb24pIHtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGNmZy5yb3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzT2JqZWN0ID0gY2ZnLmlzT2JqZWN0O1xuICAgICAgICBpZiAodGhpcy5faXNPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX3JlZ2lzdGVyT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXNNb2RlbCA9IGNmZy5pc01vZGVsO1xuICAgICAgICBpZiAodGhpcy5faXNNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fcmVnaXN0ZXJNb2RlbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGNmZy52aXNpYmxlO1xuICAgICAgICB0aGlzLmN1bGxlZCA9IGNmZy5jdWxsZWQ7XG4gICAgICAgIHRoaXMucGlja2FibGUgPSBjZmcucGlja2FibGU7XG4gICAgICAgIHRoaXMuY2xpcHBhYmxlID0gY2ZnLmNsaXBwYWJsZTtcbiAgICAgICAgdGhpcy5jb2xsaWRhYmxlID0gY2ZnLmNvbGxpZGFibGU7XG4gICAgICAgIHRoaXMuY2FzdHNTaGFkb3cgPSBjZmcuY2FzdHNTaGFkb3c7XG4gICAgICAgIHRoaXMucmVjZWl2ZXNTaGFkb3cgPSBjZmcucmVjZWl2ZXNTaGFkb3c7XG4gICAgICAgIHRoaXMueHJheWVkID0gY2ZnLnhyYXllZDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IGNmZy5oaWdobGlnaHRlZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGNmZy5zZWxlY3RlZDtcbiAgICAgICAgdGhpcy5lZGdlcyA9IGNmZy5lZGdlcztcbiAgICAgICAgdGhpcy5sYXllciA9IGNmZy5sYXllcjtcbiAgICAgICAgdGhpcy5jb2xvcml6ZSA9IGNmZy5jb2xvcml6ZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gY2ZnLm9wYWNpdHk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gY2ZnLm9mZnNldDtcblxuICAgICAgICBpZiAoY2ZnLnBhcmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5zY2VuZS5jb21wb25lbnRzW2NmZy5wYXJlbnRJZF07XG4gICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiUGFyZW50IG5vdCBmb3VuZDogJ1wiICsgY2ZnLnBhcmVudElkICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcGFyZW50Tm9kZS5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiUGFyZW50IGlzIG5vdCBhIE5vZGU6ICdcIiArIGNmZy5wYXJlbnRJZCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hZGRDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGNmZy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICghY2ZnLnBhcmVudC5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiUGFyZW50IGlzIG5vdCBhIE5vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZmcucGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Tm9kZSA9IGNmZy5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1lc2ggbWVtYmVyc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIENvbXBvbmVudCBpcyBhIE1lc2guXG4gICAgICogQGZpbmFsXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzTWVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBOb2RlLlxuICAgICAqXG4gICAgICogVGhlIHBhcmVudCBOb2RlIG1heSBhbHNvIGJlIHNldCBieSBwYXNzaW5nIHRoZSBNZXNoIHRvIHRoZSBwYXJlbnQncyB7QGxpbmsgTm9kZSNhZGRDaGlsZH0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgX2NoZWNrQmlsbGJvYXJkKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgXCJub25lXCI7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gXCJzcGhlcmljYWxcIiAmJiB2YWx1ZSAhPT0gXCJjeWxpbmRyaWNhbFwiICYmIHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuc3VwcG9ydGVkIHZhbHVlIGZvciAnYmlsbGJvYXJkJzogXCIgKyB2YWx1ZSArIFwiIC0gYWNjZXB0ZWQgdmFsdWVzIGFyZSBcIiArXG4gICAgICAgICAgICAgICAgXCInc3BoZXJpY2FsJywgJ2N5bGluZHJpY2FsJyBhbmQgJ25vbmUnIC0gZGVmYXVsdGluZyB0byAnbm9uZScuXCIpO1xuICAgICAgICAgICAgdmFsdWUgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHhlb2tpdCB0byBjb21waWxlIHNoYWRlcnMgZm9yIHRoaXMgTWVzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXBpbGUoKSB7XG4gICAgICAgIGNvbnN0IGRyYXdIYXNoID0gdGhpcy5fbWFrZURyYXdIYXNoKCk7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5kcmF3SGFzaCAhPT0gZHJhd0hhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmRyYXdIYXNoID0gZHJhd0hhc2g7XG4gICAgICAgICAgICB0aGlzLl9wdXREcmF3UmVuZGVyZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UmVuZGVyZXIgPSBEcmF3UmVuZGVyZXIuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgLy8gdGhpcy5fc2hhZG93UmVuZGVyZXIgPSBTaGFkb3dSZW5kZXJlci5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0ZpbGxSZW5kZXJlciA9IEVtcGhhc2lzRmlsbFJlbmRlcmVyLmdldCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlciA9IEVtcGhhc2lzRWRnZXNSZW5kZXJlci5nZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlja0hhc2ggPSB0aGlzLl9tYWtlUGlja0hhc2goKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBpY2tIYXNoICE9PSBwaWNrSGFzaCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUucGlja0hhc2ggPSBwaWNrSGFzaDtcbiAgICAgICAgICAgIHRoaXMuX3B1dFBpY2tSZW5kZXJlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3BpY2tNZXNoUmVuZGVyZXIgPSBQaWNrTWVzaFJlbmRlcmVyLmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvY2NsdXNpb25IYXNoID0gdGhpcy5fbWFrZU9jY2x1c2lvbkhhc2goKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLm9jY2x1c2lvbkhhc2ggIT09IG9jY2x1c2lvbkhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLm9jY2x1c2lvbkhhc2ggPSBvY2NsdXNpb25IYXNoO1xuICAgICAgICAgICAgdGhpcy5fcHV0T2NjbHVzaW9uUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX29jY2x1c2lvblJlbmRlcmVyID0gT2NjbHVzaW9uUmVuZGVyZXIuZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldExvY2FsTWF0cml4RGlydHkoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsTWF0cml4RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXRXb3JsZE1hdHJpeERpcnR5KCk7XG4gICAgfVxuXG4gICAgX3NldFdvcmxkTWF0cml4RGlydHkoKSB7XG4gICAgICAgIHRoaXMuX3dvcmxkTWF0cml4RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl93b3JsZE5vcm1hbE1hdHJpeERpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfYnVpbGRXb3JsZE1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxNYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbG9jYWxNYXRyaXgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZE1hdHJpeFtpXSA9IGxvY2FsTWF0cml4W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0aC5tdWxNYXQ0KHRoaXMuX3BhcmVudE5vZGUud29ybGRNYXRyaXgsIGxvY2FsTWF0cml4LCB0aGlzLl93b3JsZE1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ybGRNYXRyaXhEaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9idWlsZFdvcmxkTm9ybWFsTWF0cml4KCkge1xuICAgICAgICBpZiAodGhpcy5fd29ybGRNYXRyaXhEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRXb3JsZE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd29ybGROb3JtYWxNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkTm9ybWFsTWF0cml4ID0gbWF0aC5tYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogb3JkZXIgb2YgaW52ZXJzZSBhbmQgdHJhbnNwb3NlIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIG1hdGgudHJhbnNwb3NlTWF0NCh0aGlzLl93b3JsZE1hdHJpeCwgdGhpcy5fd29ybGROb3JtYWxNYXRyaXgpO1xuICAgICAgICBtYXRoLmludmVyc2VNYXQ0KHRoaXMuX3dvcmxkTm9ybWFsTWF0cml4KTtcbiAgICAgICAgdGhpcy5fd29ybGROb3JtYWxNYXRyaXhEaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9zZXRBQUJCRGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzOyBub2RlOyBub2RlID0gbm9kZS5fcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuX2FhYmJEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlQUFCQigpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5fYWFiYkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hYWJiKSB7XG4gICAgICAgICAgICB0aGlzLl9hYWJiID0gbWF0aC5BQUJCMygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1aWxkQUFCQih0aGlzLndvcmxkTWF0cml4LCB0aGlzLl9hYWJiKTsgLy8gTWVzaCBvciBQZXJmb3JtYW5jZU1vZGVsXG4gICAgICAgIHRoaXMuX2FhYmJEaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF93ZWJnbENvbnRleHRSZXN0b3JlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fZHJhd1JlbmRlcmVyLndlYmdsQ29udGV4dFJlc3RvcmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvd1JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSZW5kZXJlci53ZWJnbENvbnRleHRSZXN0b3JlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbXBoYXNpc0ZpbGxSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1waGFzaXNGaWxsUmVuZGVyZXIud2ViZ2xDb250ZXh0UmVzdG9yZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIud2ViZ2xDb250ZXh0UmVzdG9yZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGlja01lc2hSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcGlja01lc2hSZW5kZXJlci53ZWJnbENvbnRleHRSZXN0b3JlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9waWNrVHJpYW5nbGVSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcGlja01lc2hSZW5kZXJlci53ZWJnbENvbnRleHRSZXN0b3JlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vY2NsdXNpb25SZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fb2NjbHVzaW9uUmVuZGVyZXIud2ViZ2xDb250ZXh0UmVzdG9yZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tYWtlRHJhd0hhc2goKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICAgICAgY29uc3QgaGFzaCA9IFtcbiAgICAgICAgICAgIHNjZW5lLmNhbnZhcy5jYW52YXMuaWQsXG4gICAgICAgICAgICAoc2NlbmUuZ2FtbWFJbnB1dCA/IFwiZ2k7XCIgOiBcIjtcIikgKyAoc2NlbmUuZ2FtbWFPdXRwdXQgPyBcImdvXCIgOiBcIlwiKSxcbiAgICAgICAgICAgIHNjZW5lLl9saWdodHNTdGF0ZS5nZXRIYXNoKCksXG4gICAgICAgICAgICBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLmdldEhhc2goKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUuc3RhdGlvbmFyeSkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmJpbGxib2FyZCA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9uXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIikge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3NcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9jXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5yZWNlaXZlc1NoYWRvdykge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3JzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2gucHVzaChcIjtcIik7XG4gICAgICAgIHJldHVybiBoYXNoLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgX21ha2VQaWNrSGFzaCgpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgICAgICBjb25zdCBoYXNoID0gW1xuICAgICAgICAgICAgc2NlbmUuY2FudmFzLmNhbnZhcy5pZCxcbiAgICAgICAgICAgIHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuZ2V0SGFzaCgpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0aW9uYXJ5KSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuYmlsbGJvYXJkID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL25cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiKSB7XG4gICAgICAgICAgICBoYXNoLnB1c2goXCIvc1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5iaWxsYm9hcmQgPT09IFwiY3lsaW5kcmljYWxcIikge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL2NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaC5wdXNoKFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIGhhc2guam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICBfbWFrZU9jY2x1c2lvbkhhc2goKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICAgICAgY29uc3QgaGFzaCA9IFtcbiAgICAgICAgICAgIHNjZW5lLmNhbnZhcy5jYW52YXMuaWQsXG4gICAgICAgICAgICBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLmdldEhhc2goKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUuc3RhdGlvbmFyeSkge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmJpbGxib2FyZCA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9uXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIikge1xuICAgICAgICAgICAgaGFzaC5wdXNoKFwiL3NcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgICAgIGhhc2gucHVzaChcIi9jXCIpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2gucHVzaChcIjtcIik7XG4gICAgICAgIHJldHVybiBoYXNoLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgX2J1aWxkQUFCQih3b3JsZE1hdHJpeCwgYWFiYikge1xuXG4gICAgICAgIG1hdGgudHJhbnNmb3JtT0JCMyh3b3JsZE1hdHJpeCwgdGhpcy5fZ2VvbWV0cnkub2JiLCBvYmIpO1xuICAgICAgICBtYXRoLk9CQjNUb0FBQkIzKG9iYiwgYWFiYik7XG5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fc3RhdGUub2Zmc2V0O1xuXG4gICAgICAgIGFhYmJbMF0gKz0gb2Zmc2V0WzBdO1xuICAgICAgICBhYWJiWzFdICs9IG9mZnNldFsxXTtcbiAgICAgICAgYWFiYlsyXSArPSBvZmZzZXRbMl07XG4gICAgICAgIGFhYmJbM10gKz0gb2Zmc2V0WzBdO1xuICAgICAgICBhYWJiWzRdICs9IG9mZnNldFsxXTtcbiAgICAgICAgYWFiYls1XSArPSBvZmZzZXRbMl07XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnJ0Y0NlbnRlcikge1xuICAgICAgICAgICAgY29uc3QgcnRjQ2VudGVyID0gdGhpcy5fc3RhdGUucnRjQ2VudGVyO1xuICAgICAgICAgICAgYWFiYlswXSArPSBydGNDZW50ZXJbMF07XG4gICAgICAgICAgICBhYWJiWzFdICs9IHJ0Y0NlbnRlclsxXTtcbiAgICAgICAgICAgIGFhYmJbMl0gKz0gcnRjQ2VudGVyWzJdO1xuICAgICAgICAgICAgYWFiYlszXSArPSBydGNDZW50ZXJbMF07XG4gICAgICAgICAgICBhYWJiWzRdICs9IHJ0Y0NlbnRlclsxXTtcbiAgICAgICAgICAgIGFhYmJbNV0gKz0gcnRjQ2VudGVyWzJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhpcyBNZXNoLlxuICAgICAqXG4gICAgICogU2V0IHRvIHtAbGluayBTY2VuZSNnZW9tZXRyeX0gYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtHZW9tZXRyeX1cbiAgICAgKi9cbiAgICBnZXQgZ2VvbWV0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBhcHBlYXJhbmNlIG9mIHRoaXMgTWVzaCB3aGVuIHJlbmRlcmluZyBub3JtYWxseSwgaWUuIHdoZW4gbm90IHhyYXllZCwgaGlnaGxpZ2h0ZWQgb3Igc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBTZXQgdG8ge0BsaW5rIFNjZW5lI21hdGVyaWFsfSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHR5cGUge01hdGVyaWFsfVxuICAgICAqL1xuICAgIGdldCBtYXRlcmlhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1lc2gncyBsb2NhbCB0cmFuc2xhdGlvbi5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYFswLDAsMF1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbi5zZXQodmFsdWUgfHwgWzAsIDAsIDBdKTtcbiAgICAgICAgdGhpcy5fc2V0TG9jYWxNYXRyaXhEaXJ0eSgpO1xuICAgICAgICB0aGlzLl9zZXRBQUJCRGlydHkoKTtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE1lc2gncyBsb2NhbCB0cmFuc2xhdGlvbi5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYFswLDAsMF1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1lc2gncyBsb2NhbCByb3RhdGlvbiwgYXMgRXVsZXIgYW5nbGVzIGdpdmVuIGluIGRlZ3JlZXMsIGZvciBlYWNoIG9mIHRoZSBYLCBZIGFuZCBaIGF4aXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGBbMCwwLDBdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcm90YXRpb24uc2V0KHZhbHVlIHx8IFswLCAwLCAwXSk7XG4gICAgICAgIG1hdGguZXVsZXJUb1F1YXRlcm5pb24odGhpcy5fcm90YXRpb24sIFwiWFlaXCIsIHRoaXMuX3F1YXRlcm5pb24pO1xuICAgICAgICB0aGlzLl9zZXRMb2NhbE1hdHJpeERpcnR5KCk7XG4gICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTWVzaCdzIGxvY2FsIHJvdGF0aW9uLCBhcyBFdWxlciBhbmdsZXMgZ2l2ZW4gaW4gZGVncmVlcywgZm9yIGVhY2ggb2YgdGhlIFgsIFkgYW5kIFogYXhpcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYFswLDAsMF1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1lc2gncyBsb2NhbCByb3RhdGlvbiBxdWF0ZXJuaW9uLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAsMCwwLDFdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBzZXQgcXVhdGVybmlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9xdWF0ZXJuaW9uLnNldCh2YWx1ZSB8fCBbMCwgMCwgMCwgMV0pO1xuICAgICAgICBtYXRoLnF1YXRlcm5pb25Ub0V1bGVyKHRoaXMuX3F1YXRlcm5pb24sIFwiWFlaXCIsIHRoaXMuX3JvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0TG9jYWxNYXRyaXhEaXJ0eSgpO1xuICAgICAgICB0aGlzLl9zZXRBQUJCRGlydHkoKTtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE1lc2gncyBsb2NhbCByb3RhdGlvbiBxdWF0ZXJuaW9uLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzAsMCwwLDFdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgcXVhdGVybmlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1YXRlcm5pb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTWVzaCdzIGxvY2FsIHNjYWxlLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzEsMSwxXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlLnNldCh2YWx1ZSB8fCBbMSwgMSwgMV0pO1xuICAgICAgICB0aGlzLl9zZXRMb2NhbE1hdHJpeERpcnR5KCk7XG4gICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTWVzaCdzIGxvY2FsIHNjYWxlLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzEsMSwxXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTWVzaCdzIGxvY2FsIG1vZGVsaW5nIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIHNldCBtYXRyaXgodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fbG9jYWxNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX19sb2NhbE1hdHJpeCA9IG1hdGguaWRlbnRpdHlNYXQ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2xvY2FsTWF0cml4LnNldCh2YWx1ZSB8fCBpZGVudGl0eU1hdCk7XG4gICAgICAgIG1hdGguZGVjb21wb3NlTWF0NCh0aGlzLl9fbG9jYWxNYXRyaXgsIHRoaXMuX3Bvc2l0aW9uLCB0aGlzLl9xdWF0ZXJuaW9uLCB0aGlzLl9zY2FsZSk7XG4gICAgICAgIHRoaXMuX2xvY2FsTWF0cml4RGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2V0V29ybGRNYXRyaXhEaXJ0eSgpO1xuICAgICAgICB0aGlzLl9zZXRBQUJCRGlydHkoKTtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE1lc2gncyBsb2NhbCBtb2RlbGluZyB0cmFuc2Zvcm0gbWF0cml4LlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgbWF0cml4KCkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxNYXRyaXhEaXJ0eSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fbG9jYWxNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fbG9jYWxNYXRyaXggPSBtYXRoLmlkZW50aXR5TWF0NCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0aC5jb21wb3NlTWF0NCh0aGlzLl9wb3NpdGlvbiwgdGhpcy5fcXVhdGVybmlvbiwgdGhpcy5fc2NhbGUsIHRoaXMuX19sb2NhbE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbE1hdHJpeERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19sb2NhbE1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBNZXNoJ3MgV29ybGQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdvcmxkTWF0cml4XG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIGdldCB3b3JsZE1hdHJpeCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmxkTWF0cml4RGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkV29ybGRNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRNYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTWVzaCdzIFdvcmxkIG5vcm1hbCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IHdvcmxkTm9ybWFsTWF0cml4KCkge1xuICAgICAgICBpZiAodGhpcy5fd29ybGROb3JtYWxNYXRyaXhEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRXb3JsZE5vcm1hbE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZE5vcm1hbE1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBNZXNoIGFib3V0IHRoZSBnaXZlbiBsb2NhbCBheGlzIGJ5IHRoZSBnaXZlbiBpbmNyZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBheGlzIExvY2FsIGF4aXMgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBBbmdsZSBpbmNyZW1lbnQgaW4gZGVncmVlcy5cbiAgICAgKi9cbiAgICByb3RhdGUoYXhpcywgYW5nbGUpIHtcbiAgICAgICAgYW5nbGVBeGlzWzBdID0gYXhpc1swXTtcbiAgICAgICAgYW5nbGVBeGlzWzFdID0gYXhpc1sxXTtcbiAgICAgICAgYW5nbGVBeGlzWzJdID0gYXhpc1syXTtcbiAgICAgICAgYW5nbGVBeGlzWzNdID0gYW5nbGUgKiBtYXRoLkRFR1RPUkFEO1xuICAgICAgICBtYXRoLmFuZ2xlQXhpc1RvUXVhdGVybmlvbihhbmdsZUF4aXMsIHExKTtcbiAgICAgICAgbWF0aC5tdWxRdWF0ZXJuaW9ucyh0aGlzLnF1YXRlcm5pb24sIHExLCBxMik7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbiA9IHEyO1xuICAgICAgICB0aGlzLl9zZXRMb2NhbE1hdHJpeERpcnR5KCk7XG4gICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIE1lc2ggYWJvdXQgdGhlIGdpdmVuIFdvcmxkLXNwYWNlIGF4aXMgYnkgdGhlIGdpdmVuIGluY3JlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGF4aXMgTG9jYWwgYXhpcyBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIGluY3JlbWVudCBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIHJvdGF0ZU9uV29ybGRBeGlzKGF4aXMsIGFuZ2xlKSB7XG4gICAgICAgIGFuZ2xlQXhpc1swXSA9IGF4aXNbMF07XG4gICAgICAgIGFuZ2xlQXhpc1sxXSA9IGF4aXNbMV07XG4gICAgICAgIGFuZ2xlQXhpc1syXSA9IGF4aXNbMl07XG4gICAgICAgIGFuZ2xlQXhpc1szXSA9IGFuZ2xlICogbWF0aC5ERUdUT1JBRDtcbiAgICAgICAgbWF0aC5hbmdsZUF4aXNUb1F1YXRlcm5pb24oYW5nbGVBeGlzLCBxMSk7XG4gICAgICAgIG1hdGgubXVsUXVhdGVybmlvbnMocTEsIHRoaXMucXVhdGVybmlvbiwgcTEpO1xuICAgICAgICAvL3RoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShxMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIE1lc2ggYWJvdXQgdGhlIGxvY2FsIFgtYXhpcyBieSB0aGUgZ2l2ZW4gaW5jcmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIGluY3JlbWVudCBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIHJvdGF0ZVgoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlKHhBeGlzLCBhbmdsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgTWVzaCBhYm91dCB0aGUgbG9jYWwgWS1heGlzIGJ5IHRoZSBnaXZlbiBpbmNyZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgaW5jcmVtZW50IGluIGRlZ3JlZXMuXG4gICAgICovXG4gICAgcm90YXRlWShhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGUoeUF4aXMsIGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBNZXNoIGFib3V0IHRoZSBsb2NhbCBaLWF4aXMgYnkgdGhlIGdpdmVuIGluY3JlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBBbmdsZSBpbmNyZW1lbnQgaW4gZGVncmVlcy5cbiAgICAgKi9cbiAgICByb3RhdGVaKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZSh6QXhpcywgYW5nbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIE1lc2ggYWxvbmcgbG9jYWwgc3BhY2UgdmVjdG9yIGJ5IHRoZSBnaXZlbiBpbmNyZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBheGlzIE5vcm1hbGl6ZWQgbG9jYWwgc3BhY2UgM0QgdmVjdG9yIGFsb25nIHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgdG8gdHJhbnNsYXRlIGFsb25nICB0aGUgdmVjdG9yLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZShheGlzLCBkaXN0YW5jZSkge1xuICAgICAgICBtYXRoLnZlYzNBcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uLCBheGlzLCB2ZWNhKTtcbiAgICAgICAgbWF0aC5tdWxWZWMzU2NhbGFyKHZlY2EsIGRpc3RhbmNlLCB2ZWNiKTtcbiAgICAgICAgbWF0aC5hZGRWZWMzKHRoaXMucG9zaXRpb24sIHZlY2IsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRMb2NhbE1hdHJpeERpcnR5KCk7XG4gICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIE1lc2ggYWxvbmcgdGhlIGxvY2FsIFgtYXhpcyBieSB0aGUgZ2l2ZW4gaW5jcmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHRvIHRyYW5zbGF0ZSBhbG9uZyAgdGhlIFgtYXhpcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVYKGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh4QXhpcywgZGlzdGFuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIE1lc2ggYWxvbmcgdGhlIGxvY2FsIFktYXhpcyBieSB0aGUgZ2l2ZW4gaW5jcmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHRvIHRyYW5zbGF0ZSBhbG9uZyAgdGhlIFktYXhpcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh5QXhpcywgZGlzdGFuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIE1lc2ggYWxvbmcgdGhlIGxvY2FsIFotYXhpcyBieSB0aGUgZ2l2ZW4gaW5jcmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHRvIHRyYW5zbGF0ZSBhbG9uZyAgdGhlIFotYXhpcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVaKGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh6QXhpcywgZGlzdGFuY2UpO1xuICAgIH1cblxuICAgIF9wdXREcmF3UmVuZGVyZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fZHJhd1JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UmVuZGVyZXIucHV0KCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93UmVuZGVyZXIucHV0KCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0ZpbGxSZW5kZXJlci5wdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIucHV0KCk7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3B1dFBpY2tSZW5kZXJlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9waWNrTWVzaFJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9waWNrTWVzaFJlbmRlcmVyLnB1dCgpO1xuICAgICAgICAgICAgdGhpcy5fcGlja01lc2hSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BpY2tUcmlhbmdsZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9waWNrVHJpYW5nbGVSZW5kZXJlci5wdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BpY2tUcmlhbmdsZVJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wdXRPY2NsdXNpb25SZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX29jY2x1c2lvblJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vY2NsdXNpb25SZW5kZXJlci5wdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29jY2x1c2lvblJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRW50aXR5IG1lbWJlcnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIHRvIGluZGljYXRlIHRoYXQgTWVzaCBpbXBsZW1lbnRzIHtAbGluayBFbnRpdHl9LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzRW50aXR5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGBgYGB0cnVlYGBgYCBpZiB0aGlzIE1lc2ggcmVwcmVzZW50cyBhIG1vZGVsLlxuICAgICAqXG4gICAgICogV2hlbiB0aGlzIHJldHVybnMgYGBgYHRydWVgYGBgLCB0aGUgTWVzaCB3aWxsIGJlIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNtb2RlbHN9IGFuZFxuICAgICAqIG1heSBhbHNvIGhhdmUgYSBjb3JyZXNwb25kaW5nIHtAbGluayBNZXRhTW9kZWx9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzTW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc01vZGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYGBgYHRydWVgYGBgIGlmIHRoaXMgTWVzaCByZXByZXNlbnRzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyByZXR1cm5zIGBgYGB0cnVlYGBgYCwgdGhlIE1lc2ggd2lsbCBiZSByZWdpc3RlcmVkIGJ5IHtAbGluayBNZXNoI2lkfSBpbiB7QGxpbmsgU2NlbmUjb2JqZWN0c30gYW5kXG4gICAgICogbWF5IGFsc28gaGF2ZSBhIGNvcnJlc3BvbmRpbmcge0BsaW5rIE1ldGFPYmplY3R9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTWVzaCdzIFdvcmxkLXNwYWNlIDNEIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRlZCBieSBhIHNpeC1lbGVtZW50IEZsb2F0NjRBcnJheSBjb250YWluaW5nIHRoZSBtaW4vbWF4IGV4dGVudHMgb2YgdGhlXG4gICAgICogYXhpcy1hbGlnbmVkIHZvbHVtZSwgaWUuIGBgYGBbeG1pbiwgeW1pbix6bWluLHhtYXgseW1heCwgem1heF1gYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIGdldCBhYWJiKCkge1xuICAgICAgICBpZiAodGhpcy5fYWFiYkRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FhYmI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2VudGVyIG9mIHRoZSByZWxhdGl2ZS10by1jZW50ZXIgKFJUQykgY29vcmRpbmF0ZSBzeXN0ZW0gZm9yIHRoaXMgTWVzaC5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyBpcyBnaXZlbiwgdGhlbiB7QGxpbmsgTWVzaCNtYXRyaXh9LCB7QGxpbmsgTWVzaCNwb3NpdGlvbn0gYW5kIHtAbGluayBNZXNoI2dlb21ldHJ5fSBhcmUgYWxsIGFzc3VtZWQgdG8gYmUgcmVsYXRpdmUgdG8gdGhpcyBjZW50ZXIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RmxvYXQ2NEFycmF5fVxuICAgICAqL1xuICAgIHNldCBydGNDZW50ZXIocnRjQ2VudGVyKSB7XG4gICAgICAgIGlmIChydGNDZW50ZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhdGUucnRjQ2VudGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUucnRjQ2VudGVyID0gbWF0aC52ZWMzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5ydGNDZW50ZXIuc2V0KHJ0Y0NlbnRlcik7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5ydGNDZW50ZXJIYXNoID0gcnRjQ2VudGVyLmpvaW4oKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fYWFiYkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5ydGNDZW50ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5ydGNDZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnJ0Y0NlbnRlckhhc2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuX2FhYmJEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAzRCBvcmlnaW4gb2YgdGhlIE1lc2gncyB7QGxpbmsgR2VvbWV0cnl9J3MgdmVydGV4IHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyBpcyBkZWZpbmVkLCB0aGVuIHRoZSBwb3NpdGlvbnMgYXJlIFJUQywgd2hpY2ggbWVhbnMgdGhhdCB0aGV5IGFyZSByZWxhdGl2ZSB0byB0aGlzIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge0Zsb2F0NjRBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgcnRjQ2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUucnRjQ2VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoaXMgTWVzaC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG51bVRyaWFuZ2xlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bVRyaWFuZ2xlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoaXMgTWVzaCBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBNZXNoI3Zpc2libGV9IGlzIGBgYGB0cnVlYGBgYCBhbmQge0BsaW5rIE1lc2gjY3VsbGVkfSBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogV2hlbiB7QGxpbmsgTWVzaCNpc09iamVjdH0gYW5kIHtAbGluayBNZXNoI3Zpc2libGV9IGFyZSBib3RoIGBgYGB0cnVlYGBgYCB0aGUgTWVzaCB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgTWVzaCNpZH0gaW4ge0BsaW5rIFNjZW5lI3Zpc2libGVPYmplY3RzfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCB2aXNpYmxlKHZpc2libGUpIHtcbiAgICAgICAgdmlzaWJsZSA9IHZpc2libGUgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLl9vYmplY3RWaXNpYmlsaXR5VXBkYXRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIE1lc2ggaXMgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcmVuZGVyZWQgd2hlbiB7QGxpbmsgTWVzaCN2aXNpYmxlfSBpcyBgYGBgdHJ1ZWBgYGAgYW5kIHtAbGluayBNZXNoI2N1bGxlZH0gaXMgYGBgYGZhbHNlYGBgYC5cbiAgICAgKlxuICAgICAqIFdoZW4ge0BsaW5rIE1lc2gjaXNPYmplY3R9IGFuZCB7QGxpbmsgTWVzaCN2aXNpYmxlfSBhcmUgYm90aCBgYGBgdHJ1ZWBgYGAgdGhlIE1lc2ggd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSN2aXNpYmxlT2JqZWN0c30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggaXMgeHJheWVkLlxuICAgICAqXG4gICAgICogWFJheWVkIGFwcGVhcmFuY2UgaXMgY29uZmlndXJlZCBieSB0aGUge0BsaW5rIEVtcGhhc2lzTWF0ZXJpYWx9IHJlZmVyZW5jZWQgYnkge0BsaW5rIE1lc2gjeHJheU1hdGVyaWFsfS5cbiAgICAgKlxuICAgICAqIFdoZW4ge0BsaW5rIE1lc2gjaXNPYmplY3R9IGFuZCB7QGxpbmsgTWVzaCN4cmF5ZWR9IGFyZSBib3RoIGBgYGB0cnVlYGBgIHRoZSBNZXNoIHdpbGwgYmVcbiAgICAgKiByZWdpc3RlcmVkIGJ5IHtAbGluayBNZXNoI2lkfSBpbiB7QGxpbmsgU2NlbmUjeHJheWVkT2JqZWN0c30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgeHJheWVkKHhyYXllZCkge1xuICAgICAgICB4cmF5ZWQgPSAhIXhyYXllZDtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnhyYXllZCA9PT0geHJheWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUueHJheWVkID0geHJheWVkO1xuICAgICAgICBpZiAodGhpcy5faXNPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX29iamVjdFhSYXllZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBNZXNoIGlzIHhyYXllZC5cbiAgICAgKlxuICAgICAqIFhSYXllZCBhcHBlYXJhbmNlIGlzIGNvbmZpZ3VyZWQgYnkgdGhlIHtAbGluayBFbXBoYXNpc01hdGVyaWFsfSByZWZlcmVuY2VkIGJ5IHtAbGluayBNZXNoI3hyYXlNYXRlcmlhbH0uXG4gICAgICpcbiAgICAgKiBXaGVuIHtAbGluayBNZXNoI2lzT2JqZWN0fSBhbmQge0BsaW5rIE1lc2gjeHJheWVkfSBhcmUgYm90aCBgYGBgdHJ1ZWBgYCB0aGUgTWVzaCB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgTWVzaCNpZH0gaW4ge0BsaW5rIFNjZW5lI3hyYXllZE9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHhyYXllZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnhyYXllZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoaXMgTWVzaCBpcyBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIEhpZ2hsaWdodGVkIGFwcGVhcmFuY2UgaXMgY29uZmlndXJlZCBieSB0aGUge0BsaW5rIEVtcGhhc2lzTWF0ZXJpYWx9IHJlZmVyZW5jZWQgYnkge0BsaW5rIE1lc2gjaGlnaGxpZ2h0TWF0ZXJpYWx9LlxuICAgICAqXG4gICAgICogV2hlbiB7QGxpbmsgTWVzaCNpc09iamVjdH0gYW5kIHtAbGluayBNZXNoI2hpZ2hsaWdodGVkfSBhcmUgYm90aCBgYGBgdHJ1ZWBgYGAgdGhlIE1lc2ggd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNoaWdobGlnaHRlZE9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGhpZ2hsaWdodGVkKGhpZ2hsaWdodGVkKSB7XG4gICAgICAgIGhpZ2hsaWdodGVkID0gISFoaWdobGlnaHRlZDtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVkID09PSB0aGlzLl9zdGF0ZS5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLmhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0ZWQ7XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0SGlnaGxpZ2h0ZWRVcGRhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgTWVzaCBpcyBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIEhpZ2hsaWdodGVkIGFwcGVhcmFuY2UgaXMgY29uZmlndXJlZCBieSB0aGUge0BsaW5rIEVtcGhhc2lzTWF0ZXJpYWx9IHJlZmVyZW5jZWQgYnkge0BsaW5rIE1lc2gjaGlnaGxpZ2h0TWF0ZXJpYWx9LlxuICAgICAqXG4gICAgICogV2hlbiB7QGxpbmsgTWVzaCNpc09iamVjdH0gYW5kIHtAbGluayBNZXNoI2hpZ2hsaWdodGVkfSBhcmUgYm90aCBgYGBgdHJ1ZWBgYGAgdGhlIE1lc2ggd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNoaWdobGlnaHRlZE9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGhpZ2hsaWdodGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBTZWxlY3RlZCBhcHBlYXJhbmNlIGlzIGNvbmZpZ3VyZWQgYnkgdGhlIHtAbGluayBFbXBoYXNpc01hdGVyaWFsfSByZWZlcmVuY2VkIGJ5IHtAbGluayBNZXNoI3NlbGVjdGVkTWF0ZXJpYWx9LlxuICAgICAqXG4gICAgICogV2hlbiB7QGxpbmsgTWVzaCNpc09iamVjdH0gYW5kIHtAbGluayBNZXNoI3NlbGVjdGVkfSBhcmUgYm90aCBgYGBgdHJ1ZWBgYCB0aGUgTWVzaCB3aWxsIGJlXG4gICAgICogcmVnaXN0ZXJlZCBieSB7QGxpbmsgTWVzaCNpZH0gaW4ge0BsaW5rIFNjZW5lI3NlbGVjdGVkT2JqZWN0c30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAhIXNlbGVjdGVkO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRoaXMuX3N0YXRlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLl9vYmplY3RTZWxlY3RlZFVwZGF0ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBNZXNoIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogU2VsZWN0ZWQgYXBwZWFyYW5jZSBpcyBjb25maWd1cmVkIGJ5IHRoZSB7QGxpbmsgRW1waGFzaXNNYXRlcmlhbH0gcmVmZXJlbmNlZCBieSB7QGxpbmsgTWVzaCNzZWxlY3RlZE1hdGVyaWFsfS5cbiAgICAgKlxuICAgICAqIFdoZW4ge0BsaW5rIE1lc2gjaXNPYmplY3R9IGFuZCB7QGxpbmsgTWVzaCNzZWxlY3RlZH0gYXJlIGJvdGggYGBgYHRydWVgYGAgdGhlIE1lc2ggd2lsbCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgYnkge0BsaW5rIE1lc2gjaWR9IGluIHtAbGluayBTY2VuZSNzZWxlY3RlZE9iamVjdHN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggaXMgZWRnZS1lbmhhbmNlZC5cbiAgICAgKlxuICAgICAqIEVkZ2UgYXBwZWFyYW5jZSBpcyBjb25maWd1cmVkIGJ5IHRoZSB7QGxpbmsgRWRnZU1hdGVyaWFsfSByZWZlcmVuY2VkIGJ5IHtAbGluayBNZXNoI2VkZ2VNYXRlcmlhbH0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgZWRnZXMoZWRnZXMpIHtcbiAgICAgICAgZWRnZXMgPSAhIWVkZ2VzO1xuICAgICAgICBpZiAoZWRnZXMgPT09IHRoaXMuX3N0YXRlLmVkZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuZWRnZXMgPSBlZGdlcztcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBNZXNoIGlzIGVkZ2UtZW5oYW5jZWQuXG4gICAgICpcbiAgICAgKiBFZGdlIGFwcGVhcmFuY2UgaXMgY29uZmlndXJlZCBieSB0aGUge0BsaW5rIEVkZ2VNYXRlcmlhbH0gcmVmZXJlbmNlZCBieSB7QGxpbmsgTWVzaCNlZGdlTWF0ZXJpYWx9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGVkZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZWRnZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggaXMgY3VsbGVkLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBNZXNoI3Zpc2libGV9IGlzIGBgYGB0cnVlYGBgYCBhbmQge0BsaW5rIE1lc2gjY3VsbGVkfSBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGN1bGxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5jdWxsZWQgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIE1lc2ggaXMgY3VsbGVkLlxuICAgICAqXG4gICAgICogT25seSByZW5kZXJlZCB3aGVuIHtAbGluayBNZXNoI3Zpc2libGV9IGlzIGBgYGB0cnVlYGBgYCBhbmQge0BsaW5rIE1lc2gjY3VsbGVkfSBpcyBgYGBgZmFsc2VgYGBgLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGN1bGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1bGxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoaXMgTWVzaCBpcyBjbGlwcGFibGUuXG4gICAgICpcbiAgICAgKiBDbGlwcGluZyBpcyBkb25lIGJ5IHRoZSB7QGxpbmsgU2VjdGlvblBsYW5lfXMgaW4ge0BsaW5rIFNjZW5lI3NlY3Rpb25QbGFuZXN9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGNsaXBwYWJsZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmNsaXBwYWJsZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5jbGlwcGFibGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhpcyBNZXNoIGlzIGNsaXBwYWJsZS5cbiAgICAgKlxuICAgICAqIENsaXBwaW5nIGlzIGRvbmUgYnkgdGhlIHtAbGluayBTZWN0aW9uUGxhbmV9cyBpbiB7QGxpbmsgU2NlbmUjc2VjdGlvblBsYW5lc30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2xpcHBhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY2xpcHBhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhpcyBNZXNoIGluY2x1ZGVkIGluIGJvdW5kYXJ5IGNhbGN1bGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBjb2xsaWRhYmxlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgIT09IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuX3N0YXRlLmNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5jb2xsaWRhYmxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NldEFBQkJEaXJ0eSgpO1xuICAgICAgICB0aGlzLnNjZW5lLl9hYWJiRGlydHkgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIE1lc2ggaW5jbHVkZWQgaW4gYm91bmRhcnkgY2FsY3VsYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbGxpZGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5jb2xsaWRhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaWYgdGhpcyBNZXNoIGlzIHBpY2thYmxlLlxuICAgICAqXG4gICAgICogUGlja2luZyBpcyBkb25lIHZpYSBjYWxscyB0byB7QGxpbmsgU2NlbmUjcGlja30uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgcGlja2FibGUodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5waWNrYWJsZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5waWNrYWJsZSA9IHZhbHVlO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHRyaWdnZXIgYSByZW5kZXI7XG4gICAgICAgIC8vIHN0YXRlIGlzIG9ubHkgdXNlZCB3aGVuIHBpY2tpbmdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgTWVzaCBpcyBwaWNrYWJsZS5cbiAgICAgKlxuICAgICAqIFBpY2tpbmcgaXMgZG9uZSB2aWEgY2FsbHMgdG8ge0BsaW5rIFNjZW5lI3BpY2t9LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHBpY2thYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUucGlja2FibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggY2FzdHMgc2hhZG93cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBjYXN0c1NoYWRvdyh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9zdGF0ZS5jYXN0c1NoYWRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLmNhc3RzU2hhZG93ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgTWVzaCBjYXN0cyBzaGFkb3dzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhc3RzU2hhZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY2FzdHNTaGFkb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpZiB0aGlzIE1lc2ggY2FuIGhhdmUgc2hhZG93cyBjYXN0IHVwb24gaXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgcmVjZWl2ZXNTaGFkb3codmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fc3RhdGUucmVjZWl2ZXNTaGFkb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5yZWNlaXZlc1NoYWRvdyA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5oYXNoID0gdmFsdWUgPyBcIi9tb2QvcnM7XCIgOiBcIi9tb2Q7XCI7XG4gICAgICAgIHRoaXMuZmlyZShcImRpcnR5XCIsIHRoaXMpOyAvLyBOb3cgbmVlZCB0byAocmUpY29tcGlsZSBvYmplY3RSZW5kZXJlcnMgdG8gaW5jbHVkZS9leGNsdWRlIHNoYWRvdyBtYXBwaW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIE1lc2ggY2FuIGhhdmUgc2hhZG93cyBjYXN0IHVwb24gaXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgcmVjZWl2ZXNTaGFkb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5yZWNlaXZlc1NoYWRvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoaXMgTWVzaCBjYW4gaGF2ZSBTY2FsYWJsZSBBbWJpZW50IE9ic2N1cmFuY2UgKFNBTykgYXBwbGllZCB0byBpdC5cbiAgICAgKlxuICAgICAqIFNBTyBpcyBjb25maWd1cmVkIGJ5IHtAbGluayBTQU99LlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZ2V0IHNhb0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVE9ETzogU3VwcG9ydCBTQU8gb24gTWVzaGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUkdCIGNvbG9yaXplIGNvbG9yIGZvciB0aGlzIE1lc2guXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHJlbmRlcmVkIGZyYWdtZW50IGNvbG9ycy5cbiAgICAgKlxuICAgICAqIEVhY2ggZWxlbWVudCBvZiB0aGUgY29sb3IgaXMgaW4gcmFuZ2UgYGBgYFswLi4xXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgc2V0IGNvbG9yaXplKHZhbHVlKSB7XG4gICAgICAgIGxldCBjb2xvcml6ZSA9IHRoaXMuX3N0YXRlLmNvbG9yaXplO1xuICAgICAgICBpZiAoIWNvbG9yaXplKSB7XG4gICAgICAgICAgICBjb2xvcml6ZSA9IHRoaXMuX3N0YXRlLmNvbG9yaXplID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgIGNvbG9yaXplWzNdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbG9yaXplWzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICBjb2xvcml6ZVsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgY29sb3JpemVbMl0gPSB2YWx1ZVsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yaXplWzBdID0gMTtcbiAgICAgICAgICAgIGNvbG9yaXplWzFdID0gMTtcbiAgICAgICAgICAgIGNvbG9yaXplWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvcml6ZWQgPSAoISF2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuX29iamVjdENvbG9yaXplVXBkYXRlZCh0aGlzLCBjb2xvcml6ZWQpO1xuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUkdCIGNvbG9yaXplIGNvbG9yIGZvciB0aGlzIE1lc2guXG4gICAgICpcbiAgICAgKiBNdWx0aXBsaWVzIGJ5IHJlbmRlcmVkIGZyYWdtZW50IGNvbG9ycy5cbiAgICAgKlxuICAgICAqIEVhY2ggZWxlbWVudCBvZiB0aGUgY29sb3IgaXMgaW4gcmFuZ2UgYGBgYFswLi4xXWBgYGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGNvbG9yaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY29sb3JpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSBmYWN0b3IgZm9yIHRoaXMgTWVzaC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3IgaW4gcmFuZ2UgYGBgYFswLi4xXWBgYGAgd2hpY2ggbXVsdGlwbGllcyBieSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgYWxwaGFzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgb3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICAgIGxldCBjb2xvcml6ZSA9IHRoaXMuX3N0YXRlLmNvbG9yaXplO1xuICAgICAgICBpZiAoIWNvbG9yaXplKSB7XG4gICAgICAgICAgICBjb2xvcml6ZSA9IHRoaXMuX3N0YXRlLmNvbG9yaXplID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgIGNvbG9yaXplWzBdID0gMTtcbiAgICAgICAgICAgIGNvbG9yaXplWzFdID0gMTtcbiAgICAgICAgICAgIGNvbG9yaXplWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcGFjaXR5VXBkYXRlZCA9IChvcGFjaXR5ICE9PSBudWxsICYmIG9wYWNpdHkgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbG9yaXplWzNdID0gb3BhY2l0eVVwZGF0ZWQgPyBvcGFjaXR5IDogMS4wO1xuICAgICAgICB0aGlzLnNjZW5lLl9vYmplY3RPcGFjaXR5VXBkYXRlZCh0aGlzLCBvcGFjaXR5VXBkYXRlZCk7XG4gICAgICAgIHRoaXMuZ2xSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IGZhY3RvciBmb3IgdGhpcyBNZXNoLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvciBpbiByYW5nZSBgYGBgWzAuLjFdYGBgYCB3aGljaCBtdWx0aXBsaWVzIGJ5IHRoZSByZW5kZXJlZCBmcmFnbWVudCBhbHBoYXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBvcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY29sb3JpemVbM107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpZiB0aGlzIE1lc2ggaXMgdHJhbnNwYXJlbnQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHRyYW5zcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWwuYWxwaGFNb2RlID09PSAyIC8qIGJsZW5kICovIHx8IHRoaXMuX3N0YXRlLmNvbG9yaXplWzNdIDwgMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1lc2gncyByZW5kZXJpbmcgb3JkZXIgcmVsYXRpdmUgdG8gb3RoZXIgTWVzaGVzLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgYGBgMGBgYGAuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgdHJhbnNwYXJlbnQgTWVzaGVzLCB0byBtYWtlIHRoZW0gcmVuZGVyIGluIGEgc3BlY2lmaWMgb3JkZXIgZm9yIGNvcnJlY3QgYWxwaGEgYmxlbmRpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBsYXllcih2YWx1ZSkge1xuICAgICAgICAvLyBUT0RPOiBPbmx5IGFjY2VwdCByZW5kZXJpbmcgbGF5ZXIgaW4gcmFuZ2UgWzAuLi5NQVhfbGF5ZXJdXG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgMDtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9zdGF0ZS5sYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLmxheWVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm5lZWRTdGF0ZVNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBNZXNoJ3MgcmVuZGVyaW5nIG9yZGVyIHJlbGF0aXZlIHRvIG90aGVyIE1lc2hlcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGBgYDBgYGBgLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHRyYW5zcGFyZW50IE1lc2hlcywgdG8gbWFrZSB0aGVtIHJlbmRlciBpbiBhIHNwZWNpZmljIG9yZGVyIGZvciBjb3JyZWN0IGFscGhhIGJsZW5kaW5nLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5sYXllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoZSBOb2RlJ3MgcG9zaXRpb24gaXMgc3RhdGlvbmFyeS5cbiAgICAgKlxuICAgICAqIFdoZW4gdHJ1ZSwgd2lsbCBkaXNhYmxlIHRoZSBlZmZlY3Qgb2Yge0BsaW5rIENhbWVyYX0gdHJhbnNsYXRpb25zIGZvciB0aGlzIE1lc2gsIHdoaWxlIHN0aWxsIGFsbG93aW5nIGl0IHRvIHJvdGF0ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIHNreWJveGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHN0YXRpb25hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5zdGF0aW9uYXJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE5vZGUncyBiaWxsYm9hcmRpbmcgYmVoYXZpb3VyLlxuICAgICAqXG4gICAgICogT3B0aW9ucyBhcmU6XG4gICAgICogKiBgYGBgXCJub25lXCJgYGBgIC0gIChkZWZhdWx0KSAtIE5vIGJpbGxib2FyZGluZy5cbiAgICAgKiAqIGBgYGBcInNwaGVyaWNhbFwiYGBgYCAtIE1lc2ggaXMgYmlsbGJvYXJkZWQgdG8gZmFjZSB0aGUgdmlld3BvaW50LCByb3RhdGluZyBib3RoIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseS5cbiAgICAgKiAqIGBgYGBcImN5bGluZHJpY2FsXCJgYGBgIC0gTWVzaCBpcyBiaWxsYm9hcmRlZCB0byBmYWNlIHRoZSB2aWV3cG9pbnQsIHJvdGF0aW5nIG9ubHkgYWJvdXQgaXRzIHZlcnRpY2FsbHkgYXhpcy4gVXNlIHRoaXMgbW9kZSBmb3IgdGhpbmdzIGxpa2UgdHJlZXMgb24gYSBsYW5kc2NhcGUuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYmlsbGJvYXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYmlsbGJvYXJkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1lc2gncyAzRCBXb3JsZC1zcGFjZSBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBUaGUgb2Zmc2V0IGR5bmFtaWNhbGx5IHRyYW5zbGF0ZXMgdGhlIE1lc2ggaW4gV29ybGQtc3BhY2UuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGBbMCwgMCwgMF1gYGBgLlxuICAgICAqXG4gICAgICogUHJvdmlkZSBhIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlIHRvIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAqL1xuICAgIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUub2Zmc2V0LnNldCh2YWx1ZSB8fCBbMCwgMCwgMF0pO1xuICAgICAgICB0aGlzLl9zZXRBQUJCRGlydHkoKTtcbiAgICAgICAgdGhpcy5nbFJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE1lc2gncyAzRCBXb3JsZC1zcGFjZSBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBgYGBbMCwwLDBdYGBgYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUub2Zmc2V0O1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRHJhd2FibGUgbWVtYmVyc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBNZXNoIGltcGxlbWVudHMge0BsaW5rIERyYXdhYmxlfS5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNEcmF3YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgd2l0aCBmaW5hbCB2YWx1ZSBgYGBgdHJ1ZWBgYGAgdG8gaW5kaWNhdGUgdGhhdCB4ZW9raXQgc2hvdWxkIHJlbmRlciB0aGlzIE1lc2ggaW4gc29ydGVkIG9yZGVyLCByZWxhdGl2ZSB0byBvdGhlciBNZXNoZXMuXG4gICAgICpcbiAgICAgKiBUaGUgc29ydCBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5IHtAbGluayBNZXNoI3N0YXRlU29ydENvbXBhcmV9LlxuICAgICAqXG4gICAgICogU29ydGluZyBpcyBlc3NlbnRpYWwgZm9yIHJlbmRlcmluZyBwZXJmb3JtYW5jZSwgc28gdGhhdCB4ZW9raXQgaXMgYWJsZSB0byBhdm9pZCBhcHBseWluZyBydW5zIG9mIHRoZSBzYW1lIHN0YXRlIGNoYW5nZXMgdG8gdGhlIEdQVSwgaWUuIGNhbiBjb2xsYXBzZSB0aGVtLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzU3RhdGVTb3J0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyaXNvbiBmdW5jdGlvbiB1c2VkIGJ5IHRoZSByZW5kZXJlciB0byBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHhlb2tpdCBzaG91bGQgcmVuZGVyIHRoZSBNZXNoLCByZWxhdGl2ZSB0byB0byBvdGhlciBNZXNoZXMuXG4gICAgICpcbiAgICAgKiB4ZW9raXQgcmVxdWlyZXMgdGhpcyBtZXRob2QgYmVjYXVzZSBNZXNoIGltcGxlbWVudHMge0BsaW5rIERyYXdhYmxlfS5cbiAgICAgKlxuICAgICAqIFNvcnRpbmcgaXMgZXNzZW50aWFsIGZvciByZW5kZXJpbmcgcGVyZm9ybWFuY2UsIHNvIHRoYXQgeGVva2l0IGlzIGFibGUgdG8gYXZvaWQgbmVlZGxlc3NseSBhcHBseWluZyBydW5zIG9mIHRoZSBzYW1lIHJlbmRlcmluZyBzdGF0ZSBjaGFuZ2VzIHRvIHRoZSBHUFUsIGllLiBjYW4gY29sbGFwc2UgdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWVzaH0gbWVzaDFcbiAgICAgKiBAcGFyYW0ge01lc2h9IG1lc2gyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0ZVNvcnRDb21wYXJlKG1lc2gxLCBtZXNoMikge1xuICAgICAgICByZXR1cm4gKG1lc2gxLl9zdGF0ZS5sYXllciAtIG1lc2gyLl9zdGF0ZS5sYXllcilcbiAgICAgICAgICAgIHx8IChtZXNoMS5fZHJhd1JlbmRlcmVyLmlkIC0gbWVzaDIuX2RyYXdSZW5kZXJlci5pZCkgLy8gUHJvZ3JhbSBzdGF0ZVxuICAgICAgICAgICAgfHwgKG1lc2gxLl9tYXRlcmlhbC5fc3RhdGUuaWQgLSBtZXNoMi5fbWF0ZXJpYWwuX3N0YXRlLmlkKSAvLyBNYXRlcmlhbCBzdGF0ZVxuICAgICAgICAgICAgfHwgKG1lc2gxLl9nZW9tZXRyeS5fc3RhdGUuaWQgLSBtZXNoMi5fZ2VvbWV0cnkuX3N0YXRlLmlkKTsgLy8gR2VvbWV0cnkgc3RhdGVcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICByZWJ1aWxkUmVuZGVyRmxhZ3MoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRmxhZ3MucmVzZXQoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRBY3RpdmVTZWN0aW9uUGxhbmVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MuY3VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckZsYWdzLm51bUxheWVycyA9IDE7XG4gICAgICAgIHRoaXMucmVuZGVyRmxhZ3MubnVtVmlzaWJsZUxheWVycyA9IDE7XG4gICAgICAgIHRoaXMucmVuZGVyRmxhZ3MudmlzaWJsZUxheWVyc1swXSA9IDA7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlbmRlckZsYWdzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUmVuZGVyRmxhZ3MoKSB7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyRmxhZ3MgPSB0aGlzLnJlbmRlckZsYWdzO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZS54cmF5ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHhyYXlNYXRlcmlhbCA9IHRoaXMuX3hyYXlNYXRlcmlhbC5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoeHJheU1hdGVyaWFsLmZpbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoeHJheU1hdGVyaWFsLmZpbGxBbHBoYSA8IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJGbGFncy54cmF5ZWRTaWxob3VldHRlVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLnhyYXllZFNpbGhvdWV0dGVPcGFxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4cmF5TWF0ZXJpYWwuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoeHJheU1hdGVyaWFsLmVkZ2VBbHBoYSA8IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJGbGFncy54cmF5ZWRFZGdlc1RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJGbGFncy54cmF5ZWRFZGdlc09wYXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsTWF0ZXJpYWwgPSB0aGlzLl9tYXRlcmlhbC5fc3RhdGU7XG4gICAgICAgICAgICBpZiAobm9ybWFsTWF0ZXJpYWwuYWxwaGEgPCAxLjAgfHwgc3RhdGUuY29sb3JpemVbM10gPCAxLjApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJGbGFncy5jb2xvclRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3MuY29sb3JPcGFxdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZU1hdGVyaWFsID0gdGhpcy5fZWRnZU1hdGVyaWFsLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZU1hdGVyaWFsLmFscGhhIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLmVkZ2VzVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLmVkZ2VzT3BhcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZE1hdGVyaWFsID0gdGhpcy5fc2VsZWN0ZWRNYXRlcmlhbC5fc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWF0ZXJpYWwuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRNYXRlcmlhbC5maWxsQWxwaGEgPCAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLnNlbGVjdGVkU2lsaG91ZXR0ZVRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLnNlbGVjdGVkU2lsaG91ZXR0ZU9wYXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWF0ZXJpYWwuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWF0ZXJpYWwuZWRnZUFscGhhIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJGbGFncy5zZWxlY3RlZEVkZ2VzVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3Muc2VsZWN0ZWRFZGdlc09wYXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0TWF0ZXJpYWwgPSB0aGlzLl9oaWdobGlnaHRNYXRlcmlhbC5fc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodE1hdGVyaWFsLmZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodE1hdGVyaWFsLmZpbGxBbHBoYSA8IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3MuaGlnaGxpZ2h0ZWRTaWxob3VldHRlVHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3MuaGlnaGxpZ2h0ZWRTaWxob3VldHRlT3BhcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0TWF0ZXJpYWwuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodE1hdGVyaWFsLmVkZ2VBbHBoYSA8IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3MuaGlnaGxpZ2h0ZWRFZGdlc1RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLmhpZ2hsaWdodGVkRWRnZXNPcGFxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEFjdGl2ZVNlY3Rpb25QbGFuZXMoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmNsaXBwYWJsZSkge1xuXG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmVzID0gdGhpcy5zY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXM7XG4gICAgICAgICAgICBjb25zdCBudW1TZWN0aW9uUGxhbmVzID0gc2VjdGlvblBsYW5lcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChudW1TZWN0aW9uUGxhbmVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2VjdGlvblBsYW5lczsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lID0gc2VjdGlvblBsYW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyRmxhZ3MgPSB0aGlzLnJlbmRlckZsYWdzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VjdGlvblBsYW5lLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3Muc2VjdGlvblBsYW5lc0FjdGl2ZVBlckxheWVyW2ldID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnJ0Y0NlbnRlcikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gbWF0aC5wbGFuZUFBQkIzSW50ZXJzZWN0KHNlY3Rpb25QbGFuZS5kaXIsIHNlY3Rpb25QbGFuZS5kaXN0LCB0aGlzLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHNpZGUgPSAoaW50ZXJzZWN0ID09PSAtMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW5nID0gKGludGVyc2VjdCA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmxhZ3Muc2VjdGlvblBsYW5lc0FjdGl2ZVBlckxheWVyW2ldID0gaW50ZXJzZWN0aW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckZsYWdzLnNlY3Rpb25QbGFuZXNBY3RpdmVQZXJMYXllcltpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBhcHBlYXJhbmNlIG9mIHRoaXMgTWVzaCB3aGVuIHhyYXllZC5cbiAgICAgKlxuICAgICAqIE1lc2ggaXMgeHJheWVkIHdoZW4ge0BsaW5rIE1lc2gjeHJheWVkfSBpcyBgYGBgdHJ1ZWBgYGAuXG4gICAgICpcbiAgICAgKiBTZXQgdG8ge0BsaW5rIFNjZW5lI3hyYXlNYXRlcmlhbH0gYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFbXBoYXNpc01hdGVyaWFsfVxuICAgICAqL1xuICAgIGdldCB4cmF5TWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94cmF5TWF0ZXJpYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgYXBwZWFyYW5jZSBvZiB0aGlzIE1lc2ggd2hlbiBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIE1lc2ggaXMgeHJheWVkIHdoZW4ge0BsaW5rIE1lc2gjaGlnaGxpZ2h0ZWR9IGlzIGBgYGB0cnVlYGBgYC5cbiAgICAgKlxuICAgICAqIFNldCB0byB7QGxpbmsgU2NlbmUjaGlnaGxpZ2h0TWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RW1waGFzaXNNYXRlcmlhbH1cbiAgICAgKi9cbiAgICBnZXQgaGlnaGxpZ2h0TWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRNYXRlcmlhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBhcHBlYXJhbmNlIG9mIHRoaXMgTWVzaCB3aGVuIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogTWVzaCBpcyB4cmF5ZWQgd2hlbiB7QGxpbmsgTWVzaCNzZWxlY3RlZH0gaXMgYGBgYHRydWVgYGBgLlxuICAgICAqXG4gICAgICogU2V0IHRvIHtAbGluayBTY2VuZSNzZWxlY3RlZE1hdGVyaWFsfSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHR5cGUge0VtcGhhc2lzTWF0ZXJpYWx9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkTWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE1hdGVyaWFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGFwcGVhcmFuY2Ugb2YgdGhpcyBNZXNoIHdoZW4gZWRnZXMgYXJlIGVuaGFuY2VkLlxuICAgICAqXG4gICAgICogTWVzaCBpcyB4cmF5ZWQgd2hlbiB7QGxpbmsgTWVzaCNlZGdlc30gaXMgYGBgYHRydWVgYGBgLlxuICAgICAqXG4gICAgICogU2V0IHRvIHtAbGluayBTY2VuZSNlZGdlTWF0ZXJpYWx9IGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWRnZU1hdGVyaWFsfVxuICAgICAqL1xuICAgIGdldCBlZGdlTWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGdlTWF0ZXJpYWw7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBOT1JNQUwgUkVOREVSSU5HIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKiogQHByaXZhdGUgICovXG4gICAgZHJhd0NvbG9yT3BhcXVlKGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmF3UmVuZGVyZXIgfHwgKHRoaXMuX2RyYXdSZW5kZXJlciA9IERyYXdSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdDb2xvclRyYW5zcGFyZW50KGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmF3UmVuZGVyZXIgfHwgKHRoaXMuX2RyYXdSZW5kZXJlciA9IERyYXdSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkcgU0FPIFBPU1QgRUZGRUNUIFRBUkdFVFMgLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFRPRE9cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU1QSEFTSVMgUkVOREVSSU5HIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKiogQHByaXZhdGUgICovXG4gICAgZHJhd1NpbGhvdWV0dGVYUmF5ZWQoZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyIHx8ICh0aGlzLl9lbXBoYXNpc0ZpbGxSZW5kZXJlciA9IEVtcGhhc2lzRmlsbFJlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyLmRyYXdNZXNoKGZyYW1lQ3R4LCB0aGlzLCAwKTsgLy8gMCA9PSB4cmF5XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgICovXG4gICAgZHJhd1NpbGhvdWV0dGVIaWdobGlnaHRlZChmcmFtZUN0eCkge1xuICAgICAgICBpZiAodGhpcy5fZW1waGFzaXNGaWxsUmVuZGVyZXIgfHwgKHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyID0gRW1waGFzaXNGaWxsUmVuZGVyZXIuZ2V0KHRoaXMpKSkge1xuICAgICAgICAgICAgdGhpcy5fZW1waGFzaXNGaWxsUmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMsIDEpOyAvLyAxID09IGhpZ2hsaWdodFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdTaWxob3VldHRlU2VsZWN0ZWQoZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyIHx8ICh0aGlzLl9lbXBoYXNpc0ZpbGxSZW5kZXJlciA9IEVtcGhhc2lzRmlsbFJlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRmlsbFJlbmRlcmVyLmRyYXdNZXNoKGZyYW1lQ3R4LCB0aGlzLCAyKTsgLy8gMiA9PSBzZWxlY3RlZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFREdFUyBSRU5ERVJJTkcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKiBAcHJpdmF0ZSAgKi9cbiAgICBkcmF3RWRnZXNDb2xvck9wYXF1ZShmcmFtZUN0eCkge1xuICAgICAgICBpZiAodGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyIHx8ICh0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIgPSBFbXBoYXNpc0VkZ2VzUmVuZGVyZXIuZ2V0KHRoaXMpKSkge1xuICAgICAgICAgICAgdGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyLmRyYXdNZXNoKGZyYW1lQ3R4LCB0aGlzLCAzKTsgLy8gMyA9PSBlZGdlc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdFZGdlc0NvbG9yVHJhbnNwYXJlbnQoZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlciB8fCAodGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyID0gRW1waGFzaXNFZGdlc1JlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlci5kcmF3TWVzaChmcmFtZUN0eCwgdGhpcywgMyk7IC8vIDMgPT0gZWRnZXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAgKi9cbiAgICBkcmF3RWRnZXNYUmF5ZWQoZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlciB8fCAodGhpcy5fZW1waGFzaXNFZGdlc1JlbmRlcmVyID0gRW1waGFzaXNFZGdlc1JlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlci5kcmF3TWVzaChmcmFtZUN0eCwgdGhpcywgMCk7IC8vIDAgPT0geHJheVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdFZGdlc0hpZ2hsaWdodGVkKGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIgfHwgKHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlciA9IEVtcGhhc2lzRWRnZXNSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMsIDEpOyAvLyAxID09IGhpZ2hsaWdodFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdFZGdlc1NlbGVjdGVkKGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIgfHwgKHRoaXMuX2VtcGhhc2lzRWRnZXNSZW5kZXJlciA9IEVtcGhhc2lzRWRnZXNSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbXBoYXNpc0VkZ2VzUmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMsIDIpOyAvLyAyID09IHNlbGVjdGVkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE9DQ0xVU0lPTiBDVUxMIFJFTkRFUklORyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdPY2NsdXNpb24oZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29jY2x1c2lvblJlbmRlcmVyIHx8ICh0aGlzLl9vY2NsdXNpb25SZW5kZXJlciA9IE9jY2x1c2lvblJlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX29jY2x1c2lvblJlbmRlcmVyLmRyYXdNZXNoKGZyYW1lQ3R4LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU0hBRE9XIEJVRkZFUiBSRU5ERVJJTkcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKiBAcHJpdmF0ZSAgKi9cbiAgICBkcmF3U2hhZG93KGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dSZW5kZXJlciB8fCAodGhpcy5fc2hhZG93UmVuZGVyZXIgPSBTaGFkb3dSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dSZW5kZXJlci5kcmF3TWVzaChmcmFtZUN0eCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBJQ0tJTkcgUkVOREVSSU5HIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKiBAcHJpdmF0ZSAgKi9cbiAgICBkcmF3UGlja01lc2goZnJhbWVDdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BpY2tNZXNoUmVuZGVyZXIgfHwgKHRoaXMuX3BpY2tNZXNoUmVuZGVyZXIgPSBQaWNrTWVzaFJlbmRlcmVyLmdldCh0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpY2tNZXNoUmVuZGVyZXIuZHJhd01lc2goZnJhbWVDdHgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FuUGlja1RyaWFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkuaXNSZWFkYWJsZUdlb21ldHJ5OyAvLyBWQk9HZW9tZXRyeSBkb2VzIG5vdCBzdXBwb3J0IHN1cmZhY2UgcGlja2luZyBiZWNhdXNlIGl0IGhhcyBubyBnZW9tZXRyeSBkYXRhIGluIGJyb3dzZXIgbWVtb3J5XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdQaWNrVHJpYW5nbGVzKGZyYW1lQ3R4KSB7XG4gICAgICAgIGlmICh0aGlzLl9waWNrVHJpYW5nbGVSZW5kZXJlciB8fCAodGhpcy5fcGlja1RyaWFuZ2xlUmVuZGVyZXIgPSBQaWNrVHJpYW5nbGVSZW5kZXJlci5nZXQodGhpcykpKSB7XG4gICAgICAgICAgICB0aGlzLl9waWNrVHJpYW5nbGVSZW5kZXJlci5kcmF3TWVzaChmcmFtZUN0eCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBwaWNrVHJpYW5nbGVTdXJmYWNlKHBpY2tWaWV3TWF0cml4LCBwaWNrUHJvak1hdHJpeCwgcGlja1Jlc3VsdCkge1xuICAgICAgICBwaWNrVHJpYW5nbGVTdXJmYWNlKHRoaXMsIHBpY2tWaWV3TWF0cml4LCBwaWNrUHJvak1hdHJpeCwgcGlja1Jlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICAqL1xuICAgIGRyYXdQaWNrVmVydGljZXMoZnJhbWVDdHgpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1BlcmZvcm1hbmNlTm9kZX1cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZVBpY2tlZEVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21wb25lbnQgbWVtYmVyc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIE1lc2guXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpOyAvLyB4ZW9raXQuT2JqZWN0XG4gICAgICAgIHRoaXMuX3B1dERyYXdSZW5kZXJlcnMoKTtcbiAgICAgICAgdGhpcy5fcHV0UGlja1JlbmRlcmVycygpO1xuICAgICAgICB0aGlzLl9wdXRPY2NsdXNpb25SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnNjZW5lLl9yZW5kZXJlci5wdXRQaWNrSUQodGhpcy5fc3RhdGUucGlja0lEKTsgLy8gVE9ETzogc29tZWhvdyBwdWNoIHRoaXMgZG93biBpbnRvIHhlb2tpdCBmcmFtZXdvcms/XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fZGVyZWdpc3Rlck9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0VmlzaWJpbGl0eVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3hyYXllZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuX29iamVjdFhSYXllZFVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0U2VsZWN0ZWRVcGRhdGVkKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuX29iamVjdEhpZ2hsaWdodGVkVXBkYXRlZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLl9vYmplY3RDb2xvcml6ZVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T3BhY2l0eVVwZGF0ZWQodGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5fb2JqZWN0T2Zmc2V0VXBkYXRlZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuX2RlcmVnaXN0ZXJNb2RlbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsUmVkcmF3KCk7XG4gICAgfVxuXG59XG5cblxuY29uc3QgcGlja1RyaWFuZ2xlU3VyZmFjZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBDYWNoZWQgdmFycyB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb25cblxuICAgIGNvbnN0IGxvY2FsUmF5T3JpZ2luID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgbG9jYWxSYXlEaXIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBwb3NpdGlvbkEgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBwb3NpdGlvbkIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBwb3NpdGlvbkMgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0cmlhbmdsZVZlcnRpY2VzID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYXRoLnZlYzQoKTtcbiAgICBjb25zdCB3b3JsZFBvcyA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IHZpZXdQb3MgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBiYXJ5ID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3Qgbm9ybWFsQSA9IG1hdGgudmVjMygpO1xuICAgIGNvbnN0IG5vcm1hbEIgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCBub3JtYWxDID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgdXZhID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgdXZiID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgdXZjID0gbWF0aC52ZWMzKCk7XG4gICAgY29uc3QgdGVtcFZlYzRhID0gbWF0aC52ZWM0KCk7XG4gICAgY29uc3QgdGVtcFZlYzRiID0gbWF0aC52ZWM0KCk7XG4gICAgY29uc3QgdGVtcFZlYzRjID0gbWF0aC52ZWM0KCk7XG4gICAgY29uc3QgdGVtcFZlYzMgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2IgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2MgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2QgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2UgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2YgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2cgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2ggPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2kgPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2ogPSBtYXRoLnZlYzMoKTtcbiAgICBjb25zdCB0ZW1wVmVjM2sgPSBtYXRoLnZlYzMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAobWVzaCwgcGlja1ZpZXdNYXRyaXgsIHBpY2tQcm9qTWF0cml4LCBwaWNrUmVzdWx0KSB7XG5cbiAgICAgICAgdmFyIHByaW1JbmRleCA9IHBpY2tSZXN1bHQucHJpbUluZGV4O1xuXG4gICAgICAgIGlmIChwcmltSW5kZXggIT09IHVuZGVmaW5lZCAmJiBwcmltSW5kZXggIT09IG51bGwgJiYgcHJpbUluZGV4ID4gLTEpIHtcblxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5Ll9zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmNhbWVyYTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHNjZW5lLmNhbnZhcztcblxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnByaW1pdGl2ZU5hbWUgPT09IFwidHJpYW5nbGVzXCIpIHtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlIHBpY2tlZDsgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBNZXNoIGhhcyBhIEdlb21ldHJ5IHRoYXQgaGFzIHByaW1pdGl2ZXMgb2YgdHlwZSBcInRyaWFuZ2xlXCJcblxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQucHJpbWl0aXZlID0gXCJ0cmlhbmdsZVwiO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBXb3JsZC1zcGFjZSBwb3NpdGlvbnMgb2YgdGhlIHRyaWFuZ2xlJ3MgdmVydGljZXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBwcmltSW5kZXg7IC8vIEluZGljYXRlcyB0aGUgZmlyc3QgdHJpYW5nbGUgaW5kZXggaW4gdGhlIGluZGljZXMgYXJyYXlcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5pbmRpY2VzOyAvLyBJbmRpY2VzIGludG8gZ2VvbWV0cnkgYXJyYXlzLCBub3QgaW50byBzaGFyZWQgVmVydGV4QnVmc1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LnBvc2l0aW9ucztcblxuICAgICAgICAgICAgICAgIGxldCBpYTM7XG4gICAgICAgICAgICAgICAgbGV0IGliMztcbiAgICAgICAgICAgICAgICBsZXQgaWMzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGljZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaWEgPSBpbmRpY2VzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGliID0gaW5kaWNlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpYyA9IGluZGljZXNbaSArIDJdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlVmVydGljZXNbMF0gPSBpYTtcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVWZXJ0aWNlc1sxXSA9IGliO1xuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZVZlcnRpY2VzWzJdID0gaWM7XG5cbiAgICAgICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5pbmRpY2VzID0gdHJpYW5nbGVWZXJ0aWNlcztcblxuICAgICAgICAgICAgICAgICAgICBpYTMgPSBpYSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGliMyA9IGliICogMztcbiAgICAgICAgICAgICAgICAgICAgaWMzID0gaWMgKiAzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpYTMgPSBpICogMztcbiAgICAgICAgICAgICAgICAgICAgaWIzID0gaWEzICsgMztcbiAgICAgICAgICAgICAgICAgICAgaWMzID0gaWIzICsgMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFbMF0gPSBwb3NpdGlvbnNbaWEzICsgMF07XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BWzFdID0gcG9zaXRpb25zW2lhMyArIDFdO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQVsyXSA9IHBvc2l0aW9uc1tpYTMgKyAyXTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQlswXSA9IHBvc2l0aW9uc1tpYjMgKyAwXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkJbMV0gPSBwb3NpdGlvbnNbaWIzICsgMV07XG4gICAgICAgICAgICAgICAgcG9zaXRpb25CWzJdID0gcG9zaXRpb25zW2liMyArIDJdO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb25DWzBdID0gcG9zaXRpb25zW2ljMyArIDBdO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ1sxXSA9IHBvc2l0aW9uc1tpYzMgKyAxXTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNbMl0gPSBwb3NpdGlvbnNbaWMzICsgMl07XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkuY29tcHJlc3NHZW9tZXRyeSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlY29tcHJlc3MgdmVydGV4IHBvc2l0aW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uc0RlY29kZU1hdHJpeCA9IGdlb21ldHJ5LnBvc2l0aW9uc0RlY29kZU1hdHJpeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc0RlY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlDb21wcmVzc2lvblV0aWxzLmRlY29tcHJlc3NQb3NpdGlvbihwb3NpdGlvbkEsIHBvc2l0aW9uc0RlY29kZU1hdHJpeCwgcG9zaXRpb25BKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Q29tcHJlc3Npb25VdGlscy5kZWNvbXByZXNzUG9zaXRpb24ocG9zaXRpb25CLCBwb3NpdGlvbnNEZWNvZGVNYXRyaXgsIHBvc2l0aW9uQik7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeUNvbXByZXNzaW9uVXRpbHMuZGVjb21wcmVzc1Bvc2l0aW9uKHBvc2l0aW9uQywgcG9zaXRpb25zRGVjb2RlTWF0cml4LCBwb3NpdGlvbkMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byByYXktcGljayB0aGUgdHJpYW5nbGUgaW4gbG9jYWwgc3BhY2VcblxuICAgICAgICAgICAgICAgIGxldCBjYW52YXNQb3M7XG5cbiAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5jYW52YXNQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUG9zID0gcGlja1Jlc3VsdC5jYW52YXNQb3M7XG4gICAgICAgICAgICAgICAgICAgIG1hdGguY2FudmFzUG9zVG9Mb2NhbFJheShjYW52YXMuY2FudmFzLCBwaWNrVmlld01hdHJpeCwgcGlja1Byb2pNYXRyaXgsIG1lc2gud29ybGRNYXRyaXgsIGNhbnZhc1BvcywgbG9jYWxSYXlPcmlnaW4sIGxvY2FsUmF5RGlyKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGlja1Jlc3VsdC5vcmlnaW4gJiYgcGlja1Jlc3VsdC5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0aC53b3JsZFJheVRvTG9jYWxSYXkobWVzaC53b3JsZE1hdHJpeCwgcGlja1Jlc3VsdC5vcmlnaW4sIHBpY2tSZXN1bHQuZGlyZWN0aW9uLCBsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGgubm9ybWFsaXplVmVjMyhsb2NhbFJheURpcik7XG4gICAgICAgICAgICAgICAgbWF0aC5yYXlQbGFuZUludGVyc2VjdChsb2NhbFJheU9yaWdpbiwgbG9jYWxSYXlEaXIsIHBvc2l0aW9uQSwgcG9zaXRpb25CLCBwb3NpdGlvbkMsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBMb2NhbC1zcGFjZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHJheS10cmlhbmdsZSBpbnRlcnNlY3Rpb25cblxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQubG9jYWxQb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgaW50ZXJwb2xhdGVkIFdvcmxkLXNwYWNlIGNvb3JkaW5hdGVzXG5cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHRyYW5zZm9ybSBob21vZ2VuZW91cyBjb29yZHNcblxuICAgICAgICAgICAgICAgIHRlbXBWZWM0YVswXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgICAgICAgICAgIHRlbXBWZWM0YVsxXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICAgICAgICAgIHRlbXBWZWM0YVsyXSA9IHBvc2l0aW9uWzJdO1xuICAgICAgICAgICAgICAgIHRlbXBWZWM0YVszXSA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgV29ybGQtc3BhY2UgY2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSByYXktdHJpYW5nbGUgaW50ZXJzZWN0aW9uXG5cbiAgICAgICAgICAgICAgICBtYXRoLnRyYW5zZm9ybVZlYzQobWVzaC53b3JsZE1hdHJpeCwgdGVtcFZlYzRhLCB0ZW1wVmVjNGIpO1xuXG4gICAgICAgICAgICAgICAgd29ybGRQb3NbMF0gPSB0ZW1wVmVjNGJbMF07XG4gICAgICAgICAgICAgICAgd29ybGRQb3NbMV0gPSB0ZW1wVmVjNGJbMV07XG4gICAgICAgICAgICAgICAgd29ybGRQb3NbMl0gPSB0ZW1wVmVjNGJbMl07XG5cbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LndvcmxkUG9zID0gd29ybGRQb3M7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgVmlldy1zcGFjZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIHJheS10cmlhbmdsZSBpbnRlcnNlY3Rpb25cblxuICAgICAgICAgICAgICAgIG1hdGgudHJhbnNmb3JtVmVjNChjYW1lcmEubWF0cml4LCB0ZW1wVmVjNGIsIHRlbXBWZWM0Yyk7XG5cbiAgICAgICAgICAgICAgICB2aWV3UG9zWzBdID0gdGVtcFZlYzRjWzBdO1xuICAgICAgICAgICAgICAgIHZpZXdQb3NbMV0gPSB0ZW1wVmVjNGNbMV07XG4gICAgICAgICAgICAgICAgdmlld1Bvc1syXSA9IHRlbXBWZWM0Y1syXTtcblxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQudmlld1BvcyA9IHZpZXdQb3M7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgb2YgdGhlIHJheS10cmlhbmdsZSBpbnRlcnNlY3Rpb25cblxuICAgICAgICAgICAgICAgIG1hdGguY2FydGVzaWFuVG9CYXJ5Y2VudHJpYyhwb3NpdGlvbiwgcG9zaXRpb25BLCBwb3NpdGlvbkIsIHBvc2l0aW9uQywgYmFyeSk7XG5cbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LmJhcnkgPSBiYXJ5O1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGludGVycG9sYXRlZCBub3JtYWwgdmVjdG9yXG5cbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxzID0gZ2VvbWV0cnkubm9ybWFscztcblxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmNvbXByZXNzR2VvbWV0cnkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb21wcmVzcyB2ZXJ0ZXggbm9ybWFsc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpYTIgPSBpYSAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpYjIgPSBpYiAqIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpYzIgPSBpYyAqIDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Q29tcHJlc3Npb25VdGlscy5kZWNvbXByZXNzTm9ybWFsKG5vcm1hbHMuc3ViYXJyYXkoaWEyLCBpYTIgKyAyKSwgbm9ybWFsQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeUNvbXByZXNzaW9uVXRpbHMuZGVjb21wcmVzc05vcm1hbChub3JtYWxzLnN1YmFycmF5KGliMiwgaWIyICsgMiksIG5vcm1hbEIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlDb21wcmVzc2lvblV0aWxzLmRlY29tcHJlc3NOb3JtYWwobm9ybWFscy5zdWJhcnJheShpYzIsIGljMiArIDIpLCBub3JtYWxDKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBWzBdID0gbm9ybWFsc1tpYTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQVsxXSA9IG5vcm1hbHNbaWEzICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBWzJdID0gbm9ybWFsc1tpYTMgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQlswXSA9IG5vcm1hbHNbaWIzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEJbMV0gPSBub3JtYWxzW2liMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQlsyXSA9IG5vcm1hbHNbaWIzICsgMl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbENbMF0gPSBub3JtYWxzW2ljM107XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxDWzFdID0gbm9ybWFsc1tpYzMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbENbMl0gPSBub3JtYWxzW2ljMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gbWF0aC5hZGRWZWMzKG1hdGguYWRkVmVjMyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubXVsVmVjM1NjYWxhcihub3JtYWxBLCBiYXJ5WzBdLCB0ZW1wVmVjMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm11bFZlYzNTY2FsYXIobm9ybWFsQiwgYmFyeVsxXSwgdGVtcFZlYzNiKSwgdGVtcFZlYzNjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGgubXVsVmVjM1NjYWxhcihub3JtYWxDLCBiYXJ5WzJdLCB0ZW1wVmVjM2QpLCB0ZW1wVmVjM2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQud29ybGROb3JtYWwgPSBtYXRoLm5vcm1hbGl6ZVZlYzMobWF0aC50cmFuc2Zvcm1WZWMzKG1lc2gud29ybGROb3JtYWxNYXRyaXgsIG5vcm1hbCwgdGVtcFZlYzNmKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGludGVycG9sYXRlZCBVViBjb29yZGluYXRlc1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXZzID0gZ2VvbWV0cnkudXY7XG5cbiAgICAgICAgICAgICAgICBpZiAodXZzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdXZhWzBdID0gdXZzWyhpYSAqIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgdXZhWzFdID0gdXZzWyhpYSAqIDIpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgdXZiWzBdID0gdXZzWyhpYiAqIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgdXZiWzFdID0gdXZzWyhpYiAqIDIpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgdXZjWzBdID0gdXZzWyhpYyAqIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgdXZjWzFdID0gdXZzWyhpYyAqIDIpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmNvbXByZXNzR2VvbWV0cnkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb21wcmVzcyB2ZXJ0ZXggVVZzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHV2RGVjb2RlTWF0cml4ID0gZ2VvbWV0cnkudXZEZWNvZGVNYXRyaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXZEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeUNvbXByZXNzaW9uVXRpbHMuZGVjb21wcmVzc1VWKHV2YSwgdXZEZWNvZGVNYXRyaXgsIHV2YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlDb21wcmVzc2lvblV0aWxzLmRlY29tcHJlc3NVVih1dmIsIHV2RGVjb2RlTWF0cml4LCB1dmIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5Q29tcHJlc3Npb25VdGlscy5kZWNvbXByZXNzVVYodXZjLCB1dkRlY29kZU1hdHJpeCwgdXZjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQudXYgPSBtYXRoLmFkZFZlYzMoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLmFkZFZlYzMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC5tdWxWZWMyU2NhbGFyKHV2YSwgYmFyeVswXSwgdGVtcFZlYzNnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm11bFZlYzJTY2FsYXIodXZiLCBiYXJ5WzFdLCB0ZW1wVmVjM2gpLCB0ZW1wVmVjM2kpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC5tdWxWZWMyU2NhbGFyKHV2YywgYmFyeVsyXSwgdGVtcFZlYzNqKSwgdGVtcFZlYzNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuXG5leHBvcnQge01lc2h9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/Mesh.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawRenderer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawRenderer.js ***!
  \************************************************************************************/
/*! exports provided: DrawRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrawRenderer\", function() { return DrawRenderer; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _DrawShaderSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\n\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_5__[\"math\"].vec3();\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\n/**\n * @private\n */\nconst DrawRenderer = function (hash, mesh) {\n    this.id = ids.addItem({});\n    this._hash = hash;\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._shaderSource = new _DrawShaderSource_js__WEBPACK_IMPORTED_MODULE_1__[\"DrawShaderSource\"](mesh);\n    this._allocate(mesh);\n};\n\nconst drawRenderers = {};\n\nDrawRenderer.get = function (mesh) {\n    const scene = mesh.scene;\n    const hash = [\n        scene.canvas.canvas.id,\n        (scene.gammaInput ? \"gi;\" : \";\") + (scene.gammaOutput ? \"go\" : \"\"),\n        scene._lightsState.getHash(),\n        scene._sectionPlanesState.getHash(),\n        mesh._geometry._state.hash,\n        mesh._material._state.hash,\n        mesh._state.drawHash\n    ].join(\";\");\n    let renderer = drawRenderers[hash];\n    if (!renderer) {\n        renderer = new DrawRenderer(hash, mesh);\n        if (renderer.errors) {\n            console.log(renderer.errors.join(\"\\n\"));\n            return null;\n        }\n        drawRenderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nDrawRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        ids.removeItem(this.id);\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete drawRenderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs--;\n    }\n};\n\nDrawRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nDrawRenderer.prototype.drawMesh = function (frameCtx, mesh) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const maxTextureUnits = _webglInfo_js__WEBPACK_IMPORTED_MODULE_4__[\"WEBGL_INFO\"].MAX_TEXTURE_UNITS;\n    const scene = mesh.scene;\n    const material = mesh._material;\n    const gl = scene.canvas.gl;\n    const program = this._program;\n    const meshState = mesh._state;\n    const materialState = mesh._material._state;\n    const geometryState = mesh._geometry._state;\n    const camera = scene.camera;\n    const rtcCenter = mesh.rtcCenter;\n\n    if (frameCtx.lastProgramId !== this._program.id) {\n        frameCtx.lastProgramId = this._program.id;\n        this._bindProgram(frameCtx);\n    }\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);\n    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_6__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    if (materialState.id !== this._lastMaterialId) {\n\n        frameCtx.textureUnit = this._baseTextureUnit;\n\n        const backfaces = materialState.backfaces;\n        if (frameCtx.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frameCtx.backfaces = backfaces;\n        }\n\n        const frontface = materialState.frontface;\n        if (frameCtx.frontface !== frontface) {\n            if (frontface) {\n                gl.frontFace(gl.CCW);\n            } else {\n                gl.frontFace(gl.CW);\n            }\n            frameCtx.frontface = frontface;\n        }\n\n        if (frameCtx.lineWidth !== materialState.lineWidth) {\n            gl.lineWidth(materialState.lineWidth);\n            frameCtx.lineWidth = materialState.lineWidth;\n        }\n\n        if (this._uPointSize) {\n            gl.uniform1f(this._uPointSize, materialState.pointSize);\n        }\n\n        switch (materialState.type) {\n            case \"LambertMaterial\":\n                if (this._uMaterialAmbient) {\n                    gl.uniform3fv(this._uMaterialAmbient, materialState.ambient);\n                }\n                if (this._uMaterialColor) {\n                    gl.uniform4f(this._uMaterialColor, materialState.color[0], materialState.color[1], materialState.color[2], materialState.alpha);\n                }\n                if (this._uMaterialEmissive) {\n                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);\n                }\n                break;\n\n            case \"PhongMaterial\":\n                if (this._uMaterialShininess) {\n                    gl.uniform1f(this._uMaterialShininess, materialState.shininess);\n                }\n                if (this._uMaterialAmbient) {\n                    gl.uniform3fv(this._uMaterialAmbient, materialState.ambient);\n                }\n                if (this._uMaterialDiffuse) {\n                    gl.uniform3fv(this._uMaterialDiffuse, materialState.diffuse);\n                }\n                if (this._uMaterialSpecular) {\n                    gl.uniform3fv(this._uMaterialSpecular, materialState.specular);\n                }\n                if (this._uMaterialEmissive) {\n                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);\n                }\n                if (this._uAlphaModeCutoff) {\n                    gl.uniform4f(\n                        this._uAlphaModeCutoff,\n                        1.0 * materialState.alpha,\n                        materialState.alphaMode === 1 ? 1.0 : 0.0,\n                        materialState.alphaCutoff,\n                        0);\n                }\n                if (material._ambientMap && material._ambientMap._state.texture && this._uMaterialAmbientMap) {\n                    program.bindTexture(this._uMaterialAmbientMap, material._ambientMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uMaterialAmbientMapMatrix) {\n                        gl.uniformMatrix4fv(this._uMaterialAmbientMapMatrix, false, material._ambientMap._state.matrix);\n                    }\n                }\n                if (material._diffuseMap && material._diffuseMap._state.texture && this._uDiffuseMap) {\n                    program.bindTexture(this._uDiffuseMap, material._diffuseMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uDiffuseMapMatrix) {\n                        gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, material._diffuseMap._state.matrix);\n                    }\n                }\n                if (material._specularMap && material._specularMap._state.texture && this._uSpecularMap) {\n                    program.bindTexture(this._uSpecularMap, material._specularMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uSpecularMapMatrix) {\n                        gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, material._specularMap._state.matrix);\n                    }\n                }\n                if (material._emissiveMap && material._emissiveMap._state.texture && this._uEmissiveMap) {\n                    program.bindTexture(this._uEmissiveMap, material._emissiveMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uEmissiveMapMatrix) {\n                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, material._emissiveMap._state.matrix);\n                    }\n                }\n                if (material._alphaMap && material._alphaMap._state.texture && this._uAlphaMap) {\n                    program.bindTexture(this._uAlphaMap, material._alphaMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uAlphaMapMatrix) {\n                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, material._alphaMap._state.matrix);\n                    }\n                }\n                if (material._reflectivityMap && material._reflectivityMap._state.texture && this._uReflectivityMap) {\n                    program.bindTexture(this._uReflectivityMap, material._reflectivityMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    if (this._uReflectivityMapMatrix) {\n                        gl.uniformMatrix4fv(this._uReflectivityMapMatrix, false, material._reflectivityMap._state.matrix);\n                    }\n                }\n                if (material._normalMap && material._normalMap._state.texture && this._uNormalMap) {\n                    program.bindTexture(this._uNormalMap, material._normalMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uNormalMapMatrix) {\n                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, material._normalMap._state.matrix);\n                    }\n                }\n                if (material._occlusionMap && material._occlusionMap._state.texture && this._uOcclusionMap) {\n                    program.bindTexture(this._uOcclusionMap, material._occlusionMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uOcclusionMapMatrix) {\n                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, material._occlusionMap._state.matrix);\n                    }\n                }\n                if (material._diffuseFresnel) {\n                    if (this._uDiffuseFresnelEdgeBias) {\n                        gl.uniform1f(this._uDiffuseFresnelEdgeBias, material._diffuseFresnel.edgeBias);\n                    }\n                    if (this._uDiffuseFresnelCenterBias) {\n                        gl.uniform1f(this._uDiffuseFresnelCenterBias, material._diffuseFresnel.centerBias);\n                    }\n                    if (this._uDiffuseFresnelEdgeColor) {\n                        gl.uniform3fv(this._uDiffuseFresnelEdgeColor, material._diffuseFresnel.edgeColor);\n                    }\n                    if (this._uDiffuseFresnelCenterColor) {\n                        gl.uniform3fv(this._uDiffuseFresnelCenterColor, material._diffuseFresnel.centerColor);\n                    }\n                    if (this._uDiffuseFresnelPower) {\n                        gl.uniform1f(this._uDiffuseFresnelPower, material._diffuseFresnel.power);\n                    }\n                }\n                if (material._specularFresnel) {\n                    if (this._uSpecularFresnelEdgeBias) {\n                        gl.uniform1f(this._uSpecularFresnelEdgeBias, material._specularFresnel.edgeBias);\n                    }\n                    if (this._uSpecularFresnelCenterBias) {\n                        gl.uniform1f(this._uSpecularFresnelCenterBias, material._specularFresnel.centerBias);\n                    }\n                    if (this._uSpecularFresnelEdgeColor) {\n                        gl.uniform3fv(this._uSpecularFresnelEdgeColor, material._specularFresnel.edgeColor);\n                    }\n                    if (this._uSpecularFresnelCenterColor) {\n                        gl.uniform3fv(this._uSpecularFresnelCenterColor, material._specularFresnel.centerColor);\n                    }\n                    if (this._uSpecularFresnelPower) {\n                        gl.uniform1f(this._uSpecularFresnelPower, material._specularFresnel.power);\n                    }\n                }\n                if (material._alphaFresnel) {\n                    if (this._uAlphaFresnelEdgeBias) {\n                        gl.uniform1f(this._uAlphaFresnelEdgeBias, material._alphaFresnel.edgeBias);\n                    }\n                    if (this._uAlphaFresnelCenterBias) {\n                        gl.uniform1f(this._uAlphaFresnelCenterBias, material._alphaFresnel.centerBias);\n                    }\n                    if (this._uAlphaFresnelEdgeColor) {\n                        gl.uniform3fv(this._uAlphaFresnelEdgeColor, material._alphaFresnel.edgeColor);\n                    }\n                    if (this._uAlphaFresnelCenterColor) {\n                        gl.uniform3fv(this._uAlphaFresnelCenterColor, material._alphaFresnel.centerColor);\n                    }\n                    if (this._uAlphaFresnelPower) {\n                        gl.uniform1f(this._uAlphaFresnelPower, material._alphaFresnel.power);\n                    }\n                }\n                if (material._reflectivityFresnel) {\n                    if (this._uReflectivityFresnelEdgeBias) {\n                        gl.uniform1f(this._uReflectivityFresnelEdgeBias, material._reflectivityFresnel.edgeBias);\n                    }\n                    if (this._uReflectivityFresnelCenterBias) {\n                        gl.uniform1f(this._uReflectivityFresnelCenterBias, material._reflectivityFresnel.centerBias);\n                    }\n                    if (this._uReflectivityFresnelEdgeColor) {\n                        gl.uniform3fv(this._uReflectivityFresnelEdgeColor, material._reflectivityFresnel.edgeColor);\n                    }\n                    if (this._uReflectivityFresnelCenterColor) {\n                        gl.uniform3fv(this._uReflectivityFresnelCenterColor, material._reflectivityFresnel.centerColor);\n                    }\n                    if (this._uReflectivityFresnelPower) {\n                        gl.uniform1f(this._uReflectivityFresnelPower, material._reflectivityFresnel.power);\n                    }\n                }\n                if (material._emissiveFresnel) {\n                    if (this._uEmissiveFresnelEdgeBias) {\n                        gl.uniform1f(this._uEmissiveFresnelEdgeBias, material._emissiveFresnel.edgeBias);\n                    }\n                    if (this._uEmissiveFresnelCenterBias) {\n                        gl.uniform1f(this._uEmissiveFresnelCenterBias, material._emissiveFresnel.centerBias);\n                    }\n                    if (this._uEmissiveFresnelEdgeColor) {\n                        gl.uniform3fv(this._uEmissiveFresnelEdgeColor, material._emissiveFresnel.edgeColor);\n                    }\n                    if (this._uEmissiveFresnelCenterColor) {\n                        gl.uniform3fv(this._uEmissiveFresnelCenterColor, material._emissiveFresnel.centerColor);\n                    }\n                    if (this._uEmissiveFresnelPower) {\n                        gl.uniform1f(this._uEmissiveFresnelPower, material._emissiveFresnel.power);\n                    }\n                }\n                break;\n\n            case \"MetallicMaterial\":\n                if (this._uBaseColor) {\n                    gl.uniform3fv(this._uBaseColor, materialState.baseColor);\n                }\n                if (this._uMaterialMetallic) {\n                    gl.uniform1f(this._uMaterialMetallic, materialState.metallic);\n                }\n                if (this._uMaterialRoughness) {\n                    gl.uniform1f(this._uMaterialRoughness, materialState.roughness);\n                }\n                if (this._uMaterialSpecularF0) {\n                    gl.uniform1f(this._uMaterialSpecularF0, materialState.specularF0);\n                }\n                if (this._uMaterialEmissive) {\n                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);\n                }\n                if (this._uAlphaModeCutoff) {\n                    gl.uniform4f(\n                        this._uAlphaModeCutoff,\n                        1.0 * materialState.alpha,\n                        materialState.alphaMode === 1 ? 1.0 : 0.0,\n                        materialState.alphaCutoff,\n                        0.0);\n                }\n                const baseColorMap = material._baseColorMap;\n                if (baseColorMap && baseColorMap._state.texture && this._uBaseColorMap) {\n                    program.bindTexture(this._uBaseColorMap, baseColorMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uBaseColorMapMatrix) {\n                        gl.uniformMatrix4fv(this._uBaseColorMapMatrix, false, baseColorMap._state.matrix);\n                    }\n                }\n                const metallicMap = material._metallicMap;\n                if (metallicMap && metallicMap._state.texture && this._uMetallicMap) {\n                    program.bindTexture(this._uMetallicMap, metallicMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uMetallicMapMatrix) {\n                        gl.uniformMatrix4fv(this._uMetallicMapMatrix, false, metallicMap._state.matrix);\n                    }\n                }\n                const roughnessMap = material._roughnessMap;\n                if (roughnessMap && roughnessMap._state.texture && this._uRoughnessMap) {\n                    program.bindTexture(this._uRoughnessMap, roughnessMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uRoughnessMapMatrix) {\n                        gl.uniformMatrix4fv(this._uRoughnessMapMatrix, false, roughnessMap._state.matrix);\n                    }\n                }\n                const metallicRoughnessMap = material._metallicRoughnessMap;\n                if (metallicRoughnessMap && metallicRoughnessMap._state.texture && this._uMetallicRoughnessMap) {\n                    program.bindTexture(this._uMetallicRoughnessMap, metallicRoughnessMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uMetallicRoughnessMapMatrix) {\n                        gl.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix, false, metallicRoughnessMap._state.matrix);\n                    }\n                }\n                var emissiveMap = material._emissiveMap;\n                if (emissiveMap && emissiveMap._state.texture && this._uEmissiveMap) {\n                    program.bindTexture(this._uEmissiveMap, emissiveMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uEmissiveMapMatrix) {\n                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, emissiveMap._state.matrix);\n                    }\n                }\n                var occlusionMap = material._occlusionMap;\n                if (occlusionMap && material._occlusionMap._state.texture && this._uOcclusionMap) {\n                    program.bindTexture(this._uOcclusionMap, occlusionMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uOcclusionMapMatrix) {\n                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, occlusionMap._state.matrix);\n                    }\n                }\n                var alphaMap = material._alphaMap;\n                if (alphaMap && alphaMap._state.texture && this._uAlphaMap) {\n                    program.bindTexture(this._uAlphaMap, alphaMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uAlphaMapMatrix) {\n                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, alphaMap._state.matrix);\n                    }\n                }\n                var normalMap = material._normalMap;\n                if (normalMap && normalMap._state.texture && this._uNormalMap) {\n                    program.bindTexture(this._uNormalMap, normalMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uNormalMapMatrix) {\n                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, normalMap._state.matrix);\n                    }\n                }\n                break;\n\n            case \"SpecularMaterial\":\n                if (this._uMaterialDiffuse) {\n                    gl.uniform3fv(this._uMaterialDiffuse, materialState.diffuse);\n                }\n                if (this._uMaterialSpecular) {\n                    gl.uniform3fv(this._uMaterialSpecular, materialState.specular);\n                }\n                if (this._uMaterialGlossiness) {\n                    gl.uniform1f(this._uMaterialGlossiness, materialState.glossiness);\n                }\n                if (this._uMaterialReflectivity) {\n                    gl.uniform1f(this._uMaterialReflectivity, materialState.reflectivity);\n                }\n                if (this._uMaterialEmissive) {\n                    gl.uniform3fv(this._uMaterialEmissive, materialState.emissive);\n                }\n                if (this._uAlphaModeCutoff) {\n                    gl.uniform4f(\n                        this._uAlphaModeCutoff,\n                        1.0 * materialState.alpha,\n                        materialState.alphaMode === 1 ? 1.0 : 0.0,\n                        materialState.alphaCutoff,\n                        0.0);\n                }\n                const diffuseMap = material._diffuseMap;\n                if (diffuseMap && diffuseMap._state.texture && this._uDiffuseMap) {\n                    program.bindTexture(this._uDiffuseMap, diffuseMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uDiffuseMapMatrix) {\n                        gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, diffuseMap._state.matrix);\n                    }\n                }\n                const specularMap = material._specularMap;\n                if (specularMap && specularMap._state.texture && this._uSpecularMap) {\n                    program.bindTexture(this._uSpecularMap, specularMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uSpecularMapMatrix) {\n                        gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, specularMap._state.matrix);\n                    }\n                }\n                const glossinessMap = material._glossinessMap;\n                if (glossinessMap && glossinessMap._state.texture && this._uGlossinessMap) {\n                    program.bindTexture(this._uGlossinessMap, glossinessMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uGlossinessMapMatrix) {\n                        gl.uniformMatrix4fv(this._uGlossinessMapMatrix, false, glossinessMap._state.matrix);\n                    }\n                }\n                const specularGlossinessMap = material._specularGlossinessMap;\n                if (specularGlossinessMap && specularGlossinessMap._state.texture && this._uSpecularGlossinessMap) {\n                    program.bindTexture(this._uSpecularGlossinessMap, specularGlossinessMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uSpecularGlossinessMapMatrix) {\n                        gl.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix, false, specularGlossinessMap._state.matrix);\n                    }\n                }\n                var emissiveMap = material._emissiveMap;\n                if (emissiveMap && emissiveMap._state.texture && this._uEmissiveMap) {\n                    program.bindTexture(this._uEmissiveMap, emissiveMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uEmissiveMapMatrix) {\n                        gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, emissiveMap._state.matrix);\n                    }\n                }\n                var occlusionMap = material._occlusionMap;\n                if (occlusionMap && occlusionMap._state.texture && this._uOcclusionMap) {\n                    program.bindTexture(this._uOcclusionMap, occlusionMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uOcclusionMapMatrix) {\n                        gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, occlusionMap._state.matrix);\n                    }\n                }\n                var alphaMap = material._alphaMap;\n                if (alphaMap && alphaMap._state.texture && this._uAlphaMap) {\n                    program.bindTexture(this._uAlphaMap, alphaMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uAlphaMapMatrix) {\n                        gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, alphaMap._state.matrix);\n                    }\n                }\n                var normalMap = material._normalMap;\n                if (normalMap && normalMap._state.texture && this._uNormalMap) {\n                    program.bindTexture(this._uNormalMap, normalMap._state.texture, frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                    if (this._uNormalMapMatrix) {\n                        gl.uniformMatrix4fv(this._uNormalMapMatrix, false, normalMap._state.matrix);\n                    }\n                }\n                break;\n        }\n        this._lastMaterialId = materialState.id;\n    }\n\n    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);\n    if (this._uModelNormalMatrix) {\n        gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, mesh.worldNormalMatrix);\n    }\n\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, meshState.clippable);\n    }\n\n    if (this._uColorize) {\n        const colorize = meshState.colorize;\n        const lastColorize = this._lastColorize;\n        if (lastColorize[0] !== colorize[0] ||\n            lastColorize[1] !== colorize[1] ||\n            lastColorize[2] !== colorize[2] ||\n            lastColorize[3] !== colorize[3]) {\n            gl.uniform4fv(this._uColorize, colorize);\n            lastColorize[0] = colorize[0];\n            lastColorize[1] = colorize[1];\n            lastColorize[2] = colorize[2];\n            lastColorize[3] = colorize[3];\n        }\n    }\n\n    gl.uniform3fv(this._uOffset, meshState.offset);\n\n    // Bind VBOs\n\n    if (geometryState.id !== this._lastGeometryId) {\n        if (this._uPositionsDecodeMatrix) {\n            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        }\n        if (this._uUVDecodeMatrix) {\n            gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometryState.uvDecodeMatrix);\n        }\n        if (this._aPosition) {\n            this._aPosition.bindArrayBuffer(geometryState.positionsBuf);\n            frameCtx.bindArray++;\n        }\n        if (this._aNormal) {\n            this._aNormal.bindArrayBuffer(geometryState.normalsBuf);\n            frameCtx.bindArray++;\n        }\n        if (this._aUV) {\n            this._aUV.bindArrayBuffer(geometryState.uvBuf);\n            frameCtx.bindArray++;\n        }\n        if (this._aColor) {\n            this._aColor.bindArrayBuffer(geometryState.colorsBuf);\n            frameCtx.bindArray++;\n        }\n        if (this._aFlags) {\n            this._aFlags.bindArrayBuffer(geometryState.flagsBuf);\n            frameCtx.bindArray++;\n        }\n        if (geometryState.indicesBuf) {\n            geometryState.indicesBuf.bind();\n            frameCtx.bindArray++;\n        }\n        this._lastGeometryId = geometryState.id;\n    }\n\n    // Draw (indices bound in prev step)\n\n    if (geometryState.indicesBuf) {\n        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n        frameCtx.drawElements++;\n    } else if (geometryState.positions) {\n        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);\n        frameCtx.drawArrays++;\n    }\n};\n\nDrawRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    const material = mesh._material;\n    const lightsState = scene._lightsState;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const materialState = mesh._material._state;\n\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__[\"Program\"](gl, this._shaderSource);\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uUVDecodeMatrix = program.getLocation(\"uvDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uModelNormalMatrix = program.getLocation(\"modelNormalMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uViewNormalMatrix = program.getLocation(\"viewNormalMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uGammaFactor = program.getLocation(\"gammaFactor\");\n    this._uLightAmbient = [];\n    this._uLightColor = [];\n    this._uLightDir = [];\n    this._uLightPos = [];\n    this._uLightAttenuation = [];\n    this._uShadowViewMatrix = [];\n    this._uShadowProjMatrix = [];\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n\n    const lights = lightsState.lights;\n    let light;\n\n    for (var i = 0, len = lights.length; i < len; i++) {\n        light = lights[i];\n        switch (light.type) {\n\n            case \"ambient\":\n                this._uLightAmbient[i] = program.getLocation(\"lightAmbient\");\n                break;\n\n            case \"dir\":\n                this._uLightColor[i] = program.getLocation(\"lightColor\" + i);\n                this._uLightPos[i] = null;\n                this._uLightDir[i] = program.getLocation(\"lightDir\" + i);\n                break;\n\n            case \"point\":\n                this._uLightColor[i] = program.getLocation(\"lightColor\" + i);\n                this._uLightPos[i] = program.getLocation(\"lightPos\" + i);\n                this._uLightDir[i] = null;\n                this._uLightAttenuation[i] = program.getLocation(\"lightAttenuation\" + i);\n                break;\n\n            case \"spot\":\n                this._uLightColor[i] = program.getLocation(\"lightColor\" + i);\n                this._uLightPos[i] = program.getLocation(\"lightPos\" + i);\n                this._uLightDir[i] = program.getLocation(\"lightDir\" + i);\n                this._uLightAttenuation[i] = program.getLocation(\"lightAttenuation\" + i);\n                break;\n        }\n\n        if (light.castsShadow) {\n            this._uShadowViewMatrix[i] = program.getLocation(\"shadowViewMatrix\" + i);\n            this._uShadowProjMatrix[i] = program.getLocation(\"shadowProjMatrix\" + i);\n        }\n    }\n\n    if (lightsState.lightMaps.length > 0) {\n        this._uLightMap = \"lightMap\";\n    }\n\n    if (lightsState.reflectionMaps.length > 0) {\n        this._uReflectionMap = \"reflectionMap\";\n    }\n\n    this._uSectionPlanes = [];\n    const sectionPlanes = sectionPlanesState.sectionPlanes;\n    for (var i = 0, len = sectionPlanes.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n\n    this._uPointSize = program.getLocation(\"pointSize\");\n\n    switch (materialState.type) {\n        case \"LambertMaterial\":\n            this._uMaterialColor = program.getLocation(\"materialColor\");\n            this._uMaterialEmissive = program.getLocation(\"materialEmissive\");\n            this._uAlphaModeCutoff = program.getLocation(\"materialAlphaModeCutoff\");\n            break;\n\n        case \"PhongMaterial\":\n            this._uMaterialAmbient = program.getLocation(\"materialAmbient\");\n            this._uMaterialDiffuse = program.getLocation(\"materialDiffuse\");\n            this._uMaterialSpecular = program.getLocation(\"materialSpecular\");\n            this._uMaterialEmissive = program.getLocation(\"materialEmissive\");\n            this._uAlphaModeCutoff = program.getLocation(\"materialAlphaModeCutoff\");\n            this._uMaterialShininess = program.getLocation(\"materialShininess\");\n            if (material._ambientMap) {\n                this._uMaterialAmbientMap = \"ambientMap\";\n                this._uMaterialAmbientMapMatrix = program.getLocation(\"ambientMapMatrix\");\n            }\n            if (material._diffuseMap) {\n                this._uDiffuseMap = \"diffuseMap\";\n                this._uDiffuseMapMatrix = program.getLocation(\"diffuseMapMatrix\");\n            }\n            if (material._specularMap) {\n                this._uSpecularMap = \"specularMap\";\n                this._uSpecularMapMatrix = program.getLocation(\"specularMapMatrix\");\n            }\n            if (material._emissiveMap) {\n                this._uEmissiveMap = \"emissiveMap\";\n                this._uEmissiveMapMatrix = program.getLocation(\"emissiveMapMatrix\");\n            }\n            if (material._alphaMap) {\n                this._uAlphaMap = \"alphaMap\";\n                this._uAlphaMapMatrix = program.getLocation(\"alphaMapMatrix\");\n            }\n            if (material._reflectivityMap) {\n                this._uReflectivityMap = \"reflectivityMap\";\n                this._uReflectivityMapMatrix = program.getLocation(\"reflectivityMapMatrix\");\n            }\n            if (material._normalMap) {\n                this._uNormalMap = \"normalMap\";\n                this._uNormalMapMatrix = program.getLocation(\"normalMapMatrix\");\n            }\n            if (material._occlusionMap) {\n                this._uOcclusionMap = \"occlusionMap\";\n                this._uOcclusionMapMatrix = program.getLocation(\"occlusionMapMatrix\");\n            }\n            if (material._diffuseFresnel) {\n                this._uDiffuseFresnelEdgeBias = program.getLocation(\"diffuseFresnelEdgeBias\");\n                this._uDiffuseFresnelCenterBias = program.getLocation(\"diffuseFresnelCenterBias\");\n                this._uDiffuseFresnelEdgeColor = program.getLocation(\"diffuseFresnelEdgeColor\");\n                this._uDiffuseFresnelCenterColor = program.getLocation(\"diffuseFresnelCenterColor\");\n                this._uDiffuseFresnelPower = program.getLocation(\"diffuseFresnelPower\");\n            }\n            if (material._specularFresnel) {\n                this._uSpecularFresnelEdgeBias = program.getLocation(\"specularFresnelEdgeBias\");\n                this._uSpecularFresnelCenterBias = program.getLocation(\"specularFresnelCenterBias\");\n                this._uSpecularFresnelEdgeColor = program.getLocation(\"specularFresnelEdgeColor\");\n                this._uSpecularFresnelCenterColor = program.getLocation(\"specularFresnelCenterColor\");\n                this._uSpecularFresnelPower = program.getLocation(\"specularFresnelPower\");\n            }\n            if (material._alphaFresnel) {\n                this._uAlphaFresnelEdgeBias = program.getLocation(\"alphaFresnelEdgeBias\");\n                this._uAlphaFresnelCenterBias = program.getLocation(\"alphaFresnelCenterBias\");\n                this._uAlphaFresnelEdgeColor = program.getLocation(\"alphaFresnelEdgeColor\");\n                this._uAlphaFresnelCenterColor = program.getLocation(\"alphaFresnelCenterColor\");\n                this._uAlphaFresnelPower = program.getLocation(\"alphaFresnelPower\");\n            }\n            if (material._reflectivityFresnel) {\n                this._uReflectivityFresnelEdgeBias = program.getLocation(\"reflectivityFresnelEdgeBias\");\n                this._uReflectivityFresnelCenterBias = program.getLocation(\"reflectivityFresnelCenterBias\");\n                this._uReflectivityFresnelEdgeColor = program.getLocation(\"reflectivityFresnelEdgeColor\");\n                this._uReflectivityFresnelCenterColor = program.getLocation(\"reflectivityFresnelCenterColor\");\n                this._uReflectivityFresnelPower = program.getLocation(\"reflectivityFresnelPower\");\n            }\n            if (material._emissiveFresnel) {\n                this._uEmissiveFresnelEdgeBias = program.getLocation(\"emissiveFresnelEdgeBias\");\n                this._uEmissiveFresnelCenterBias = program.getLocation(\"emissiveFresnelCenterBias\");\n                this._uEmissiveFresnelEdgeColor = program.getLocation(\"emissiveFresnelEdgeColor\");\n                this._uEmissiveFresnelCenterColor = program.getLocation(\"emissiveFresnelCenterColor\");\n                this._uEmissiveFresnelPower = program.getLocation(\"emissiveFresnelPower\");\n            }\n            break;\n\n        case \"MetallicMaterial\":\n            this._uBaseColor = program.getLocation(\"materialBaseColor\");\n            this._uMaterialMetallic = program.getLocation(\"materialMetallic\");\n            this._uMaterialRoughness = program.getLocation(\"materialRoughness\");\n            this._uMaterialSpecularF0 = program.getLocation(\"materialSpecularF0\");\n            this._uMaterialEmissive = program.getLocation(\"materialEmissive\");\n            this._uAlphaModeCutoff = program.getLocation(\"materialAlphaModeCutoff\");\n            if (material._baseColorMap) {\n                this._uBaseColorMap = \"baseColorMap\";\n                this._uBaseColorMapMatrix = program.getLocation(\"baseColorMapMatrix\");\n            }\n            if (material._metallicMap) {\n                this._uMetallicMap = \"metallicMap\";\n                this._uMetallicMapMatrix = program.getLocation(\"metallicMapMatrix\");\n            }\n            if (material._roughnessMap) {\n                this._uRoughnessMap = \"roughnessMap\";\n                this._uRoughnessMapMatrix = program.getLocation(\"roughnessMapMatrix\");\n            }\n            if (material._metallicRoughnessMap) {\n                this._uMetallicRoughnessMap = \"metallicRoughnessMap\";\n                this._uMetallicRoughnessMapMatrix = program.getLocation(\"metallicRoughnessMapMatrix\");\n            }\n            if (material._emissiveMap) {\n                this._uEmissiveMap = \"emissiveMap\";\n                this._uEmissiveMapMatrix = program.getLocation(\"emissiveMapMatrix\");\n            }\n            if (material._occlusionMap) {\n                this._uOcclusionMap = \"occlusionMap\";\n                this._uOcclusionMapMatrix = program.getLocation(\"occlusionMapMatrix\");\n            }\n            if (material._alphaMap) {\n                this._uAlphaMap = \"alphaMap\";\n                this._uAlphaMapMatrix = program.getLocation(\"alphaMapMatrix\");\n            }\n            if (material._normalMap) {\n                this._uNormalMap = \"normalMap\";\n                this._uNormalMapMatrix = program.getLocation(\"normalMapMatrix\");\n            }\n            break;\n\n        case \"SpecularMaterial\":\n            this._uMaterialDiffuse = program.getLocation(\"materialDiffuse\");\n            this._uMaterialSpecular = program.getLocation(\"materialSpecular\");\n            this._uMaterialGlossiness = program.getLocation(\"materialGlossiness\");\n            this._uMaterialReflectivity = program.getLocation(\"reflectivityFresnel\");\n            this._uMaterialEmissive = program.getLocation(\"materialEmissive\");\n            this._uAlphaModeCutoff = program.getLocation(\"materialAlphaModeCutoff\");\n            if (material._diffuseMap) {\n                this._uDiffuseMap = \"diffuseMap\";\n                this._uDiffuseMapMatrix = program.getLocation(\"diffuseMapMatrix\");\n            }\n            if (material._specularMap) {\n                this._uSpecularMap = \"specularMap\";\n                this._uSpecularMapMatrix = program.getLocation(\"specularMapMatrix\");\n            }\n            if (material._glossinessMap) {\n                this._uGlossinessMap = \"glossinessMap\";\n                this._uGlossinessMapMatrix = program.getLocation(\"glossinessMapMatrix\");\n            }\n            if (material._specularGlossinessMap) {\n                this._uSpecularGlossinessMap = \"materialSpecularGlossinessMap\";\n                this._uSpecularGlossinessMapMatrix = program.getLocation(\"materialSpecularGlossinessMapMatrix\");\n            }\n            if (material._emissiveMap) {\n                this._uEmissiveMap = \"emissiveMap\";\n                this._uEmissiveMapMatrix = program.getLocation(\"emissiveMapMatrix\");\n            }\n            if (material._occlusionMap) {\n                this._uOcclusionMap = \"occlusionMap\";\n                this._uOcclusionMapMatrix = program.getLocation(\"occlusionMapMatrix\");\n            }\n            if (material._alphaMap) {\n                this._uAlphaMap = \"alphaMap\";\n                this._uAlphaMapMatrix = program.getLocation(\"alphaMapMatrix\");\n            }\n            if (material._normalMap) {\n                this._uNormalMap = \"normalMap\";\n                this._uNormalMapMatrix = program.getLocation(\"normalMapMatrix\");\n            }\n            break;\n    }\n\n    this._aPosition = program.getAttribute(\"position\");\n    this._aNormal = program.getAttribute(\"normal\");\n    this._aUV = program.getAttribute(\"uv\");\n    this._aColor = program.getAttribute(\"color\");\n    this._aFlags = program.getAttribute(\"flags\");\n\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uColorize = program.getLocation(\"colorize\");\n    this._uOffset = program.getLocation(\"offset\");\n\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n\n    this._lastColorize = new Float32Array(4);\n\n    this._baseTextureUnit = 0;\n\n};\n\nDrawRenderer.prototype._bindProgram = function (frameCtx) {\n\n    const maxTextureUnits = _webglInfo_js__WEBPACK_IMPORTED_MODULE_4__[\"WEBGL_INFO\"].MAX_TEXTURE_UNITS;\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const lightsState = scene._lightsState;\n    const project = scene.camera.project;\n    let light;\n\n    const program = this._program;\n\n    program.bind();\n\n    frameCtx.useProgram++;\n    frameCtx.textureUnit = 0;\n\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n\n    this._lastColorize[0] = -1;\n    this._lastColorize[1] = -1;\n    this._lastColorize[2] = -1;\n    this._lastColorize[3] = -1;\n\n    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n\n    for (var i = 0, len = lightsState.lights.length; i < len; i++) {\n\n        light = lightsState.lights[i];\n\n        if (this._uLightAmbient[i]) {\n            gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);\n\n        } else {\n\n            if (this._uLightColor[i]) {\n                gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);\n            }\n\n            if (this._uLightPos[i]) {\n                gl.uniform3fv(this._uLightPos[i], light.pos);\n                if (this._uLightAttenuation[i]) {\n                    gl.uniform1f(this._uLightAttenuation[i], light.attenuation);\n                }\n            }\n\n            if (this._uLightDir[i]) {\n                gl.uniform3fv(this._uLightDir[i], light.dir);\n            }\n\n            if (light.castsShadow) {\n                if (this._uShadowViewMatrix[i]) {\n                    gl.uniformMatrix4fv(this._uShadowViewMatrix[i], false, light.getShadowViewMatrix());\n                }\n                if (this._uShadowProjMatrix[i]) {\n                    gl.uniformMatrix4fv(this._uShadowProjMatrix[i], false, light.getShadowProjMatrix());\n                }\n                const shadowRenderBuf = light.getShadowRenderBuf();\n                if (shadowRenderBuf) {\n                    program.bindTexture(\"shadowMap\" + i, shadowRenderBuf.getTexture(), frameCtx.textureUnit);\n                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n                    frameCtx.bindTexture++;\n                }\n            }\n        }\n    }\n\n    if (lightsState.lightMaps.length > 0 && lightsState.lightMaps[0].texture && this._uLightMap) {\n        program.bindTexture(this._uLightMap, lightsState.lightMaps[0].texture, frameCtx.textureUnit);\n        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n        frameCtx.bindTexture++;\n    }\n\n    if (lightsState.reflectionMaps.length > 0 && lightsState.reflectionMaps[0].texture && this._uReflectionMap) {\n        program.bindTexture(this._uReflectionMap, lightsState.reflectionMaps[0].texture, frameCtx.textureUnit);\n        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % maxTextureUnits;\n        frameCtx.bindTexture++;\n    }\n\n    if (this._uGammaFactor) {\n        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);\n    }\n\n    this._baseTextureUnit = frameCtx.textureUnit;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZHJhdy9EcmF3UmVuZGVyZXIuanM/MGY1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ2dCO0FBQ1I7QUFDVjtBQUNTO0FBQ047QUFDZTs7QUFFdkQsa0JBQWtCLGtEQUFJOztBQUV0QixnQkFBZ0IsaURBQUcsR0FBRzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFFQUFnQjtBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsd0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx5RUFBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsd0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsU0FBUzs7QUFFN0Q7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL2RyYXcvRHJhd1JlbmRlcmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yIHhlb2xhYnMgLyBodHRwczovL2dpdGh1Yi5jb20veGVvbGFic1xuICovXG5cbmltcG9ydCB7TWFwfSBmcm9tIFwiLi4vLi4vdXRpbHMvTWFwLmpzXCI7XG5pbXBvcnQge0RyYXdTaGFkZXJTb3VyY2V9IGZyb20gXCIuL0RyYXdTaGFkZXJTb3VyY2UuanNcIjtcbmltcG9ydCB7UHJvZ3JhbX0gZnJvbSBcIi4uLy4uL3dlYmdsL1Byb2dyYW0uanNcIjtcbmltcG9ydCB7c3RhdHN9IGZyb20gJy4uLy4uL3N0YXRzLmpzJztcbmltcG9ydCB7V0VCR0xfSU5GT30gZnJvbSAnLi4vLi4vd2ViZ2xJbmZvLmpzJztcbmltcG9ydCB7bWF0aH0gZnJvbSBcIi4uLy4uL21hdGgvbWF0aC5qc1wiO1xuaW1wb3J0IHtnZXRQbGFuZVJUQ1Bvc30gZnJvbSBcIi4uLy4uL21hdGgvcnRjQ29vcmRzLmpzXCI7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuXG5jb25zdCBpZHMgPSBuZXcgTWFwKHt9KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBEcmF3UmVuZGVyZXIgPSBmdW5jdGlvbiAoaGFzaCwgbWVzaCkge1xuICAgIHRoaXMuaWQgPSBpZHMuYWRkSXRlbSh7fSk7XG4gICAgdGhpcy5faGFzaCA9IGhhc2g7XG4gICAgdGhpcy5fc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIHRoaXMuX3VzZUNvdW50ID0gMDtcbiAgICB0aGlzLl9zaGFkZXJTb3VyY2UgPSBuZXcgRHJhd1NoYWRlclNvdXJjZShtZXNoKTtcbiAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbn07XG5cbmNvbnN0IGRyYXdSZW5kZXJlcnMgPSB7fTtcblxuRHJhd1JlbmRlcmVyLmdldCA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IGhhc2ggPSBbXG4gICAgICAgIHNjZW5lLmNhbnZhcy5jYW52YXMuaWQsXG4gICAgICAgIChzY2VuZS5nYW1tYUlucHV0ID8gXCJnaTtcIiA6IFwiO1wiKSArIChzY2VuZS5nYW1tYU91dHB1dCA/IFwiZ29cIiA6IFwiXCIpLFxuICAgICAgICBzY2VuZS5fbGlnaHRzU3RhdGUuZ2V0SGFzaCgpLFxuICAgICAgICBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLmdldEhhc2goKSxcbiAgICAgICAgbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmhhc2gsXG4gICAgICAgIG1lc2guX21hdGVyaWFsLl9zdGF0ZS5oYXNoLFxuICAgICAgICBtZXNoLl9zdGF0ZS5kcmF3SGFzaFxuICAgIF0uam9pbihcIjtcIik7XG4gICAgbGV0IHJlbmRlcmVyID0gZHJhd1JlbmRlcmVyc1toYXNoXTtcbiAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IERyYXdSZW5kZXJlcihoYXNoLCBtZXNoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyLmVycm9ycykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVuZGVyZXIuZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd1JlbmRlcmVyc1toYXNoXSA9IHJlbmRlcmVyO1xuICAgICAgICBzdGF0cy5tZW1vcnkucHJvZ3JhbXMrKztcbiAgICB9XG4gICAgcmVuZGVyZXIuX3VzZUNvdW50Kys7XG4gICAgcmV0dXJuIHJlbmRlcmVyO1xufTtcblxuRHJhd1JlbmRlcmVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5fdXNlQ291bnQgPT09IDApIHtcbiAgICAgICAgaWRzLnJlbW92ZUl0ZW0odGhpcy5pZCk7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZHJhd1JlbmRlcmVyc1t0aGlzLl9oYXNoXTtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zLS07XG4gICAgfVxufTtcblxuRHJhd1JlbmRlcmVyLnByb3RvdHlwZS53ZWJnbENvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbn07XG5cbkRyYXdSZW5kZXJlci5wcm90b3R5cGUuZHJhd01lc2ggPSBmdW5jdGlvbiAoZnJhbWVDdHgsIG1lc2gpIHtcblxuICAgIGlmICghdGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhUZXh0dXJlVW5pdHMgPSBXRUJHTF9JTkZPLk1BWF9URVhUVVJFX1VOSVRTO1xuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG1lc2guX21hdGVyaWFsO1xuICAgIGNvbnN0IGdsID0gc2NlbmUuY2FudmFzLmdsO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIGNvbnN0IG1lc2hTdGF0ZSA9IG1lc2guX3N0YXRlO1xuICAgIGNvbnN0IG1hdGVyaWFsU3RhdGUgPSBtZXNoLl9tYXRlcmlhbC5fc3RhdGU7XG4gICAgY29uc3QgZ2VvbWV0cnlTdGF0ZSA9IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZTtcbiAgICBjb25zdCBjYW1lcmEgPSBzY2VuZS5jYW1lcmE7XG4gICAgY29uc3QgcnRjQ2VudGVyID0gbWVzaC5ydGNDZW50ZXI7XG5cbiAgICBpZiAoZnJhbWVDdHgubGFzdFByb2dyYW1JZCAhPT0gdGhpcy5fcHJvZ3JhbS5pZCkge1xuICAgICAgICBmcmFtZUN0eC5sYXN0UHJvZ3JhbUlkID0gdGhpcy5fcHJvZ3JhbS5pZDtcbiAgICAgICAgdGhpcy5fYmluZFByb2dyYW0oZnJhbWVDdHgpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVZpZXdNYXRyaXgsIGZhbHNlLCBydGNDZW50ZXIgPyBmcmFtZUN0eC5nZXRSVENWaWV3TWF0cml4KG1lc2hTdGF0ZS5ydGNDZW50ZXJIYXNoLCBydGNDZW50ZXIpIDogY2FtZXJhLnZpZXdNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVZpZXdOb3JtYWxNYXRyaXgsIGZhbHNlLCBjYW1lcmEudmlld05vcm1hbE1hdHJpeCk7XG5cbiAgICBpZiAobWVzaFN0YXRlLmNsaXBwYWJsZSkge1xuICAgICAgICBjb25zdCBudW1TZWN0aW9uUGxhbmVzID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlY3Rpb25QbGFuZXMgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmVzID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyRmxhZ3MgPSBtZXNoLnJlbmRlckZsYWdzO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvblBsYW5lSW5kZXggPSAwOyBzZWN0aW9uUGxhbmVJbmRleCA8IG51bVNlY3Rpb25QbGFuZXM7IHNlY3Rpb25QbGFuZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmVVbmlmb3JtcyA9IHRoaXMuX3VTZWN0aW9uUGxhbmVzW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSByZW5kZXJGbGFncy5zZWN0aW9uUGxhbmVzQWN0aXZlUGVyTGF5ZXJbc2VjdGlvblBsYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzZWN0aW9uUGxhbmVVbmlmb3Jtcy5hY3RpdmUsIGFjdGl2ZSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25QbGFuZSA9IHNlY3Rpb25QbGFuZXNbc2VjdGlvblBsYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLnBvcywgcnRjQ2VudGVyID8gZ2V0UGxhbmVSVENQb3Moc2VjdGlvblBsYW5lLmRpc3QsIHNlY3Rpb25QbGFuZS5kaXIsIHJ0Y0NlbnRlciwgdGVtcFZlYzNhKSA6IHNlY3Rpb25QbGFuZS5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLmRpciwgc2VjdGlvblBsYW5lLmRpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuaWQgIT09IHRoaXMuX2xhc3RNYXRlcmlhbElkKSB7XG5cbiAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSB0aGlzLl9iYXNlVGV4dHVyZVVuaXQ7XG5cbiAgICAgICAgY29uc3QgYmFja2ZhY2VzID0gbWF0ZXJpYWxTdGF0ZS5iYWNrZmFjZXM7XG4gICAgICAgIGlmIChmcmFtZUN0eC5iYWNrZmFjZXMgIT09IGJhY2tmYWNlcykge1xuICAgICAgICAgICAgaWYgKGJhY2tmYWNlcykge1xuICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUN0eC5iYWNrZmFjZXMgPSBiYWNrZmFjZXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcm9udGZhY2UgPSBtYXRlcmlhbFN0YXRlLmZyb250ZmFjZTtcbiAgICAgICAgaWYgKGZyYW1lQ3R4LmZyb250ZmFjZSAhPT0gZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICBpZiAoZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZShnbC5DVyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUN0eC5mcm9udGZhY2UgPSBmcm9udGZhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhbWVDdHgubGluZVdpZHRoICE9PSBtYXRlcmlhbFN0YXRlLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgZ2wubGluZVdpZHRoKG1hdGVyaWFsU3RhdGUubGluZVdpZHRoKTtcbiAgICAgICAgICAgIGZyYW1lQ3R4LmxpbmVXaWR0aCA9IG1hdGVyaWFsU3RhdGUubGluZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3VQb2ludFNpemUpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91UG9pbnRTaXplLCBtYXRlcmlhbFN0YXRlLnBvaW50U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1hdGVyaWFsU3RhdGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkxhbWJlcnRNYXRlcmlhbFwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxBbWJpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdU1hdGVyaWFsQW1iaWVudCwgbWF0ZXJpYWxTdGF0ZS5hbWJpZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLl91TWF0ZXJpYWxDb2xvciwgbWF0ZXJpYWxTdGF0ZS5jb2xvclswXSwgbWF0ZXJpYWxTdGF0ZS5jb2xvclsxXSwgbWF0ZXJpYWxTdGF0ZS5jb2xvclsyXSwgbWF0ZXJpYWxTdGF0ZS5hbHBoYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxFbWlzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VNYXRlcmlhbEVtaXNzaXZlLCBtYXRlcmlhbFN0YXRlLmVtaXNzaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJQaG9uZ01hdGVyaWFsXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbFNoaW5pbmVzcykge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdU1hdGVyaWFsU2hpbmluZXNzLCBtYXRlcmlhbFN0YXRlLnNoaW5pbmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxBbWJpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdU1hdGVyaWFsQW1iaWVudCwgbWF0ZXJpYWxTdGF0ZS5hbWJpZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbERpZmZ1c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91TWF0ZXJpYWxEaWZmdXNlLCBtYXRlcmlhbFN0YXRlLmRpZmZ1c2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU1hdGVyaWFsU3BlY3VsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91TWF0ZXJpYWxTcGVjdWxhciwgbWF0ZXJpYWxTdGF0ZS5zcGVjdWxhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxFbWlzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VNYXRlcmlhbEVtaXNzaXZlLCBtYXRlcmlhbFN0YXRlLmVtaXNzaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VBbHBoYU1vZGVDdXRvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhTW9kZUN1dG9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgIDEuMCAqIG1hdGVyaWFsU3RhdGUuYWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbFN0YXRlLmFscGhhTW9kZSA9PT0gMSA/IDEuMCA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsU3RhdGUuYWxwaGFDdXRvZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9hbWJpZW50TWFwICYmIG1hdGVyaWFsLl9hbWJpZW50TWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VNYXRlcmlhbEFtYmllbnRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91TWF0ZXJpYWxBbWJpZW50TWFwLCBtYXRlcmlhbC5fYW1iaWVudE1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU1hdGVyaWFsQW1iaWVudE1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91TWF0ZXJpYWxBbWJpZW50TWFwTWF0cml4LCBmYWxzZSwgbWF0ZXJpYWwuX2FtYmllbnRNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9kaWZmdXNlTWFwICYmIG1hdGVyaWFsLl9kaWZmdXNlTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VEaWZmdXNlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdURpZmZ1c2VNYXAsIG1hdGVyaWFsLl9kaWZmdXNlTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91RGlmZnVzZU1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91RGlmZnVzZU1hcE1hdHJpeCwgZmFsc2UsIG1hdGVyaWFsLl9kaWZmdXNlTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fc3BlY3VsYXJNYXAgJiYgbWF0ZXJpYWwuX3NwZWN1bGFyTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VTcGVjdWxhck1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VTcGVjdWxhck1hcCwgbWF0ZXJpYWwuX3NwZWN1bGFyTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91U3BlY3VsYXJNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVNwZWN1bGFyTWFwTWF0cml4LCBmYWxzZSwgbWF0ZXJpYWwuX3NwZWN1bGFyTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fZW1pc3NpdmVNYXAgJiYgbWF0ZXJpYWwuX2VtaXNzaXZlTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VFbWlzc2l2ZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VFbWlzc2l2ZU1hcCwgbWF0ZXJpYWwuX2VtaXNzaXZlTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91RW1pc3NpdmVNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdUVtaXNzaXZlTWFwTWF0cml4LCBmYWxzZSwgbWF0ZXJpYWwuX2VtaXNzaXZlTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFNYXAgJiYgbWF0ZXJpYWwuX2FscGhhTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VBbHBoYU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VBbHBoYU1hcCwgbWF0ZXJpYWwuX2FscGhhTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91QWxwaGFNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdUFscGhhTWFwTWF0cml4LCBmYWxzZSwgbWF0ZXJpYWwuX2FscGhhTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fcmVmbGVjdGl2aXR5TWFwICYmIG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdVJlZmxlY3Rpdml0eU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VSZWZsZWN0aXZpdHlNYXAsIG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlNYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VSZWZsZWN0aXZpdHlNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVJlZmxlY3Rpdml0eU1hcE1hdHJpeCwgZmFsc2UsIG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9ub3JtYWxNYXAgJiYgbWF0ZXJpYWwuX25vcm1hbE1hcC5fc3RhdGUudGV4dHVyZSAmJiB0aGlzLl91Tm9ybWFsTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdU5vcm1hbE1hcCwgbWF0ZXJpYWwuX25vcm1hbE1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU5vcm1hbE1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91Tm9ybWFsTWFwTWF0cml4LCBmYWxzZSwgbWF0ZXJpYWwuX25vcm1hbE1hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwuX29jY2x1c2lvbk1hcCAmJiBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VPY2NsdXNpb25NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91T2NjbHVzaW9uTWFwLCBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91T2NjbHVzaW9uTWFwTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VPY2NsdXNpb25NYXBNYXRyaXgsIGZhbHNlLCBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fZGlmZnVzZUZyZXNuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VEaWZmdXNlRnJlc25lbEVkZ2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdURpZmZ1c2VGcmVzbmVsRWRnZUJpYXMsIG1hdGVyaWFsLl9kaWZmdXNlRnJlc25lbC5lZGdlQmlhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VEaWZmdXNlRnJlc25lbENlbnRlckJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91RGlmZnVzZUZyZXNuZWxDZW50ZXJCaWFzLCBtYXRlcmlhbC5fZGlmZnVzZUZyZXNuZWwuY2VudGVyQmlhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VEaWZmdXNlRnJlc25lbEVkZ2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91RGlmZnVzZUZyZXNuZWxFZGdlQ29sb3IsIG1hdGVyaWFsLl9kaWZmdXNlRnJlc25lbC5lZGdlQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91RGlmZnVzZUZyZXNuZWxDZW50ZXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91RGlmZnVzZUZyZXNuZWxDZW50ZXJDb2xvciwgbWF0ZXJpYWwuX2RpZmZ1c2VGcmVzbmVsLmNlbnRlckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdURpZmZ1c2VGcmVzbmVsUG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91RGlmZnVzZUZyZXNuZWxQb3dlciwgbWF0ZXJpYWwuX2RpZmZ1c2VGcmVzbmVsLnBvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwuX3NwZWN1bGFyRnJlc25lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVNwZWN1bGFyRnJlc25lbEVkZ2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdVNwZWN1bGFyRnJlc25lbEVkZ2VCaWFzLCBtYXRlcmlhbC5fc3BlY3VsYXJGcmVzbmVsLmVkZ2VCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVNwZWN1bGFyRnJlc25lbENlbnRlckJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91U3BlY3VsYXJGcmVzbmVsQ2VudGVyQmlhcywgbWF0ZXJpYWwuX3NwZWN1bGFyRnJlc25lbC5jZW50ZXJCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVNwZWN1bGFyRnJlc25lbEVkZ2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91U3BlY3VsYXJGcmVzbmVsRWRnZUNvbG9yLCBtYXRlcmlhbC5fc3BlY3VsYXJGcmVzbmVsLmVkZ2VDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VTcGVjdWxhckZyZXNuZWxDZW50ZXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91U3BlY3VsYXJGcmVzbmVsQ2VudGVyQ29sb3IsIG1hdGVyaWFsLl9zcGVjdWxhckZyZXNuZWwuY2VudGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91U3BlY3VsYXJGcmVzbmVsUG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91U3BlY3VsYXJGcmVzbmVsUG93ZXIsIG1hdGVyaWFsLl9zcGVjdWxhckZyZXNuZWwucG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFGcmVzbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91QWxwaGFGcmVzbmVsRWRnZUJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91QWxwaGFGcmVzbmVsRWRnZUJpYXMsIG1hdGVyaWFsLl9hbHBoYUZyZXNuZWwuZWRnZUJpYXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91QWxwaGFGcmVzbmVsQ2VudGVyQmlhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VBbHBoYUZyZXNuZWxDZW50ZXJCaWFzLCBtYXRlcmlhbC5fYWxwaGFGcmVzbmVsLmNlbnRlckJpYXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91QWxwaGFGcmVzbmVsRWRnZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VBbHBoYUZyZXNuZWxFZGdlQ29sb3IsIG1hdGVyaWFsLl9hbHBoYUZyZXNuZWwuZWRnZUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUFscGhhRnJlc25lbENlbnRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VBbHBoYUZyZXNuZWxDZW50ZXJDb2xvciwgbWF0ZXJpYWwuX2FscGhhRnJlc25lbC5jZW50ZXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VBbHBoYUZyZXNuZWxQb3dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VBbHBoYUZyZXNuZWxQb3dlciwgbWF0ZXJpYWwuX2FscGhhRnJlc25lbC5wb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlGcmVzbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbEVkZ2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdVJlZmxlY3Rpdml0eUZyZXNuZWxFZGdlQmlhcywgbWF0ZXJpYWwuX3JlZmxlY3Rpdml0eUZyZXNuZWwuZWRnZUJpYXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbENlbnRlckJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbENlbnRlckJpYXMsIG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlGcmVzbmVsLmNlbnRlckJpYXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbEVkZ2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbEVkZ2VDb2xvciwgbWF0ZXJpYWwuX3JlZmxlY3Rpdml0eUZyZXNuZWwuZWRnZUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVJlZmxlY3Rpdml0eUZyZXNuZWxDZW50ZXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbENlbnRlckNvbG9yLCBtYXRlcmlhbC5fcmVmbGVjdGl2aXR5RnJlc25lbC5jZW50ZXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VSZWZsZWN0aXZpdHlGcmVzbmVsUG93ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbFBvd2VyLCBtYXRlcmlhbC5fcmVmbGVjdGl2aXR5RnJlc25lbC5wb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9lbWlzc2l2ZUZyZXNuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VFbWlzc2l2ZUZyZXNuZWxFZGdlQmlhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VFbWlzc2l2ZUZyZXNuZWxFZGdlQmlhcywgbWF0ZXJpYWwuX2VtaXNzaXZlRnJlc25lbC5lZGdlQmlhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VFbWlzc2l2ZUZyZXNuZWxDZW50ZXJCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUVtaXNzaXZlRnJlc25lbENlbnRlckJpYXMsIG1hdGVyaWFsLl9lbWlzc2l2ZUZyZXNuZWwuY2VudGVyQmlhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VFbWlzc2l2ZUZyZXNuZWxFZGdlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdUVtaXNzaXZlRnJlc25lbEVkZ2VDb2xvciwgbWF0ZXJpYWwuX2VtaXNzaXZlRnJlc25lbC5lZGdlQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91RW1pc3NpdmVGcmVzbmVsQ2VudGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdUVtaXNzaXZlRnJlc25lbENlbnRlckNvbG9yLCBtYXRlcmlhbC5fZW1pc3NpdmVGcmVzbmVsLmNlbnRlckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUVtaXNzaXZlRnJlc25lbFBvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUVtaXNzaXZlRnJlc25lbFBvd2VyLCBtYXRlcmlhbC5fZW1pc3NpdmVGcmVzbmVsLnBvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIk1ldGFsbGljTWF0ZXJpYWxcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUJhc2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VCYXNlQ29sb3IsIG1hdGVyaWFsU3RhdGUuYmFzZUNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbE1ldGFsbGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91TWF0ZXJpYWxNZXRhbGxpYywgbWF0ZXJpYWxTdGF0ZS5tZXRhbGxpYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxSb3VnaG5lc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VNYXRlcmlhbFJvdWdobmVzcywgbWF0ZXJpYWxTdGF0ZS5yb3VnaG5lc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU1hdGVyaWFsU3BlY3VsYXJGMCkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdU1hdGVyaWFsU3BlY3VsYXJGMCwgbWF0ZXJpYWxTdGF0ZS5zcGVjdWxhckYwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbEVtaXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdU1hdGVyaWFsRW1pc3NpdmUsIG1hdGVyaWFsU3RhdGUuZW1pc3NpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUFscGhhTW9kZUN1dG9mZikge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGYoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91QWxwaGFNb2RlQ3V0b2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgMS4wICogbWF0ZXJpYWxTdGF0ZS5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsU3RhdGUuYWxwaGFNb2RlID09PSAxID8gMS4wIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxTdGF0ZS5hbHBoYUN1dG9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VDb2xvck1hcCA9IG1hdGVyaWFsLl9iYXNlQ29sb3JNYXA7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VDb2xvck1hcCAmJiBiYXNlQ29sb3JNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdUJhc2VDb2xvck1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VCYXNlQ29sb3JNYXAsIGJhc2VDb2xvck1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUJhc2VDb2xvck1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91QmFzZUNvbG9yTWFwTWF0cml4LCBmYWxzZSwgYmFzZUNvbG9yTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFsbGljTWFwID0gbWF0ZXJpYWwuX21ldGFsbGljTWFwO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhbGxpY01hcCAmJiBtZXRhbGxpY01hcC5fc3RhdGUudGV4dHVyZSAmJiB0aGlzLl91TWV0YWxsaWNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91TWV0YWxsaWNNYXAsIG1ldGFsbGljTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWV0YWxsaWNNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1ldGFsbGljTWFwTWF0cml4LCBmYWxzZSwgbWV0YWxsaWNNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91Z2huZXNzTWFwID0gbWF0ZXJpYWwuX3JvdWdobmVzc01hcDtcbiAgICAgICAgICAgICAgICBpZiAocm91Z2huZXNzTWFwICYmIHJvdWdobmVzc01hcC5fc3RhdGUudGV4dHVyZSAmJiB0aGlzLl91Um91Z2huZXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdVJvdWdobmVzc01hcCwgcm91Z2huZXNzTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91Um91Z2huZXNzTWFwTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VSb3VnaG5lc3NNYXBNYXRyaXgsIGZhbHNlLCByb3VnaG5lc3NNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3NNYXAgPSBtYXRlcmlhbC5fbWV0YWxsaWNSb3VnaG5lc3NNYXA7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzTWFwICYmIG1ldGFsbGljUm91Z2huZXNzTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VNZXRhbGxpY1JvdWdobmVzc01hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VNZXRhbGxpY1JvdWdobmVzc01hcCwgbWV0YWxsaWNSb3VnaG5lc3NNYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZFRleHR1cmUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNZXRhbGxpY1JvdWdobmVzc01hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91TWV0YWxsaWNSb3VnaG5lc3NNYXBNYXRyaXgsIGZhbHNlLCBtZXRhbGxpY1JvdWdobmVzc01hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW1pc3NpdmVNYXAgPSBtYXRlcmlhbC5fZW1pc3NpdmVNYXA7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXNzaXZlTWFwICYmIGVtaXNzaXZlTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VFbWlzc2l2ZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VFbWlzc2l2ZU1hcCwgZW1pc3NpdmVNYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZFRleHR1cmUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VFbWlzc2l2ZU1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91RW1pc3NpdmVNYXBNYXRyaXgsIGZhbHNlLCBlbWlzc2l2ZU1hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb2NjbHVzaW9uTWFwID0gbWF0ZXJpYWwuX29jY2x1c2lvbk1hcDtcbiAgICAgICAgICAgICAgICBpZiAob2NjbHVzaW9uTWFwICYmIG1hdGVyaWFsLl9vY2NsdXNpb25NYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdU9jY2x1c2lvbk1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VPY2NsdXNpb25NYXAsIG9jY2x1c2lvbk1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU9jY2x1c2lvbk1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91T2NjbHVzaW9uTWFwTWF0cml4LCBmYWxzZSwgb2NjbHVzaW9uTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbHBoYU1hcCA9IG1hdGVyaWFsLl9hbHBoYU1hcDtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGFNYXAgJiYgYWxwaGFNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdUFscGhhTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdUFscGhhTWFwLCBhbHBoYU1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUFscGhhTWFwTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VBbHBoYU1hcE1hdHJpeCwgZmFsc2UsIGFscGhhTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxNYXAgPSBtYXRlcmlhbC5fbm9ybWFsTWFwO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxNYXAgJiYgbm9ybWFsTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VOb3JtYWxNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91Tm9ybWFsTWFwLCBub3JtYWxNYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZFRleHR1cmUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VOb3JtYWxNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU5vcm1hbE1hcE1hdHJpeCwgZmFsc2UsIG5vcm1hbE1hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIlNwZWN1bGFyTWF0ZXJpYWxcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU1hdGVyaWFsRGlmZnVzZSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VNYXRlcmlhbERpZmZ1c2UsIG1hdGVyaWFsU3RhdGUuZGlmZnVzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxTcGVjdWxhcikge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VNYXRlcmlhbFNwZWN1bGFyLCBtYXRlcmlhbFN0YXRlLnNwZWN1bGFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VNYXRlcmlhbEdsb3NzaW5lc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VNYXRlcmlhbEdsb3NzaW5lc3MsIG1hdGVyaWFsU3RhdGUuZ2xvc3NpbmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TWF0ZXJpYWxSZWZsZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VNYXRlcmlhbFJlZmxlY3Rpdml0eSwgbWF0ZXJpYWxTdGF0ZS5yZWZsZWN0aXZpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdU1hdGVyaWFsRW1pc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91TWF0ZXJpYWxFbWlzc2l2ZSwgbWF0ZXJpYWxTdGF0ZS5lbWlzc2l2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91QWxwaGFNb2RlQ3V0b2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00ZihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VBbHBoYU1vZGVDdXRvZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLjAgKiBtYXRlcmlhbFN0YXRlLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxTdGF0ZS5hbHBoYU1vZGUgPT09IDEgPyAxLjAgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbFN0YXRlLmFscGhhQ3V0b2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZnVzZU1hcCA9IG1hdGVyaWFsLl9kaWZmdXNlTWFwO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmdXNlTWFwICYmIGRpZmZ1c2VNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdURpZmZ1c2VNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91RGlmZnVzZU1hcCwgZGlmZnVzZU1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdURpZmZ1c2VNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdURpZmZ1c2VNYXBNYXRyaXgsIGZhbHNlLCBkaWZmdXNlTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWN1bGFyTWFwID0gbWF0ZXJpYWwuX3NwZWN1bGFyTWFwO1xuICAgICAgICAgICAgICAgIGlmIChzcGVjdWxhck1hcCAmJiBzcGVjdWxhck1hcC5fc3RhdGUudGV4dHVyZSAmJiB0aGlzLl91U3BlY3VsYXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91U3BlY3VsYXJNYXAsIHNwZWN1bGFyTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91U3BlY3VsYXJNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVNwZWN1bGFyTWFwTWF0cml4LCBmYWxzZSwgc3BlY3VsYXJNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvc3NpbmVzc01hcCA9IG1hdGVyaWFsLl9nbG9zc2luZXNzTWFwO1xuICAgICAgICAgICAgICAgIGlmIChnbG9zc2luZXNzTWFwICYmIGdsb3NzaW5lc3NNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdUdsb3NzaW5lc3NNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91R2xvc3NpbmVzc01hcCwgZ2xvc3NpbmVzc01hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUdsb3NzaW5lc3NNYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdUdsb3NzaW5lc3NNYXBNYXRyaXgsIGZhbHNlLCBnbG9zc2luZXNzTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWN1bGFyR2xvc3NpbmVzc01hcCA9IG1hdGVyaWFsLl9zcGVjdWxhckdsb3NzaW5lc3NNYXA7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWN1bGFyR2xvc3NpbmVzc01hcCAmJiBzcGVjdWxhckdsb3NzaW5lc3NNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdVNwZWN1bGFyR2xvc3NpbmVzc01hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VTcGVjdWxhckdsb3NzaW5lc3NNYXAsIHNwZWN1bGFyR2xvc3NpbmVzc01hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVNwZWN1bGFyR2xvc3NpbmVzc01hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91U3BlY3VsYXJHbG9zc2luZXNzTWFwTWF0cml4LCBmYWxzZSwgc3BlY3VsYXJHbG9zc2luZXNzTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbWlzc2l2ZU1hcCA9IG1hdGVyaWFsLl9lbWlzc2l2ZU1hcDtcbiAgICAgICAgICAgICAgICBpZiAoZW1pc3NpdmVNYXAgJiYgZW1pc3NpdmVNYXAuX3N0YXRlLnRleHR1cmUgJiYgdGhpcy5fdUVtaXNzaXZlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdUVtaXNzaXZlTWFwLCBlbWlzc2l2ZU1hcC5fc3RhdGUudGV4dHVyZSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdUVtaXNzaXZlTWFwTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VFbWlzc2l2ZU1hcE1hdHJpeCwgZmFsc2UsIGVtaXNzaXZlTWFwLl9zdGF0ZS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvY2NsdXNpb25NYXAgPSBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwO1xuICAgICAgICAgICAgICAgIGlmIChvY2NsdXNpb25NYXAgJiYgb2NjbHVzaW9uTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VPY2NsdXNpb25NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91T2NjbHVzaW9uTWFwLCBvY2NsdXNpb25NYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZFRleHR1cmUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VPY2NsdXNpb25NYXBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU9jY2x1c2lvbk1hcE1hdHJpeCwgZmFsc2UsIG9jY2x1c2lvbk1hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWxwaGFNYXAgPSBtYXRlcmlhbC5fYWxwaGFNYXA7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhTWFwICYmIGFscGhhTWFwLl9zdGF0ZS50ZXh0dXJlICYmIHRoaXMuX3VBbHBoYU1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VBbHBoYU1hcCwgYWxwaGFNYXAuX3N0YXRlLnRleHR1cmUsIGZyYW1lQ3R4LnRleHR1cmVVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAoZnJhbWVDdHgudGV4dHVyZVVuaXQgKyAxKSAlIG1heFRleHR1cmVVbml0cztcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZFRleHR1cmUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VBbHBoYU1hcE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91QWxwaGFNYXBNYXRyaXgsIGZhbHNlLCBhbHBoYU1hcC5fc3RhdGUubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsTWFwID0gbWF0ZXJpYWwuX25vcm1hbE1hcDtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsTWFwICYmIG5vcm1hbE1hcC5fc3RhdGUudGV4dHVyZSAmJiB0aGlzLl91Tm9ybWFsTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZFRleHR1cmUodGhpcy5fdU5vcm1hbE1hcCwgbm9ybWFsTWFwLl9zdGF0ZS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl91Tm9ybWFsTWFwTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VOb3JtYWxNYXBNYXRyaXgsIGZhbHNlLCBub3JtYWxNYXAuX3N0YXRlLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBtYXRlcmlhbFN0YXRlLmlkO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTWF0cml4LCBnbC5GQUxTRSwgbWVzaC53b3JsZE1hdHJpeCk7XG4gICAgaWYgKHRoaXMuX3VNb2RlbE5vcm1hbE1hdHJpeCkge1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VNb2RlbE5vcm1hbE1hdHJpeCwgZ2wuRkFMU0UsIG1lc2gud29ybGROb3JtYWxNYXRyaXgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl91Q2xpcHBhYmxlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaSh0aGlzLl91Q2xpcHBhYmxlLCBtZXNoU3RhdGUuY2xpcHBhYmxlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdUNvbG9yaXplKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yaXplID0gbWVzaFN0YXRlLmNvbG9yaXplO1xuICAgICAgICBjb25zdCBsYXN0Q29sb3JpemUgPSB0aGlzLl9sYXN0Q29sb3JpemU7XG4gICAgICAgIGlmIChsYXN0Q29sb3JpemVbMF0gIT09IGNvbG9yaXplWzBdIHx8XG4gICAgICAgICAgICBsYXN0Q29sb3JpemVbMV0gIT09IGNvbG9yaXplWzFdIHx8XG4gICAgICAgICAgICBsYXN0Q29sb3JpemVbMl0gIT09IGNvbG9yaXplWzJdIHx8XG4gICAgICAgICAgICBsYXN0Q29sb3JpemVbM10gIT09IGNvbG9yaXplWzNdKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KHRoaXMuX3VDb2xvcml6ZSwgY29sb3JpemUpO1xuICAgICAgICAgICAgbGFzdENvbG9yaXplWzBdID0gY29sb3JpemVbMF07XG4gICAgICAgICAgICBsYXN0Q29sb3JpemVbMV0gPSBjb2xvcml6ZVsxXTtcbiAgICAgICAgICAgIGxhc3RDb2xvcml6ZVsyXSA9IGNvbG9yaXplWzJdO1xuICAgICAgICAgICAgbGFzdENvbG9yaXplWzNdID0gY29sb3JpemVbM107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VPZmZzZXQsIG1lc2hTdGF0ZS5vZmZzZXQpO1xuXG4gICAgLy8gQmluZCBWQk9zXG5cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pZCAhPT0gdGhpcy5fbGFzdEdlb21ldHJ5SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCwgZmFsc2UsIGdlb21ldHJ5U3RhdGUucG9zaXRpb25zRGVjb2RlTWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdVVWRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuX3VVVkRlY29kZU1hdHJpeCwgZmFsc2UsIGdlb21ldHJ5U3RhdGUudXZEZWNvZGVNYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FQb3NpdGlvbi5iaW5kQXJyYXlCdWZmZXIoZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnNCdWYpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FOb3JtYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FOb3JtYWwuYmluZEFycmF5QnVmZmVyKGdlb21ldHJ5U3RhdGUubm9ybWFsc0J1Zik7XG4gICAgICAgICAgICBmcmFtZUN0eC5iaW5kQXJyYXkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYVVWKSB7XG4gICAgICAgICAgICB0aGlzLl9hVVYuYmluZEFycmF5QnVmZmVyKGdlb21ldHJ5U3RhdGUudXZCdWYpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fYUNvbG9yLmJpbmRBcnJheUJ1ZmZlcihnZW9tZXRyeVN0YXRlLmNvbG9yc0J1Zik7XG4gICAgICAgICAgICBmcmFtZUN0eC5iaW5kQXJyYXkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYUZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9hRmxhZ3MuYmluZEFycmF5QnVmZmVyKGdlb21ldHJ5U3RhdGUuZmxhZ3NCdWYpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zikge1xuICAgICAgICAgICAgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLmJpbmQoKTtcbiAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRBcnJheSsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RHZW9tZXRyeUlkID0gZ2VvbWV0cnlTdGF0ZS5pZDtcbiAgICB9XG5cbiAgICAvLyBEcmF3IChpbmRpY2VzIGJvdW5kIGluIHByZXYgc3RlcClcblxuICAgIGlmIChnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYpIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlLCBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYubnVtSXRlbXMsIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zi5pdGVtVHlwZSwgMCk7XG4gICAgICAgIGZyYW1lQ3R4LmRyYXdFbGVtZW50cysrO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnMpIHtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGdlb21ldHJ5U3RhdGUucG9zaXRpb25zLm51bUl0ZW1zKTtcbiAgICAgICAgZnJhbWVDdHguZHJhd0FycmF5cysrO1xuICAgIH1cbn07XG5cbkRyYXdSZW5kZXJlci5wcm90b3R5cGUuX2FsbG9jYXRlID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBtZXNoLl9tYXRlcmlhbDtcbiAgICBjb25zdCBsaWdodHNTdGF0ZSA9IHNjZW5lLl9saWdodHNTdGF0ZTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzU3RhdGUgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlO1xuICAgIGNvbnN0IG1hdGVyaWFsU3RhdGUgPSBtZXNoLl9tYXRlcmlhbC5fc3RhdGU7XG5cbiAgICB0aGlzLl9wcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHRoaXMuX3NoYWRlclNvdXJjZSk7XG4gICAgaWYgKHRoaXMuX3Byb2dyYW0uZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5fcHJvZ3JhbS5lcnJvcnM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX3Byb2dyYW07XG4gICAgdGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJwb3NpdGlvbnNEZWNvZGVNYXRyaXhcIik7XG4gICAgdGhpcy5fdVVWRGVjb2RlTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInV2RGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91TW9kZWxOb3JtYWxNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibW9kZWxOb3JtYWxNYXRyaXhcIik7XG4gICAgdGhpcy5fdVZpZXdNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwidmlld01hdHJpeFwiKTtcbiAgICB0aGlzLl91Vmlld05vcm1hbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJ2aWV3Tm9ybWFsTWF0cml4XCIpO1xuICAgIHRoaXMuX3VQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInByb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdUdhbW1hRmFjdG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImdhbW1hRmFjdG9yXCIpO1xuICAgIHRoaXMuX3VMaWdodEFtYmllbnQgPSBbXTtcbiAgICB0aGlzLl91TGlnaHRDb2xvciA9IFtdO1xuICAgIHRoaXMuX3VMaWdodERpciA9IFtdO1xuICAgIHRoaXMuX3VMaWdodFBvcyA9IFtdO1xuICAgIHRoaXMuX3VMaWdodEF0dGVudWF0aW9uID0gW107XG4gICAgdGhpcy5fdVNoYWRvd1ZpZXdNYXRyaXggPSBbXTtcbiAgICB0aGlzLl91U2hhZG93UHJvak1hdHJpeCA9IFtdO1xuXG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX3VMb2dEZXB0aEJ1ZkZDID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImxvZ0RlcHRoQnVmRkNcIik7XG4gICAgfVxuXG4gICAgY29uc3QgbGlnaHRzID0gbGlnaHRzU3RhdGUubGlnaHRzO1xuICAgIGxldCBsaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaWdodHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGlnaHQgPSBsaWdodHNbaV07XG4gICAgICAgIHN3aXRjaCAobGlnaHQudHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlIFwiYW1iaWVudFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VMaWdodEFtYmllbnRbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRBbWJpZW50XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0Q29sb3JbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRDb2xvclwiICsgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0UG9zW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHREaXJbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHREaXJcIiArIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHRDb2xvcltpXSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsaWdodENvbG9yXCIgKyBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHRQb3NbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRQb3NcIiArIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VMaWdodERpcltpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0QXR0ZW51YXRpb25baV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRBdHRlbnVhdGlvblwiICsgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0Q29sb3JbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRDb2xvclwiICsgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0UG9zW2ldID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImxpZ2h0UG9zXCIgKyBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHREaXJbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHREaXJcIiArIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VMaWdodEF0dGVudWF0aW9uW2ldID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImxpZ2h0QXR0ZW51YXRpb25cIiArIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpZ2h0LmNhc3RzU2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLl91U2hhZG93Vmlld01hdHJpeFtpXSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzaGFkb3dWaWV3TWF0cml4XCIgKyBpKTtcbiAgICAgICAgICAgIHRoaXMuX3VTaGFkb3dQcm9qTWF0cml4W2ldID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNoYWRvd1Byb2pNYXRyaXhcIiArIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpZ2h0c1N0YXRlLmxpZ2h0TWFwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3VMaWdodE1hcCA9IFwibGlnaHRNYXBcIjtcbiAgICB9XG5cbiAgICBpZiAobGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl91UmVmbGVjdGlvbk1hcCA9IFwicmVmbGVjdGlvbk1hcFwiO1xuICAgIH1cblxuICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzID0gW107XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lcyA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzLnB1c2goe1xuICAgICAgICAgICAgYWN0aXZlOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpKSxcbiAgICAgICAgICAgIHBvczogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZVBvc1wiICsgaSksXG4gICAgICAgICAgICBkaXI6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVEaXJcIiArIGkpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VQb2ludFNpemUgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9pbnRTaXplXCIpO1xuXG4gICAgc3dpdGNoIChtYXRlcmlhbFN0YXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkxhbWJlcnRNYXRlcmlhbFwiOlxuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsQ29sb3IgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxDb2xvclwiKTtcbiAgICAgICAgICAgIHRoaXMuX3VNYXRlcmlhbEVtaXNzaXZlID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsRW1pc3NpdmVcIik7XG4gICAgICAgICAgICB0aGlzLl91QWxwaGFNb2RlQ3V0b2ZmID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsQWxwaGFNb2RlQ3V0b2ZmXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlBob25nTWF0ZXJpYWxcIjpcbiAgICAgICAgICAgIHRoaXMuX3VNYXRlcmlhbEFtYmllbnQgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxBbWJpZW50XCIpO1xuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsRGlmZnVzZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbERpZmZ1c2VcIik7XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxTcGVjdWxhciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbFNwZWN1bGFyXCIpO1xuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsRW1pc3NpdmUgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxFbWlzc2l2ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3VBbHBoYU1vZGVDdXRvZmYgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxBbHBoYU1vZGVDdXRvZmZcIik7XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxTaGluaW5lc3MgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxTaGluaW5lc3NcIik7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX2FtYmllbnRNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxBbWJpZW50TWFwID0gXCJhbWJpZW50TWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsQW1iaWVudE1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJhbWJpZW50TWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9kaWZmdXNlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdURpZmZ1c2VNYXAgPSBcImRpZmZ1c2VNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91RGlmZnVzZU1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJkaWZmdXNlTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9zcGVjdWxhck1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VTcGVjdWxhck1hcCA9IFwic3BlY3VsYXJNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91U3BlY3VsYXJNYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwic3BlY3VsYXJNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX2VtaXNzaXZlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUVtaXNzaXZlTWFwID0gXCJlbWlzc2l2ZU1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VFbWlzc2l2ZU1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJlbWlzc2l2ZU1hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91QWxwaGFNYXAgPSBcImFscGhhTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImFscGhhTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91UmVmbGVjdGl2aXR5TWFwID0gXCJyZWZsZWN0aXZpdHlNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91UmVmbGVjdGl2aXR5TWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInJlZmxlY3Rpdml0eU1hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fbm9ybWFsTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdU5vcm1hbE1hcCA9IFwibm9ybWFsTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdU5vcm1hbE1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJub3JtYWxNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX29jY2x1c2lvbk1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VPY2NsdXNpb25NYXAgPSBcIm9jY2x1c2lvbk1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VPY2NsdXNpb25NYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwib2NjbHVzaW9uTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9kaWZmdXNlRnJlc25lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VEaWZmdXNlRnJlc25lbEVkZ2VCaWFzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImRpZmZ1c2VGcmVzbmVsRWRnZUJpYXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdURpZmZ1c2VGcmVzbmVsQ2VudGVyQmlhcyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJkaWZmdXNlRnJlc25lbENlbnRlckJpYXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdURpZmZ1c2VGcmVzbmVsRWRnZUNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImRpZmZ1c2VGcmVzbmVsRWRnZUNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VEaWZmdXNlRnJlc25lbENlbnRlckNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImRpZmZ1c2VGcmVzbmVsQ2VudGVyQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdURpZmZ1c2VGcmVzbmVsUG93ZXIgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZGlmZnVzZUZyZXNuZWxQb3dlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fc3BlY3VsYXJGcmVzbmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVNwZWN1bGFyRnJlc25lbEVkZ2VCaWFzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNwZWN1bGFyRnJlc25lbEVkZ2VCaWFzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VTcGVjdWxhckZyZXNuZWxDZW50ZXJCaWFzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNwZWN1bGFyRnJlc25lbENlbnRlckJpYXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVNwZWN1bGFyRnJlc25lbEVkZ2VDb2xvciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzcGVjdWxhckZyZXNuZWxFZGdlQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVNwZWN1bGFyRnJlc25lbENlbnRlckNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNwZWN1bGFyRnJlc25lbENlbnRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VTcGVjdWxhckZyZXNuZWxQb3dlciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzcGVjdWxhckZyZXNuZWxQb3dlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFGcmVzbmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhRnJlc25lbEVkZ2VCaWFzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImFscGhhRnJlc25lbEVkZ2VCaWFzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VBbHBoYUZyZXNuZWxDZW50ZXJCaWFzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImFscGhhRnJlc25lbENlbnRlckJpYXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhRnJlc25lbEVkZ2VDb2xvciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJhbHBoYUZyZXNuZWxFZGdlQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhRnJlc25lbENlbnRlckNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImFscGhhRnJlc25lbENlbnRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VBbHBoYUZyZXNuZWxQb3dlciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJhbHBoYUZyZXNuZWxQb3dlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fcmVmbGVjdGl2aXR5RnJlc25lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VSZWZsZWN0aXZpdHlGcmVzbmVsRWRnZUJpYXMgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicmVmbGVjdGl2aXR5RnJlc25lbEVkZ2VCaWFzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VSZWZsZWN0aXZpdHlGcmVzbmVsQ2VudGVyQmlhcyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJyZWZsZWN0aXZpdHlGcmVzbmVsQ2VudGVyQmlhc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91UmVmbGVjdGl2aXR5RnJlc25lbEVkZ2VDb2xvciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJyZWZsZWN0aXZpdHlGcmVzbmVsRWRnZUNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VSZWZsZWN0aXZpdHlGcmVzbmVsQ2VudGVyQ29sb3IgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicmVmbGVjdGl2aXR5RnJlc25lbENlbnRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VSZWZsZWN0aXZpdHlGcmVzbmVsUG93ZXIgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicmVmbGVjdGl2aXR5RnJlc25lbFBvd2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9lbWlzc2l2ZUZyZXNuZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91RW1pc3NpdmVGcmVzbmVsRWRnZUJpYXMgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZW1pc3NpdmVGcmVzbmVsRWRnZUJpYXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUVtaXNzaXZlRnJlc25lbENlbnRlckJpYXMgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZW1pc3NpdmVGcmVzbmVsQ2VudGVyQmlhc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91RW1pc3NpdmVGcmVzbmVsRWRnZUNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImVtaXNzaXZlRnJlc25lbEVkZ2VDb2xvclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91RW1pc3NpdmVGcmVzbmVsQ2VudGVyQ29sb3IgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZW1pc3NpdmVGcmVzbmVsQ2VudGVyQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUVtaXNzaXZlRnJlc25lbFBvd2VyID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImVtaXNzaXZlRnJlc25lbFBvd2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk1ldGFsbGljTWF0ZXJpYWxcIjpcbiAgICAgICAgICAgIHRoaXMuX3VCYXNlQ29sb3IgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxCYXNlQ29sb3JcIik7XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxNZXRhbGxpYyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbE1ldGFsbGljXCIpO1xuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsUm91Z2huZXNzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsUm91Z2huZXNzXCIpO1xuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsU3BlY3VsYXJGMCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbFNwZWN1bGFyRjBcIik7XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxFbWlzc2l2ZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbEVtaXNzaXZlXCIpO1xuICAgICAgICAgICAgdGhpcy5fdUFscGhhTW9kZUN1dG9mZiA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtYXRlcmlhbEFscGhhTW9kZUN1dG9mZlwiKTtcbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYmFzZUNvbG9yTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUJhc2VDb2xvck1hcCA9IFwiYmFzZUNvbG9yTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUJhc2VDb2xvck1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJiYXNlQ29sb3JNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX21ldGFsbGljTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdU1ldGFsbGljTWFwID0gXCJtZXRhbGxpY01hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VNZXRhbGxpY01hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtZXRhbGxpY01hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fcm91Z2huZXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVJvdWdobmVzc01hcCA9IFwicm91Z2huZXNzTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVJvdWdobmVzc01hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJyb3VnaG5lc3NNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX21ldGFsbGljUm91Z2huZXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdU1ldGFsbGljUm91Z2huZXNzTWFwID0gXCJtZXRhbGxpY1JvdWdobmVzc01hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VNZXRhbGxpY1JvdWdobmVzc01hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtZXRhbGxpY1JvdWdobmVzc01hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fZW1pc3NpdmVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91RW1pc3NpdmVNYXAgPSBcImVtaXNzaXZlTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUVtaXNzaXZlTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImVtaXNzaXZlTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9vY2NsdXNpb25NYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91T2NjbHVzaW9uTWFwID0gXCJvY2NsdXNpb25NYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91T2NjbHVzaW9uTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm9jY2x1c2lvbk1hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91QWxwaGFNYXAgPSBcImFscGhhTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUFscGhhTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImFscGhhTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9ub3JtYWxNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91Tm9ybWFsTWFwID0gXCJub3JtYWxNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91Tm9ybWFsTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm5vcm1hbE1hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJTcGVjdWxhck1hdGVyaWFsXCI6XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxEaWZmdXNlID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsRGlmZnVzZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3VNYXRlcmlhbFNwZWN1bGFyID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsU3BlY3VsYXJcIik7XG4gICAgICAgICAgICB0aGlzLl91TWF0ZXJpYWxHbG9zc2luZXNzID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsR2xvc3NpbmVzc1wiKTtcbiAgICAgICAgICAgIHRoaXMuX3VNYXRlcmlhbFJlZmxlY3Rpdml0eSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJyZWZsZWN0aXZpdHlGcmVzbmVsXCIpO1xuICAgICAgICAgICAgdGhpcy5fdU1hdGVyaWFsRW1pc3NpdmUgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxFbWlzc2l2ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3VBbHBoYU1vZGVDdXRvZmYgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibWF0ZXJpYWxBbHBoYU1vZGVDdXRvZmZcIik7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX2RpZmZ1c2VNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91RGlmZnVzZU1hcCA9IFwiZGlmZnVzZU1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VEaWZmdXNlTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImRpZmZ1c2VNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX3NwZWN1bGFyTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVNwZWN1bGFyTWFwID0gXCJzcGVjdWxhck1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VTcGVjdWxhck1hcE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzcGVjdWxhck1hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fZ2xvc3NpbmVzc01hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VHbG9zc2luZXNzTWFwID0gXCJnbG9zc2luZXNzTWFwXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUdsb3NzaW5lc3NNYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZ2xvc3NpbmVzc01hcE1hdHJpeFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5fc3BlY3VsYXJHbG9zc2luZXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdVNwZWN1bGFyR2xvc3NpbmVzc01hcCA9IFwibWF0ZXJpYWxTcGVjdWxhckdsb3NzaW5lc3NNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91U3BlY3VsYXJHbG9zc2luZXNzTWFwTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm1hdGVyaWFsU3BlY3VsYXJHbG9zc2luZXNzTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9lbWlzc2l2ZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VFbWlzc2l2ZU1hcCA9IFwiZW1pc3NpdmVNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91RW1pc3NpdmVNYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZW1pc3NpdmVNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX29jY2x1c2lvbk1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VPY2NsdXNpb25NYXAgPSBcIm9jY2x1c2lvbk1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VPY2NsdXNpb25NYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwib2NjbHVzaW9uTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9hbHBoYU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VBbHBoYU1hcCA9IFwiYWxwaGFNYXBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl91QWxwaGFNYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiYWxwaGFNYXBNYXRyaXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX25vcm1hbE1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VOb3JtYWxNYXAgPSBcIm5vcm1hbE1hcFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VOb3JtYWxNYXBNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibm9ybWFsTWFwTWF0cml4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fYVBvc2l0aW9uID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgICB0aGlzLl9hTm9ybWFsID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGUoXCJub3JtYWxcIik7XG4gICAgdGhpcy5fYVVWID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGUoXCJ1dlwiKTtcbiAgICB0aGlzLl9hQ29sb3IgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZShcImNvbG9yXCIpO1xuICAgIHRoaXMuX2FGbGFncyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlKFwiZmxhZ3NcIik7XG5cbiAgICB0aGlzLl91Q2xpcHBhYmxlID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImNsaXBwYWJsZVwiKTtcbiAgICB0aGlzLl91Q29sb3JpemUgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiY29sb3JpemVcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG5cbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZlcnRleEJ1ZnNJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xuXG4gICAgdGhpcy5fbGFzdENvbG9yaXplID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlVW5pdCA9IDA7XG5cbn07XG5cbkRyYXdSZW5kZXJlci5wcm90b3R5cGUuX2JpbmRQcm9ncmFtID0gZnVuY3Rpb24gKGZyYW1lQ3R4KSB7XG5cbiAgICBjb25zdCBtYXhUZXh0dXJlVW5pdHMgPSBXRUJHTF9JTkZPLk1BWF9URVhUVVJFX1VOSVRTO1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgbGlnaHRzU3RhdGUgPSBzY2VuZS5fbGlnaHRzU3RhdGU7XG4gICAgY29uc3QgcHJvamVjdCA9IHNjZW5lLmNhbWVyYS5wcm9qZWN0O1xuICAgIGxldCBsaWdodDtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuXG4gICAgcHJvZ3JhbS5iaW5kKCk7XG5cbiAgICBmcmFtZUN0eC51c2VQcm9ncmFtKys7XG4gICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAwO1xuXG4gICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RWZXJ0ZXhCdWZzSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RHZW9tZXRyeUlkID0gbnVsbDtcblxuICAgIHRoaXMuX2xhc3RDb2xvcml6ZVswXSA9IC0xO1xuICAgIHRoaXMuX2xhc3RDb2xvcml6ZVsxXSA9IC0xO1xuICAgIHRoaXMuX2xhc3RDb2xvcml6ZVsyXSA9IC0xO1xuICAgIHRoaXMuX2xhc3RDb2xvcml6ZVszXSA9IC0xO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91UHJvak1hdHJpeCwgZmFsc2UsIHByb2plY3QubWF0cml4KTtcblxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBsb2dEZXB0aEJ1ZkZDID0gMi4wIC8gKE1hdGgubG9nKHByb2plY3QuZmFyICsgMS4wKSAvIE1hdGguTE4yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VMb2dEZXB0aEJ1ZkZDLCBsb2dEZXB0aEJ1ZkZDKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgbGlnaHQgPSBsaWdodHNTdGF0ZS5saWdodHNbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuX3VMaWdodEFtYmllbnRbaV0pIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLl91TGlnaHRBbWJpZW50W2ldLCBsaWdodC5jb2xvclswXSwgbGlnaHQuY29sb3JbMV0sIGxpZ2h0LmNvbG9yWzJdLCBsaWdodC5pbnRlbnNpdHkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91TGlnaHRDb2xvcltpXSkge1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLl91TGlnaHRDb2xvcltpXSwgbGlnaHQuY29sb3JbMF0sIGxpZ2h0LmNvbG9yWzFdLCBsaWdodC5jb2xvclsyXSwgbGlnaHQuaW50ZW5zaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VMaWdodFBvc1tpXSkge1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdUxpZ2h0UG9zW2ldLCBsaWdodC5wb3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TGlnaHRBdHRlbnVhdGlvbltpXSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUxpZ2h0QXR0ZW51YXRpb25baV0sIGxpZ2h0LmF0dGVudWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91TGlnaHREaXJbaV0pIHtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VMaWdodERpcltpXSwgbGlnaHQuZGlyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpZ2h0LmNhc3RzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VTaGFkb3dWaWV3TWF0cml4W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVNoYWRvd1ZpZXdNYXRyaXhbaV0sIGZhbHNlLCBsaWdodC5nZXRTaGFkb3dWaWV3TWF0cml4KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdVNoYWRvd1Byb2pNYXRyaXhbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91U2hhZG93UHJvak1hdHJpeFtpXSwgZmFsc2UsIGxpZ2h0LmdldFNoYWRvd1Byb2pNYXRyaXgoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd1JlbmRlckJ1ZiA9IGxpZ2h0LmdldFNoYWRvd1JlbmRlckJ1ZigpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSZW5kZXJCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZShcInNoYWRvd01hcFwiICsgaSwgc2hhZG93UmVuZGVyQnVmLmdldFRleHR1cmUoKSwgZnJhbWVDdHgudGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC50ZXh0dXJlVW5pdCA9IChmcmFtZUN0eC50ZXh0dXJlVW5pdCArIDEpICUgbWF4VGV4dHVyZVVuaXRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUN0eC5iaW5kVGV4dHVyZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaWdodHNTdGF0ZS5saWdodE1hcHMubGVuZ3RoID4gMCAmJiBsaWdodHNTdGF0ZS5saWdodE1hcHNbMF0udGV4dHVyZSAmJiB0aGlzLl91TGlnaHRNYXApIHtcbiAgICAgICAgcHJvZ3JhbS5iaW5kVGV4dHVyZSh0aGlzLl91TGlnaHRNYXAsIGxpZ2h0c1N0YXRlLmxpZ2h0TWFwc1swXS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgfVxuXG4gICAgaWYgKGxpZ2h0c1N0YXRlLnJlZmxlY3Rpb25NYXBzLmxlbmd0aCA+IDAgJiYgbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHNbMF0udGV4dHVyZSAmJiB0aGlzLl91UmVmbGVjdGlvbk1hcCkge1xuICAgICAgICBwcm9ncmFtLmJpbmRUZXh0dXJlKHRoaXMuX3VSZWZsZWN0aW9uTWFwLCBsaWdodHNTdGF0ZS5yZWZsZWN0aW9uTWFwc1swXS50ZXh0dXJlLCBmcmFtZUN0eC50ZXh0dXJlVW5pdCk7XG4gICAgICAgIGZyYW1lQ3R4LnRleHR1cmVVbml0ID0gKGZyYW1lQ3R4LnRleHR1cmVVbml0ICsgMSkgJSBtYXhUZXh0dXJlVW5pdHM7XG4gICAgICAgIGZyYW1lQ3R4LmJpbmRUZXh0dXJlKys7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3VHYW1tYUZhY3Rvcikge1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUdhbW1hRmFjdG9yLCBzY2VuZS5nYW1tYUZhY3Rvcik7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFzZVRleHR1cmVVbml0ID0gZnJhbWVDdHgudGV4dHVyZVVuaXQ7XG59O1xuXG5leHBvcnQge0RyYXdSZW5kZXJlcn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawShaderSource.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawShaderSource.js ***!
  \****************************************************************************************/
/*! exports provided: DrawShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DrawShaderSource\", function() { return DrawShaderSource; });\n/**\n * @private\n */\nconst DrawShaderSource = function (mesh) {\n    if (mesh._material._state.type === \"LambertMaterial\") {\n        this.vertex = buildVertexLambert(mesh);\n        this.fragment = buildFragmentLambert(mesh);\n    } else {\n        this.vertex = buildVertexDraw(mesh);\n        this.fragment = buildFragmentDraw(mesh);\n    }\n};\n\nconst TEXTURE_DECODE_FUNCS = {\n    \"linear\": \"linearToLinear\",\n    \"sRGB\": \"sRGBToLinear\",\n    \"gamma\": \"gammaToLinear\"\n};\n\nfunction getReceivesShadow(mesh) {\n    if (!mesh.receivesShadow) {\n        return false;\n    }\n    const lights = mesh.scene._lightsState.lights;\n    if (!lights || lights.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = lights.length; i < len; i++) {\n        if (lights[i].castsShadow) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction hasTextures(mesh) {\n    if (!mesh._geometry._state.uvBuf) {\n        return false;\n    }\n    const material = mesh._material;\n    return !!(material._ambientMap ||\n        material._occlusionMap ||\n        material._baseColorMap ||\n        material._diffuseMap ||\n        material._alphaMap ||\n        material._specularMap ||\n        material._glossinessMap ||\n        material._specularGlossinessMap ||\n        material._emissiveMap ||\n        material._metallicMap ||\n        material._roughnessMap ||\n        material._metallicRoughnessMap ||\n        material._reflectivityMap ||\n        material._normalMap);\n}\n\nfunction hasNormals(mesh) {\n    const primitive = mesh._geometry._state.primitiveName;\n    if ((mesh._geometry._state.autoVertexNormals || mesh._geometry._state.normalsBuf) && (primitive === \"triangles\" || primitive === \"triangle-strip\" || primitive === \"triangle-fan\")) {\n        return true;\n    }\n    return false;\n}\n\nfunction buildVertexLambert(mesh) {\n\n    const scene = mesh.scene;\n    const sectionPlanesState = mesh.scene._sectionPlanesState;\n    const lightsState = mesh.scene._lightsState;\n    const geometryState = mesh._geometry._state;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!geometryState.compressGeometry;\n\n    const src = [];\n    src.push(\"// Lambertian drawing vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"uniform vec4 colorize;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    src.push(\"uniform vec4 lightAmbient;\");\n    src.push(\"uniform vec4 materialColor;\");\n    src.push(\"uniform vec3 materialEmissive;\");\n    if (geometryState.normalsBuf) {\n        src.push(\"attribute vec3 normal;\");\n        src.push(\"uniform mat4 modelNormalMatrix;\");\n        src.push(\"uniform mat4 viewNormalMatrix;\");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n            const light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            src.push(\"uniform vec4 lightColor\" + i + \";\");\n            if (light.type === \"dir\") {\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n            if (light.type === \"point\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n            }\n            if (light.type === \"spot\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n        }\n        if (quantizedGeometry) {\n            src.push(\"vec3 octDecode(vec2 oct) {\");\n            src.push(\"    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));\");\n            src.push(\"    if (v.z < 0.0) {\");\n            src.push(\"        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);\");\n            src.push(\"    }\");\n            src.push(\"    return normalize(v);\");\n            src.push(\"}\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"uniform float pointSize;\");\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    src.push(\"vec4 worldPosition;\");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    if (geometryState.normalsBuf) {\n        if (quantizedGeometry) {\n            src.push(\"vec4 localNormal = vec4(octDecode(normal.xy), 0.0); \");\n        } else {\n            src.push(\"vec4 localNormal = vec4(normal, 0.0); \");\n        }\n        src.push(\"mat4 modelNormalMatrix2 = modelNormalMatrix;\");\n        src.push(\"mat4 viewNormalMatrix2 = viewNormalMatrix;\");\n    }\n    src.push(\"mat4 viewMatrix2 = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2 = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n        src.push(\"billboard(modelViewMatrix);\");\n        if (geometryState.normalsBuf) {\n            src.push(\"mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;\");\n            src.push(\"billboard(modelNormalMatrix2);\");\n            src.push(\"billboard(viewNormalMatrix2);\");\n            src.push(\"billboard(modelViewNormalMatrix);\");\n        }\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition = modelViewMatrix * localPosition;\");\n    } else {\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition  = viewMatrix2 * worldPosition; \");\n    }\n    if (geometryState.normalsBuf) {\n        src.push(\"vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);\");\n    }\n    src.push(\"vec3 reflectedColor = vec3(0.0, 0.0, 0.0);\");\n    src.push(\"vec3 viewLightDir = vec3(0.0, 0.0, -1.0);\");\n    src.push(\"float lambertian = 1.0;\");\n    if (geometryState.normalsBuf) {\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n            const light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            if (light.type === \"dir\") {\n                if (light.space === \"view\") {\n                    src.push(\"viewLightDir = normalize(lightDir\" + i + \");\");\n                } else {\n                    src.push(\"viewLightDir = normalize((viewMatrix2 * vec4(lightDir\" + i + \", 0.0)).xyz);\");\n                }\n            } else if (light.type === \"point\") {\n                if (light.space === \"view\") {\n                    src.push(\"viewLightDir = -normalize(lightPos\" + i + \" - viewPosition.xyz);\");\n                } else {\n                    src.push(\"viewLightDir = -normalize((viewMatrix2 * vec4(lightPos\" + i + \", 0.0)).xyz);\");\n                }\n            } else if (light.type === \"spot\") {\n                if (light.space === \"view\") {\n                    src.push(\"viewLightDir = normalize(lightDir\" + i + \");\");\n                } else {\n                    src.push(\"viewLightDir = normalize((viewMatrix2 * vec4(lightDir\" + i + \", 0.0)).xyz);\");\n                }\n            } else {\n                continue;\n            }\n            src.push(\"lambertian = max(dot(-viewNormal, viewLightDir), 0.0);\");\n            src.push(\"reflectedColor += lambertian * (lightColor\" + i + \".rgb * lightColor\" + i + \".a);\");\n        }\n    }\n    //src.push(\"vColor = vec4((reflectedColor * materialColor) + (lightAmbient.rgb * lightAmbient.a), 1.0) * colorize;\");\n    src.push(\"vColor = vec4((lightAmbient.rgb * lightAmbient.a * materialColor.rgb) + materialEmissive.rgb + (reflectedColor * materialColor.rgb), materialColor.a) * colorize;\"); // TODO: How to have ambient bright enough for canvas BG but not too bright for scene?\n    if (clipping) {\n        src.push(\"vWorldPosition = worldPosition;\");\n    }\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"gl_PointSize = pointSize;\");\n    }\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragmentLambert(mesh) {\n    const scene = mesh.scene;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const materialState = mesh._material._state;\n    const geometryState = mesh._geometry._state;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const solid =  false && false;\n    const gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.\n    const src = [];\n    src.push(\"// Lambertian drawing fragment shader\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n        src.push(\"uniform bool clippable;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    if (gammaOutput) {\n        src.push(\"uniform float gammaFactor;\");\n        src.push(\"    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {\");\n        src.push(\"    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        if (solid) {\n            src.push(\"  if (gl_FrontFacing == false) {\");\n            src.push(\"     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\");\n            src.push(\"     return;\");\n            src.push(\"  }\");\n        }\n        src.push(\"}\");\n    }\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"vec2 cxy = 2.0 * gl_PointCoord - 1.0;\");\n        src.push(\"float r = dot(cxy, cxy);\");\n        src.push(\"if (r > 1.0) {\");\n        src.push(\"   discard;\");\n        src.push(\"}\");\n\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n    if (gammaOutput) {\n        src.push(\"gl_FragColor = linearToGamma(vColor, gammaFactor);\");\n    } else {\n        src.push(\"gl_FragColor = vColor;\");\n    }\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildVertexDraw(mesh) {\n    const scene = mesh.scene;\n    const material = mesh._material;\n    const meshState = mesh._state;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const geometryState = mesh._geometry._state;\n    const lightsState = scene._lightsState;\n    let i;\n    let len;\n    let light;\n    const billboard = meshState.billboard;\n    const stationary = meshState.stationary;\n    const texturing = hasTextures(mesh);\n    const normals = hasNormals(mesh);\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const receivesShadow = getReceivesShadow(mesh);\n    const quantizedGeometry = !!geometryState.compressGeometry;\n    const src = [];\n    src.push(\"// Drawing vertex shader\");\n    if (normals && material._normalMap) {\n        src.push(\"#extension GL_OES_standard_derivatives : enable\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute  vec3 position;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    src.push(\"uniform  mat4 modelMatrix;\");\n    src.push(\"uniform  mat4 viewMatrix;\");\n    src.push(\"uniform  mat4 projMatrix;\");\n    src.push(\"varying  vec3 vViewPosition;\");\n    src.push(\"uniform  vec3 offset;\");\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    if (lightsState.lightMaps.length > 0) {\n        src.push(\"varying    vec3 vWorldNormal;\");\n    }\n    if (normals) {\n        src.push(\"attribute  vec3 normal;\");\n        src.push(\"uniform    mat4 modelNormalMatrix;\");\n        src.push(\"uniform    mat4 viewNormalMatrix;\");\n        src.push(\"varying    vec3 vViewNormal;\");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n            light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            if (light.type === \"dir\") {\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n            if (light.type === \"point\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n            }\n            if (light.type === \"spot\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n            if (!(light.type === \"dir\" && light.space === \"view\")) {\n                src.push(\"varying vec4 vViewLightReverseDirAndDist\" + i + \";\");\n            }\n        }\n        if (quantizedGeometry) {\n            src.push(\"vec3 octDecode(vec2 oct) {\");\n            src.push(\"    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));\");\n            src.push(\"    if (v.z < 0.0) {\");\n            src.push(\"        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);\");\n            src.push(\"    }\");\n            src.push(\"    return normalize(v);\");\n            src.push(\"}\");\n        }\n    }\n    if (texturing) {\n        src.push(\"attribute vec2 uv;\");\n        src.push(\"varying vec2 vUV;\");\n        if (quantizedGeometry) {\n            src.push(\"uniform mat3 uvDecodeMatrix;\")\n        }\n    }\n    if (geometryState.colors) {\n        src.push(\"attribute vec4 color;\");\n        src.push(\"varying vec4 vColor;\");\n    }\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"uniform float pointSize;\");\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    if (receivesShadow) {\n        src.push(\"const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) { // Light sources\n            if (lightsState.lights[i].castsShadow) {\n                src.push(\"uniform mat4 shadowViewMatrix\" + i + \";\");\n                src.push(\"uniform mat4 shadowProjMatrix\" + i + \";\");\n                src.push(\"varying vec4 vShadowPosFromLight\" + i + \";\");\n            }\n        }\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    src.push(\"vec4 worldPosition;\");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    if (normals) {\n        if (quantizedGeometry) {\n            src.push(\"vec4 localNormal = vec4(octDecode(normal.xy), 0.0); \");\n        } else {\n            src.push(\"vec4 localNormal = vec4(normal, 0.0); \");\n        }\n        src.push(\"mat4 modelNormalMatrix2    = modelNormalMatrix;\");\n        src.push(\"mat4 viewNormalMatrix2     = viewNormalMatrix;\");\n    }\n    src.push(\"mat4 viewMatrix2           = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2          = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n        src.push(\"billboard(modelViewMatrix);\");\n        if (normals) {\n            src.push(\"mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;\");\n            src.push(\"billboard(modelNormalMatrix2);\");\n            src.push(\"billboard(viewNormalMatrix2);\");\n            src.push(\"billboard(modelViewNormalMatrix);\");\n        }\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition = modelViewMatrix * localPosition;\");\n    } else {\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition  = viewMatrix2 * worldPosition; \");\n    }\n    if (normals) {\n        src.push(\"vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; \");\n        if (lightsState.lightMaps.length > 0) {\n            src.push(\"vWorldNormal = worldNormal;\");\n        }\n        src.push(\"vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);\");\n        src.push(\"vec3 tmpVec3;\");\n        src.push(\"float lightDist;\");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) { // Lights\n            light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            if (light.type === \"dir\") {\n                if (light.space === \"world\") {\n                    src.push(\"tmpVec3 = vec3(viewMatrix2 * vec4(lightDir\" + i + \", 0.0) ).xyz;\");\n                    src.push(\"vViewLightReverseDirAndDist\" + i + \" = vec4(-tmpVec3, 0.0);\");\n                }\n            }\n            if (light.type === \"point\") {\n                if (light.space === \"world\") {\n                    src.push(\"tmpVec3 = (viewMatrix2 * vec4(lightPos\" + i + \", 1.0)).xyz - viewPosition.xyz;\");\n                    src.push(\"lightDist = abs(length(tmpVec3));\");\n                } else {\n                    src.push(\"tmpVec3 = lightPos\" + i + \".xyz - viewPosition.xyz;\");\n                    src.push(\"lightDist = abs(length(tmpVec3));\");\n                }\n                src.push(\"vViewLightReverseDirAndDist\" + i + \" = vec4(tmpVec3, lightDist);\");\n            }\n        }\n    }\n    if (texturing) {\n        if (quantizedGeometry) {\n            src.push(\"vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;\");\n        } else {\n            src.push(\"vUV = uv;\");\n        }\n    }\n    if (geometryState.colors) {\n        src.push(\"vColor = color;\");\n    }\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"gl_PointSize = pointSize;\");\n    }\n    if (clipping) {\n        src.push(\"vWorldPosition = worldPosition;\");\n    }\n    src.push(\"   vViewPosition = viewPosition.xyz;\");\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n    }\n    src.push(\"gl_Position = clipPos;\");\n    if (receivesShadow) {\n        src.push(\"const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\");\n        src.push(\"vec4 tempx; \");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) { // Light sources\n            if (lightsState.lights[i].castsShadow) {\n                src.push(\"vShadowPosFromLight\" + i + \" = texUnitConverter * shadowProjMatrix\" + i + \" * (shadowViewMatrix\" + i + \" * worldPosition); \");\n            }\n        }\n    }\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragmentDraw(mesh) {\n\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    const material = mesh._material;\n    const geometryState = mesh._geometry._state;\n    const sectionPlanesState = mesh.scene._sectionPlanesState;\n    const lightsState = mesh.scene._lightsState;\n    const materialState = mesh._material._state;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const normals = hasNormals(mesh);\n    const uvs = geometryState.uvBuf;\n    const solid =  false && false;\n    const phongMaterial = (materialState.type === \"PhongMaterial\");\n    const metallicMaterial = (materialState.type === \"MetallicMaterial\");\n    const specularMaterial = (materialState.type === \"SpecularMaterial\");\n    const receivesShadow = getReceivesShadow(mesh);\n    const gammaInput = scene.gammaInput; // If set, then it expects that all textures and colors are premultiplied gamma. Default is false.\n    const gammaOutput = scene.gammaOutput; // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.\n\n    let light;\n    const src = [];\n\n    src.push(\"// Drawing fragment shader\");\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n\n    if (normals && material._normalMap) {\n        src.push(\"#extension GL_OES_standard_derivatives : enable\");\n    }\n\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n\n    if (receivesShadow) {\n        src.push(\"float unpackDepth (vec4 color) {\");\n        src.push(\"  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));\");\n        src.push(\"  return dot(color, bitShift);\");\n        src.push(\"}\");\n    }\n\n    //--------------------------------------------------------------------------------\n    // GAMMA CORRECTION\n    //--------------------------------------------------------------------------------\n\n    src.push(\"uniform float gammaFactor;\");\n    src.push(\"vec4 linearToLinear( in vec4 value ) {\");\n    src.push(\"  return value;\");\n    src.push(\"}\");\n    src.push(\"vec4 sRGBToLinear( in vec4 value ) {\");\n    src.push(\"  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\");\n    src.push(\"}\");\n    src.push(\"vec4 gammaToLinear( in vec4 value) {\");\n    src.push(\"  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\");\n    src.push(\"}\");\n    if (gammaOutput) {\n        src.push(\"vec4 linearToGamma( in vec4 value, in float gammaFactor ) {\");\n        src.push(\"  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\");\n        src.push(\"}\");\n    }\n\n    //--------------------------------------------------------------------------------\n    // USER CLIP PLANES\n    //--------------------------------------------------------------------------------\n\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n        src.push(\"uniform bool clippable;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n\n    if (normals) {\n\n        //--------------------------------------------------------------------------------\n        // LIGHT AND REFLECTION MAP INPUTS\n        // Define here so available globally to shader functions\n        //--------------------------------------------------------------------------------\n\n        if (lightsState.lightMaps.length > 0) {\n            src.push(\"uniform samplerCube lightMap;\");\n            src.push(\"uniform mat4 viewNormalMatrix;\");\n        }\n        if (lightsState.reflectionMaps.length > 0) {\n            src.push(\"uniform samplerCube reflectionMap;\");\n        }\n        if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {\n            src.push(\"uniform mat4 viewMatrix;\");\n        }\n\n        //--------------------------------------------------------------------------------\n        // SHADING FUNCTIONS\n        //--------------------------------------------------------------------------------\n\n        // CONSTANT DEFINITIONS\n\n        src.push(\"#define PI 3.14159265359\");\n        src.push(\"#define RECIPROCAL_PI 0.31830988618\");\n        src.push(\"#define RECIPROCAL_PI2 0.15915494\");\n        src.push(\"#define EPSILON 1e-6\");\n\n        src.push(\"#define saturate(a) clamp( a, 0.0, 1.0 )\");\n\n        // UTILITY DEFINITIONS\n\n        src.push(\"vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\");\n        src.push(\"   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\");\n        src.push(\"}\");\n\n        // STRUCTURES\n\n        src.push(\"struct IncidentLight {\");\n        src.push(\"   vec3 color;\");\n        src.push(\"   vec3 direction;\");\n        src.push(\"};\");\n\n        src.push(\"struct ReflectedLight {\");\n        src.push(\"   vec3 diffuse;\");\n        src.push(\"   vec3 specular;\");\n        src.push(\"};\");\n\n        src.push(\"struct Geometry {\");\n        src.push(\"   vec3 position;\");\n        src.push(\"   vec3 viewNormal;\");\n        src.push(\"   vec3 worldNormal;\");\n        src.push(\"   vec3 viewEyeDir;\");\n        src.push(\"};\");\n\n        src.push(\"struct Material {\");\n        src.push(\"   vec3    diffuseColor;\");\n        src.push(\"   float   specularRoughness;\");\n        src.push(\"   vec3    specularColor;\");\n        src.push(\"   float   shine;\"); // Only used for Phong\n        src.push(\"};\");\n\n        // COMMON UTILS\n\n        if (phongMaterial) {\n\n            if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {\n\n                src.push(\"void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {\");\n\n                if (lightsState.lightMaps.length > 0) {\n                    src.push(\"   vec3 irradiance = \" + TEXTURE_DECODE_FUNCS[lightsState.lightMaps[0].encoding] + \"(textureCube(lightMap, geometry.worldNormal)).rgb;\");\n                    src.push(\"   irradiance *= PI;\");\n                    src.push(\"   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);\");\n                    src.push(\"   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;\");\n                }\n                if (lightsState.reflectionMaps.length > 0) {\n                    src.push(\"   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);\");\n                    src.push(\"   vec3 radiance               = textureCube(reflectionMap, reflectVec).rgb * 0.2;\");\n                    src.push(\"   radiance *= PI;\");\n                    src.push(\"   reflectedLight.specular     += radiance;\");\n                }\n                src.push(\"}\");\n            }\n\n            src.push(\"void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {\");\n            src.push(\"   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));\");\n            src.push(\"   vec3 irradiance = dotNL * directLight.color * PI;\");\n            src.push(\"   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);\");\n            src.push(\"   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);\");\n            src.push(\"}\");\n        }\n\n        if (metallicMaterial || specularMaterial) {\n\n            // IRRADIANCE EVALUATION\n\n            src.push(\"float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {\");\n            src.push(\"   float r = ggxRoughness + 0.0001;\");\n            src.push(\"   return (2.0 / (r * r) - 2.0);\");\n            src.push(\"}\");\n\n            src.push(\"float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {\");\n            src.push(\"   float maxMIPLevelScalar = float( maxMIPLevel );\");\n            src.push(\"   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );\");\n            src.push(\"   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\");\n            src.push(\"}\");\n\n            if (lightsState.reflectionMaps.length > 0) {\n                src.push(\"vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {\");\n                src.push(\"   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);\"); //TODO: a random factor - fix this\n                src.push(\"   vec3 envMapColor = \" + TEXTURE_DECODE_FUNCS[lightsState.reflectionMaps[0].encoding] + \"(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;\");\n                src.push(\"  return envMapColor;\");\n                src.push(\"}\");\n            }\n\n            // SPECULAR BRDF EVALUATION\n\n            src.push(\"vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {\");\n            src.push(\"   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\");\n            src.push(\"   return ( 1.0 - specularColor ) * fresnel + specularColor;\");\n            src.push(\"}\");\n\n            src.push(\"float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {\");\n            src.push(\"   float a2 = ( alpha * alpha );\");\n            src.push(\"   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );\");\n            src.push(\"   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );\");\n            src.push(\"   return 1.0 / ( gl * gv );\");\n            src.push(\"}\");\n\n            src.push(\"float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\");\n            src.push(\"   float a2 = ( alpha * alpha );\");\n            src.push(\"   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );\");\n            src.push(\"   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );\");\n            src.push(\"   return 0.5 / max( gv + gl, EPSILON );\");\n            src.push(\"}\");\n\n            src.push(\"float D_GGX(const in float alpha, const in float dotNH) {\");\n            src.push(\"   float a2 = ( alpha * alpha );\");\n            src.push(\"   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;\");\n            src.push(\"   return RECIPROCAL_PI * a2 / ( denom * denom);\");\n            src.push(\"}\");\n\n            src.push(\"vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {\");\n            src.push(\"   float alpha = ( roughness * roughness );\");\n            src.push(\"   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );\");\n            src.push(\"   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );\");\n            src.push(\"   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );\");\n            src.push(\"   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );\");\n            src.push(\"   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\");\n            src.push(\"   vec3  F = F_Schlick( specularColor, dotLH );\");\n            src.push(\"   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\");\n            src.push(\"   float D = D_GGX( alpha, dotNH );\");\n            src.push(\"   return F * (G * D);\");\n            src.push(\"}\");\n\n            src.push(\"vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {\");\n            src.push(\"   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));\");\n            src.push(\"   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);\");\n            src.push(\"   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);\");\n            src.push(\"   vec4 r = roughness * c0 + c1;\");\n            src.push(\"   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\");\n            src.push(\"   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;\");\n            src.push(\"   return specularColor * AB.x + AB.y;\");\n            src.push(\"}\");\n\n            if (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0) {\n\n                src.push(\"void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {\");\n                if (lightsState.lightMaps.length > 0) {\n                    src.push(\"   vec3 irradiance = sRGBToLinear(textureCube(lightMap, geometry.worldNormal)).rgb;\");\n                    src.push(\"   irradiance *= PI;\");\n                    src.push(\"   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);\");\n                    src.push(\"   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;\");\n                    //   src.push(\"   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);\");\n                }\n                if (lightsState.reflectionMaps.length > 0) {\n                    src.push(\"   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);\");\n                    src.push(\"   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);\");\n                    src.push(\"   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);\");\n                    src.push(\"   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);\");\n                    src.push(\"   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);\");\n                    src.push(\"   reflectedLight.specular     += radiance * specularBRDFContrib;\");\n                }\n                src.push(\"}\");\n            }\n\n            // MAIN LIGHTING COMPUTATION FUNCTION\n\n            src.push(\"void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {\");\n            src.push(\"   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));\");\n            src.push(\"   vec3 irradiance = dotNL * incidentLight.color * PI;\");\n            src.push(\"   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);\");\n            src.push(\"   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);\");\n            src.push(\"}\");\n\n        } // (metallicMaterial || specularMaterial)\n\n    } // geometry.normals\n\n    //--------------------------------------------------------------------------------\n    // GEOMETRY INPUTS\n    //--------------------------------------------------------------------------------\n\n    src.push(\"varying vec3 vViewPosition;\");\n\n    if (geometryState.colors) {\n        src.push(\"varying vec4 vColor;\");\n    }\n\n    if (uvs &&\n        ((normals && material._normalMap)\n            || material._ambientMap\n            || material._baseColorMap\n            || material._diffuseMap\n            || material._emissiveMap\n            || material._metallicMap\n            || material._roughnessMap\n            || material._metallicRoughnessMap\n            || material._specularMap\n            || material._glossinessMap\n            || material._specularGlossinessMap\n            || material._occlusionMap\n            || material._alphaMap)) {\n        src.push(\"varying vec2 vUV;\");\n    }\n\n    if (normals) {\n        if (lightsState.lightMaps.length > 0) {\n            src.push(\"varying vec3 vWorldNormal;\");\n        }\n        src.push(\"varying vec3 vViewNormal;\");\n    }\n\n    //--------------------------------------------------------------------------------\n    // MATERIAL CHANNEL INPUTS\n    //--------------------------------------------------------------------------------\n\n    if (materialState.ambient) {\n        src.push(\"uniform vec3 materialAmbient;\");\n    }\n    if (materialState.baseColor) {\n        src.push(\"uniform vec3 materialBaseColor;\");\n    }\n    if (materialState.alpha !== undefined && materialState.alpha !== null) {\n        src.push(\"uniform vec4 materialAlphaModeCutoff;\"); // [alpha, alphaMode, alphaCutoff]\n    }\n    if (materialState.emissive) {\n        src.push(\"uniform vec3 materialEmissive;\");\n    }\n    if (materialState.diffuse) {\n        src.push(\"uniform vec3 materialDiffuse;\");\n    }\n    if (materialState.glossiness !== undefined && materialState.glossiness !== null) {\n        src.push(\"uniform float materialGlossiness;\");\n    }\n    if (materialState.shininess !== undefined && materialState.shininess !== null) {\n        src.push(\"uniform float materialShininess;\");  // Phong channel\n    }\n    if (materialState.specular) {\n        src.push(\"uniform vec3 materialSpecular;\");\n    }\n    if (materialState.metallic !== undefined && materialState.metallic !== null) {\n        src.push(\"uniform float materialMetallic;\");\n    }\n    if (materialState.roughness !== undefined && materialState.roughness !== null) {\n        src.push(\"uniform float materialRoughness;\");\n    }\n    if (materialState.specularF0 !== undefined && materialState.specularF0 !== null) {\n        src.push(\"uniform float materialSpecularF0;\");\n    }\n\n    //--------------------------------------------------------------------------------\n    // MATERIAL TEXTURE INPUTS\n    //--------------------------------------------------------------------------------\n\n    if (uvs && material._ambientMap) {\n        src.push(\"uniform sampler2D ambientMap;\");\n        if (material._ambientMap._state.matrix) {\n            src.push(\"uniform mat4 ambientMapMatrix;\");\n        }\n    }\n    if (uvs && material._baseColorMap) {\n        src.push(\"uniform sampler2D baseColorMap;\");\n        if (material._baseColorMap._state.matrix) {\n            src.push(\"uniform mat4 baseColorMapMatrix;\");\n        }\n    }\n    if (uvs && material._diffuseMap) {\n        src.push(\"uniform sampler2D diffuseMap;\");\n        if (material._diffuseMap._state.matrix) {\n            src.push(\"uniform mat4 diffuseMapMatrix;\");\n        }\n    }\n    if (uvs && material._emissiveMap) {\n        src.push(\"uniform sampler2D emissiveMap;\");\n        if (material._emissiveMap._state.matrix) {\n            src.push(\"uniform mat4 emissiveMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._metallicMap) {\n        src.push(\"uniform sampler2D metallicMap;\");\n        if (material._metallicMap._state.matrix) {\n            src.push(\"uniform mat4 metallicMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._roughnessMap) {\n        src.push(\"uniform sampler2D roughnessMap;\");\n        if (material._roughnessMap._state.matrix) {\n            src.push(\"uniform mat4 roughnessMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._metallicRoughnessMap) {\n        src.push(\"uniform sampler2D metallicRoughnessMap;\");\n        if (material._metallicRoughnessMap._state.matrix) {\n            src.push(\"uniform mat4 metallicRoughnessMapMatrix;\");\n        }\n    }\n    if (normals && material._normalMap) {\n        src.push(\"uniform sampler2D normalMap;\");\n        if (material._normalMap._state.matrix) {\n            src.push(\"uniform mat4 normalMapMatrix;\");\n        }\n        src.push(\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\");\n        src.push(\"      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\");\n        src.push(\"      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\");\n        src.push(\"      vec2 st0 = dFdx( uv.st );\");\n        src.push(\"      vec2 st1 = dFdy( uv.st );\");\n        src.push(\"      vec3 S = normalize( q0 * st1.t - q1 * st0.t );\");\n        src.push(\"      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\");\n        src.push(\"      vec3 N = normalize( surf_norm );\");\n        src.push(\"      vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\");\n        src.push(\"      mat3 tsn = mat3( S, T, N );\");\n        //     src.push(\"      mapN *= 3.0;\");\n        src.push(\"      return normalize( tsn * mapN );\");\n        src.push(\"}\");\n    }\n    if (uvs && material._occlusionMap) {\n        src.push(\"uniform sampler2D occlusionMap;\");\n        if (material._occlusionMap._state.matrix) {\n            src.push(\"uniform mat4 occlusionMapMatrix;\");\n        }\n    }\n    if (uvs && material._alphaMap) {\n        src.push(\"uniform sampler2D alphaMap;\");\n        if (material._alphaMap._state.matrix) {\n            src.push(\"uniform mat4 alphaMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._specularMap) {\n        src.push(\"uniform sampler2D specularMap;\");\n        if (material._specularMap._state.matrix) {\n            src.push(\"uniform mat4 specularMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._glossinessMap) {\n        src.push(\"uniform sampler2D glossinessMap;\");\n        if (material._glossinessMap._state.matrix) {\n            src.push(\"uniform mat4 glossinessMapMatrix;\");\n        }\n    }\n    if (normals && uvs && material._specularGlossinessMap) {\n        src.push(\"uniform sampler2D materialSpecularGlossinessMap;\");\n        if (material._specularGlossinessMap._state.matrix) {\n            src.push(\"uniform mat4 materialSpecularGlossinessMapMatrix;\");\n        }\n    }\n\n    //--------------------------------------------------------------------------------\n    // MATERIAL FRESNEL INPUTS\n    //--------------------------------------------------------------------------------\n\n    if (normals && (material._diffuseFresnel ||\n        material._specularFresnel ||\n        material._alphaFresnel ||\n        material._emissiveFresnel ||\n        material._reflectivityFresnel)) {\n        src.push(\"float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {\");\n        src.push(\"    float fr = abs(dot(eyeDir, normal));\");\n        src.push(\"    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);\");\n        src.push(\"    return pow(finalFr, power);\");\n        src.push(\"}\");\n        if (material._diffuseFresnel) {\n            src.push(\"uniform float  diffuseFresnelCenterBias;\");\n            src.push(\"uniform float  diffuseFresnelEdgeBias;\");\n            src.push(\"uniform float  diffuseFresnelPower;\");\n            src.push(\"uniform vec3   diffuseFresnelCenterColor;\");\n            src.push(\"uniform vec3   diffuseFresnelEdgeColor;\");\n        }\n        if (material._specularFresnel) {\n            src.push(\"uniform float  specularFresnelCenterBias;\");\n            src.push(\"uniform float  specularFresnelEdgeBias;\");\n            src.push(\"uniform float  specularFresnelPower;\");\n            src.push(\"uniform vec3   specularFresnelCenterColor;\");\n            src.push(\"uniform vec3   specularFresnelEdgeColor;\");\n        }\n        if (material._alphaFresnel) {\n            src.push(\"uniform float  alphaFresnelCenterBias;\");\n            src.push(\"uniform float  alphaFresnelEdgeBias;\");\n            src.push(\"uniform float  alphaFresnelPower;\");\n            src.push(\"uniform vec3   alphaFresnelCenterColor;\");\n            src.push(\"uniform vec3   alphaFresnelEdgeColor;\");\n        }\n        if (material._reflectivityFresnel) {\n            src.push(\"uniform float  materialSpecularF0FresnelCenterBias;\");\n            src.push(\"uniform float  materialSpecularF0FresnelEdgeBias;\");\n            src.push(\"uniform float  materialSpecularF0FresnelPower;\");\n            src.push(\"uniform vec3   materialSpecularF0FresnelCenterColor;\");\n            src.push(\"uniform vec3   materialSpecularF0FresnelEdgeColor;\");\n        }\n        if (material._emissiveFresnel) {\n            src.push(\"uniform float  emissiveFresnelCenterBias;\");\n            src.push(\"uniform float  emissiveFresnelEdgeBias;\");\n            src.push(\"uniform float  emissiveFresnelPower;\");\n            src.push(\"uniform vec3   emissiveFresnelCenterColor;\");\n            src.push(\"uniform vec3   emissiveFresnelEdgeColor;\");\n        }\n    }\n\n    //--------------------------------------------------------------------------------\n    // LIGHT SOURCES\n    //--------------------------------------------------------------------------------\n\n    src.push(\"uniform vec4   lightAmbient;\");\n\n    if (normals) {\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) { // Light sources\n            const light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            src.push(\"uniform vec4 lightColor\" + i + \";\");\n            if (light.type === \"point\") {\n                src.push(\"uniform vec3 lightAttenuation\" + i + \";\");\n            }\n            if (light.type === \"dir\" && light.space === \"view\") {\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n            if (light.type === \"point\" && light.space === \"view\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n            } else {\n                src.push(\"varying vec4 vViewLightReverseDirAndDist\" + i + \";\");\n            }\n        }\n    }\n\n    if (receivesShadow) {\n\n        // Variance castsShadow mapping filter\n\n        // src.push(\"float linstep(float low, float high, float v){\");\n        // src.push(\"      return clamp((v-low)/(high-low), 0.0, 1.0);\");\n        // src.push(\"}\");\n        //\n        // src.push(\"float VSM(sampler2D depths, vec2 uv, float compare){\");\n        // src.push(\"      vec2 moments = texture2D(depths, uv).xy;\");\n        // src.push(\"      float p = smoothstep(compare-0.02, compare, moments.x);\");\n        // src.push(\"      float variance = max(moments.y - moments.x*moments.x, -0.001);\");\n        // src.push(\"      float d = compare - moments.x;\");\n        // src.push(\"      float p_max = linstep(0.2, 1.0, variance / (variance + d*d));\");\n        // src.push(\"      return clamp(max(p, p_max), 0.0, 1.0);\");\n        // src.push(\"}\");\n\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) { // Light sources\n            if (lightsState.lights[i].castsShadow) {\n                src.push(\"varying vec4 vShadowPosFromLight\" + i + \";\");\n                src.push(\"uniform sampler2D shadowMap\" + i + \";\");\n            }\n        }\n    }\n\n    src.push(\"uniform vec4 colorize;\");\n\n    //================================================================================\n    // MAIN\n    //================================================================================\n\n    src.push(\"void main(void) {\");\n\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        if (solid) {\n            src.push(\"  if (gl_FrontFacing == false) {\");\n            src.push(\"     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\");\n            src.push(\"     return;\");\n            src.push(\"  }\");\n        }\n        src.push(\"}\");\n    }\n\n    if (geometryState.primitiveName === \"points\") {\n        src.push(\"vec2 cxy = 2.0 * gl_PointCoord - 1.0;\");\n        src.push(\"float r = dot(cxy, cxy);\");\n        src.push(\"if (r > 1.0) {\");\n        src.push(\"   discard;\");\n        src.push(\"}\");\n    }\n\n    src.push(\"float occlusion = 1.0;\");\n\n    if (materialState.ambient) {\n        src.push(\"vec3 ambientColor = materialAmbient;\");\n    } else {\n        src.push(\"vec3 ambientColor = vec3(1.0, 1.0, 1.0);\");\n    }\n\n    if (materialState.diffuse) {\n        src.push(\"vec3 diffuseColor = materialDiffuse;\");\n    } else if (materialState.baseColor) {\n        src.push(\"vec3 diffuseColor = materialBaseColor;\");\n    } else {\n        src.push(\"vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\");\n    }\n\n    if (geometryState.colors) {\n        src.push(\"diffuseColor *= vColor.rgb;\");\n    }\n\n    if (materialState.emissive) {\n        src.push(\"vec3 emissiveColor = materialEmissive;\"); // Emissive default is (0,0,0), so initializing here\n    } else {\n        src.push(\"vec3  emissiveColor = vec3(0.0, 0.0, 0.0);\");\n    }\n\n    if (materialState.specular) {\n        src.push(\"vec3 specular = materialSpecular;\");\n    } else {\n        src.push(\"vec3 specular = vec3(1.0, 1.0, 1.0);\");\n    }\n\n    if (materialState.alpha !== undefined) {\n        src.push(\"float alpha = materialAlphaModeCutoff[0];\");\n    } else {\n        src.push(\"float alpha = 1.0;\");\n    }\n\n    if (geometryState.colors) {\n        src.push(\"alpha *= vColor.a;\");\n    }\n\n    if (materialState.glossiness !== undefined) {\n        src.push(\"float glossiness = materialGlossiness;\");\n    } else {\n        src.push(\"float glossiness = 1.0;\");\n    }\n\n    if (materialState.metallic !== undefined) {\n        src.push(\"float metallic = materialMetallic;\");\n    } else {\n        src.push(\"float metallic = 1.0;\");\n    }\n\n    if (materialState.roughness !== undefined) {\n        src.push(\"float roughness = materialRoughness;\");\n    } else {\n        src.push(\"float roughness = 1.0;\");\n    }\n\n    if (materialState.specularF0 !== undefined) {\n        src.push(\"float specularF0 = materialSpecularF0;\");\n    } else {\n        src.push(\"float specularF0 = 1.0;\");\n    }\n\n    //--------------------------------------------------------------------------------\n    // TEXTURING\n    //--------------------------------------------------------------------------------\n\n    if (uvs && ((normals && material._normalMap)\n        || material._ambientMap\n        || material._baseColorMap\n        || material._diffuseMap\n        || material._occlusionMap\n        || material._emissiveMap\n        || material._metallicMap\n        || material._roughnessMap\n        || material._metallicRoughnessMap\n        || material._specularMap\n        || material._glossinessMap\n        || material._specularGlossinessMap\n        || material._alphaMap)) {\n        src.push(\"vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);\");\n        src.push(\"vec2 textureCoord;\");\n    }\n\n    if (uvs && material._ambientMap) {\n        if (material._ambientMap._state.matrix) {\n            src.push(\"textureCoord = (ambientMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"vec4 ambientTexel = texture2D(ambientMap, textureCoord).rgb;\");\n        src.push(\"ambientTexel = \" + TEXTURE_DECODE_FUNCS[material._ambientMap._state.encoding] + \"(ambientTexel);\");\n        src.push(\"ambientColor *= ambientTexel.rgb;\");\n    }\n\n    if (uvs && material._diffuseMap) {\n        if (material._diffuseMap._state.matrix) {\n            src.push(\"textureCoord = (diffuseMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"vec4 diffuseTexel = texture2D(diffuseMap, textureCoord);\");\n        src.push(\"diffuseTexel = \" + TEXTURE_DECODE_FUNCS[material._diffuseMap._state.encoding] + \"(diffuseTexel);\");\n        src.push(\"diffuseColor *= diffuseTexel.rgb;\");\n        src.push(\"alpha *= diffuseTexel.a;\");\n    }\n\n    if (uvs && material._baseColorMap) {\n        if (material._baseColorMap._state.matrix) {\n            src.push(\"textureCoord = (baseColorMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"vec4 baseColorTexel = texture2D(baseColorMap, textureCoord);\");\n        src.push(\"baseColorTexel = \" + TEXTURE_DECODE_FUNCS[material._baseColorMap._state.encoding] + \"(baseColorTexel);\");\n        src.push(\"diffuseColor *= baseColorTexel.rgb;\");\n        src.push(\"alpha *= baseColorTexel.a;\");\n    }\n\n    if (uvs && material._emissiveMap) {\n        if (material._emissiveMap._state.matrix) {\n            src.push(\"textureCoord = (emissiveMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"vec4 emissiveTexel = texture2D(emissiveMap, textureCoord);\");\n        src.push(\"emissiveTexel = \" + TEXTURE_DECODE_FUNCS[material._emissiveMap._state.encoding] + \"(emissiveTexel);\");\n        src.push(\"emissiveColor = emissiveTexel.rgb;\");\n    }\n\n    if (uvs && material._alphaMap) {\n        if (material._alphaMap._state.matrix) {\n            src.push(\"textureCoord = (alphaMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"alpha *= texture2D(alphaMap, textureCoord).r;\");\n    }\n\n    if (uvs && material._occlusionMap) {\n        if (material._occlusionMap._state.matrix) {\n            src.push(\"textureCoord = (occlusionMapMatrix * texturePos).xy;\");\n        } else {\n            src.push(\"textureCoord = texturePos.xy;\");\n        }\n        src.push(\"occlusion *= texture2D(occlusionMap, textureCoord).r;\");\n    }\n\n    if (normals && ((lightsState.lights.length > 0) || lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {\n\n        //--------------------------------------------------------------------------------\n        // SHADING\n        //--------------------------------------------------------------------------------\n\n        if (uvs && material._normalMap) {\n            if (material._normalMap._state.matrix) {\n                src.push(\"textureCoord = (normalMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );\");\n        } else {\n            src.push(\"vec3 viewNormal = normalize(vViewNormal);\");\n        }\n\n        if (uvs && material._specularMap) {\n            if (material._specularMap._state.matrix) {\n                src.push(\"textureCoord = (specularMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"specular *= texture2D(specularMap, textureCoord).rgb;\");\n        }\n\n        if (uvs && material._glossinessMap) {\n            if (material._glossinessMap._state.matrix) {\n                src.push(\"textureCoord = (glossinessMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"glossiness *= texture2D(glossinessMap, textureCoord).r;\");\n        }\n\n        if (uvs && material._specularGlossinessMap) {\n            if (material._specularGlossinessMap._state.matrix) {\n                src.push(\"textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"vec4 specGlossRGB = texture2D(materialSpecularGlossinessMap, textureCoord).rgba;\"); // TODO: what if only RGB texture?\n            src.push(\"specular *= specGlossRGB.rgb;\");\n            src.push(\"glossiness *= specGlossRGB.a;\");\n        }\n\n        if (uvs && material._metallicMap) {\n            if (material._metallicMap._state.matrix) {\n                src.push(\"textureCoord = (metallicMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"metallic *= texture2D(metallicMap, textureCoord).r;\");\n        }\n\n        if (uvs && material._roughnessMap) {\n            if (material._roughnessMap._state.matrix) {\n                src.push(\"textureCoord = (roughnessMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"roughness *= texture2D(roughnessMap, textureCoord).r;\");\n        }\n\n        if (uvs && material._metallicRoughnessMap) {\n            if (material._metallicRoughnessMap._state.matrix) {\n                src.push(\"textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;\");\n            } else {\n                src.push(\"textureCoord = texturePos.xy;\");\n            }\n            src.push(\"vec3 metalRoughRGB = texture2D(metallicRoughnessMap, textureCoord).rgb;\");\n            src.push(\"metallic *= metalRoughRGB.b;\");\n            src.push(\"roughness *= metalRoughRGB.g;\");\n        }\n\n        src.push(\"vec3 viewEyeDir = normalize(-vViewPosition);\");\n\n        if (material._diffuseFresnel) {\n            src.push(\"float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);\");\n            src.push(\"diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);\");\n        }\n        if (material._specularFresnel) {\n            src.push(\"float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);\");\n            src.push(\"specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);\");\n        }\n        if (material._alphaFresnel) {\n            src.push(\"float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);\");\n            src.push(\"alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);\");\n        }\n        if (material._emissiveFresnel) {\n            src.push(\"float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);\");\n            src.push(\"emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);\");\n        }\n\n        src.push(\"if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {\"); // ie. (alphaMode == \"mask\" && alpha < alphaCutoff)\n        src.push(\"   discard;\"); // TODO: Discard earlier within this shader?\n        src.push(\"}\");\n\n        // PREPARE INPUTS FOR SHADER FUNCTIONS\n\n        src.push(\"IncidentLight  light;\");\n        src.push(\"Material       material;\");\n        src.push(\"Geometry       geometry;\");\n        src.push(\"ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));\");\n        src.push(\"vec3           viewLightDir;\");\n\n        if (phongMaterial) {\n            src.push(\"material.diffuseColor      = diffuseColor;\");\n            src.push(\"material.specularColor     = specular;\");\n            src.push(\"material.shine             = materialShininess;\");\n        }\n\n        if (specularMaterial) {\n            src.push(\"float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);\"); // Energy conservation\n            src.push(\"material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;\");\n            src.push(\"material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );\");\n            src.push(\"material.specularColor     = specular;\");\n        }\n\n        if (metallicMaterial) {\n            src.push(\"float dielectricSpecular = 0.16 * specularF0 * specularF0;\");\n            src.push(\"material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);\");\n            src.push(\"material.specularRoughness = clamp(roughness, 0.04, 1.0);\");\n            src.push(\"material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);\");\n        }\n\n        src.push(\"geometry.position      = vViewPosition;\");\n        if (lightsState.lightMaps.length > 0) {\n            src.push(\"geometry.worldNormal   = normalize(vWorldNormal);\");\n        }\n        src.push(\"geometry.viewNormal    = viewNormal;\");\n        src.push(\"geometry.viewEyeDir    = viewEyeDir;\");\n\n        // ENVIRONMENT AND REFLECTION MAP SHADING\n\n        if ((phongMaterial) && (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {\n            src.push(\"computePhongLightMapping(geometry, material, reflectedLight);\");\n        }\n\n        if ((specularMaterial || metallicMaterial) && (lightsState.lightMaps.length > 0 || lightsState.reflectionMaps.length > 0)) {\n            src.push(\"computePBRLightMapping(geometry, material, reflectedLight);\");\n        }\n\n        // LIGHT SOURCE SHADING\n\n        src.push(\"float shadow = 1.0;\");\n\n        // if (receivesShadow) {\n        //\n        //     src.push(\"float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);\");\n        //     src.push(\"float illuminated = VSM(sLightDepth, lightUV, lightDepth2);\");\n        //\n        src.push(\"float shadowAcneRemover = 0.007;\");\n        src.push(\"vec3 fragmentDepth;\");\n        src.push(\"float texelSize = 1.0 / 1024.0;\");\n        src.push(\"float amountInLight = 0.0;\");\n        src.push(\"vec3 shadowCoord;\");\n        src.push('vec4 rgbaDepth;');\n        src.push(\"float depth;\");\n        // }\n\n        const numShadows = 0;\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n\n            const light = lightsState.lights[i];\n\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            if (light.type === \"dir\" && light.space === \"view\") {\n                src.push(\"viewLightDir = -normalize(lightDir\" + i + \");\");\n            } else if (light.type === \"point\" && light.space === \"view\") {\n                src.push(\"viewLightDir = normalize(lightPos\" + i + \" - vViewPosition);\");\n                //src.push(\"tmpVec3 = lightPos\" + i + \".xyz - viewPosition.xyz;\");\n                //src.push(\"lightDist = abs(length(tmpVec3));\");\n            } else {\n                src.push(\"viewLightDir = normalize(vViewLightReverseDirAndDist\" + i + \".xyz);\"); // If normal mapping, the fragment->light vector will be in tangent space\n            }\n\n            if (receivesShadow && light.castsShadow) {\n\n                // if (true) {\n                //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');\n                //     src.push(\"lightDepth2 = clamp(length(vec3[0.0, 20.0, 20.0])/40.0, 0.0, 1.0);\");\n                //     src.push(\"castsShadow *= VSM(shadowMap' + i + ', shadowCoord, lightDepth2);\");\n                // }\n                //\n                // if (false) {\n                //\n                // PCF\n\n                src.push(\"shadow = 0.0;\");\n\n                src.push(\"fragmentDepth = vShadowPosFromLight\" + i + \".xyz;\");\n                src.push(\"fragmentDepth.z -= shadowAcneRemover;\");\n                src.push(\"for (int x = -3; x <= 3; x++) {\");\n                src.push(\"  for (int y = -3; y <= 3; y++) {\");\n                src.push(\"      float texelDepth = unpackDepth(texture2D(shadowMap\" + i + \", fragmentDepth.xy + vec2(x, y) * texelSize));\");\n                src.push(\"      if (fragmentDepth.z < texelDepth) {\");\n                src.push(\"          shadow += 1.0;\");\n                src.push(\"      }\");\n                src.push(\"  }\");\n                src.push(\"}\");\n\n                src.push(\"shadow = shadow / 9.0;\");\n\n                src.push(\"light.color =  lightColor\" + i + \".rgb * (lightColor\" + i + \".a * shadow);\"); // a is intensity\n                //\n                // }\n                //\n                // if (false){\n                //\n                //     src.push(\"shadow = 1.0;\");\n                //\n                //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');\n                //\n                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.94201624, -0.39906216 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');\n                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.94558609, -0.76890725 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');\n                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.094184101, -0.92938870 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');\n                //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.34495938, 0.29387760 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');\n                //\n                //     src.push(\"light.color =  lightColor\" + i + \".rgb * (lightColor\" + i + \".a * shadow);\");\n                // }\n            } else {\n                src.push(\"light.color =  lightColor\" + i + \".rgb * (lightColor\" + i + \".a );\"); // a is intensity\n            }\n\n            src.push(\"light.direction = viewLightDir;\");\n\n            if (phongMaterial) {\n                src.push(\"computePhongLighting(light, geometry, material, reflectedLight);\");\n            }\n\n            if (specularMaterial || metallicMaterial) {\n                src.push(\"computePBRLighting(light, geometry, material, reflectedLight);\");\n            }\n        }\n\n        if (numShadows > 0) {\n            //src.push(\"shadow /= \" + (9 * numShadows) + \".0;\");\n        }\n\n        //src.push(\"reflectedLight.diffuse *= shadow;\");\n\n        // COMBINE TERMS\n\n        if (phongMaterial) {\n            src.push(\"vec3 outgoingLight = (lightAmbient.rgb * lightAmbient.a * diffuseColor) + ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;\");\n\n        } else {\n            src.push(\"vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (occlusion * reflectedLight.specular) + emissiveColor;\");\n        }\n\n    } else {\n\n        //--------------------------------------------------------------------------------\n        // NO SHADING - EMISSIVE and AMBIENT ONLY\n        //--------------------------------------------------------------------------------\n\n        src.push(\"ambientColor *= (lightAmbient.rgb * lightAmbient.a);\");\n\n        src.push(\"vec3 outgoingLight = emissiveColor + ambientColor;\");\n    }\n\n    src.push(\"gl_FragColor = vec4(outgoingLight, alpha) * colorize;\");\n\n    if (gammaOutput) {\n        src.push(\"gl_FragColor = linearToGamma(gl_FragColor, gammaFactor);\");\n    }\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n\n    src.push(\"}\");\n\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZHJhdy9EcmF3U2hhZGVyU291cmNlLmpzPzViNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDLDRDQUE0QztBQUM1QztBQUNBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDakQsZ0RBQWdEO0FBQ2hELHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELCtFQUErRTtBQUMvRSwwQ0FBMEM7QUFDMUMsZ0hBQWdIO0FBQ2hILDJCQUEyQjtBQUMzQiw4Q0FBOEM7QUFDOUMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEMsbUJBQW1CO0FBQ25CO0FBQ0EsK0JBQStCO0FBQy9CLHVEQUF1RDtBQUN2RCxpQ0FBaUM7QUFDakM7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFLFNBQVM7QUFDVCwyREFBMkQ7QUFDM0Q7QUFDQSw4REFBOEQ7QUFDOUQsNERBQTREO0FBQzVEO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5QztBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDO0FBQ0EsMkZBQTJGO0FBQzNGLG9EQUFvRDtBQUNwRCxtREFBbUQ7QUFDbkQsdURBQXVEO0FBQ3ZEO0FBQ0EsK0RBQStEO0FBQy9ELGlFQUFpRTtBQUNqRSxzRUFBc0U7QUFDdEUsS0FBSztBQUNMLCtEQUErRDtBQUMvRCxpRUFBaUU7QUFDakUsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZELHFDQUFxQztBQUNyQztBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSxpQkFBaUI7QUFDakIseUdBQXlHO0FBQ3pHO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEZBQThGO0FBQzlGLGlCQUFpQjtBQUNqQiwwR0FBMEc7QUFDMUc7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwRUFBMEU7QUFDMUUsaUJBQWlCO0FBQ2pCLHlHQUF5RztBQUN6RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLHVHQUF1RztBQUN2RztBQUNBO0FBQ0Esc0hBQXNIO0FBQ3RILCtLQUErSyxHQUFHO0FBQ2xMO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxvQ0FBb0M7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQUssSUFBSSxLQUF1QjtBQUNsRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtDQUFrQztBQUNsQztBQUNBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyx5Q0FBeUM7QUFDekMsc0VBQXNFLFNBQVM7QUFDL0UsK0RBQStEO0FBQy9ELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLDRDQUE0QztBQUM1QyxpRkFBaUY7QUFDakYsMEZBQTBGO0FBQzFGLG1CQUFtQjtBQUNuQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsc0VBQXNFLFNBQVM7QUFDL0Usd0RBQXdEO0FBQ3hELDJJQUEySTtBQUMzSSx1QkFBdUI7QUFDdkI7QUFDQSxxQ0FBcUMsU0FBUyxFQUFFO0FBQ2hEO0FBQ0Esc0RBQXNEO0FBQ3RELG1FQUFtRTtBQUNuRSxrQ0FBa0M7QUFDbEMseUJBQXlCO0FBQ3pCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsMENBQTBDO0FBQzFDLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsS0FBSztBQUNMLHdDQUF3QztBQUN4QztBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsMENBQTBDO0FBQzFDLG1DQUFtQztBQUNuQztBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsb0RBQW9EO0FBQ3BELG1EQUFtRDtBQUNuRCw4Q0FBOEM7QUFDOUMsd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELCtFQUErRTtBQUMvRSwwQ0FBMEM7QUFDMUMsZ0hBQWdIO0FBQ2hILDJCQUEyQjtBQUMzQiw4Q0FBOEM7QUFDOUMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJLHdEQUF3RCxTQUFTLE9BQU87QUFDeEU7QUFDQSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsdURBQXVEO0FBQ3ZELGlDQUFpQztBQUNqQztBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBLGlFQUFpRTtBQUNqRSxnRUFBZ0U7QUFDaEU7QUFDQSxzREFBc0Q7QUFDdEQsdURBQXVEO0FBQ3ZEO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0M7QUFDQSwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELG1EQUFtRDtBQUNuRCx1REFBdUQ7QUFDdkQ7QUFDQSwrREFBK0Q7QUFDL0QsaUVBQWlFO0FBQ2pFLHNFQUFzRTtBQUN0RSxLQUFLO0FBQ0wsK0RBQStEO0FBQy9ELGlFQUFpRTtBQUNqRSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLDRGQUE0RjtBQUM1RiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLHdEQUF3RCxTQUFTLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RywrREFBK0Q7QUFDL0QsaUJBQWlCO0FBQ2pCLGlGQUFpRjtBQUNqRiwrREFBK0Q7QUFDL0Q7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxTQUFTO0FBQ1QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxrREFBa0Q7QUFDbEQsdURBQXVEO0FBQ3ZEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EscUlBQXFJO0FBQ3JJLDZCQUE2QjtBQUM3Qix3REFBd0QsU0FBUyxPQUFPO0FBQ3hFO0FBQ0Esb0pBQW9KO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQUssSUFBSSxLQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCw2R0FBNkc7QUFDN0csZ0RBQWdEO0FBQ2hELG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLG9EQUFvRDtBQUNwRCw2QkFBNkI7QUFDN0IsZUFBZTtBQUNmLGtEQUFrRDtBQUNsRCxrTUFBa007QUFDbE0sZUFBZTtBQUNmLGtEQUFrRDtBQUNsRCw4RUFBOEU7QUFDOUUsZUFBZTtBQUNmO0FBQ0EsNkVBQTZFO0FBQzdFLHdGQUF3RjtBQUN4RixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLHlDQUF5QztBQUN6Qyx1QkFBdUIsNkNBQTZDO0FBQ3BFLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsK0VBQStFO0FBQy9FLDJFQUEyRTtBQUMzRSxtQkFBbUI7O0FBRW5COztBQUVBLHdDQUF3QztBQUN4QyxnQ0FBZ0M7QUFDaEMsb0NBQW9DO0FBQ3BDLG9CQUFvQjs7QUFFcEIseUNBQXlDO0FBQ3pDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsb0JBQW9COztBQUVwQixtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLG9CQUFvQjs7QUFFcEIsbUNBQW1DO0FBQ25DLDBDQUEwQztBQUMxQywrQ0FBK0M7QUFDL0MsMkNBQTJDO0FBQzNDLG1DQUFtQyxHQUFHO0FBQ3RDLG9CQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUE7O0FBRUEsc0pBQXNKOztBQUV0SjtBQUNBLG9LQUFvSztBQUNwSyxrREFBa0Q7QUFDbEQsbUdBQW1HO0FBQ25HLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xILGdIQUFnSDtBQUNoSCxnREFBZ0Q7QUFDaEQseUVBQXlFO0FBQ3pFO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBLGtMQUFrTDtBQUNsTCxxR0FBcUc7QUFDckcsMEVBQTBFO0FBQzFFLHlHQUF5RztBQUN6RyxnTkFBZ047QUFDaE4sdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBOztBQUVBLHNGQUFzRjtBQUN0Rix5REFBeUQ7QUFDekQsc0RBQXNEO0FBQ3RELHVCQUF1Qjs7QUFFdkIsa0hBQWtIO0FBQ2xILHdFQUF3RTtBQUN4RSx1SkFBdUo7QUFDdkosaUZBQWlGO0FBQ2pGLHVCQUF1Qjs7QUFFdkI7QUFDQSx5SkFBeUo7QUFDekosNkdBQTZHLEdBQUc7QUFDaEgsMktBQTJLO0FBQzNLLCtDQUErQztBQUMvQywyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUEseUZBQXlGO0FBQ3pGLHdGQUF3RjtBQUN4RixrRkFBa0Y7QUFDbEYsdUJBQXVCOztBQUV2QiwyR0FBMkc7QUFDM0csc0RBQXNEO0FBQ3RELDBGQUEwRjtBQUMxRiwwRkFBMEY7QUFDMUYsa0RBQWtEO0FBQ2xELHVCQUF1Qjs7QUFFdkIscUhBQXFIO0FBQ3JILHNEQUFzRDtBQUN0RCwwRkFBMEY7QUFDMUYsMEZBQTBGO0FBQzFGLDhEQUE4RDtBQUM5RCx1QkFBdUI7O0FBRXZCLCtFQUErRTtBQUMvRSxzREFBc0Q7QUFDdEQsNkVBQTZFO0FBQzdFLHNFQUFzRTtBQUN0RSx1QkFBdUI7O0FBRXZCLHVLQUF1SztBQUN2SyxpRUFBaUU7QUFDakUsbUdBQW1HO0FBQ25HLHVHQUF1RztBQUN2RyxtR0FBbUc7QUFDbkcsdUZBQXVGO0FBQ3ZGLDJGQUEyRjtBQUMzRixxRUFBcUU7QUFDckUsZ0ZBQWdGO0FBQ2hGLHlEQUF5RDtBQUN6RCw0Q0FBNEM7QUFDNUMsdUJBQXVCOztBQUV2Qiw2SUFBNkk7QUFDN0ksK0ZBQStGO0FBQy9GLDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usc0RBQXNEO0FBQ3RELHNGQUFzRjtBQUN0RixzRUFBc0U7QUFDdEUsNERBQTREO0FBQzVELHVCQUF1Qjs7QUFFdkI7O0FBRUEsb0pBQW9KO0FBQ3BKO0FBQ0EsaUhBQWlIO0FBQ2pILGtEQUFrRDtBQUNsRCxtR0FBbUc7QUFDbkcsMkZBQTJGO0FBQzNGLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xILGlIQUFpSDtBQUNqSCx1SEFBdUg7QUFDdkgsbUlBQW1JO0FBQ25JLDJKQUEySjtBQUMzSiwrRkFBK0Y7QUFDL0Y7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUEsa0xBQWtMO0FBQ2xMLHVHQUF1RztBQUN2Ryw0RUFBNEU7QUFDNUUseUdBQXlHO0FBQ3pHLGdLQUFnSztBQUNoSyx1QkFBdUI7O0FBRXZCLFNBQVM7O0FBRVQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtRkFBbUY7QUFDbkYsa0dBQWtHO0FBQ2xHLGtHQUFrRztBQUNsRyxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELHNFQUFzRTtBQUN0RSx1RUFBdUU7QUFDdkUsd0RBQXdEO0FBQ3hELCtFQUErRTtBQUMvRSxtREFBbUQ7QUFDbkQsMkNBQTJDO0FBQzNDLHVEQUF1RDtBQUN2RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRywwREFBMEQ7QUFDMUQsaUdBQWlHO0FBQ2pHLGlEQUFpRDtBQUNqRCxtQkFBbUI7QUFDbkI7QUFDQSw4REFBOEQ7QUFDOUQsNERBQTREO0FBQzVELHlEQUF5RDtBQUN6RCwrREFBK0Q7QUFDL0QsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsNkRBQTZEO0FBQzdELDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMERBQTBEO0FBQzFELHVEQUF1RDtBQUN2RCw2REFBNkQ7QUFDN0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsdUVBQXVFO0FBQ3ZFLG9FQUFvRTtBQUNwRSwwRUFBMEU7QUFDMUUsd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsNkRBQTZEO0FBQzdELDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQSx3REFBd0QsU0FBUyxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2IsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLHNCQUFzQjtBQUN0QjtBQUNBLHlFQUF5RTtBQUN6RSxtRUFBbUU7QUFDbkUsa0ZBQWtGO0FBQ2xGLHlGQUF5RjtBQUN6Rix5REFBeUQ7QUFDekQsd0ZBQXdGO0FBQ3hGLGlFQUFpRTtBQUNqRSxzQkFBc0I7O0FBRXRCLHdEQUF3RCxTQUFTLE9BQU87QUFDeEU7QUFDQSxvRUFBb0U7QUFDcEUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0Esa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQyx1QkFBdUIsNkNBQTZDO0FBQ3BFLHdEQUF3RDtBQUN4RCwySUFBMkk7QUFDM0ksdUJBQXVCO0FBQ3ZCO0FBQ0EscUNBQXFDLFNBQVMsRUFBRTtBQUNoRDtBQUNBLHNEQUFzRDtBQUN0RCxtRUFBbUU7QUFDbkUsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6QjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RCwwQ0FBMEM7QUFDMUMsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QixtQkFBbUI7QUFDbkI7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBLHNEQUFzRDtBQUN0RCxLQUFLO0FBQ0wsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3RELEtBQUs7QUFDTCx3REFBd0Q7QUFDeEQsS0FBSztBQUNMLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBLHdEQUF3RCxHQUFHO0FBQzNELEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRCxLQUFLO0FBQ0wsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hELEtBQUs7QUFDTCx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQsS0FBSztBQUNMLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RCxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hELEtBQUs7QUFDTCx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVCxtREFBbUQ7QUFDbkQ7QUFDQSw4RUFBOEU7QUFDOUUsa0hBQWtIO0FBQ2xILG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVCxtREFBbUQ7QUFDbkQ7QUFDQSwwRUFBMEU7QUFDMUUsa0hBQWtIO0FBQ2xILG1EQUFtRDtBQUNuRCwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSxTQUFTO0FBQ1QsbURBQW1EO0FBQ25EO0FBQ0EsOEVBQThFO0FBQzlFLHdIQUF3SDtBQUN4SCxxREFBcUQ7QUFDckQsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsU0FBUztBQUNULG1EQUFtRDtBQUNuRDtBQUNBLDRFQUE0RTtBQUM1RSxxSEFBcUg7QUFDckgsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsU0FBUztBQUNULG1EQUFtRDtBQUNuRDtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLFNBQVM7QUFDVCxtREFBbUQ7QUFDbkQ7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsYUFBYTtBQUNiLHVEQUF1RDtBQUN2RDtBQUNBLGlIQUFpSDtBQUNqSCxTQUFTO0FBQ1QsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsYUFBYTtBQUNiLHVEQUF1RDtBQUN2RDtBQUNBLDJFQUEyRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FLGFBQWE7QUFDYix1REFBdUQ7QUFDdkQ7QUFDQSw2RUFBNkU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBLCtGQUErRjtBQUMvRixhQUFhO0FBQ2IsdURBQXVEO0FBQ3ZEO0FBQ0Esc0dBQXNHLEdBQUc7QUFDekcsbURBQW1EO0FBQ25ELG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLGFBQWE7QUFDYix1REFBdUQ7QUFDdkQ7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxhQUFhO0FBQ2IsdURBQXVEO0FBQ3ZEO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEYsYUFBYTtBQUNiLHVEQUF1RDtBQUN2RDtBQUNBLDZGQUE2RjtBQUM3RixrREFBa0Q7QUFDbEQsbURBQW1EO0FBQ25EOztBQUVBLDhEQUE4RDs7QUFFOUQ7QUFDQSxvSkFBb0o7QUFDcEosOEdBQThHO0FBQzlHO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEosNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUkscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEosa0hBQWtIO0FBQ2xIOztBQUVBLGdHQUFnRyxHQUFHO0FBQ25HLDZCQUE2QixHQUFHO0FBQ2hDLG1CQUFtQjs7QUFFbkI7O0FBRUEsdUNBQXVDO0FBQ3ZDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsdUdBQXVHO0FBQ3ZHLDhDQUE4Qzs7QUFFOUM7QUFDQSxnRUFBZ0U7QUFDaEUsNERBQTREO0FBQzVELHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBLDBHQUEwRyxHQUFHO0FBQzdHLDJGQUEyRjtBQUMzRix3RkFBd0Y7QUFDeEYsNERBQTREO0FBQzVEOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLGdIQUFnSDtBQUNoSCwrRUFBK0U7QUFDL0UseUdBQXlHO0FBQ3pHOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0EsaUZBQWlGO0FBQ2pGOztBQUVBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixvRkFBb0Y7QUFDcEY7QUFDQSxrREFBa0Q7QUFDbEQscUNBQXFDO0FBQ3JDLGlEQUFpRDtBQUNqRCw0Q0FBNEM7QUFDNUMsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQSx3REFBd0QsU0FBUzs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsYUFBYTtBQUNiLHNGQUFzRjtBQUN0RiwrRUFBK0U7QUFDL0UsNkRBQTZEO0FBQzdELGFBQWE7QUFDYiw2RkFBNkYsR0FBRztBQUNoRzs7QUFFQTs7QUFFQTtBQUNBLDJIQUEySDtBQUMzSCxtR0FBbUc7QUFDbkcsa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QywyRUFBMkU7QUFDM0UsK0RBQStEO0FBQy9ELDBDQUEwQyxRQUFRLE9BQU87QUFDekQsNENBQTRDLFFBQVEsT0FBTztBQUMzRCx5SUFBeUk7QUFDekksbUVBQW1FO0FBQ25FLGtEQUFrRDtBQUNsRCxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDJCQUEyQjs7QUFFM0IsZ0RBQWdEOztBQUVoRCxvR0FBb0csR0FBRztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0Esd0xBQXdMO0FBQ3hMLHVMQUF1TDtBQUN2TCx5TEFBeUw7QUFDekwsc0xBQXNMO0FBQ3RMO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0EsYUFBYTtBQUNiLDRGQUE0RixHQUFHO0FBQy9GOztBQUVBLHFEQUFxRDs7QUFFckQ7QUFDQSwwRkFBMEY7QUFDMUY7O0FBRUE7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQSxxREFBcUQ7O0FBRXJEOztBQUVBO0FBQ0Esc0xBQXNMOztBQUV0TCxTQUFTO0FBQ1QsMElBQTBJO0FBQzFJOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTs7QUFFdEUsb0VBQW9FO0FBQ3BFOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQSwwRUFBMEU7QUFDMUU7O0FBRUE7QUFDQSw2RUFBNkU7QUFDN0U7O0FBRUEsZUFBZTs7QUFFZjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZHJhdy9EcmF3U2hhZGVyU291cmNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBEcmF3U2hhZGVyU291cmNlID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBpZiAobWVzaC5fbWF0ZXJpYWwuX3N0YXRlLnR5cGUgPT09IFwiTGFtYmVydE1hdGVyaWFsXCIpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSBidWlsZFZlcnRleExhbWJlcnQobWVzaCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50TGFtYmVydChtZXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZlcnRleCA9IGJ1aWxkVmVydGV4RHJhdyhtZXNoKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnREcmF3KG1lc2gpO1xuICAgIH1cbn07XG5cbmNvbnN0IFRFWFRVUkVfREVDT0RFX0ZVTkNTID0ge1xuICAgIFwibGluZWFyXCI6IFwibGluZWFyVG9MaW5lYXJcIixcbiAgICBcInNSR0JcIjogXCJzUkdCVG9MaW5lYXJcIixcbiAgICBcImdhbW1hXCI6IFwiZ2FtbWFUb0xpbmVhclwiXG59O1xuXG5mdW5jdGlvbiBnZXRSZWNlaXZlc1NoYWRvdyhtZXNoKSB7XG4gICAgaWYgKCFtZXNoLnJlY2VpdmVzU2hhZG93KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlnaHRzID0gbWVzaC5zY2VuZS5fbGlnaHRzU3RhdGUubGlnaHRzO1xuICAgIGlmICghbGlnaHRzIHx8IGxpZ2h0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChsaWdodHNbaV0uY2FzdHNTaGFkb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzVGV4dHVyZXMobWVzaCkge1xuICAgIGlmICghbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLnV2QnVmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBtZXNoLl9tYXRlcmlhbDtcbiAgICByZXR1cm4gISEobWF0ZXJpYWwuX2FtYmllbnRNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX29jY2x1c2lvbk1hcCB8fFxuICAgICAgICBtYXRlcmlhbC5fYmFzZUNvbG9yTWFwIHx8XG4gICAgICAgIG1hdGVyaWFsLl9kaWZmdXNlTWFwIHx8XG4gICAgICAgIG1hdGVyaWFsLl9hbHBoYU1hcCB8fFxuICAgICAgICBtYXRlcmlhbC5fc3BlY3VsYXJNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX2dsb3NzaW5lc3NNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX3NwZWN1bGFyR2xvc3NpbmVzc01hcCB8fFxuICAgICAgICBtYXRlcmlhbC5fZW1pc3NpdmVNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX21ldGFsbGljTWFwIHx8XG4gICAgICAgIG1hdGVyaWFsLl9yb3VnaG5lc3NNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX21ldGFsbGljUm91Z2huZXNzTWFwIHx8XG4gICAgICAgIG1hdGVyaWFsLl9yZWZsZWN0aXZpdHlNYXAgfHxcbiAgICAgICAgbWF0ZXJpYWwuX25vcm1hbE1hcCk7XG59XG5cbmZ1bmN0aW9uIGhhc05vcm1hbHMobWVzaCkge1xuICAgIGNvbnN0IHByaW1pdGl2ZSA9IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5wcmltaXRpdmVOYW1lO1xuICAgIGlmICgobWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmF1dG9WZXJ0ZXhOb3JtYWxzIHx8IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5ub3JtYWxzQnVmKSAmJiAocHJpbWl0aXZlID09PSBcInRyaWFuZ2xlc1wiIHx8IHByaW1pdGl2ZSA9PT0gXCJ0cmlhbmdsZS1zdHJpcFwiIHx8IHByaW1pdGl2ZSA9PT0gXCJ0cmlhbmdsZS1mYW5cIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWZXJ0ZXhMYW1iZXJ0KG1lc2gpIHtcblxuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzU3RhdGUgPSBtZXNoLnNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGU7XG4gICAgY29uc3QgbGlnaHRzU3RhdGUgPSBtZXNoLnNjZW5lLl9saWdodHNTdGF0ZTtcbiAgICBjb25zdCBnZW9tZXRyeVN0YXRlID0gbWVzaC5fZ2VvbWV0cnkuX3N0YXRlO1xuICAgIGNvbnN0IGJpbGxib2FyZCA9IG1lc2guX3N0YXRlLmJpbGxib2FyZDtcbiAgICBjb25zdCBzdGF0aW9uYXJ5ID0gbWVzaC5fc3RhdGUuc3RhdGlvbmFyeTtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgcXVhbnRpemVkR2VvbWV0cnkgPSAhIWdlb21ldHJ5U3RhdGUuY29tcHJlc3NHZW9tZXRyeTtcblxuICAgIGNvbnN0IHNyYyA9IFtdO1xuICAgIHNyYy5wdXNoKFwiLy8gTGFtYmVydGlhbiBkcmF3aW5nIHZlcnRleCBzaGFkZXJcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0IGNvbG9yaXplO1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBvZmZzZXQ7XCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBwb3NpdGlvbnNEZWNvZGVNYXRyaXg7XCIpO1xuICAgIH1cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgfVxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0IGxpZ2h0QW1iaWVudDtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzQgbWF0ZXJpYWxDb2xvcjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgbWF0ZXJpYWxFbWlzc2l2ZTtcIik7XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUubm9ybWFsc0J1Zikge1xuICAgICAgICBzcmMucHVzaChcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG1vZGVsTm9ybWFsTWF0cml4O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgdmlld05vcm1hbE1hdHJpeDtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaWdodHNTdGF0ZS5saWdodHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzU3RhdGUubGlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiYW1iaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCBsaWdodENvbG9yXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodERpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodFBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInNwb3RcIikge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0RGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIG9jdERlY29kZSh2ZWMyIG9jdCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHZlYzMgdiA9IHZlYzMob2N0Lnh5LCAxLjAgLSBhYnMob2N0LngpIC0gYWJzKG9jdC55KSk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgaWYgKHYueiA8IDAuMCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICAgICB2Lnh5ID0gKDEuMCAtIGFicyh2Lnl4KSkgKiB2ZWMyKHYueCA+PSAwLjAgPyAxLjAgOiAtMS4wLCB2LnkgPj0gMC4wID8gMS4wIDogLTEuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgfVwiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHJldHVybiBub3JtYWxpemUodik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZDb2xvcjtcIik7XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlTmFtZSA9PT0gXCJwb2ludHNcIikge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgcG9pbnRTaXplO1wiKTtcbiAgICB9XG4gICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIiB8fCBiaWxsYm9hcmQgPT09IFwiY3lsaW5kcmljYWxcIikge1xuICAgICAgICBzcmMucHVzaChcInZvaWQgYmlsbGJvYXJkKGlub3V0IG1hdDQgbWF0KSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVswXSA9IDEuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzFdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMl0gPSAwLjA7XCIpO1xuICAgICAgICBpZiAoYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVswXSA9IDAuMDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVsxXSA9IDEuMDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVsyXSA9IDAuMDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMF0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVsxXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzJdID0xLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGxvY2FsUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApOyBcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IHdvcmxkUG9zaXRpb247XCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcImxvY2FsUG9zaXRpb24gPSBwb3NpdGlvbnNEZWNvZGVNYXRyaXggKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUubm9ybWFsc0J1Zikge1xuICAgICAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbE5vcm1hbCA9IHZlYzQob2N0RGVjb2RlKG5vcm1hbC54eSksIDAuMCk7IFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbE5vcm1hbCA9IHZlYzQobm9ybWFsLCAwLjApOyBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsTm9ybWFsTWF0cml4MiA9IG1vZGVsTm9ybWFsTWF0cml4O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IHZpZXdOb3JtYWxNYXRyaXgyID0gdmlld05vcm1hbE1hdHJpeDtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwibWF0NCB2aWV3TWF0cml4MiA9IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbE1hdHJpeDIgPSBtb2RlbE1hdHJpeDtcIik7XG4gICAgaWYgKHN0YXRpb25hcnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2aWV3TWF0cml4MlszXVswXSA9IHZpZXdNYXRyaXgyWzNdWzFdID0gdmlld01hdHJpeDJbM11bMl0gPSAwLjA7XCIpXG4gICAgfVxuICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIgfHwgYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsVmlld01hdHJpeCA9IHZpZXdNYXRyaXgyICogbW9kZWxNYXRyaXgyO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxNYXRyaXgyKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKHZpZXdNYXRyaXgyKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsVmlld01hdHJpeCk7XCIpO1xuICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5ub3JtYWxzQnVmKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1hdDQgbW9kZWxWaWV3Tm9ybWFsTWF0cml4ID0gIHZpZXdOb3JtYWxNYXRyaXgyICogbW9kZWxOb3JtYWxNYXRyaXgyO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsTm9ybWFsTWF0cml4Mik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQodmlld05vcm1hbE1hdHJpeDIpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsVmlld05vcm1hbE1hdHJpeCk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4MiAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgICAgICBzcmMucHVzaChcIndvcmxkUG9zaXRpb24ueHl6ID0gd29ybGRQb3NpdGlvbi54eXogKyBvZmZzZXQ7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzQgdmlld1Bvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXgyICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbi54eXogPSB3b3JsZFBvc2l0aW9uLnh5eiArIG9mZnNldDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCB2aWV3UG9zaXRpb24gID0gdmlld01hdHJpeDIgKiB3b3JsZFBvc2l0aW9uOyBcIik7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVN0YXRlLm5vcm1hbHNCdWYpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHZpZXdOb3JtYWwgPSBub3JtYWxpemUoKHZpZXdOb3JtYWxNYXRyaXgyICogbW9kZWxOb3JtYWxNYXRyaXgyICogbG9jYWxOb3JtYWwpLnh5eik7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZlYzMgcmVmbGVjdGVkQ29sb3IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1wiKTtcbiAgICBzcmMucHVzaChcInZlYzMgdmlld0xpZ2h0RGlyID0gdmVjMygwLjAsIDAuMCwgLTEuMCk7XCIpO1xuICAgIHNyYy5wdXNoKFwiZmxvYXQgbGFtYmVydGlhbiA9IDEuMDtcIik7XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUubm9ybWFsc0J1Zikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaWdodCA9IGxpZ2h0c1N0YXRlLmxpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcImFtYmllbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlnaHQuc3BhY2UgPT09IFwidmlld1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidmlld0xpZ2h0RGlyID0gbm9ybWFsaXplKGxpZ2h0RGlyXCIgKyBpICsgXCIpO1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZSgodmlld01hdHJpeDIgKiB2ZWM0KGxpZ2h0RGlyXCIgKyBpICsgXCIsIDAuMCkpLnh5eik7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlnaHQudHlwZSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ2h0LnNwYWNlID09PSBcInZpZXdcIikge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IC1ub3JtYWxpemUobGlnaHRQb3NcIiArIGkgKyBcIiAtIHZpZXdQb3NpdGlvbi54eXopO1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IC1ub3JtYWxpemUoKHZpZXdNYXRyaXgyICogdmVjNChsaWdodFBvc1wiICsgaSArIFwiLCAwLjApKS54eXopO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpZ2h0LnR5cGUgPT09IFwic3BvdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ2h0LnNwYWNlID09PSBcInZpZXdcIikge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZShsaWdodERpclwiICsgaSArIFwiKTtcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2aWV3TGlnaHREaXIgPSBub3JtYWxpemUoKHZpZXdNYXRyaXgyICogdmVjNChsaWdodERpclwiICsgaSArIFwiLCAwLjApKS54eXopO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjLnB1c2goXCJsYW1iZXJ0aWFuID0gbWF4KGRvdCgtdmlld05vcm1hbCwgdmlld0xpZ2h0RGlyKSwgMC4wKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInJlZmxlY3RlZENvbG9yICs9IGxhbWJlcnRpYW4gKiAobGlnaHRDb2xvclwiICsgaSArIFwiLnJnYiAqIGxpZ2h0Q29sb3JcIiArIGkgKyBcIi5hKTtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9zcmMucHVzaChcInZDb2xvciA9IHZlYzQoKHJlZmxlY3RlZENvbG9yICogbWF0ZXJpYWxDb2xvcikgKyAobGlnaHRBbWJpZW50LnJnYiAqIGxpZ2h0QW1iaWVudC5hKSwgMS4wKSAqIGNvbG9yaXplO1wiKTtcbiAgICBzcmMucHVzaChcInZDb2xvciA9IHZlYzQoKGxpZ2h0QW1iaWVudC5yZ2IgKiBsaWdodEFtYmllbnQuYSAqIG1hdGVyaWFsQ29sb3IucmdiKSArIG1hdGVyaWFsRW1pc3NpdmUucmdiICsgKHJlZmxlY3RlZENvbG9yICogbWF0ZXJpYWxDb2xvci5yZ2IpLCBtYXRlcmlhbENvbG9yLmEpICogY29sb3JpemU7XCIpOyAvLyBUT0RPOiBIb3cgdG8gaGF2ZSBhbWJpZW50IGJyaWdodCBlbm91Z2ggZm9yIGNhbnZhcyBCRyBidXQgbm90IHRvbyBicmlnaHQgZm9yIHNjZW5lP1xuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZU5hbWUgPT09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9Qb2ludFNpemUgPSBwb2ludFNpemU7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZlYzQgY2xpcFBvcyA9IHByb2pNYXRyaXggKiB2aWV3UG9zaXRpb247XCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBzcmMucHVzaChcInZGcmFnRGVwdGggPSAxLjAgKyBjbGlwUG9zLnc7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcImdsX1Bvc2l0aW9uID0gY2xpcFBvcztcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnRMYW1iZXJ0KG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICBjb25zdCBtYXRlcmlhbFN0YXRlID0gbWVzaC5fbWF0ZXJpYWwuX3N0YXRlO1xuICAgIGNvbnN0IGdlb21ldHJ5U3RhdGUgPSBtZXNoLl9nZW9tZXRyeS5fc3RhdGU7XG4gICAgY29uc3QgY2xpcHBpbmcgPSBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNvbGlkID0gZmFsc2UgJiYgbWF0ZXJpYWxTdGF0ZS5iYWNrZmFjZXM7XG4gICAgY29uc3QgZ2FtbWFPdXRwdXQgPSBzY2VuZS5nYW1tYU91dHB1dDsgLy8gSWYgc2V0LCB0aGVuIGl0IGV4cGVjdHMgdGhhdCBhbGwgdGV4dHVyZXMgYW5kIGNvbG9ycyBuZWVkIHRvIGJlIG91dHB1dHRlZCBpbiBwcmVtdWx0aXBsaWVkIGdhbW1hLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgIGNvbnN0IHNyYyA9IFtdO1xuICAgIHNyYy5wdXNoKFwiLy8gTGFtYmVydGlhbiBkcmF3aW5nIGZyYWdtZW50IHNoYWRlclwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbHNlXCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbmRpZlwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgfVxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIGNsaXBwYWJsZTtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZDb2xvcjtcIik7XG4gICAgaWYgKGdhbW1hT3V0cHV0KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBnYW1tYUZhY3RvcjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgIHZlYzQgbGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgICByZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIDEuMCAvIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcImlmIChjbGlwcGFibGUpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICBmbG9hdCBkaXN0ID0gMC4wO1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImlmIChzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkgKyBcIikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZGlzdCArPSBjbGFtcChkb3QoLXNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiLnh5eiwgdldvcmxkUG9zaXRpb24ueHl6IC0gc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCIueHl6KSwgMC4wLCAxMDAwLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgaWYgKGRpc3QgPiAwLjApIHsgZGlzY2FyZDsgfVwiKTtcbiAgICAgICAgaWYgKHNvbGlkKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgaWYgKGdsX0Zyb250RmFjaW5nID09IGZhbHNlKSB7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgICAgcmV0dXJuO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICB9XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlTmFtZSA9PT0gXCJwb2ludHNcIikge1xuICAgICAgICBzcmMucHVzaChcInZlYzIgY3h5ID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgciA9IGRvdChjeHksIGN4eSk7XCIpO1xuICAgICAgICBzcmMucHVzaChcImlmIChyID4gMS4wKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIGRpc2NhcmQ7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcIik7XG4gICAgfVxuICAgIGlmIChnYW1tYU91dHB1dCkge1xuICAgICAgICBzcmMucHVzaChcImdsX0ZyYWdDb2xvciA9IGxpbmVhclRvR2FtbWEodkNvbG9yLCBnYW1tYUZhY3Rvcik7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmVydGV4RHJhdyhtZXNoKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbWVzaC5fbWF0ZXJpYWw7XG4gICAgY29uc3QgbWVzaFN0YXRlID0gbWVzaC5fc3RhdGU7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICBjb25zdCBnZW9tZXRyeVN0YXRlID0gbWVzaC5fZ2VvbWV0cnkuX3N0YXRlO1xuICAgIGNvbnN0IGxpZ2h0c1N0YXRlID0gc2NlbmUuX2xpZ2h0c1N0YXRlO1xuICAgIGxldCBpO1xuICAgIGxldCBsZW47XG4gICAgbGV0IGxpZ2h0O1xuICAgIGNvbnN0IGJpbGxib2FyZCA9IG1lc2hTdGF0ZS5iaWxsYm9hcmQ7XG4gICAgY29uc3Qgc3RhdGlvbmFyeSA9IG1lc2hTdGF0ZS5zdGF0aW9uYXJ5O1xuICAgIGNvbnN0IHRleHR1cmluZyA9IGhhc1RleHR1cmVzKG1lc2gpO1xuICAgIGNvbnN0IG5vcm1hbHMgPSBoYXNOb3JtYWxzKG1lc2gpO1xuICAgIGNvbnN0IGNsaXBwaW5nID0gc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCByZWNlaXZlc1NoYWRvdyA9IGdldFJlY2VpdmVzU2hhZG93KG1lc2gpO1xuICAgIGNvbnN0IHF1YW50aXplZEdlb21ldHJ5ID0gISFnZW9tZXRyeVN0YXRlLmNvbXByZXNzR2VvbWV0cnk7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBEcmF3aW5nIHZlcnRleCBzaGFkZXJcIik7XG4gICAgaWYgKG5vcm1hbHMgJiYgbWF0ZXJpYWwuX25vcm1hbE1hcCkge1xuICAgICAgICBzcmMucHVzaChcIiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcImF0dHJpYnV0ZSAgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHBvc2l0aW9uc0RlY29kZU1hdHJpeDtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidW5pZm9ybSAgbWF0NCBtb2RlbE1hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtICBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSAgbWF0NCBwcm9qTWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInZhcnlpbmcgIHZlYzMgdlZpZXdQb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtICB2ZWMzIG9mZnNldDtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgIH1cbiAgICBpZiAobGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nICAgIHZlYzMgdldvcmxkTm9ybWFsO1wiKTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgIHZlYzMgbm9ybWFsO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtICAgIG1hdDQgbW9kZWxOb3JtYWxNYXRyaXg7XCIpO1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gICAgbWF0NCB2aWV3Tm9ybWFsTWF0cml4O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nICAgIHZlYzMgdlZpZXdOb3JtYWw7XCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsaWdodCA9IGxpZ2h0c1N0YXRlLmxpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcImFtYmllbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodERpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodFBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInNwb3RcIikge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0RGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEobGlnaHQudHlwZSA9PT0gXCJkaXJcIiAmJiBsaWdodC5zcGFjZSA9PT0gXCJ2aWV3XCIpKSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzQgdlZpZXdMaWdodFJldmVyc2VEaXJBbmREaXN0XCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIG9jdERlY29kZSh2ZWMyIG9jdCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHZlYzMgdiA9IHZlYzMob2N0Lnh5LCAxLjAgLSBhYnMob2N0LngpIC0gYWJzKG9jdC55KSk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgaWYgKHYueiA8IDAuMCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICAgICB2Lnh5ID0gKDEuMCAtIGFicyh2Lnl4KSkgKiB2ZWMyKHYueCA+PSAwLjAgPyAxLjAgOiAtMS4wLCB2LnkgPj0gMC4wID8gMS4wIDogLTEuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgfVwiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHJldHVybiBub3JtYWxpemUodik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0dXJpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjMiB1djtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWMyIHZVVjtcIik7XG4gICAgICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDMgdXZEZWNvZGVNYXRyaXg7XCIpXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUuY29sb3JzKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiYXR0cmlidXRlIHZlYzQgY29sb3I7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2Q29sb3I7XCIpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5wcmltaXRpdmVOYW1lID09PSBcInBvaW50c1wiKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBwb2ludFNpemU7XCIpO1xuICAgIH1cbiAgICBpZiAoYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiIHx8IGJpbGxib2FyZCA9PT0gXCJjeWxpbmRyaWNhbFwiKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidm9pZCBiaWxsYm9hcmQoaW5vdXQgbWF0NCBtYXQpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzBdID0gMS4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMV0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVsyXSA9IDAuMDtcIik7XG4gICAgICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzBdID0gMC4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzFdID0gMS4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzJdID0gMC4wO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVswXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzFdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMl0gPTEuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKHJlY2VpdmVzU2hhZG93KSB7XG4gICAgICAgIHNyYy5wdXNoKFwiY29uc3QgbWF0NCB0ZXhVbml0Q29udmVydGVyID0gbWF0NCgwLjUsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC41LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjUsIDAuNSwgMC41LCAxLjApO1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpZ2h0c1N0YXRlLmxpZ2h0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyAvLyBMaWdodCBzb3VyY2VzXG4gICAgICAgICAgICBpZiAobGlnaHRzU3RhdGUubGlnaHRzW2ldLmNhc3RzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgc2hhZG93Vmlld01hdHJpeFwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBzaGFkb3dQcm9qTWF0cml4XCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZTaGFkb3dQb3NGcm9tTGlnaHRcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjLnB1c2goXCJ2b2lkIG1haW4odm9pZCkge1wiKTtcbiAgICBzcmMucHVzaChcInZlYzQgbG9jYWxQb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7IFwiKTtcbiAgICBzcmMucHVzaChcInZlYzQgd29ybGRQb3NpdGlvbjtcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwibG9jYWxQb3NpdGlvbiA9IHBvc2l0aW9uc0RlY29kZU1hdHJpeCAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBpZiAobm9ybWFscykge1xuICAgICAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbE5vcm1hbCA9IHZlYzQob2N0RGVjb2RlKG5vcm1hbC54eSksIDAuMCk7IFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbE5vcm1hbCA9IHZlYzQobm9ybWFsLCAwLjApOyBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsTm9ybWFsTWF0cml4MiAgICA9IG1vZGVsTm9ybWFsTWF0cml4O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IHZpZXdOb3JtYWxNYXRyaXgyICAgICA9IHZpZXdOb3JtYWxNYXRyaXg7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIm1hdDQgdmlld01hdHJpeDIgICAgICAgICAgID0gdmlld01hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsTWF0cml4MiAgICAgICAgICA9IG1vZGVsTWF0cml4O1wiKTtcbiAgICBpZiAoc3RhdGlvbmFyeSkge1xuICAgICAgICBzcmMucHVzaChcInZpZXdNYXRyaXgyWzNdWzBdID0gdmlld01hdHJpeDJbM11bMV0gPSB2aWV3TWF0cml4MlszXVsyXSA9IDAuMDtcIilcbiAgICB9XG4gICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIiB8fCBiaWxsYm9hcmQgPT09IFwiY3lsaW5kcmljYWxcIikge1xuICAgICAgICBzcmMucHVzaChcIm1hdDQgbW9kZWxWaWV3TWF0cml4ID0gdmlld01hdHJpeDIgKiBtb2RlbE1hdHJpeDI7XCIpO1xuICAgICAgICBzcmMucHVzaChcImJpbGxib2FyZChtb2RlbE1hdHJpeDIpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQodmlld01hdHJpeDIpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxWaWV3TWF0cml4KTtcIik7XG4gICAgICAgIGlmIChub3JtYWxzKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1hdDQgbW9kZWxWaWV3Tm9ybWFsTWF0cml4ID0gIHZpZXdOb3JtYWxNYXRyaXgyICogbW9kZWxOb3JtYWxNYXRyaXgyO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsTm9ybWFsTWF0cml4Mik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQodmlld05vcm1hbE1hdHJpeDIpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsVmlld05vcm1hbE1hdHJpeCk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4MiAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgICAgICBzcmMucHVzaChcIndvcmxkUG9zaXRpb24ueHl6ID0gd29ybGRQb3NpdGlvbi54eXogKyBvZmZzZXQ7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzQgdmlld1Bvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXgyICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbi54eXogPSB3b3JsZFBvc2l0aW9uLnh5eiArIG9mZnNldDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCB2aWV3UG9zaXRpb24gID0gdmlld01hdHJpeDIgKiB3b3JsZFBvc2l0aW9uOyBcIik7XG4gICAgfVxuICAgIGlmIChub3JtYWxzKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyB3b3JsZE5vcm1hbCA9IChtb2RlbE5vcm1hbE1hdHJpeDIgKiBsb2NhbE5vcm1hbCkueHl6OyBcIik7XG4gICAgICAgIGlmIChsaWdodHNTdGF0ZS5saWdodE1hcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2V29ybGROb3JtYWwgPSB3b3JsZE5vcm1hbDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ2Vmlld05vcm1hbCA9IG5vcm1hbGl6ZSgodmlld05vcm1hbE1hdHJpeDIgKiB2ZWM0KHdvcmxkTm9ybWFsLCAxLjApKS54eXopO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHRtcFZlYzM7XCIpO1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IGxpZ2h0RGlzdDtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaWdodHNTdGF0ZS5saWdodHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgLy8gTGlnaHRzXG4gICAgICAgICAgICBsaWdodCA9IGxpZ2h0c1N0YXRlLmxpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcImFtYmllbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlnaHQuc3BhY2UgPT09IFwid29ybGRcIikge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInRtcFZlYzMgPSB2ZWMzKHZpZXdNYXRyaXgyICogdmVjNChsaWdodERpclwiICsgaSArIFwiLCAwLjApICkueHl6O1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2Vmlld0xpZ2h0UmV2ZXJzZURpckFuZERpc3RcIiArIGkgKyBcIiA9IHZlYzQoLXRtcFZlYzMsIDAuMCk7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlnaHQuc3BhY2UgPT09IFwid29ybGRcIikge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInRtcFZlYzMgPSAodmlld01hdHJpeDIgKiB2ZWM0KGxpZ2h0UG9zXCIgKyBpICsgXCIsIDEuMCkpLnh5eiAtIHZpZXdQb3NpdGlvbi54eXo7XCIpO1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcImxpZ2h0RGlzdCA9IGFicyhsZW5ndGgodG1wVmVjMykpO1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInRtcFZlYzMgPSBsaWdodFBvc1wiICsgaSArIFwiLnh5eiAtIHZpZXdQb3NpdGlvbi54eXo7XCIpO1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcImxpZ2h0RGlzdCA9IGFicyhsZW5ndGgodG1wVmVjMykpO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2Vmlld0xpZ2h0UmV2ZXJzZURpckFuZERpc3RcIiArIGkgKyBcIiA9IHZlYzQodG1wVmVjMywgbGlnaHREaXN0KTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRleHR1cmluZykge1xuICAgICAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidlVWID0gKHV2RGVjb2RlTWF0cml4ICogdmVjMyh1diwgMS4wKSkueHk7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2VVYgPSB1djtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUuY29sb3JzKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidkNvbG9yID0gY29sb3I7XCIpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5wcmltaXRpdmVOYW1lID09PSBcInBvaW50c1wiKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfUG9pbnRTaXplID0gcG9pbnRTaXplO1wiKTtcbiAgICB9XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCIgICB2Vmlld1Bvc2l0aW9uID0gdmlld1Bvc2l0aW9uLnh5ejtcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGNsaXBQb3MgPSBwcm9qTWF0cml4ICogdmlld1Bvc2l0aW9uO1wiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2RnJhZ0RlcHRoID0gMS4wICsgY2xpcFBvcy53O1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJnbF9Qb3NpdGlvbiA9IGNsaXBQb3M7XCIpO1xuICAgIGlmIChyZWNlaXZlc1NoYWRvdykge1xuICAgICAgICBzcmMucHVzaChcImNvbnN0IG1hdDQgdGV4VW5pdENvbnZlcnRlciA9IG1hdDQoMC41LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjUsIDAuNSwgMS4wKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCB0ZW1weDsgXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IC8vIExpZ2h0IHNvdXJjZXNcbiAgICAgICAgICAgIGlmIChsaWdodHNTdGF0ZS5saWdodHNbaV0uY2FzdHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInZTaGFkb3dQb3NGcm9tTGlnaHRcIiArIGkgKyBcIiA9IHRleFVuaXRDb252ZXJ0ZXIgKiBzaGFkb3dQcm9qTWF0cml4XCIgKyBpICsgXCIgKiAoc2hhZG93Vmlld01hdHJpeFwiICsgaSArIFwiICogd29ybGRQb3NpdGlvbik7IFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMucHVzaChcIn1cIik7XG4gICAgcmV0dXJuIHNyYztcbn1cblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudERyYXcobWVzaCkge1xuXG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IGdsID0gc2NlbmUuY2FudmFzLmdsO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbWVzaC5fbWF0ZXJpYWw7XG4gICAgY29uc3QgZ2VvbWV0cnlTdGF0ZSA9IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzU3RhdGUgPSBtZXNoLnNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGU7XG4gICAgY29uc3QgbGlnaHRzU3RhdGUgPSBtZXNoLnNjZW5lLl9saWdodHNTdGF0ZTtcbiAgICBjb25zdCBtYXRlcmlhbFN0YXRlID0gbWVzaC5fbWF0ZXJpYWwuX3N0YXRlO1xuICAgIGNvbnN0IGNsaXBwaW5nID0gc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBub3JtYWxzID0gaGFzTm9ybWFscyhtZXNoKTtcbiAgICBjb25zdCB1dnMgPSBnZW9tZXRyeVN0YXRlLnV2QnVmO1xuICAgIGNvbnN0IHNvbGlkID0gZmFsc2UgJiYgbWF0ZXJpYWxTdGF0ZS5iYWNrZmFjZXM7XG4gICAgY29uc3QgcGhvbmdNYXRlcmlhbCA9IChtYXRlcmlhbFN0YXRlLnR5cGUgPT09IFwiUGhvbmdNYXRlcmlhbFwiKTtcbiAgICBjb25zdCBtZXRhbGxpY01hdGVyaWFsID0gKG1hdGVyaWFsU3RhdGUudHlwZSA9PT0gXCJNZXRhbGxpY01hdGVyaWFsXCIpO1xuICAgIGNvbnN0IHNwZWN1bGFyTWF0ZXJpYWwgPSAobWF0ZXJpYWxTdGF0ZS50eXBlID09PSBcIlNwZWN1bGFyTWF0ZXJpYWxcIik7XG4gICAgY29uc3QgcmVjZWl2ZXNTaGFkb3cgPSBnZXRSZWNlaXZlc1NoYWRvdyhtZXNoKTtcbiAgICBjb25zdCBnYW1tYUlucHV0ID0gc2NlbmUuZ2FtbWFJbnB1dDsgLy8gSWYgc2V0LCB0aGVuIGl0IGV4cGVjdHMgdGhhdCBhbGwgdGV4dHVyZXMgYW5kIGNvbG9ycyBhcmUgcHJlbXVsdGlwbGllZCBnYW1tYS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICBjb25zdCBnYW1tYU91dHB1dCA9IHNjZW5lLmdhbW1hT3V0cHV0OyAvLyBJZiBzZXQsIHRoZW4gaXQgZXhwZWN0cyB0aGF0IGFsbCB0ZXh0dXJlcyBhbmQgY29sb3JzIG5lZWQgdG8gYmUgb3V0cHV0dGVkIGluIHByZW11bHRpcGxpZWQgZ2FtbWEuIERlZmF1bHQgaXMgZmFsc2UuXG5cbiAgICBsZXQgbGlnaHQ7XG4gICAgY29uc3Qgc3JjID0gW107XG5cbiAgICBzcmMucHVzaChcIi8vIERyYXdpbmcgZnJhZ21lbnQgc2hhZGVyXCIpO1xuXG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFscyAmJiBtYXRlcmlhbC5fbm9ybWFsTWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIik7XG4gICAgfVxuXG4gICAgc3JjLnB1c2goXCIjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIGhpZ2hwIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZWxzZVwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZW5kaWZcIik7XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgfVxuXG4gICAgaWYgKHJlY2VpdmVzU2hhZG93KSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgdW5wYWNrRGVwdGggKHZlYzQgY29sb3IpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICBjb25zdCB2ZWM0IGJpdFNoaWZ0ID0gdmVjNCgxLjAsIDEuMC8yNTYuMCwgMS4wLygyNTYuMCAqIDI1Ni4wKSwgMS4wLygyNTYuMCoyNTYuMCoyNTYuMCkpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgIHJldHVybiBkb3QoY29sb3IsIGJpdFNoaWZ0KTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR0FNTUEgQ09SUkVDVElPTlxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBnYW1tYUZhY3RvcjtcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGxpbmVhclRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1wiKTtcbiAgICBzcmMucHVzaChcIiAgcmV0dXJuIHZhbHVlO1wiKTtcbiAgICBzcmMucHVzaChcIn1cIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IHNSR0JUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcIik7XG4gICAgc3JjLnB1c2goXCIgIHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHZhbHVlLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHZhbHVlLncgKTtcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCBnYW1tYVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlKSB7XCIpO1xuICAgIHNyYy5wdXNoKFwiICByZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1wiKTtcbiAgICBzcmMucHVzaChcIn1cIik7XG4gICAgaWYgKGdhbW1hT3V0cHV0KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCBsaW5lYXJUb0dhbW1hKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICByZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIDEuMCAvIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVU0VSIENMSVAgUExBTkVTXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgY2xpcHBhYmxlO1wiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbHMpIHtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExJR0hUIEFORCBSRUZMRUNUSU9OIE1BUCBJTlBVVFNcbiAgICAgICAgLy8gRGVmaW5lIGhlcmUgc28gYXZhaWxhYmxlIGdsb2JhbGx5IHRvIHNoYWRlciBmdW5jdGlvbnNcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChsaWdodHNTdGF0ZS5saWdodE1hcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIGxpZ2h0TWFwO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdOb3JtYWxNYXRyaXg7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaWdodHNTdGF0ZS5yZWZsZWN0aW9uTWFwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlckN1YmUgcmVmbGVjdGlvbk1hcDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLmxpZ2h0TWFwcy5sZW5ndGggPiAwIHx8IGxpZ2h0c1N0YXRlLnJlZmxlY3Rpb25NYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTSEFESU5HIEZVTkNUSU9OU1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gQ09OU1RBTlQgREVGSU5JVElPTlNcblxuICAgICAgICBzcmMucHVzaChcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVwiKTtcbiAgICAgICAgc3JjLnB1c2goXCIjZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxOFwiKTtcbiAgICAgICAgc3JjLnB1c2goXCIjZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiI2RlZmluZSBFUFNJTE9OIDFlLTZcIik7XG5cbiAgICAgICAgc3JjLnB1c2goXCIjZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXCIpO1xuXG4gICAgICAgIC8vIFVUSUxJVFkgREVGSU5JVElPTlNcblxuICAgICAgICBzcmMucHVzaChcInZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbihpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXgpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgcmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgLy8gU1RSVUNUVVJFU1xuXG4gICAgICAgIHNyYy5wdXNoKFwic3RydWN0IEluY2lkZW50TGlnaHQge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIGNvbG9yO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIGRpcmVjdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifTtcIik7XG5cbiAgICAgICAgc3JjLnB1c2goXCJzdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIGRpZmZ1c2U7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgc3BlY3VsYXI7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn07XCIpO1xuXG4gICAgICAgIHNyYy5wdXNoKFwic3RydWN0IEdlb21ldHJ5IHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyB2aWV3Tm9ybWFsO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIHdvcmxkTm9ybWFsO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIHZpZXdFeWVEaXI7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn07XCIpO1xuXG4gICAgICAgIHNyYy5wdXNoKFwic3RydWN0IE1hdGVyaWFsIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyAgICBkaWZmdXNlQ29sb3I7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0ICAgc3BlY3VsYXJSb3VnaG5lc3M7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgICAgc3BlY3VsYXJDb2xvcjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgICBzaGluZTtcIik7IC8vIE9ubHkgdXNlZCBmb3IgUGhvbmdcbiAgICAgICAgc3JjLnB1c2goXCJ9O1wiKTtcblxuICAgICAgICAvLyBDT01NT04gVVRJTFNcblxuICAgICAgICBpZiAocGhvbmdNYXRlcmlhbCkge1xuXG4gICAgICAgICAgICBpZiAobGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDAgfHwgbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2b2lkIGNvbXB1dGVQaG9uZ0xpZ2h0TWFwcGluZyhjb25zdCBpbiBHZW9tZXRyeSBnZW9tZXRyeSwgY29uc3QgaW4gTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7XCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLmxpZ2h0TWFwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyBpcnJhZGlhbmNlID0gXCIgKyBURVhUVVJFX0RFQ09ERV9GVU5DU1tsaWdodHNTdGF0ZS5saWdodE1hcHNbMF0uZW5jb2RpbmddICsgXCIodGV4dHVyZUN1YmUobGlnaHRNYXAsIGdlb21ldHJ5LndvcmxkTm9ybWFsKSkucmdiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICBpcnJhZGlhbmNlICo9IFBJO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIGRpZmZ1c2VCUkRGQ29udHJpYiA9IChSRUNJUFJPQ0FMX1BJICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yKTtcIik7XG4gICAgICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmVmbGVjdGVkTGlnaHQuZGlmZnVzZSArPSBpcnJhZGlhbmNlICogZGlmZnVzZUJSREZDb250cmliO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLnJlZmxlY3Rpb25NYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIHJlZmxlY3RWZWMgICAgICAgICAgICAgPSByZWZsZWN0KC1nZW9tZXRyeS52aWV3RXllRGlyLCBnZW9tZXRyeS52aWV3Tm9ybWFsKTtcIik7XG4gICAgICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyByYWRpYW5jZSAgICAgICAgICAgICAgID0gdGV4dHVyZUN1YmUocmVmbGVjdGlvbk1hcCwgcmVmbGVjdFZlYykucmdiICogMC4yO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICByYWRpYW5jZSAqPSBQSTtcIik7XG4gICAgICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmVmbGVjdGVkTGlnaHQuc3BlY3VsYXIgICAgICs9IHJhZGlhbmNlO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcmMucHVzaChcInZvaWQgY29tcHV0ZVBob25nTGlnaHRpbmcoY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cnkgZ2VvbWV0cnksIGNvbnN0IGluIE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgZG90TkwgICAgID0gc2F0dXJhdGUoZG90KGdlb21ldHJ5LnZpZXdOb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbikpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvciAqIFBJO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmVmbGVjdGVkTGlnaHQuZGlmZnVzZSAgKz0gaXJyYWRpYW5jZSAqIChSRUNJUFJPQ0FMX1BJICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHJlZmxlY3RlZExpZ2h0LnNwZWN1bGFyICs9IGRpcmVjdExpZ2h0LmNvbG9yICogbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAqIHBvdyhtYXgoZG90KHJlZmxlY3QoLWRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgLWdlb21ldHJ5LnZpZXdOb3JtYWwpLCBnZW9tZXRyeS52aWV3RXllRGlyKSwgMC4wKSwgbWF0ZXJpYWwuc2hpbmUpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRhbGxpY01hdGVyaWFsIHx8IHNwZWN1bGFyTWF0ZXJpYWwpIHtcblxuICAgICAgICAgICAgLy8gSVJSQURJQU5DRSBFVkFMVUFUSU9OXG5cbiAgICAgICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcykge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgciA9IGdneFJvdWdobmVzcyArIDAuMDAwMTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHJldHVybiAoMi4wIC8gKHIgKiByKSAtIDIuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuXG4gICAgICAgICAgICBzcmMucHVzaChcImZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsKSB7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgZGVzaXJlZE1JUExldmVsID0gbWF4TUlQTGV2ZWxTY2FsYXIgLSAwLjc5MjQ4IC0gMC41ICogbG9nMiggKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICogYmxpbm5TaGluaW5lc3NFeHBvbmVudCApICsgMS4wICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgICAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLnJlZmxlY3Rpb25NYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoY29uc3QgaW4gdmVjMyByZWZsZWN0VmVjLCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwpIHtcIik7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBtaXBMZXZlbCA9IDAuNSAqIGdldFNwZWN1bGFyTUlQTGV2ZWwoYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgbWF4TUlQTGV2ZWwpO1wiKTsgLy9UT0RPOiBhIHJhbmRvbSBmYWN0b3IgLSBmaXggdGhpc1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyBlbnZNYXBDb2xvciA9IFwiICsgVEVYVFVSRV9ERUNPREVfRlVOQ1NbbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHNbMF0uZW5jb2RpbmddICsgXCIodGV4dHVyZUN1YmUocmVmbGVjdGlvbk1hcCwgcmVmbGVjdFZlYywgbWlwTGV2ZWwpKS5yZ2I7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICByZXR1cm4gZW52TWFwQ29sb3I7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU1BFQ1VMQVIgQlJERiBFVkFMVUFUSU9OXG5cbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjMyBGX1NjaGxpY2soY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBkb3RMSCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgR19HR1hfU21pdGgoY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROVikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgYTIgPSAoIGFscGhhICogYWxwaGEgKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqICggZG90TkwgKiBkb3ROTCApICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiAoIGRvdE5WICogZG90TlYgKSApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgICAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROVikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgYTIgPSAoIGFscGhhICogYWxwaGEgKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqICggZG90TlYgKiBkb3ROViApICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiAoIGRvdE5MICogZG90TkwgKSApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgICAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBEX0dHWChjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkgpIHtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGEyID0gKCBhbHBoYSAqIGFscGhhICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBkZW5vbSA9ICggZG90TkggKiBkb3ROSCkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gKCBkZW5vbSAqIGRlbm9tKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjMyBCUkRGX1NwZWN1bGFyX0dHWChjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJ5IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcykge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgYWxwaGEgPSAoIHJvdWdobmVzcyAqIHJvdWdobmVzcyApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdFeWVEaXIgKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkudmlld05vcm1hbCwgaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKSApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS52aWV3Tm9ybWFsLCBnZW9tZXRyeS52aWV3RXllRGlyICkgKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkudmlld05vcm1hbCwgaGFsZkRpciApICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBHID0gR19HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmV0dXJuIEYgKiAoRyAqIEQpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgICAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KGNvbnN0IGluIEdlb21ldHJ5IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcykge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZmxvYXQgZG90TlYgPSBzYXR1cmF0ZShkb3QoZ2VvbWV0cnkudmlld05vcm1hbCwgZ2VvbWV0cnkudmlld0V5ZURpcikpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgY29uc3QgdmVjNCBjMCA9IHZlYzQoIC0xLCAtMC4wMjc1LCAtMC41NzIsICAwLjAyMik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBjb25zdCB2ZWM0IGMxID0gdmVjNCggIDEsICAwLjA0MjUsICAgMS4wNCwgLTAuMDQpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgdmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGZsb2F0IGEwMDQgPSBtaW4oci54ICogci54LCBleHAyKC05LjI4ICogZG90TlYpKSAqIHIueCArIHIueTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzIgQUIgICAgPSB2ZWMyKC0xLjA0LCAxLjA0KSAqIGEwMDQgKyByLnp3O1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBBQi54ICsgQUIueTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgICAgIGlmIChsaWdodHNTdGF0ZS5saWdodE1hcHMubGVuZ3RoID4gMCB8fCBsaWdodHNTdGF0ZS5yZWZsZWN0aW9uTWFwcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInZvaWQgY29tcHV0ZVBCUkxpZ2h0TWFwcGluZyhjb25zdCBpbiBHZW9tZXRyeSBnZW9tZXRyeSwgY29uc3QgaW4gTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7XCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaWdodHNTdGF0ZS5saWdodE1hcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgaXJyYWRpYW5jZSA9IHNSR0JUb0xpbmVhcih0ZXh0dXJlQ3ViZShsaWdodE1hcCwgZ2VvbWV0cnkud29ybGROb3JtYWwpKS5yZ2I7XCIpO1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgIGlycmFkaWFuY2UgKj0gUEk7XCIpO1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgZGlmZnVzZUJSREZDb250cmliID0gKFJFQ0lQUk9DQUxfUEkgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZWZsZWN0ZWRMaWdodC5kaWZmdXNlICs9IGlycmFkaWFuY2UgKiBkaWZmdXNlQlJERkNvbnRyaWI7XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIHNyYy5wdXNoKFwiICAgcmVmbGVjdGVkTGlnaHQuZGlmZnVzZSA9IHZlYzMoMS4wLCAwLjAsIDAuMCk7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgcmVmbGVjdFZlYyAgICAgICAgICAgICA9IHJlZmxlY3QoLWdlb21ldHJ5LnZpZXdFeWVEaXIsIGdlb21ldHJ5LnZpZXdOb3JtYWwpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZWZsZWN0VmVjICAgICAgICAgICAgICAgICAgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKHJlZmxlY3RWZWMsIHZpZXdNYXRyaXgpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBibGlubkV4cEZyb21Sb3VnaG5lc3MgPSBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQobWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIHJhZGlhbmNlICAgICAgICAgICAgICAgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZShyZWZsZWN0VmVjLCBibGlubkV4cEZyb21Sb3VnaG5lc3MsIDgpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICB2ZWMzIHNwZWN1bGFyQlJERkNvbnRyaWIgICAgPSBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudChnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MpO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICByZWZsZWN0ZWRMaWdodC5zcGVjdWxhciAgICAgKz0gcmFkaWFuY2UgKiBzcGVjdWxhckJSREZDb250cmliO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNQUlOIExJR0hUSU5HIENPTVBVVEFUSU9OIEZVTkNUSU9OXG5cbiAgICAgICAgICAgIHNyYy5wdXNoKFwidm9pZCBjb21wdXRlUEJSTGlnaHRpbmcoY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyeSBnZW9tZXRyeSwgY29uc3QgaW4gTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0KSB7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBmbG9hdCBkb3ROTCAgICAgPSBzYXR1cmF0ZShkb3QoZ2VvbWV0cnkudmlld05vcm1hbCwgaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24pKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogaW5jaWRlbnRMaWdodC5jb2xvciAqIFBJO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgcmVmbGVjdGVkTGlnaHQuZGlmZnVzZSAgKz0gaXJyYWRpYW5jZSAqIChSRUNJUFJPQ0FMX1BJICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIHJlZmxlY3RlZExpZ2h0LnNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWChpbmNpZGVudExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgICAgICB9IC8vIChtZXRhbGxpY01hdGVyaWFsIHx8IHNwZWN1bGFyTWF0ZXJpYWwpXG5cbiAgICB9IC8vIGdlb21ldHJ5Lm5vcm1hbHNcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHRU9NRVRSWSBJTlBVVFNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiKTtcblxuICAgIGlmIChnZW9tZXRyeVN0YXRlLmNvbG9ycykge1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2Q29sb3I7XCIpO1xuICAgIH1cblxuICAgIGlmICh1dnMgJiZcbiAgICAgICAgKChub3JtYWxzICYmIG1hdGVyaWFsLl9ub3JtYWxNYXApXG4gICAgICAgICAgICB8fCBtYXRlcmlhbC5fYW1iaWVudE1hcFxuICAgICAgICAgICAgfHwgbWF0ZXJpYWwuX2Jhc2VDb2xvck1hcFxuICAgICAgICAgICAgfHwgbWF0ZXJpYWwuX2RpZmZ1c2VNYXBcbiAgICAgICAgICAgIHx8IG1hdGVyaWFsLl9lbWlzc2l2ZU1hcFxuICAgICAgICAgICAgfHwgbWF0ZXJpYWwuX21ldGFsbGljTWFwXG4gICAgICAgICAgICB8fCBtYXRlcmlhbC5fcm91Z2huZXNzTWFwXG4gICAgICAgICAgICB8fCBtYXRlcmlhbC5fbWV0YWxsaWNSb3VnaG5lc3NNYXBcbiAgICAgICAgICAgIHx8IG1hdGVyaWFsLl9zcGVjdWxhck1hcFxuICAgICAgICAgICAgfHwgbWF0ZXJpYWwuX2dsb3NzaW5lc3NNYXBcbiAgICAgICAgICAgIHx8IG1hdGVyaWFsLl9zcGVjdWxhckdsb3NzaW5lc3NNYXBcbiAgICAgICAgICAgIHx8IG1hdGVyaWFsLl9vY2NsdXNpb25NYXBcbiAgICAgICAgICAgIHx8IG1hdGVyaWFsLl9hbHBoYU1hcCkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFscykge1xuICAgICAgICBpZiAobGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWMzIHZXb3JsZE5vcm1hbDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzMgdlZpZXdOb3JtYWw7XCIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNQVRFUklBTCBDSEFOTkVMIElOUFVUU1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmFtYmllbnQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgbWF0ZXJpYWxBbWJpZW50O1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuYmFzZUNvbG9yKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIG1hdGVyaWFsQmFzZUNvbG9yO1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFN0YXRlLmFscGhhICE9PSBudWxsKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0IG1hdGVyaWFsQWxwaGFNb2RlQ3V0b2ZmO1wiKTsgLy8gW2FscGhhLCBhbHBoYU1vZGUsIGFscGhhQ3V0b2ZmXVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5lbWlzc2l2ZSkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBtYXRlcmlhbEVtaXNzaXZlO1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuZGlmZnVzZSkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBtYXRlcmlhbERpZmZ1c2U7XCIpO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5nbG9zc2luZXNzICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxTdGF0ZS5nbG9zc2luZXNzICE9PSBudWxsKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBtYXRlcmlhbEdsb3NzaW5lc3M7XCIpO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFN0YXRlLnNoaW5pbmVzcyAhPT0gbnVsbCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgbWF0ZXJpYWxTaGluaW5lc3M7XCIpOyAgLy8gUGhvbmcgY2hhbm5lbFxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5zcGVjdWxhcikge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBtYXRlcmlhbFNwZWN1bGFyO1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUubWV0YWxsaWMgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFN0YXRlLm1ldGFsbGljICE9PSBudWxsKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBtYXRlcmlhbE1ldGFsbGljO1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUucm91Z2huZXNzICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxTdGF0ZS5yb3VnaG5lc3MgIT09IG51bGwpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IG1hdGVyaWFsUm91Z2huZXNzO1wiKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuc3BlY3VsYXJGMCAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsU3RhdGUuc3BlY3VsYXJGMCAhPT0gbnVsbCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgbWF0ZXJpYWxTcGVjdWxhckYwO1wiKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTUFURVJJQUwgVEVYVFVSRSBJTlBVVFNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBpZiAodXZzICYmIG1hdGVyaWFsLl9hbWJpZW50TWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgYW1iaWVudE1hcDtcIik7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fYW1iaWVudE1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBhbWJpZW50TWFwTWF0cml4O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXZzICYmIG1hdGVyaWFsLl9iYXNlQ29sb3JNYXApIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXIyRCBiYXNlQ29sb3JNYXA7XCIpO1xuICAgICAgICBpZiAobWF0ZXJpYWwuX2Jhc2VDb2xvck1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBiYXNlQ29sb3JNYXBNYXRyaXg7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX2RpZmZ1c2VNYXApIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9kaWZmdXNlTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IGRpZmZ1c2VNYXBNYXRyaXg7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX2VtaXNzaXZlTWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XCIpO1xuICAgICAgICBpZiAobWF0ZXJpYWwuX2VtaXNzaXZlTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IGVtaXNzaXZlTWFwTWF0cml4O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybWFscyAmJiB1dnMgJiYgbWF0ZXJpYWwuX21ldGFsbGljTWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNNYXA7XCIpO1xuICAgICAgICBpZiAobWF0ZXJpYWwuX21ldGFsbGljTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG1ldGFsbGljTWFwTWF0cml4O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybWFscyAmJiB1dnMgJiYgbWF0ZXJpYWwuX3JvdWdobmVzc01hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcIik7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fcm91Z2huZXNzTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHJvdWdobmVzc01hcE1hdHJpeDtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm1hbHMgJiYgdXZzICYmIG1hdGVyaWFsLl9tZXRhbGxpY1JvdWdobmVzc01hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbGljUm91Z2huZXNzTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9tZXRhbGxpY1JvdWdobmVzc01hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBtZXRhbGxpY1JvdWdobmVzc01hcE1hdHJpeDtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm1hbHMgJiYgbWF0ZXJpYWwuX25vcm1hbE1hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcIik7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fbm9ybWFsTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG5vcm1hbE1hcE1hdHJpeDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIHV2ICkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMzIHEwID0gdmVjMyggZEZkeCggZXllX3Bvcy54ICksIGRGZHgoIGV5ZV9wb3MueSApLCBkRmR4KCBleWVfcG9zLnogKSApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMzIHExID0gdmVjMyggZEZkeSggZXllX3Bvcy54ICksIGRGZHkoIGV5ZV9wb3MueSApLCBkRmR5KCBleWVfcG9zLnogKSApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMyIHN0MCA9IGRGZHgoIHV2LnN0ICk7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgICAgIHZlYzIgc3QxID0gZEZkeSggdXYuc3QgKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgICAgdmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgICB2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdXYgKS54eXogKiAyLjAgLSAxLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgICAgIG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1wiKTtcbiAgICAgICAgLy8gICAgIHNyYy5wdXNoKFwiICAgICAgbWFwTiAqPSAzLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgICAgIHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKHV2cyAmJiBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9vY2NsdXNpb25NYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgb2NjbHVzaW9uTWFwTWF0cml4O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXZzICYmIG1hdGVyaWFsLl9hbHBoYU1hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9hbHBoYU1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBhbHBoYU1hcE1hdHJpeDtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm1hbHMgJiYgdXZzICYmIG1hdGVyaWFsLl9zcGVjdWxhck1hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9zcGVjdWxhck1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBzcGVjdWxhck1hcE1hdHJpeDtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm1hbHMgJiYgdXZzICYmIG1hdGVyaWFsLl9nbG9zc2luZXNzTWFwKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgZ2xvc3NpbmVzc01hcDtcIik7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fZ2xvc3NpbmVzc01hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBnbG9zc2luZXNzTWFwTWF0cml4O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybWFscyAmJiB1dnMgJiYgbWF0ZXJpYWwuX3NwZWN1bGFyR2xvc3NpbmVzc01hcCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIG1hdGVyaWFsU3BlY3VsYXJHbG9zc2luZXNzTWFwO1wiKTtcbiAgICAgICAgaWYgKG1hdGVyaWFsLl9zcGVjdWxhckdsb3NzaW5lc3NNYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgbWF0ZXJpYWxTcGVjdWxhckdsb3NzaW5lc3NNYXBNYXRyaXg7XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1BVEVSSUFMIEZSRVNORUwgSU5QVVRTXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaWYgKG5vcm1hbHMgJiYgKG1hdGVyaWFsLl9kaWZmdXNlRnJlc25lbCB8fFxuICAgICAgICBtYXRlcmlhbC5fc3BlY3VsYXJGcmVzbmVsIHx8XG4gICAgICAgIG1hdGVyaWFsLl9hbHBoYUZyZXNuZWwgfHxcbiAgICAgICAgbWF0ZXJpYWwuX2VtaXNzaXZlRnJlc25lbCB8fFxuICAgICAgICBtYXRlcmlhbC5fcmVmbGVjdGl2aXR5RnJlc25lbCkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBmcmVzbmVsKHZlYzMgZXllRGlyLCB2ZWMzIG5vcm1hbCwgZmxvYXQgZWRnZUJpYXMsIGZsb2F0IGNlbnRlckJpYXMsIGZsb2F0IHBvd2VyKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgICBmbG9hdCBmciA9IGFicyhkb3QoZXllRGlyLCBub3JtYWwpKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgIGZsb2F0IGZpbmFsRnIgPSBjbGFtcCgoZnIgLSBlZGdlQmlhcykgLyAoY2VudGVyQmlhcyAtIGVkZ2VCaWFzKSwgMC4wLCAxLjApO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICAgcmV0dXJuIHBvdyhmaW5hbEZyLCBwb3dlcik7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fZGlmZnVzZUZyZXNuZWwpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCAgZGlmZnVzZUZyZXNuZWxDZW50ZXJCaWFzO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCAgZGlmZnVzZUZyZXNuZWxFZGdlQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIGRpZmZ1c2VGcmVzbmVsUG93ZXI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgICBkaWZmdXNlRnJlc25lbENlbnRlckNvbG9yO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzICAgZGlmZnVzZUZyZXNuZWxFZGdlQ29sb3I7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5fc3BlY3VsYXJGcmVzbmVsKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIHNwZWN1bGFyRnJlc25lbENlbnRlckJpYXM7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0ICBzcGVjdWxhckZyZXNuZWxFZGdlQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIHNwZWN1bGFyRnJlc25lbFBvd2VyO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzICAgc3BlY3VsYXJGcmVzbmVsQ2VudGVyQ29sb3I7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgICBzcGVjdWxhckZyZXNuZWxFZGdlQ29sb3I7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFGcmVzbmVsKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIGFscGhhRnJlc25lbENlbnRlckJpYXM7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0ICBhbHBoYUZyZXNuZWxFZGdlQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIGFscGhhRnJlc25lbFBvd2VyO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzICAgYWxwaGFGcmVzbmVsQ2VudGVyQ29sb3I7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgICBhbHBoYUZyZXNuZWxFZGdlQ29sb3I7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5fcmVmbGVjdGl2aXR5RnJlc25lbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0ICBtYXRlcmlhbFNwZWN1bGFyRjBGcmVzbmVsQ2VudGVyQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIG1hdGVyaWFsU3BlY3VsYXJGMEZyZXNuZWxFZGdlQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIG1hdGVyaWFsU3BlY3VsYXJGMEZyZXNuZWxQb3dlcjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyAgIG1hdGVyaWFsU3BlY3VsYXJGMEZyZXNuZWxDZW50ZXJDb2xvcjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyAgIG1hdGVyaWFsU3BlY3VsYXJGMEZyZXNuZWxFZGdlQ29sb3I7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5fZW1pc3NpdmVGcmVzbmVsKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIGVtaXNzaXZlRnJlc25lbENlbnRlckJpYXM7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0ICBlbWlzc2l2ZUZyZXNuZWxFZGdlQmlhcztcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgIGVtaXNzaXZlRnJlc25lbFBvd2VyO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzICAgZW1pc3NpdmVGcmVzbmVsQ2VudGVyQ29sb3I7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgICBlbWlzc2l2ZUZyZXNuZWxFZGdlQ29sb3I7XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIExJR0hUIFNPVVJDRVNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCAgIGxpZ2h0QW1iaWVudDtcIik7XG5cbiAgICBpZiAobm9ybWFscykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IC8vIExpZ2h0IHNvdXJjZXNcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzU3RhdGUubGlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiYW1iaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCBsaWdodENvbG9yXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0QXR0ZW51YXRpb25cIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlnaHQudHlwZSA9PT0gXCJkaXJcIiAmJiBsaWdodC5zcGFjZSA9PT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodERpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInBvaW50XCIgJiYgbGlnaHQuc3BhY2UgPT09IFwidmlld1wiKSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgbGlnaHRQb3NcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZWaWV3TGlnaHRSZXZlcnNlRGlyQW5kRGlzdFwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWNlaXZlc1NoYWRvdykge1xuXG4gICAgICAgIC8vIFZhcmlhbmNlIGNhc3RzU2hhZG93IG1hcHBpbmcgZmlsdGVyXG5cbiAgICAgICAgLy8gc3JjLnB1c2goXCJmbG9hdCBsaW5zdGVwKGZsb2F0IGxvdywgZmxvYXQgaGlnaCwgZmxvYXQgdil7XCIpO1xuICAgICAgICAvLyBzcmMucHVzaChcIiAgICAgIHJldHVybiBjbGFtcCgodi1sb3cpLyhoaWdoLWxvdyksIDAuMCwgMS4wKTtcIik7XG4gICAgICAgIC8vIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gc3JjLnB1c2goXCJmbG9hdCBWU00oc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSl7XCIpO1xuICAgICAgICAvLyBzcmMucHVzaChcIiAgICAgIHZlYzIgbW9tZW50cyA9IHRleHR1cmUyRChkZXB0aHMsIHV2KS54eTtcIik7XG4gICAgICAgIC8vIHNyYy5wdXNoKFwiICAgICAgZmxvYXQgcCA9IHNtb290aHN0ZXAoY29tcGFyZS0wLjAyLCBjb21wYXJlLCBtb21lbnRzLngpO1wiKTtcbiAgICAgICAgLy8gc3JjLnB1c2goXCIgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1heChtb21lbnRzLnkgLSBtb21lbnRzLngqbW9tZW50cy54LCAtMC4wMDEpO1wiKTtcbiAgICAgICAgLy8gc3JjLnB1c2goXCIgICAgICBmbG9hdCBkID0gY29tcGFyZSAtIG1vbWVudHMueDtcIik7XG4gICAgICAgIC8vIHNyYy5wdXNoKFwiICAgICAgZmxvYXQgcF9tYXggPSBsaW5zdGVwKDAuMiwgMS4wLCB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGQqZCkpO1wiKTtcbiAgICAgICAgLy8gc3JjLnB1c2goXCIgICAgICByZXR1cm4gY2xhbXAobWF4KHAsIHBfbWF4KSwgMC4wLCAxLjApO1wiKTtcbiAgICAgICAgLy8gc3JjLnB1c2goXCJ9XCIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaWdodHNTdGF0ZS5saWdodHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgLy8gTGlnaHQgc291cmNlc1xuICAgICAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLmxpZ2h0c1tpXS5jYXN0c1NoYWRvdykge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZTaGFkb3dQb3NGcm9tTGlnaHRcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCBjb2xvcml6ZTtcIik7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gTUFJTlxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG5cbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJpZiAoY2xpcHBhYmxlKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgZmxvYXQgZGlzdCA9IDAuMDtcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiaWYgKHNlY3Rpb25QbGFuZUFjdGl2ZVwiICsgaSArIFwiKSB7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBkaXN0ICs9IGNsYW1wKGRvdCgtc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCIueHl6LCB2V29ybGRQb3NpdGlvbi54eXogLSBzZWN0aW9uUGxhbmVQb3NcIiArIGkgKyBcIi54eXopLCAwLjAsIDEwMDAuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwiICBpZiAoZGlzdCA+IDAuMCkgeyBkaXNjYXJkOyB9XCIpO1xuICAgICAgICBpZiAoc29saWQpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICBpZiAoZ2xfRnJvbnRGYWNpbmcgPT0gZmFsc2UpIHtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICByZXR1cm47XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgIH1cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZU5hbWUgPT09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IHIgPSBkb3QoY3h5LCBjeHkpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJpZiAociA+IDEuMCkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBkaXNjYXJkO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cblxuICAgIHNyYy5wdXNoKFwiZmxvYXQgb2NjbHVzaW9uID0gMS4wO1wiKTtcblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmFtYmllbnQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIGFtYmllbnRDb2xvciA9IG1hdGVyaWFsQW1iaWVudDtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIGFtYmllbnRDb2xvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmRpZmZ1c2UpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIGRpZmZ1c2VDb2xvciA9IG1hdGVyaWFsRGlmZnVzZTtcIik7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbFN0YXRlLmJhc2VDb2xvcikge1xuICAgICAgICBzcmMucHVzaChcInZlYzMgZGlmZnVzZUNvbG9yID0gbWF0ZXJpYWxCYXNlQ29sb3I7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyBkaWZmdXNlQ29sb3IgPSB2ZWMzKDEuMCwgMS4wLCAxLjApO1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5jb2xvcnMpIHtcbiAgICAgICAgc3JjLnB1c2goXCJkaWZmdXNlQ29sb3IgKj0gdkNvbG9yLnJnYjtcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuZW1pc3NpdmUpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIGVtaXNzaXZlQ29sb3IgPSBtYXRlcmlhbEVtaXNzaXZlO1wiKTsgLy8gRW1pc3NpdmUgZGVmYXVsdCBpcyAoMCwwLDApLCBzbyBpbml0aWFsaXppbmcgaGVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyAgZW1pc3NpdmVDb2xvciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLnNwZWN1bGFyKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyBzcGVjdWxhciA9IG1hdGVyaWFsU3BlY3VsYXI7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyBzcGVjdWxhciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBhbHBoYSA9IG1hdGVyaWFsQWxwaGFNb2RlQ3V0b2ZmWzBdO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IGFscGhhID0gMS4wO1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5jb2xvcnMpIHtcbiAgICAgICAgc3JjLnB1c2goXCJhbHBoYSAqPSB2Q29sb3IuYTtcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuZ2xvc3NpbmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgZ2xvc3NpbmVzcyA9IG1hdGVyaWFsR2xvc3NpbmVzcztcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBnbG9zc2luZXNzID0gMS4wO1wiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5tZXRhbGxpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgbWV0YWxsaWMgPSBtYXRlcmlhbE1ldGFsbGljO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IG1ldGFsbGljID0gMS4wO1wiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsUm91Z2huZXNzO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IHJvdWdobmVzcyA9IDEuMDtcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuc3BlY3VsYXJGMCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgc3BlY3VsYXJGMCA9IG1hdGVyaWFsU3BlY3VsYXJGMDtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBzcGVjdWxhckYwID0gMS4wO1wiKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVEVYVFVSSU5HXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaWYgKHV2cyAmJiAoKG5vcm1hbHMgJiYgbWF0ZXJpYWwuX25vcm1hbE1hcClcbiAgICAgICAgfHwgbWF0ZXJpYWwuX2FtYmllbnRNYXBcbiAgICAgICAgfHwgbWF0ZXJpYWwuX2Jhc2VDb2xvck1hcFxuICAgICAgICB8fCBtYXRlcmlhbC5fZGlmZnVzZU1hcFxuICAgICAgICB8fCBtYXRlcmlhbC5fb2NjbHVzaW9uTWFwXG4gICAgICAgIHx8IG1hdGVyaWFsLl9lbWlzc2l2ZU1hcFxuICAgICAgICB8fCBtYXRlcmlhbC5fbWV0YWxsaWNNYXBcbiAgICAgICAgfHwgbWF0ZXJpYWwuX3JvdWdobmVzc01hcFxuICAgICAgICB8fCBtYXRlcmlhbC5fbWV0YWxsaWNSb3VnaG5lc3NNYXBcbiAgICAgICAgfHwgbWF0ZXJpYWwuX3NwZWN1bGFyTWFwXG4gICAgICAgIHx8IG1hdGVyaWFsLl9nbG9zc2luZXNzTWFwXG4gICAgICAgIHx8IG1hdGVyaWFsLl9zcGVjdWxhckdsb3NzaW5lc3NNYXBcbiAgICAgICAgfHwgbWF0ZXJpYWwuX2FscGhhTWFwKSkge1xuICAgICAgICBzcmMucHVzaChcInZlYzQgdGV4dHVyZVBvcyA9IHZlYzQodlVWLnMsIHZVVi50LCAxLjAsIDEuMCk7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzIgdGV4dHVyZUNvb3JkO1wiKTtcbiAgICB9XG5cbiAgICBpZiAodXZzICYmIG1hdGVyaWFsLl9hbWJpZW50TWFwKSB7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fYW1iaWVudE1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChhbWJpZW50TWFwTWF0cml4ICogdGV4dHVyZVBvcykueHk7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSB0ZXh0dXJlUG9zLnh5O1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcInZlYzQgYW1iaWVudFRleGVsID0gdGV4dHVyZTJEKGFtYmllbnRNYXAsIHRleHR1cmVDb29yZCkucmdiO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJhbWJpZW50VGV4ZWwgPSBcIiArIFRFWFRVUkVfREVDT0RFX0ZVTkNTW21hdGVyaWFsLl9hbWJpZW50TWFwLl9zdGF0ZS5lbmNvZGluZ10gKyBcIihhbWJpZW50VGV4ZWwpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJhbWJpZW50Q29sb3IgKj0gYW1iaWVudFRleGVsLnJnYjtcIik7XG4gICAgfVxuXG4gICAgaWYgKHV2cyAmJiBtYXRlcmlhbC5fZGlmZnVzZU1hcCkge1xuICAgICAgICBpZiAobWF0ZXJpYWwuX2RpZmZ1c2VNYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAoZGlmZnVzZU1hcE1hdHJpeCAqIHRleHR1cmVQb3MpLnh5O1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidGV4dHVyZUNvb3JkID0gdGV4dHVyZVBvcy54eTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ2ZWM0IGRpZmZ1c2VUZXhlbCA9IHRleHR1cmUyRChkaWZmdXNlTWFwLCB0ZXh0dXJlQ29vcmQpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJkaWZmdXNlVGV4ZWwgPSBcIiArIFRFWFRVUkVfREVDT0RFX0ZVTkNTW21hdGVyaWFsLl9kaWZmdXNlTWFwLl9zdGF0ZS5lbmNvZGluZ10gKyBcIihkaWZmdXNlVGV4ZWwpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJkaWZmdXNlQ29sb3IgKj0gZGlmZnVzZVRleGVsLnJnYjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYWxwaGEgKj0gZGlmZnVzZVRleGVsLmE7XCIpO1xuICAgIH1cblxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX2Jhc2VDb2xvck1hcCkge1xuICAgICAgICBpZiAobWF0ZXJpYWwuX2Jhc2VDb2xvck1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChiYXNlQ29sb3JNYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCBiYXNlQ29sb3JUZXhlbCA9IHRleHR1cmUyRChiYXNlQ29sb3JNYXAsIHRleHR1cmVDb29yZCk7XCIpO1xuICAgICAgICBzcmMucHVzaChcImJhc2VDb2xvclRleGVsID0gXCIgKyBURVhUVVJFX0RFQ09ERV9GVU5DU1ttYXRlcmlhbC5fYmFzZUNvbG9yTWFwLl9zdGF0ZS5lbmNvZGluZ10gKyBcIihiYXNlQ29sb3JUZXhlbCk7XCIpO1xuICAgICAgICBzcmMucHVzaChcImRpZmZ1c2VDb2xvciAqPSBiYXNlQ29sb3JUZXhlbC5yZ2I7XCIpO1xuICAgICAgICBzcmMucHVzaChcImFscGhhICo9IGJhc2VDb2xvclRleGVsLmE7XCIpO1xuICAgIH1cblxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX2VtaXNzaXZlTWFwKSB7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fZW1pc3NpdmVNYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAoZW1pc3NpdmVNYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCBlbWlzc2l2ZVRleGVsID0gdGV4dHVyZTJEKGVtaXNzaXZlTWFwLCB0ZXh0dXJlQ29vcmQpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJlbWlzc2l2ZVRleGVsID0gXCIgKyBURVhUVVJFX0RFQ09ERV9GVU5DU1ttYXRlcmlhbC5fZW1pc3NpdmVNYXAuX3N0YXRlLmVuY29kaW5nXSArIFwiKGVtaXNzaXZlVGV4ZWwpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJlbWlzc2l2ZUNvbG9yID0gZW1pc3NpdmVUZXhlbC5yZ2I7XCIpO1xuICAgIH1cblxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX2FscGhhTWFwKSB7XG4gICAgICAgIGlmIChtYXRlcmlhbC5fYWxwaGFNYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAoYWxwaGFNYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwiYWxwaGEgKj0gdGV4dHVyZTJEKGFscGhhTWFwLCB0ZXh0dXJlQ29vcmQpLnI7XCIpO1xuICAgIH1cblxuICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX29jY2x1c2lvbk1hcCkge1xuICAgICAgICBpZiAobWF0ZXJpYWwuX29jY2x1c2lvbk1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChvY2NsdXNpb25NYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwib2NjbHVzaW9uICo9IHRleHR1cmUyRChvY2NsdXNpb25NYXAsIHRleHR1cmVDb29yZCkucjtcIik7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbHMgJiYgKChsaWdodHNTdGF0ZS5saWdodHMubGVuZ3RoID4gMCkgfHwgbGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDAgfHwgbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkpIHtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNIQURJTkdcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX25vcm1hbE1hcCkge1xuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9ub3JtYWxNYXAuX3N0YXRlLm1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidGV4dHVyZUNvb3JkID0gKG5vcm1hbE1hcE1hdHJpeCAqIHRleHR1cmVQb3MpLnh5O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSB0ZXh0dXJlUG9zLnh5O1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjMyB2aWV3Tm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIHZWaWV3UG9zaXRpb24sIG5vcm1hbGl6ZSh2Vmlld05vcm1hbCksIHRleHR1cmVDb29yZCApO1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjMyB2aWV3Tm9ybWFsID0gbm9ybWFsaXplKHZWaWV3Tm9ybWFsKTtcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXZzICYmIG1hdGVyaWFsLl9zcGVjdWxhck1hcCkge1xuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9zcGVjdWxhck1hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAoc3BlY3VsYXJNYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidGV4dHVyZUNvb3JkID0gdGV4dHVyZVBvcy54eTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcInNwZWN1bGFyICo9IHRleHR1cmUyRChzcGVjdWxhck1hcCwgdGV4dHVyZUNvb3JkKS5yZ2I7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV2cyAmJiBtYXRlcmlhbC5fZ2xvc3NpbmVzc01hcCkge1xuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLl9nbG9zc2luZXNzTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChnbG9zc2luZXNzTWFwTWF0cml4ICogdGV4dHVyZVBvcykueHk7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjLnB1c2goXCJnbG9zc2luZXNzICo9IHRleHR1cmUyRChnbG9zc2luZXNzTWFwLCB0ZXh0dXJlQ29vcmQpLnI7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV2cyAmJiBtYXRlcmlhbC5fc3BlY3VsYXJHbG9zc2luZXNzTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX3NwZWN1bGFyR2xvc3NpbmVzc01hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAobWF0ZXJpYWxTcGVjdWxhckdsb3NzaW5lc3NNYXBNYXRyaXggKiB0ZXh0dXJlUG9zKS54eTtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidGV4dHVyZUNvb3JkID0gdGV4dHVyZVBvcy54eTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcInZlYzQgc3BlY0dsb3NzUkdCID0gdGV4dHVyZTJEKG1hdGVyaWFsU3BlY3VsYXJHbG9zc2luZXNzTWFwLCB0ZXh0dXJlQ29vcmQpLnJnYmE7XCIpOyAvLyBUT0RPOiB3aGF0IGlmIG9ubHkgUkdCIHRleHR1cmU/XG4gICAgICAgICAgICBzcmMucHVzaChcInNwZWN1bGFyICo9IHNwZWNHbG9zc1JHQi5yZ2I7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJnbG9zc2luZXNzICo9IHNwZWNHbG9zc1JHQi5hO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX21ldGFsbGljTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX21ldGFsbGljTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChtZXRhbGxpY01hcE1hdHJpeCAqIHRleHR1cmVQb3MpLnh5O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSB0ZXh0dXJlUG9zLnh5O1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYy5wdXNoKFwibWV0YWxsaWMgKj0gdGV4dHVyZTJEKG1ldGFsbGljTWFwLCB0ZXh0dXJlQ29vcmQpLnI7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV2cyAmJiBtYXRlcmlhbC5fcm91Z2huZXNzTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX3JvdWdobmVzc01hcC5fc3RhdGUubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSAocm91Z2huZXNzTWFwTWF0cml4ICogdGV4dHVyZVBvcykueHk7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjLnB1c2goXCJyb3VnaG5lc3MgKj0gdGV4dHVyZTJEKHJvdWdobmVzc01hcCwgdGV4dHVyZUNvb3JkKS5yO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dnMgJiYgbWF0ZXJpYWwuX21ldGFsbGljUm91Z2huZXNzTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwuX21ldGFsbGljUm91Z2huZXNzTWFwLl9zdGF0ZS5tYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInRleHR1cmVDb29yZCA9IChtZXRhbGxpY1JvdWdobmVzc01hcE1hdHJpeCAqIHRleHR1cmVQb3MpLnh5O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ0ZXh0dXJlQ29vcmQgPSB0ZXh0dXJlUG9zLnh5O1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmVjMyBtZXRhbFJvdWdoUkdCID0gdGV4dHVyZTJEKG1ldGFsbGljUm91Z2huZXNzTWFwLCB0ZXh0dXJlQ29vcmQpLnJnYjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1ldGFsbGljICo9IG1ldGFsUm91Z2hSR0IuYjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInJvdWdobmVzcyAqPSBtZXRhbFJvdWdoUkdCLmc7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHZpZXdFeWVEaXIgPSBub3JtYWxpemUoLXZWaWV3UG9zaXRpb24pO1wiKTtcblxuICAgICAgICBpZiAobWF0ZXJpYWwuX2RpZmZ1c2VGcmVzbmVsKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImZsb2F0IGRpZmZ1c2VGcmVzbmVsID0gZnJlc25lbCh2aWV3RXllRGlyLCB2aWV3Tm9ybWFsLCBkaWZmdXNlRnJlc25lbEVkZ2VCaWFzLCBkaWZmdXNlRnJlc25lbENlbnRlckJpYXMsIGRpZmZ1c2VGcmVzbmVsUG93ZXIpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiZGlmZnVzZUNvbG9yICo9IG1peChkaWZmdXNlRnJlc25lbEVkZ2VDb2xvciwgZGlmZnVzZUZyZXNuZWxDZW50ZXJDb2xvciwgZGlmZnVzZUZyZXNuZWwpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwuX3NwZWN1bGFyRnJlc25lbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBzcGVjdWxhckZyZXNuZWwgPSBmcmVzbmVsKHZpZXdFeWVEaXIsIHZpZXdOb3JtYWwsIHNwZWN1bGFyRnJlc25lbEVkZ2VCaWFzLCBzcGVjdWxhckZyZXNuZWxDZW50ZXJCaWFzLCBzcGVjdWxhckZyZXNuZWxQb3dlcik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJzcGVjdWxhciAqPSBtaXgoc3BlY3VsYXJGcmVzbmVsRWRnZUNvbG9yLCBzcGVjdWxhckZyZXNuZWxDZW50ZXJDb2xvciwgc3BlY3VsYXJGcmVzbmVsKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGVyaWFsLl9hbHBoYUZyZXNuZWwpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgYWxwaGFGcmVzbmVsID0gZnJlc25lbCh2aWV3RXllRGlyLCB2aWV3Tm9ybWFsLCBhbHBoYUZyZXNuZWxFZGdlQmlhcywgYWxwaGFGcmVzbmVsQ2VudGVyQmlhcywgYWxwaGFGcmVzbmVsUG93ZXIpO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiYWxwaGEgKj0gbWl4KGFscGhhRnJlc25lbEVkZ2VDb2xvci5yLCBhbHBoYUZyZXNuZWxDZW50ZXJDb2xvci5yLCBhbHBoYUZyZXNuZWwpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwuX2VtaXNzaXZlRnJlc25lbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBlbWlzc2l2ZUZyZXNuZWwgPSBmcmVzbmVsKHZpZXdFeWVEaXIsIHZpZXdOb3JtYWwsIGVtaXNzaXZlRnJlc25lbEVkZ2VCaWFzLCBlbWlzc2l2ZUZyZXNuZWxDZW50ZXJCaWFzLCBlbWlzc2l2ZUZyZXNuZWxQb3dlcik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJlbWlzc2l2ZUNvbG9yICo9IG1peChlbWlzc2l2ZUZyZXNuZWxFZGdlQ29sb3IsIGVtaXNzaXZlRnJlc25lbENlbnRlckNvbG9yLCBlbWlzc2l2ZUZyZXNuZWwpO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyYy5wdXNoKFwiaWYgKG1hdGVyaWFsQWxwaGFNb2RlQ3V0b2ZmWzFdID09IDEuMCAmJiBhbHBoYSA8IG1hdGVyaWFsQWxwaGFNb2RlQ3V0b2ZmWzJdKSB7XCIpOyAvLyBpZS4gKGFscGhhTW9kZSA9PSBcIm1hc2tcIiAmJiBhbHBoYSA8IGFscGhhQ3V0b2ZmKVxuICAgICAgICBzcmMucHVzaChcIiAgIGRpc2NhcmQ7XCIpOyAvLyBUT0RPOiBEaXNjYXJkIGVhcmxpZXIgd2l0aGluIHRoaXMgc2hhZGVyP1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgLy8gUFJFUEFSRSBJTlBVVFMgRk9SIFNIQURFUiBGVU5DVElPTlNcblxuICAgICAgICBzcmMucHVzaChcIkluY2lkZW50TGlnaHQgIGxpZ2h0O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJNYXRlcmlhbCAgICAgICBtYXRlcmlhbDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiR2VvbWV0cnkgICAgICAgZ2VvbWV0cnk7XCIpO1xuICAgICAgICBzcmMucHVzaChcIlJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQodmVjMygwLjAsMC4wLDAuMCksIHZlYzMoMC4wLDAuMCwwLjApKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjMyAgICAgICAgICAgdmlld0xpZ2h0RGlyO1wiKTtcblxuICAgICAgICBpZiAocGhvbmdNYXRlcmlhbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJtYXRlcmlhbC5kaWZmdXNlQ29sb3IgICAgICA9IGRpZmZ1c2VDb2xvcjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgICAgID0gc3BlY3VsYXI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJtYXRlcmlhbC5zaGluZSAgICAgICAgICAgICA9IG1hdGVyaWFsU2hpbmluZXNzO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjdWxhck1hdGVyaWFsKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImZsb2F0IG9uZU1pbnVzU3BlY3VsYXJTdHJlbmd0aCA9IDEuMCAtIG1heChtYXgoc3BlY3VsYXIuciwgc3BlY3VsYXIuZyApLHNwZWN1bGFyLmIpO1wiKTsgLy8gRW5lcmd5IGNvbnNlcnZhdGlvblxuICAgICAgICAgICAgc3JjLnB1c2goXCJtYXRlcmlhbC5kaWZmdXNlQ29sb3IgICAgICA9IGRpZmZ1c2VDb2xvciAqIG9uZU1pbnVzU3BlY3VsYXJTdHJlbmd0aDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIDEuMCAtIGdsb3NzaW5lc3MsIDAuMDQsIDEuMCApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwibWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAgICAgPSBzcGVjdWxhcjtcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0YWxsaWNNYXRlcmlhbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBkaWVsZWN0cmljU3BlY3VsYXIgPSAwLjE2ICogc3BlY3VsYXJGMCAqIHNwZWN1bGFyRjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJtYXRlcmlhbC5kaWZmdXNlQ29sb3IgICAgICA9IGRpZmZ1c2VDb2xvciAqICgxLjAgLSBkaWVsZWN0cmljU3BlY3VsYXIpICogKDEuMCAtIG1ldGFsbGljKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAocm91Z2huZXNzLCAwLjA0LCAxLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwibWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAgICAgPSBtaXgodmVjMyhkaWVsZWN0cmljU3BlY3VsYXIpLCBkaWZmdXNlQ29sb3IsIG1ldGFsbGljKTtcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzcmMucHVzaChcImdlb21ldHJ5LnBvc2l0aW9uICAgICAgPSB2Vmlld1Bvc2l0aW9uO1wiKTtcbiAgICAgICAgaWYgKGxpZ2h0c1N0YXRlLmxpZ2h0TWFwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImdlb21ldHJ5LndvcmxkTm9ybWFsICAgPSBub3JtYWxpemUodldvcmxkTm9ybWFsKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJnZW9tZXRyeS52aWV3Tm9ybWFsICAgID0gdmlld05vcm1hbDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2VvbWV0cnkudmlld0V5ZURpciAgICA9IHZpZXdFeWVEaXI7XCIpO1xuXG4gICAgICAgIC8vIEVOVklST05NRU5UIEFORCBSRUZMRUNUSU9OIE1BUCBTSEFESU5HXG5cbiAgICAgICAgaWYgKChwaG9uZ01hdGVyaWFsKSAmJiAobGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDAgfHwgbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY29tcHV0ZVBob25nTGlnaHRNYXBwaW5nKGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQpO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc3BlY3VsYXJNYXRlcmlhbCB8fCBtZXRhbGxpY01hdGVyaWFsKSAmJiAobGlnaHRzU3RhdGUubGlnaHRNYXBzLmxlbmd0aCA+IDAgfHwgbGlnaHRzU3RhdGUucmVmbGVjdGlvbk1hcHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY29tcHV0ZVBCUkxpZ2h0TWFwcGluZyhnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0KTtcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMSUdIVCBTT1VSQ0UgU0hBRElOR1xuXG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgc2hhZG93ID0gMS4wO1wiKTtcblxuICAgICAgICAvLyBpZiAocmVjZWl2ZXNTaGFkb3cpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHNyYy5wdXNoKFwiZmxvYXQgbGlnaHREZXB0aDIgPSBjbGFtcChsZW5ndGgobGlnaHRQb3MpLzQwLjAsIDAuMCwgMS4wKTtcIik7XG4gICAgICAgIC8vICAgICBzcmMucHVzaChcImZsb2F0IGlsbHVtaW5hdGVkID0gVlNNKHNMaWdodERlcHRoLCBsaWdodFVWLCBsaWdodERlcHRoMik7XCIpO1xuICAgICAgICAvL1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IHNoYWRvd0FjbmVSZW1vdmVyID0gMC4wMDc7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzMgZnJhZ21lbnREZXB0aDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiZmxvYXQgdGV4ZWxTaXplID0gMS4wIC8gMTAyNC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJmbG9hdCBhbW91bnRJbkxpZ2h0ID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHNoYWRvd0Nvb3JkO1wiKTtcbiAgICAgICAgc3JjLnB1c2goJ3ZlYzQgcmdiYURlcHRoOycpO1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IGRlcHRoO1wiKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGNvbnN0IG51bVNoYWRvd3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzU3RhdGUubGlnaHRzW2ldO1xuXG4gICAgICAgICAgICBpZiAobGlnaHQudHlwZSA9PT0gXCJhbWJpZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcImRpclwiICYmIGxpZ2h0LnNwYWNlID09PSBcInZpZXdcIikge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidmlld0xpZ2h0RGlyID0gLW5vcm1hbGl6ZShsaWdodERpclwiICsgaSArIFwiKTtcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpZ2h0LnR5cGUgPT09IFwicG9pbnRcIiAmJiBsaWdodC5zcGFjZSA9PT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvc1wiICsgaSArIFwiIC0gdlZpZXdQb3NpdGlvbik7XCIpO1xuICAgICAgICAgICAgICAgIC8vc3JjLnB1c2goXCJ0bXBWZWMzID0gbGlnaHRQb3NcIiArIGkgKyBcIi54eXogLSB2aWV3UG9zaXRpb24ueHl6O1wiKTtcbiAgICAgICAgICAgICAgICAvL3NyYy5wdXNoKFwibGlnaHREaXN0ID0gYWJzKGxlbmd0aCh0bXBWZWMzKSk7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZSh2Vmlld0xpZ2h0UmV2ZXJzZURpckFuZERpc3RcIiArIGkgKyBcIi54eXopO1wiKTsgLy8gSWYgbm9ybWFsIG1hcHBpbmcsIHRoZSBmcmFnbWVudC0+bGlnaHQgdmVjdG9yIHdpbGwgYmUgaW4gdGFuZ2VudCBzcGFjZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjZWl2ZXNTaGFkb3cgJiYgbGlnaHQuY2FzdHNTaGFkb3cpIHtcblxuICAgICAgICAgICAgICAgIC8vIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHNyYy5wdXNoKCdzaGFkb3dDb29yZCA9ICh2U2hhZG93UG9zRnJvbUxpZ2h0JyArIGkgKyAnLnh5ei92U2hhZG93UG9zRnJvbUxpZ2h0JyArIGkgKyAnLncpLzIuMCArIDAuNTsnKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgc3JjLnB1c2goXCJsaWdodERlcHRoMiA9IGNsYW1wKGxlbmd0aCh2ZWMzWzAuMCwgMjAuMCwgMjAuMF0pLzQwLjAsIDAuMCwgMS4wKTtcIik7XG4gICAgICAgICAgICAgICAgLy8gICAgIHNyYy5wdXNoKFwiY2FzdHNTaGFkb3cgKj0gVlNNKHNoYWRvd01hcCcgKyBpICsgJywgc2hhZG93Q29vcmQsIGxpZ2h0RGVwdGgyKTtcIik7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBQQ0ZcblxuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwic2hhZG93ID0gMC4wO1wiKTtcblxuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiZnJhZ21lbnREZXB0aCA9IHZTaGFkb3dQb3NGcm9tTGlnaHRcIiArIGkgKyBcIi54eXo7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiZnJhZ21lbnREZXB0aC56IC09IHNoYWRvd0FjbmVSZW1vdmVyO1wiKTtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcImZvciAoaW50IHggPSAtMzsgeCA8PSAzOyB4KyspIHtcIik7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgIGZvciAoaW50IHkgPSAtMzsgeSA8PSAzOyB5KyspIHtcIik7XG4gICAgICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgICBmbG9hdCB0ZXhlbERlcHRoID0gdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNoYWRvd01hcFwiICsgaSArIFwiLCBmcmFnbWVudERlcHRoLnh5ICsgdmVjMih4LCB5KSAqIHRleGVsU2l6ZSkpO1wiKTtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgICAgIGlmIChmcmFnbWVudERlcHRoLnogPCB0ZXhlbERlcHRoKSB7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICAgICAgIHNoYWRvdyArPSAxLjA7XCIpO1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICAgfVwiKTtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcIiAgfVwiKTtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInNoYWRvdyA9IHNoYWRvdyAvIDkuMDtcIik7XG5cbiAgICAgICAgICAgICAgICBzcmMucHVzaChcImxpZ2h0LmNvbG9yID0gIGxpZ2h0Q29sb3JcIiArIGkgKyBcIi5yZ2IgKiAobGlnaHRDb2xvclwiICsgaSArIFwiLmEgKiBzaGFkb3cpO1wiKTsgLy8gYSBpcyBpbnRlbnNpdHlcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGlmIChmYWxzZSl7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgc3JjLnB1c2goXCJzaGFkb3cgPSAxLjA7XCIpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgIHNyYy5wdXNoKCdzaGFkb3dDb29yZCA9ICh2U2hhZG93UG9zRnJvbUxpZ2h0JyArIGkgKyAnLnh5ei92U2hhZG93UG9zRnJvbUxpZ2h0JyArIGkgKyAnLncpLzIuMCArIDAuNTsnKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBzcmMucHVzaCgnc2hhZG93IC09IChzaGFkb3dDb29yZC56ID4gdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNoYWRvd01hcCcgKyBpICsgJywgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAtMC45NDIwMTYyNCwgLTAuMzk5MDYyMTYgKSAvIDcwMC4wKSkgKyAwLjAwMTUpID8gMC4yIDogMC4wOycpO1xuICAgICAgICAgICAgICAgIC8vICAgICBzcmMucHVzaCgnc2hhZG93IC09IChzaGFkb3dDb29yZC56ID4gdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNoYWRvd01hcCcgKyBpICsgJywgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjk0NTU4NjA5LCAtMC43Njg5MDcyNSApIC8gNzAwLjApKSArIDAuMDAxNSkgPyAwLjIgOiAwLjA7Jyk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHNyYy5wdXNoKCdzaGFkb3cgLT0gKHNoYWRvd0Nvb3JkLnogPiB1bnBhY2tEZXB0aCh0ZXh0dXJlMkQoc2hhZG93TWFwJyArIGkgKyAnLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIC0wLjA5NDE4NDEwMSwgLTAuOTI5Mzg4NzAgKSAvIDcwMC4wKSkgKyAwLjAwMTUpID8gMC4yIDogMC4wOycpO1xuICAgICAgICAgICAgICAgIC8vICAgICBzcmMucHVzaCgnc2hhZG93IC09IChzaGFkb3dDb29yZC56ID4gdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNoYWRvd01hcCcgKyBpICsgJywgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjM0NDk1OTM4LCAwLjI5Mzg3NzYwICkgLyA3MDAuMCkpICsgMC4wMDE1KSA/IDAuMiA6IDAuMDsnKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBzcmMucHVzaChcImxpZ2h0LmNvbG9yID0gIGxpZ2h0Q29sb3JcIiArIGkgKyBcIi5yZ2IgKiAobGlnaHRDb2xvclwiICsgaSArIFwiLmEgKiBzaGFkb3cpO1wiKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwibGlnaHQuY29sb3IgPSAgbGlnaHRDb2xvclwiICsgaSArIFwiLnJnYiAqIChsaWdodENvbG9yXCIgKyBpICsgXCIuYSApO1wiKTsgLy8gYSBpcyBpbnRlbnNpdHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3JjLnB1c2goXCJsaWdodC5kaXJlY3Rpb24gPSB2aWV3TGlnaHREaXI7XCIpO1xuXG4gICAgICAgICAgICBpZiAocGhvbmdNYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiY29tcHV0ZVBob25nTGlnaHRpbmcobGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQpO1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNwZWN1bGFyTWF0ZXJpYWwgfHwgbWV0YWxsaWNNYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwiY29tcHV0ZVBCUkxpZ2h0aW5nKGxpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0KTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtU2hhZG93cyA+IDApIHtcbiAgICAgICAgICAgIC8vc3JjLnB1c2goXCJzaGFkb3cgLz0gXCIgKyAoOSAqIG51bVNoYWRvd3MpICsgXCIuMDtcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NyYy5wdXNoKFwicmVmbGVjdGVkTGlnaHQuZGlmZnVzZSAqPSBzaGFkb3c7XCIpO1xuXG4gICAgICAgIC8vIENPTUJJTkUgVEVSTVNcblxuICAgICAgICBpZiAocGhvbmdNYXRlcmlhbCkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIG91dGdvaW5nTGlnaHQgPSAobGlnaHRBbWJpZW50LnJnYiAqIGxpZ2h0QW1iaWVudC5hICogZGlmZnVzZUNvbG9yKSArICgob2NjbHVzaW9uICogKCggcmVmbGVjdGVkTGlnaHQuZGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LnNwZWN1bGFyKSkpKSArIGVtaXNzaXZlQ29sb3I7XCIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZlYzMgb3V0Z29pbmdMaWdodCA9IChvY2NsdXNpb24gKiAocmVmbGVjdGVkTGlnaHQuZGlmZnVzZSkpICsgKG9jY2x1c2lvbiAqIHJlZmxlY3RlZExpZ2h0LnNwZWN1bGFyKSArIGVtaXNzaXZlQ29sb3I7XCIpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTk8gU0hBRElORyAtIEVNSVNTSVZFIGFuZCBBTUJJRU5UIE9OTFlcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHNyYy5wdXNoKFwiYW1iaWVudENvbG9yICo9IChsaWdodEFtYmllbnQucmdiICogbGlnaHRBbWJpZW50LmEpO1wiKTtcblxuICAgICAgICBzcmMucHVzaChcInZlYzMgb3V0Z29pbmdMaWdodCA9IGVtaXNzaXZlQ29sb3IgKyBhbWJpZW50Q29sb3I7XCIpO1xuICAgIH1cblxuICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0NvbG9yID0gdmVjNChvdXRnb2luZ0xpZ2h0LCBhbHBoYSkgKiBjb2xvcml6ZTtcIik7XG5cbiAgICBpZiAoZ2FtbWFPdXRwdXQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb0dhbW1hKGdsX0ZyYWdDb2xvciwgZ2FtbWFGYWN0b3IpO1wiKTtcbiAgICB9XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1wiKTtcbiAgICB9XG5cbiAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICByZXR1cm4gc3JjO1xufVxuXG5leHBvcnQge0RyYXdTaGFkZXJTb3VyY2V9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/draw/DrawShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesRenderer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesRenderer.js ***!
  \*************************************************************************************************/
/*! exports provided: EmphasisEdgesRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmphasisEdgesRenderer\", function() { return EmphasisEdgesRenderer; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _EmphasisEdgesShaderSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EmphasisEdgesShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_4__[\"math\"].vec3();\n\n/**\n * @private\n */\nconst EmphasisEdgesRenderer = function (hash, mesh) {\n    this.id = ids.addItem({});\n    this._hash = hash;\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._shaderSource = new _EmphasisEdgesShaderSource_js__WEBPACK_IMPORTED_MODULE_1__[\"EmphasisEdgesShaderSource\"](mesh);\n    this._allocate(mesh);\n};\n\nconst renderers = {};\n\nEmphasisEdgesRenderer.get = function (mesh) {\n    const hash = [\n        mesh.scene.id,\n        mesh.scene.gammaOutput ? \"go\" : \"\", // Gamma input not needed\n        mesh.scene._sectionPlanesState.getHash(),\n        mesh._geometry._state.compressGeometry ? \"cp\" : \"\",\n        mesh._state.hash\n    ].join(\";\");\n    let renderer = renderers[hash];\n    if (!renderer) {\n        renderer = new EmphasisEdgesRenderer(hash, mesh);\n        renderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nEmphasisEdgesRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        ids.removeItem(this.id);\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete renderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs--;\n    }\n};\n\nEmphasisEdgesRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nEmphasisEdgesRenderer.prototype.drawMesh = function (frameCtx, mesh, mode) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const scene = this._scene;\n    const camera = scene.camera;\n    const gl = scene.canvas.gl;\n    let materialState;\n    const meshState = mesh._state;\n    const geometry = mesh._geometry;\n    const geometryState = geometry._state;\n    const rtcCenter = mesh.rtcCenter;\n\n    if (frameCtx.lastProgramId !== this._program.id) {\n        frameCtx.lastProgramId = this._program.id;\n        this._bindProgram(frameCtx);\n    }\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_5__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    switch (mode) {\n        case 0:\n            materialState = mesh._xrayMaterial._state;\n            break;\n        case 1:\n            materialState = mesh._highlightMaterial._state;\n            break;\n        case 2:\n            materialState = mesh._selectedMaterial._state;\n            break;\n        case 3:\n        default:\n            materialState = mesh._edgeMaterial._state;\n            break;\n    }\n\n    if (materialState.id !== this._lastMaterialId) {\n        const backfaces = materialState.backfaces;\n        if (frameCtx.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frameCtx.backfaces = backfaces;\n        }\n        if (frameCtx.lineWidth !== materialState.edgeWidth) {\n            gl.lineWidth(materialState.edgeWidth);\n            frameCtx.lineWidth = materialState.edgeWidth;\n        }\n        if (this._uEdgeColor) {\n            const edgeColor = materialState.edgeColor;\n            const edgeAlpha = materialState.edgeAlpha;\n            gl.uniform4f(this._uEdgeColor, edgeColor[0], edgeColor[1], edgeColor[2], edgeAlpha);\n        }\n        this._lastMaterialId = materialState.id;\n    }\n\n    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);\n\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, meshState.clippable);\n    }\n\n    gl.uniform3fv(this._uOffset, meshState.offset);\n\n    // Bind VBOs\n    let indicesBuf;\n    if (geometryState.primitive === gl.TRIANGLES) {\n        indicesBuf = geometry._getEdgeIndices();\n    } else if (geometryState.primitive === gl.LINES) {\n        indicesBuf = geometryState.indicesBuf;\n    }\n\n    if (indicesBuf) {\n        if (geometryState.id !== this._lastGeometryId) {\n            if (this._uPositionsDecodeMatrix) {\n                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n            }\n            if (this._aPosition) {\n                this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n                frameCtx.bindArray++;\n            }\n            indicesBuf.bind();\n            frameCtx.bindArray++;\n            this._lastGeometryId = geometryState.id;\n        }\n\n        gl.drawElements(gl.LINES, indicesBuf.numItems, indicesBuf.itemType, 0);\n\n        frameCtx.drawElements++;\n    }\n};\n\nEmphasisEdgesRenderer.prototype._allocate = function (mesh) {\n\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    const sectionPlanesState = scene._sectionPlanesState;\n\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__[\"Program\"](gl, this._shaderSource);\n\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n\n    const program = this._program;\n\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uSectionPlanes = [];\n    for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._uEdgeColor = program.getLocation(\"edgeColor\");\n    this._aPosition = program.getAttribute(\"position\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uGammaFactor = program.getLocation(\"gammaFactor\");\n    this._uOffset = program.getLocation(\"offset\");\n\n    if (scene.logarithmicDepthBufferEnabled ) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n};\n\nEmphasisEdgesRenderer.prototype._bindProgram = function (frameCtx) {\n\n    const program = this._program;\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const camera = scene.camera;\n    const project = camera.project;\n\n    program.bind();\n\n    frameCtx.useProgram++;\n\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n\n    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);\n\n    if (scene.logarithmicDepthBufferEnabled ) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n\n    if (this._uGammaFactor) {\n        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZW1waGFzaXMvRW1waGFzaXNFZGdlc1JlbmRlcmVyLmpzPzgxNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDa0M7QUFDMUI7QUFDVjtBQUNHO0FBQ2U7O0FBRXZELGdCQUFnQixpREFBRyxHQUFHOztBQUV0QixrQkFBa0Isa0RBQUk7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1RkFBeUI7QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUs7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHlFQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFPOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWVzaC9lbXBoYXNpcy9FbXBoYXNpc0VkZ2VzUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgeGVvbGFicyAvIGh0dHBzOi8vZ2l0aHViLmNvbS94ZW9sYWJzXG4gKi9cblxuaW1wb3J0IHtNYXB9IGZyb20gXCIuLi8uLi91dGlscy9NYXAuanNcIjtcbmltcG9ydCB7RW1waGFzaXNFZGdlc1NoYWRlclNvdXJjZX0gZnJvbSBcIi4vRW1waGFzaXNFZGdlc1NoYWRlclNvdXJjZS5qc1wiO1xuaW1wb3J0IHtQcm9ncmFtfSBmcm9tIFwiLi4vLi4vd2ViZ2wvUHJvZ3JhbS5qc1wiO1xuaW1wb3J0IHtzdGF0c30gZnJvbSAnLi4vLi4vc3RhdHMuanMnO1xuaW1wb3J0IHttYXRofSBmcm9tIFwiLi4vLi4vbWF0aC9tYXRoLmpzXCI7XG5pbXBvcnQge2dldFBsYW5lUlRDUG9zfSBmcm9tIFwiLi4vLi4vbWF0aC9ydGNDb29yZHMuanNcIjtcblxuY29uc3QgaWRzID0gbmV3IE1hcCh7fSk7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEVtcGhhc2lzRWRnZXNSZW5kZXJlciA9IGZ1bmN0aW9uIChoYXNoLCBtZXNoKSB7XG4gICAgdGhpcy5pZCA9IGlkcy5hZGRJdGVtKHt9KTtcbiAgICB0aGlzLl9oYXNoID0gaGFzaDtcbiAgICB0aGlzLl9zY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIHRoaXMuX3NoYWRlclNvdXJjZSA9IG5ldyBFbXBoYXNpc0VkZ2VzU2hhZGVyU291cmNlKG1lc2gpO1xuICAgIHRoaXMuX2FsbG9jYXRlKG1lc2gpO1xufTtcblxuY29uc3QgcmVuZGVyZXJzID0ge307XG5cbkVtcGhhc2lzRWRnZXNSZW5kZXJlci5nZXQgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgIGNvbnN0IGhhc2ggPSBbXG4gICAgICAgIG1lc2guc2NlbmUuaWQsXG4gICAgICAgIG1lc2guc2NlbmUuZ2FtbWFPdXRwdXQgPyBcImdvXCIgOiBcIlwiLCAvLyBHYW1tYSBpbnB1dCBub3QgbmVlZGVkXG4gICAgICAgIG1lc2guc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5nZXRIYXNoKCksXG4gICAgICAgIG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gXCJjcFwiIDogXCJcIixcbiAgICAgICAgbWVzaC5fc3RhdGUuaGFzaFxuICAgIF0uam9pbihcIjtcIik7XG4gICAgbGV0IHJlbmRlcmVyID0gcmVuZGVyZXJzW2hhc2hdO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBuZXcgRW1waGFzaXNFZGdlc1JlbmRlcmVyKGhhc2gsIG1lc2gpO1xuICAgICAgICByZW5kZXJlcnNbaGFzaF0gPSByZW5kZXJlcjtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zKys7XG4gICAgfVxuICAgIHJlbmRlcmVyLl91c2VDb3VudCsrO1xuICAgIHJldHVybiByZW5kZXJlcjtcbn07XG5cbkVtcGhhc2lzRWRnZXNSZW5kZXJlci5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgtLXRoaXMuX3VzZUNvdW50ID09PSAwKSB7XG4gICAgICAgIGlkcy5yZW1vdmVJdGVtKHRoaXMuaWQpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHJlbmRlcmVyc1t0aGlzLl9oYXNoXTtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zLS07XG4gICAgfVxufTtcblxuRW1waGFzaXNFZGdlc1JlbmRlcmVyLnByb3RvdHlwZS53ZWJnbENvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbn07XG5cbkVtcGhhc2lzRWRnZXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd01lc2ggPSBmdW5jdGlvbiAoZnJhbWVDdHgsIG1lc2gsIG1vZGUpIHtcblxuICAgIGlmICghdGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmNhbWVyYTtcbiAgICBjb25zdCBnbCA9IHNjZW5lLmNhbnZhcy5nbDtcbiAgICBsZXQgbWF0ZXJpYWxTdGF0ZTtcbiAgICBjb25zdCBtZXNoU3RhdGUgPSBtZXNoLl9zdGF0ZTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgIGNvbnN0IGdlb21ldHJ5U3RhdGUgPSBnZW9tZXRyeS5fc3RhdGU7XG4gICAgY29uc3QgcnRjQ2VudGVyID0gbWVzaC5ydGNDZW50ZXI7XG5cbiAgICBpZiAoZnJhbWVDdHgubGFzdFByb2dyYW1JZCAhPT0gdGhpcy5fcHJvZ3JhbS5pZCkge1xuICAgICAgICBmcmFtZUN0eC5sYXN0UHJvZ3JhbUlkID0gdGhpcy5fcHJvZ3JhbS5pZDtcbiAgICAgICAgdGhpcy5fYmluZFByb2dyYW0oZnJhbWVDdHgpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVZpZXdNYXRyaXgsIGZhbHNlLCBydGNDZW50ZXIgPyBmcmFtZUN0eC5nZXRSVENWaWV3TWF0cml4KG1lc2hTdGF0ZS5ydGNDZW50ZXJIYXNoLCBydGNDZW50ZXIpIDogY2FtZXJhLnZpZXdNYXRyaXgpO1xuXG4gICAgaWYgKG1lc2hTdGF0ZS5jbGlwcGFibGUpIHtcbiAgICAgICAgY29uc3QgbnVtU2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWN0aW9uUGxhbmVzID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckZsYWdzID0gbWVzaC5yZW5kZXJGbGFncztcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb25QbGFuZUluZGV4ID0gMDsgc2VjdGlvblBsYW5lSW5kZXggPCBudW1TZWN0aW9uUGxhbmVzOyBzZWN0aW9uUGxhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lVW5pZm9ybXMgPSB0aGlzLl91U2VjdGlvblBsYW5lc1tzZWN0aW9uUGxhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gcmVuZGVyRmxhZ3Muc2VjdGlvblBsYW5lc0FjdGl2ZVBlckxheWVyW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoc2VjdGlvblBsYW5lVW5pZm9ybXMuYWN0aXZlLCBhY3RpdmUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmUgPSBzZWN0aW9uUGxhbmVzW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5wb3MsIHJ0Y0NlbnRlciA/IGdldFBsYW5lUlRDUG9zKHNlY3Rpb25QbGFuZS5kaXN0LCBzZWN0aW9uUGxhbmUuZGlyLCBydGNDZW50ZXIsIHRlbXBWZWMzYSkgOiBzZWN0aW9uUGxhbmUucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5kaXIsIHNlY3Rpb25QbGFuZS5kaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtYXRlcmlhbFN0YXRlID0gbWVzaC5feHJheU1hdGVyaWFsLl9zdGF0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtYXRlcmlhbFN0YXRlID0gbWVzaC5faGlnaGxpZ2h0TWF0ZXJpYWwuX3N0YXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIG1hdGVyaWFsU3RhdGUgPSBtZXNoLl9zZWxlY3RlZE1hdGVyaWFsLl9zdGF0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXRlcmlhbFN0YXRlID0gbWVzaC5fZWRnZU1hdGVyaWFsLl9zdGF0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmlkICE9PSB0aGlzLl9sYXN0TWF0ZXJpYWxJZCkge1xuICAgICAgICBjb25zdCBiYWNrZmFjZXMgPSBtYXRlcmlhbFN0YXRlLmJhY2tmYWNlcztcbiAgICAgICAgaWYgKGZyYW1lQ3R4LmJhY2tmYWNlcyAhPT0gYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICBpZiAoYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lQ3R4LmJhY2tmYWNlcyA9IGJhY2tmYWNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVDdHgubGluZVdpZHRoICE9PSBtYXRlcmlhbFN0YXRlLmVkZ2VXaWR0aCkge1xuICAgICAgICAgICAgZ2wubGluZVdpZHRoKG1hdGVyaWFsU3RhdGUuZWRnZVdpZHRoKTtcbiAgICAgICAgICAgIGZyYW1lQ3R4LmxpbmVXaWR0aCA9IG1hdGVyaWFsU3RhdGUuZWRnZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91RWRnZUNvbG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlZGdlQ29sb3IgPSBtYXRlcmlhbFN0YXRlLmVkZ2VDb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VBbHBoYSA9IG1hdGVyaWFsU3RhdGUuZWRnZUFscGhhO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHRoaXMuX3VFZGdlQ29sb3IsIGVkZ2VDb2xvclswXSwgZWRnZUNvbG9yWzFdLCBlZGdlQ29sb3JbMl0sIGVkZ2VBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBtYXRlcmlhbFN0YXRlLmlkO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTWF0cml4LCBnbC5GQUxTRSwgbWVzaC53b3JsZE1hdHJpeCk7XG5cbiAgICBpZiAodGhpcy5fdUNsaXBwYWJsZSkge1xuICAgICAgICBnbC51bmlmb3JtMWkodGhpcy5fdUNsaXBwYWJsZSwgbWVzaFN0YXRlLmNsaXBwYWJsZSk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybTNmdih0aGlzLl91T2Zmc2V0LCBtZXNoU3RhdGUub2Zmc2V0KTtcblxuICAgIC8vIEJpbmQgVkJPc1xuICAgIGxldCBpbmRpY2VzQnVmO1xuICAgIGlmIChnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZSA9PT0gZ2wuVFJJQU5HTEVTKSB7XG4gICAgICAgIGluZGljZXNCdWYgPSBnZW9tZXRyeS5fZ2V0RWRnZUluZGljZXMoKTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlID09PSBnbC5MSU5FUykge1xuICAgICAgICBpbmRpY2VzQnVmID0gZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmO1xuICAgIH1cblxuICAgIGlmIChpbmRpY2VzQnVmKSB7XG4gICAgICAgIGlmIChnZW9tZXRyeVN0YXRlLmlkICE9PSB0aGlzLl9sYXN0R2VvbWV0cnlJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGZhbHNlLCBnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYVBvc2l0aW9uLmJpbmRBcnJheUJ1ZmZlcihnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0J1ZiwgZ2VvbWV0cnlTdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5GTE9BVCk7XG4gICAgICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzQnVmLmJpbmQoKTtcbiAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRBcnJheSsrO1xuICAgICAgICAgICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBnZW9tZXRyeVN0YXRlLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCBpbmRpY2VzQnVmLm51bUl0ZW1zLCBpbmRpY2VzQnVmLml0ZW1UeXBlLCAwKTtcblxuICAgICAgICBmcmFtZUN0eC5kcmF3RWxlbWVudHMrKztcbiAgICB9XG59O1xuXG5FbXBoYXNpc0VkZ2VzUmVuZGVyZXIucHJvdG90eXBlLl9hbGxvY2F0ZSA9IGZ1bmN0aW9uIChtZXNoKSB7XG5cbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcblxuICAgIHRoaXMuX3Byb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwgdGhpcy5fc2hhZGVyU291cmNlKTtcblxuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX3Byb2dyYW07XG5cbiAgICB0aGlzLl91UG9zaXRpb25zRGVjb2RlTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInBvc2l0aW9uc0RlY29kZU1hdHJpeFwiKTtcbiAgICB0aGlzLl91TW9kZWxNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibW9kZWxNYXRyaXhcIik7XG4gICAgdGhpcy5fdVZpZXdNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwidmlld01hdHJpeFwiKTtcbiAgICB0aGlzLl91UHJvak1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJwcm9qTWF0cml4XCIpO1xuICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzLnB1c2goe1xuICAgICAgICAgICAgYWN0aXZlOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpKSxcbiAgICAgICAgICAgIHBvczogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZVBvc1wiICsgaSksXG4gICAgICAgICAgICBkaXI6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVEaXJcIiArIGkpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91RWRnZUNvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImVkZ2VDb2xvclwiKTtcbiAgICB0aGlzLl9hUG9zaXRpb24gPSBwcm9ncmFtLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgIHRoaXMuX3VDbGlwcGFibGUgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiY2xpcHBhYmxlXCIpO1xuICAgIHRoaXMuX3VHYW1tYUZhY3RvciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJnYW1tYUZhY3RvclwiKTtcbiAgICB0aGlzLl91T2Zmc2V0ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcIm9mZnNldFwiKTtcblxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCApIHtcbiAgICAgICAgdGhpcy5fdUxvZ0RlcHRoQnVmRkMgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibG9nRGVwdGhCdWZGQ1wiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZlcnRleEJ1ZnNJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xufTtcblxuRW1waGFzaXNFZGdlc1JlbmRlcmVyLnByb3RvdHlwZS5fYmluZFByb2dyYW0gPSBmdW5jdGlvbiAoZnJhbWVDdHgpIHtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xuICAgIGNvbnN0IHByb2plY3QgPSBjYW1lcmEucHJvamVjdDtcblxuICAgIHByb2dyYW0uYmluZCgpO1xuXG4gICAgZnJhbWVDdHgudXNlUHJvZ3JhbSsrO1xuXG4gICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RWZXJ0ZXhCdWZzSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RHZW9tZXRyeUlkID0gbnVsbDtcblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qZWN0Lm1hdHJpeCk7XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgKSB7XG4gICAgICAgIGNvbnN0IGxvZ0RlcHRoQnVmRkMgPSAyLjAgLyAoTWF0aC5sb2cocHJvamVjdC5mYXIgKyAxLjApIC8gTWF0aC5MTjIpO1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUxvZ0RlcHRoQnVmRkMsIGxvZ0RlcHRoQnVmRkMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl91R2FtbWFGYWN0b3IpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VHYW1tYUZhY3Rvciwgc2NlbmUuZ2FtbWFGYWN0b3IpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7RW1waGFzaXNFZGdlc1JlbmRlcmVyfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesShaderSource.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesShaderSource.js ***!
  \*****************************************************************************************************/
/*! exports provided: EmphasisEdgesShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmphasisEdgesShaderSource\", function() { return EmphasisEdgesShaderSource; });\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n\n\n/**\n * @private\n */\nclass EmphasisEdgesShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n    const scene = mesh.scene;\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const src = [];\n    src.push(\"// Edges drawing vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"uniform vec4 edgeColor;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"varying float vFragDepth;\");\n        }\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    src.push(\"varying vec4 vColor;\");\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    src.push(\"vec4 worldPosition;\");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    src.push(\"mat4 viewMatrix2 = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2 = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n        src.push(\"billboard(modelViewMatrix);\");\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition = modelViewMatrix * localPosition;\");\n    } else {\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition  = viewMatrix2 * worldPosition; \");\n    }\n    src.push(\"vColor = edgeColor;\");\n    if (clipping) {\n        src.push(\"vWorldPosition = worldPosition;\");\n    }\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n        } else {\n            src.push(\"clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;\");\n            src.push(\"clipPos.z *= clipPos.w;\");\n        }\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragment(mesh) {\n\n    const scene = mesh.scene;\n    const sectionPlanesState = mesh.scene._sectionPlanesState;\n    const gammaOutput = mesh.scene.gammaOutput;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n\n    src.push(\"// Edges drawing fragment shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    if (gammaOutput) {\n        src.push(\"uniform float gammaFactor;\");\n        src.push(\"vec4 linearToGamma( in vec4 value, in float gammaFactor ) {\");\n        src.push(\"  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\");\n        src.push(\"}\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n        src.push(\"uniform bool clippable;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n    if (gammaOutput) {\n        src.push(\"gl_FragColor = linearToGamma(vColor, gammaFactor);\");\n    } else {\n        src.push(\"gl_FragColor = vColor;\");\n    }\n    src.push(\"}\");\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZW1waGFzaXMvRW1waGFzaXNFZGdlc1NoYWRlclNvdXJjZS5qcz9mOGJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQVU7QUFDekQ7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsWUFBWSx3REFBVTtBQUN0QiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0RBQWtEO0FBQ2xELHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQyxtQkFBbUI7QUFDbkI7QUFDQSwrQkFBK0I7QUFDL0IsdURBQXVEO0FBQ3ZELGlDQUFpQztBQUNqQztBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUM7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3QywrREFBK0Q7QUFDL0QsaUVBQWlFO0FBQ2pFLHNFQUFzRTtBQUN0RSxLQUFLO0FBQ0wsK0RBQStEO0FBQy9ELGlFQUFpRTtBQUNqRSxtRUFBbUU7QUFDbkU7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxZQUFZLHdEQUFVO0FBQ3RCLG1EQUFtRDtBQUNuRCxTQUFTO0FBQ1QsNkZBQTZGO0FBQzdGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0Msd0RBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtDQUFrQztBQUNsQztBQUNBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEM7QUFDQSwrQ0FBK0Msd0RBQVU7QUFDekQsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDZFQUE2RTtBQUM3RSx3RkFBd0Y7QUFDeEYsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMseUNBQXlDO0FBQ3pDLHNFQUFzRSxTQUFTO0FBQy9FLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CO0FBQ0Esa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQyxzRUFBc0UsU0FBUztBQUMvRSx3REFBd0Q7QUFDeEQsMklBQTJJO0FBQzNJLHVCQUF1QjtBQUN2QjtBQUNBLHFDQUFxQyxTQUFTLEVBQUU7QUFDaEQsbUJBQW1CO0FBQ25CO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pELDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLEtBQUs7QUFDTCx3Q0FBd0M7QUFDeEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL2VtcGhhc2lzL0VtcGhhc2lzRWRnZXNTaGFkZXJTb3VyY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1dFQkdMX0lORk99IGZyb20gXCIuLi8uLi93ZWJnbEluZm8uanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFbXBoYXNpc0VkZ2VzU2hhZGVyU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNoKSB7XG4gICAgICAgIHRoaXMudmVydGV4ID0gYnVpbGRWZXJ0ZXgobWVzaCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KG1lc2gpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRWZXJ0ZXgobWVzaCkge1xuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHF1YW50aXplZEdlb21ldHJ5ID0gISFtZXNoLl9nZW9tZXRyeS5fc3RhdGUuY29tcHJlc3NHZW9tZXRyeTtcbiAgICBjb25zdCBiaWxsYm9hcmQgPSBtZXNoLl9zdGF0ZS5iaWxsYm9hcmQ7XG4gICAgY29uc3Qgc3RhdGlvbmFyeSA9IG1lc2guX3N0YXRlLnN0YXRpb25hcnk7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBFZGdlcyBkcmF3aW5nIHZlcnRleCBzaGFkZXJcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcIiNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBwcm9qTWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCBlZGdlQ29sb3I7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIG9mZnNldDtcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHBvc2l0aW9uc0RlY29kZU1hdHJpeDtcIik7XG4gICAgfVxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcIik7XG4gICAgICAgIGlmIChXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2Q29sb3I7XCIpO1xuICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIgfHwgYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2b2lkIGJpbGxib2FyZChpbm91dCBtYXQ0IG1hdCkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMF0gPSAxLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVsxXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzJdID0gMC4wO1wiKTtcbiAgICAgICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIikge1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMF0gPSAwLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMV0gPSAxLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMl0gPSAwLjA7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzBdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMV0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVsyXSA9MS4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbFBvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTsgXCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJsb2NhbFBvc2l0aW9uID0gcG9zaXRpb25zRGVjb2RlTWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwibWF0NCB2aWV3TWF0cml4MiA9IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbE1hdHJpeDIgPSBtb2RlbE1hdHJpeDtcIik7XG4gICAgaWYgKHN0YXRpb25hcnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2aWV3TWF0cml4MlszXVswXSA9IHZpZXdNYXRyaXgyWzNdWzFdID0gdmlld01hdHJpeDJbM11bMl0gPSAwLjA7XCIpXG4gICAgfVxuICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIgfHwgYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsVmlld01hdHJpeCA9IHZpZXdNYXRyaXgyICogbW9kZWxNYXRyaXgyO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxNYXRyaXgyKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKHZpZXdNYXRyaXgyKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsVmlld01hdHJpeCk7XCIpO1xuICAgICAgICBzcmMucHVzaChcIndvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeDIgKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uLnh5eiA9IHdvcmxkUG9zaXRpb24ueHl6ICsgb2Zmc2V0O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWM0IHZpZXdQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4MiAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgICAgICBzcmMucHVzaChcIndvcmxkUG9zaXRpb24ueHl6ID0gd29ybGRQb3NpdGlvbi54eXogKyBvZmZzZXQ7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzQgdmlld1Bvc2l0aW9uICA9IHZpZXdNYXRyaXgyICogd29ybGRQb3NpdGlvbjsgXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZDb2xvciA9IGVkZ2VDb2xvcjtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGNsaXBQb3MgPSBwcm9qTWF0cml4ICogdmlld1Bvc2l0aW9uO1wiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgaWYgKFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2RnJhZ0RlcHRoID0gMS4wICsgY2xpcFBvcy53O1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY2xpcFBvcy56ID0gbG9nMiggbWF4KCAxZS02LCBjbGlwUG9zLncgKyAxLjAgKSApICogbG9nRGVwdGhCdWZGQyAtIDEuMDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcImNsaXBQb3MueiAqPSBjbGlwUG9zLnc7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwiZ2xfUG9zaXRpb24gPSBjbGlwUG9zO1wiKTtcbiAgICBzcmMucHVzaChcIn1cIik7XG4gICAgcmV0dXJuIHNyYztcbn1cblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudChtZXNoKSB7XG5cbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gbWVzaC5zY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlO1xuICAgIGNvbnN0IGdhbW1hT3V0cHV0ID0gbWVzaC5zY2VuZS5nYW1tYU91dHB1dDtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc3JjID0gW107XG5cbiAgICBzcmMucHVzaChcIi8vIEVkZ2VzIGRyYXdpbmcgZnJhZ21lbnQgc2hhZGVyXCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbHNlXCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbmRpZlwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgIH1cbiAgICBpZiAoZ2FtbWFPdXRwdXQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGdhbW1hRmFjdG9yO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWM0IGxpbmVhclRvR2FtbWEoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgIHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggMS4wIC8gZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgfVxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIGNsaXBwYWJsZTtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZDb2xvcjtcIik7XG4gICAgc3JjLnB1c2goXCJ2b2lkIG1haW4odm9pZCkge1wiKTtcbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJpZiAoY2xpcHBhYmxlKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgZmxvYXQgZGlzdCA9IDAuMDtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJpZiAoc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCIpIHtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGRpc3QgKz0gY2xhbXAoZG90KC1zZWN0aW9uUGxhbmVEaXJcIiArIGkgKyBcIi54eXosIHZXb3JsZFBvc2l0aW9uLnh5eiAtIHNlY3Rpb25QbGFuZVBvc1wiICsgaSArIFwiLnh5eiksIDAuMCwgMTAwMC4wKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCIgIGlmIChkaXN0ID4gMC4wKSB7IGRpc2NhcmQ7IH1cIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcImdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XCIpO1xuICAgIH1cbiAgICBpZiAoZ2FtbWFPdXRwdXQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb0dhbW1hKHZDb2xvciwgZ2FtbWFGYWN0b3IpO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcmMucHVzaChcImdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICByZXR1cm4gc3JjO1xufVxuXG5leHBvcnQge0VtcGhhc2lzRWRnZXNTaGFkZXJTb3VyY2V9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisEdgesShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillRenderer.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillRenderer.js ***!
  \************************************************************************************************/
/*! exports provided: EmphasisFillRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmphasisFillRenderer\", function() { return EmphasisFillRenderer; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _EmphasisFillShaderSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EmphasisFillShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_4__[\"math\"].vec3();\n\n/**\n * @private\n */\nconst EmphasisFillRenderer = function (hash, mesh) {\n    this.id = ids.addItem({});\n    this._hash = hash;\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._shaderSource = new _EmphasisFillShaderSource_js__WEBPACK_IMPORTED_MODULE_1__[\"EmphasisFillShaderSource\"](mesh);\n    this._allocate(mesh);\n};\n\nconst xrayFillRenderers = {};\n\nEmphasisFillRenderer.get = function (mesh) {\n    const hash = [\n        mesh.scene.id,\n        mesh.scene.gammaOutput ? \"go\" : \"\", // Gamma input not needed\n        mesh.scene._sectionPlanesState.getHash(),\n        !!mesh._geometry._state.normalsBuf ? \"n\" : \"\",\n        mesh._geometry._state.compressGeometry ? \"cp\" : \"\",\n        mesh._state.hash\n    ].join(\";\");\n    let renderer = xrayFillRenderers[hash];\n    if (!renderer) {\n        renderer = new EmphasisFillRenderer(hash, mesh);\n        xrayFillRenderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nEmphasisFillRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        ids.removeItem(this.id);\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete xrayFillRenderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_3__[\"stats\"].memory.programs--;\n    }\n};\n\nEmphasisFillRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nEmphasisFillRenderer.prototype.drawMesh = function (frameCtx, mesh, mode) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const scene = this._scene;\n    const camera = scene.camera;\n    const gl = scene.canvas.gl;\n    const materialState = mode === 0 ? mesh._xrayMaterial._state : (mode === 1 ? mesh._highlightMaterial._state : mesh._selectedMaterial._state);\n    const meshState = mesh._state;\n    const geometryState = mesh._geometry._state;\n    const rtcCenter = mesh.rtcCenter;\n\n    if (frameCtx.lastProgramId !== this._program.id) {\n        frameCtx.lastProgramId = this._program.id;\n        this._bindProgram(frameCtx);\n    }\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);\n    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.viewNormalMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_5__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    if (materialState.id !== this._lastMaterialId) {\n        const fillColor = materialState.fillColor;\n        const backfaces = materialState.backfaces;\n        if (frameCtx.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frameCtx.backfaces = backfaces;\n        }\n        gl.uniform4f(this._uFillColor, fillColor[0], fillColor[1], fillColor[2], materialState.fillAlpha);\n        this._lastMaterialId = materialState.id;\n    }\n\n    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);\n    if (this._uModelNormalMatrix) {\n        gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, mesh.worldNormalMatrix);\n    }\n\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, meshState.clippable);\n    }\n\n    gl.uniform3fv(this._uOffset, meshState.offset);\n\n    // Bind VBOs\n    if (geometryState.id !== this._lastGeometryId) {\n        if (this._uPositionsDecodeMatrix) {\n            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        }\n        if (this._uUVDecodeMatrix) {\n            gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometryState.uvDecodeMatrix);\n        }\n        if (this._aPosition) {\n            this._aPosition.bindArrayBuffer(geometryState.positionsBuf);\n            frameCtx.bindArray++;\n        }\n        if (this._aNormal) {\n            this._aNormal.bindArrayBuffer(geometryState.normalsBuf);\n            frameCtx.bindArray++;\n        }\n        if (geometryState.indicesBuf) {\n            geometryState.indicesBuf.bind();\n            frameCtx.bindArray++;\n            // gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n            // frameCtx.drawElements++;\n        } else if (geometryState.positionsBuf) {\n            // gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);\n            //  frameCtx.drawArrays++;\n        }\n        this._lastGeometryId = geometryState.id;\n    }\n\n    if (geometryState.indicesBuf) {\n        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n        frameCtx.drawElements++;\n    } else if (geometryState.positionsBuf) {\n        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positionsBuf.numItems);\n        frameCtx.drawArrays++;\n    }\n};\n\nEmphasisFillRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const lightsState = scene._lightsState;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const gl = scene.canvas.gl;\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_2__[\"Program\"](gl, this._shaderSource);\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uModelNormalMatrix = program.getLocation(\"modelNormalMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uViewNormalMatrix = program.getLocation(\"viewNormalMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uLightAmbient = [];\n    this._uLightColor = [];\n    this._uLightDir = [];\n    this._uLightPos = [];\n    this._uLightAttenuation = [];\n    for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n        const light = lightsState.lights[i];\n        switch (light.type) {\n            case \"ambient\":\n                this._uLightAmbient[i] = program.getLocation(\"lightAmbient\");\n                break;\n            case \"dir\":\n                this._uLightColor[i] = program.getLocation(\"lightColor\" + i);\n                this._uLightPos[i] = null;\n                this._uLightDir[i] = program.getLocation(\"lightDir\" + i);\n                break;\n            case \"point\":\n                this._uLightColor[i] = program.getLocation(\"lightColor\" + i);\n                this._uLightPos[i] = program.getLocation(\"lightPos\" + i);\n                this._uLightDir[i] = null;\n                this._uLightAttenuation[i] = program.getLocation(\"lightAttenuation\" + i);\n                break;\n        }\n    }\n    this._uSectionPlanes = [];\n    for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._uFillColor = program.getLocation(\"fillColor\");\n    this._aPosition = program.getAttribute(\"position\");\n    this._aNormal = program.getAttribute(\"normal\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uGammaFactor = program.getLocation(\"gammaFactor\");\n    this._uOffset = program.getLocation(\"offset\");\n    if (scene.logarithmicDepthBufferEnabled ) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n};\n\nEmphasisFillRenderer.prototype._bindProgram = function (frameCtx) {\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const lightsState = scene._lightsState;\n    const camera = scene.camera;\n    const project = camera.project;\n    const program = this._program;\n    program.bind();\n    frameCtx.useProgram++;\n    frameCtx.textureUnit = 0;\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n    this._lastIndicesBufId = null;\n    gl.uniformMatrix4fv(this._uViewNormalMatrix, false, camera.normalMatrix);\n    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);\n    if (scene.logarithmicDepthBufferEnabled ) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n    for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n        const light = lightsState.lights[i];\n        if (this._uLightAmbient[i]) {\n            gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);\n        } else {\n            if (this._uLightColor[i]) {\n                gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);\n            }\n            if (this._uLightPos[i]) {\n                gl.uniform3fv(this._uLightPos[i], light.pos);\n                if (this._uLightAttenuation[i]) {\n                    gl.uniform1f(this._uLightAttenuation[i], light.attenuation);\n                }\n            }\n            if (this._uLightDir[i]) {\n                gl.uniform3fv(this._uLightDir[i], light.dir);\n            }\n        }\n    }\n    if (this._uGammaFactor) {\n        gl.uniform1f(this._uGammaFactor, scene.gammaFactor);\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZW1waGFzaXMvRW1waGFzaXNGaWxsUmVuZGVyZXIuanM/MTk3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUV1QztBQUNnQztBQUN4QjtBQUNWO0FBQ0c7QUFDZTs7QUFFdkQsZ0JBQWdCLGlEQUFHLEdBQUc7O0FBRXRCLGtCQUFrQixrREFBSTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFGQUF3QjtBQUNyRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx5RUFBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZW1waGFzaXMvRW1waGFzaXNGaWxsUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgeGVvbGFicyAvIGh0dHBzOi8vZ2l0aHViLmNvbS94ZW9sYWJzXG4gKi9cblxuaW1wb3J0IHtNYXB9IGZyb20gXCIuLi8uLi91dGlscy9NYXAuanNcIjtcbmltcG9ydCB7RW1waGFzaXNGaWxsU2hhZGVyU291cmNlfSBmcm9tIFwiLi9FbXBoYXNpc0ZpbGxTaGFkZXJTb3VyY2UuanNcIjtcbmltcG9ydCB7UHJvZ3JhbX0gZnJvbSBcIi4uLy4uL3dlYmdsL1Byb2dyYW0uanNcIjtcbmltcG9ydCB7c3RhdHN9IGZyb20gJy4uLy4uL3N0YXRzLmpzJztcbmltcG9ydCB7bWF0aH0gZnJvbSBcIi4uLy4uL21hdGgvbWF0aC5qc1wiO1xuaW1wb3J0IHtnZXRQbGFuZVJUQ1Bvc30gZnJvbSBcIi4uLy4uL21hdGgvcnRjQ29vcmRzLmpzXCI7XG5cbmNvbnN0IGlkcyA9IG5ldyBNYXAoe30pO1xuXG5jb25zdCB0ZW1wVmVjM2EgPSBtYXRoLnZlYzMoKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBFbXBoYXNpc0ZpbGxSZW5kZXJlciA9IGZ1bmN0aW9uIChoYXNoLCBtZXNoKSB7XG4gICAgdGhpcy5pZCA9IGlkcy5hZGRJdGVtKHt9KTtcbiAgICB0aGlzLl9oYXNoID0gaGFzaDtcbiAgICB0aGlzLl9zY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIHRoaXMuX3NoYWRlclNvdXJjZSA9IG5ldyBFbXBoYXNpc0ZpbGxTaGFkZXJTb3VyY2UobWVzaCk7XG4gICAgdGhpcy5fYWxsb2NhdGUobWVzaCk7XG59O1xuXG5jb25zdCB4cmF5RmlsbFJlbmRlcmVycyA9IHt9O1xuXG5FbXBoYXNpc0ZpbGxSZW5kZXJlci5nZXQgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgIGNvbnN0IGhhc2ggPSBbXG4gICAgICAgIG1lc2guc2NlbmUuaWQsXG4gICAgICAgIG1lc2guc2NlbmUuZ2FtbWFPdXRwdXQgPyBcImdvXCIgOiBcIlwiLCAvLyBHYW1tYSBpbnB1dCBub3QgbmVlZGVkXG4gICAgICAgIG1lc2guc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5nZXRIYXNoKCksXG4gICAgICAgICEhbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLm5vcm1hbHNCdWYgPyBcIm5cIiA6IFwiXCIsXG4gICAgICAgIG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gXCJjcFwiIDogXCJcIixcbiAgICAgICAgbWVzaC5fc3RhdGUuaGFzaFxuICAgIF0uam9pbihcIjtcIik7XG4gICAgbGV0IHJlbmRlcmVyID0geHJheUZpbGxSZW5kZXJlcnNbaGFzaF07XG4gICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IG5ldyBFbXBoYXNpc0ZpbGxSZW5kZXJlcihoYXNoLCBtZXNoKTtcbiAgICAgICAgeHJheUZpbGxSZW5kZXJlcnNbaGFzaF0gPSByZW5kZXJlcjtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zKys7XG4gICAgfVxuICAgIHJlbmRlcmVyLl91c2VDb3VudCsrO1xuICAgIHJldHVybiByZW5kZXJlcjtcbn07XG5cbkVtcGhhc2lzRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5fdXNlQ291bnQgPT09IDApIHtcbiAgICAgICAgaWRzLnJlbW92ZUl0ZW0odGhpcy5pZCk7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgeHJheUZpbGxSZW5kZXJlcnNbdGhpcy5faGFzaF07XG4gICAgICAgIHN0YXRzLm1lbW9yeS5wcm9ncmFtcy0tO1xuICAgIH1cbn07XG5cbkVtcGhhc2lzRmlsbFJlbmRlcmVyLnByb3RvdHlwZS53ZWJnbENvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbn07XG5cbkVtcGhhc2lzRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TWVzaCA9IGZ1bmN0aW9uIChmcmFtZUN0eCwgbWVzaCwgbW9kZSkge1xuXG4gICAgaWYgKCF0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgIHRoaXMuX2FsbG9jYXRlKG1lc2gpO1xuICAgIH1cblxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xuICAgIGNvbnN0IGdsID0gc2NlbmUuY2FudmFzLmdsO1xuICAgIGNvbnN0IG1hdGVyaWFsU3RhdGUgPSBtb2RlID09PSAwID8gbWVzaC5feHJheU1hdGVyaWFsLl9zdGF0ZSA6IChtb2RlID09PSAxID8gbWVzaC5faGlnaGxpZ2h0TWF0ZXJpYWwuX3N0YXRlIDogbWVzaC5fc2VsZWN0ZWRNYXRlcmlhbC5fc3RhdGUpO1xuICAgIGNvbnN0IG1lc2hTdGF0ZSA9IG1lc2guX3N0YXRlO1xuICAgIGNvbnN0IGdlb21ldHJ5U3RhdGUgPSBtZXNoLl9nZW9tZXRyeS5fc3RhdGU7XG4gICAgY29uc3QgcnRjQ2VudGVyID0gbWVzaC5ydGNDZW50ZXI7XG5cbiAgICBpZiAoZnJhbWVDdHgubGFzdFByb2dyYW1JZCAhPT0gdGhpcy5fcHJvZ3JhbS5pZCkge1xuICAgICAgICBmcmFtZUN0eC5sYXN0UHJvZ3JhbUlkID0gdGhpcy5fcHJvZ3JhbS5pZDtcbiAgICAgICAgdGhpcy5fYmluZFByb2dyYW0oZnJhbWVDdHgpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVZpZXdNYXRyaXgsIGZhbHNlLCBydGNDZW50ZXIgPyBmcmFtZUN0eC5nZXRSVENWaWV3TWF0cml4KG1lc2hTdGF0ZS5ydGNDZW50ZXJIYXNoLCBydGNDZW50ZXIpIDogY2FtZXJhLnZpZXdNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVZpZXdOb3JtYWxNYXRyaXgsIGZhbHNlLCBjYW1lcmEudmlld05vcm1hbE1hdHJpeCk7XG5cbiAgICBpZiAobWVzaFN0YXRlLmNsaXBwYWJsZSkge1xuICAgICAgICBjb25zdCBudW1TZWN0aW9uUGxhbmVzID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlY3Rpb25QbGFuZXMgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmVzID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyRmxhZ3MgPSBtZXNoLnJlbmRlckZsYWdzO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvblBsYW5lSW5kZXggPSAwOyBzZWN0aW9uUGxhbmVJbmRleCA8IG51bVNlY3Rpb25QbGFuZXM7IHNlY3Rpb25QbGFuZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmVVbmlmb3JtcyA9IHRoaXMuX3VTZWN0aW9uUGxhbmVzW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSByZW5kZXJGbGFncy5zZWN0aW9uUGxhbmVzQWN0aXZlUGVyTGF5ZXJbc2VjdGlvblBsYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzZWN0aW9uUGxhbmVVbmlmb3Jtcy5hY3RpdmUsIGFjdGl2ZSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25QbGFuZSA9IHNlY3Rpb25QbGFuZXNbc2VjdGlvblBsYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLnBvcywgcnRjQ2VudGVyID8gZ2V0UGxhbmVSVENQb3Moc2VjdGlvblBsYW5lLmRpc3QsIHNlY3Rpb25QbGFuZS5kaXIsIHJ0Y0NlbnRlciwgdGVtcFZlYzNhKSA6IHNlY3Rpb25QbGFuZS5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLmRpciwgc2VjdGlvblBsYW5lLmRpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsU3RhdGUuaWQgIT09IHRoaXMuX2xhc3RNYXRlcmlhbElkKSB7XG4gICAgICAgIGNvbnN0IGZpbGxDb2xvciA9IG1hdGVyaWFsU3RhdGUuZmlsbENvbG9yO1xuICAgICAgICBjb25zdCBiYWNrZmFjZXMgPSBtYXRlcmlhbFN0YXRlLmJhY2tmYWNlcztcbiAgICAgICAgaWYgKGZyYW1lQ3R4LmJhY2tmYWNlcyAhPT0gYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICBpZiAoYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lQ3R4LmJhY2tmYWNlcyA9IGJhY2tmYWNlcztcbiAgICAgICAgfVxuICAgICAgICBnbC51bmlmb3JtNGYodGhpcy5fdUZpbGxDb2xvciwgZmlsbENvbG9yWzBdLCBmaWxsQ29sb3JbMV0sIGZpbGxDb2xvclsyXSwgbWF0ZXJpYWxTdGF0ZS5maWxsQWxwaGEpO1xuICAgICAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG1hdGVyaWFsU3RhdGUuaWQ7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91TW9kZWxNYXRyaXgsIGdsLkZBTFNFLCBtZXNoLndvcmxkTWF0cml4KTtcbiAgICBpZiAodGhpcy5fdU1vZGVsTm9ybWFsTWF0cml4KSB7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTm9ybWFsTWF0cml4LCBnbC5GQUxTRSwgbWVzaC53b3JsZE5vcm1hbE1hdHJpeCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3VDbGlwcGFibGUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHRoaXMuX3VDbGlwcGFibGUsIG1lc2hTdGF0ZS5jbGlwcGFibGUpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdU9mZnNldCwgbWVzaFN0YXRlLm9mZnNldCk7XG5cbiAgICAvLyBCaW5kIFZCT3NcbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pZCAhPT0gdGhpcy5fbGFzdEdlb21ldHJ5SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCwgZmFsc2UsIGdlb21ldHJ5U3RhdGUucG9zaXRpb25zRGVjb2RlTWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdVVWRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuX3VVVkRlY29kZU1hdHJpeCwgZmFsc2UsIGdlb21ldHJ5U3RhdGUudXZEZWNvZGVNYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FQb3NpdGlvbi5iaW5kQXJyYXlCdWZmZXIoZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnNCdWYpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FOb3JtYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FOb3JtYWwuYmluZEFycmF5QnVmZmVyKGdlb21ldHJ5U3RhdGUubm9ybWFsc0J1Zik7XG4gICAgICAgICAgICBmcmFtZUN0eC5iaW5kQXJyYXkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmKSB7XG4gICAgICAgICAgICBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYuYmluZCgpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgICAgICAvLyBnbC5kcmF3RWxlbWVudHMoZ2VvbWV0cnlTdGF0ZS5wcmltaXRpdmUsIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zi5udW1JdGVtcywgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLml0ZW1UeXBlLCAwKTtcbiAgICAgICAgICAgIC8vIGZyYW1lQ3R4LmRyYXdFbGVtZW50cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5U3RhdGUucG9zaXRpb25zQnVmKSB7XG4gICAgICAgICAgICAvLyBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnMubnVtSXRlbXMpO1xuICAgICAgICAgICAgLy8gIGZyYW1lQ3R4LmRyYXdBcnJheXMrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IGdlb21ldHJ5U3RhdGUuaWQ7XG4gICAgfVxuXG4gICAgaWYgKGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zikge1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2VvbWV0cnlTdGF0ZS5wcmltaXRpdmUsIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zi5udW1JdGVtcywgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLml0ZW1UeXBlLCAwKTtcbiAgICAgICAgZnJhbWVDdHguZHJhd0VsZW1lbnRzKys7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0J1Zikge1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnNCdWYubnVtSXRlbXMpO1xuICAgICAgICBmcmFtZUN0eC5kcmF3QXJyYXlzKys7XG4gICAgfVxufTtcblxuRW1waGFzaXNGaWxsUmVuZGVyZXIucHJvdG90eXBlLl9hbGxvY2F0ZSA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IGxpZ2h0c1N0YXRlID0gc2NlbmUuX2xpZ2h0c1N0YXRlO1xuICAgIGNvbnN0IHNlY3Rpb25QbGFuZXNTdGF0ZSA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB0aGlzLl9zaGFkZXJTb3VyY2UpO1xuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9zaXRpb25zRGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91TW9kZWxOb3JtYWxNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibW9kZWxOb3JtYWxNYXRyaXhcIik7XG4gICAgdGhpcy5fdVZpZXdNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwidmlld01hdHJpeFwiKTtcbiAgICB0aGlzLl91Vmlld05vcm1hbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJ2aWV3Tm9ybWFsTWF0cml4XCIpO1xuICAgIHRoaXMuX3VQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInByb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdUxpZ2h0QW1iaWVudCA9IFtdO1xuICAgIHRoaXMuX3VMaWdodENvbG9yID0gW107XG4gICAgdGhpcy5fdUxpZ2h0RGlyID0gW107XG4gICAgdGhpcy5fdUxpZ2h0UG9zID0gW107XG4gICAgdGhpcy5fdUxpZ2h0QXR0ZW51YXRpb24gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlnaHRzU3RhdGUubGlnaHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzU3RhdGUubGlnaHRzW2ldO1xuICAgICAgICBzd2l0Y2ggKGxpZ2h0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbWJpZW50XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0QW1iaWVudFtpXSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsaWdodEFtYmllbnRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0Q29sb3JbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRDb2xvclwiICsgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0UG9zW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHREaXJbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHREaXJcIiArIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0Q29sb3JbaV0gPSBwcm9ncmFtLmdldExvY2F0aW9uKFwibGlnaHRDb2xvclwiICsgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdUxpZ2h0UG9zW2ldID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImxpZ2h0UG9zXCIgKyBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91TGlnaHREaXJbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VMaWdodEF0dGVudWF0aW9uW2ldID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImxpZ2h0QXR0ZW51YXRpb25cIiArIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzLnB1c2goe1xuICAgICAgICAgICAgYWN0aXZlOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpKSxcbiAgICAgICAgICAgIHBvczogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZVBvc1wiICsgaSksXG4gICAgICAgICAgICBkaXI6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVEaXJcIiArIGkpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91RmlsbENvbG9yID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImZpbGxDb2xvclwiKTtcbiAgICB0aGlzLl9hUG9zaXRpb24gPSBwcm9ncmFtLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgIHRoaXMuX2FOb3JtYWwgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZShcIm5vcm1hbFwiKTtcbiAgICB0aGlzLl91Q2xpcHBhYmxlID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcImNsaXBwYWJsZVwiKTtcbiAgICB0aGlzLl91R2FtbWFGYWN0b3IgPSBwcm9ncmFtLmdldExvY2F0aW9uKFwiZ2FtbWFGYWN0b3JcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICkge1xuICAgICAgICB0aGlzLl91TG9nRGVwdGhCdWZGQyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsb2dEZXB0aEJ1ZkZDXCIpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZlcnRleEJ1ZnNJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xufTtcblxuRW1waGFzaXNGaWxsUmVuZGVyZXIucHJvdG90eXBlLl9iaW5kUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFtZUN0eCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgbGlnaHRzU3RhdGUgPSBzY2VuZS5fbGlnaHRzU3RhdGU7XG4gICAgY29uc3QgY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xuICAgIGNvbnN0IHByb2plY3QgPSBjYW1lcmEucHJvamVjdDtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5fcHJvZ3JhbTtcbiAgICBwcm9ncmFtLmJpbmQoKTtcbiAgICBmcmFtZUN0eC51c2VQcm9ncmFtKys7XG4gICAgZnJhbWVDdHgudGV4dHVyZVVuaXQgPSAwO1xuICAgIHRoaXMuX2xhc3RNYXRlcmlhbElkID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0VmVydGV4QnVmc0lkID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEluZGljZXNCdWZJZCA9IG51bGw7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91Vmlld05vcm1hbE1hdHJpeCwgZmFsc2UsIGNhbWVyYS5ub3JtYWxNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qZWN0Lm1hdHJpeCk7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICkge1xuICAgICAgICBjb25zdCBsb2dEZXB0aEJ1ZkZDID0gMi4wIC8gKE1hdGgubG9nKHByb2plY3QuZmFyICsgMS4wKSAvIE1hdGguTE4yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VMb2dEZXB0aEJ1ZkZDLCBsb2dEZXB0aEJ1ZkZDKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpZ2h0c1N0YXRlLmxpZ2h0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBsaWdodCA9IGxpZ2h0c1N0YXRlLmxpZ2h0c1tpXTtcbiAgICAgICAgaWYgKHRoaXMuX3VMaWdodEFtYmllbnRbaV0pIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLl91TGlnaHRBbWJpZW50W2ldLCBsaWdodC5jb2xvclswXSwgbGlnaHQuY29sb3JbMV0sIGxpZ2h0LmNvbG9yWzJdLCBsaWdodC5pbnRlbnNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VMaWdodENvbG9yW2ldKSB7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHRoaXMuX3VMaWdodENvbG9yW2ldLCBsaWdodC5jb2xvclswXSwgbGlnaHQuY29sb3JbMV0sIGxpZ2h0LmNvbG9yWzJdLCBsaWdodC5pbnRlbnNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3VMaWdodFBvc1tpXSkge1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdUxpZ2h0UG9zW2ldLCBsaWdodC5wb3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91TGlnaHRBdHRlbnVhdGlvbltpXSkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUxpZ2h0QXR0ZW51YXRpb25baV0sIGxpZ2h0LmF0dGVudWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdUxpZ2h0RGlyW2ldKSB7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLl91TGlnaHREaXJbaV0sIGxpZ2h0LmRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3VHYW1tYUZhY3Rvcikge1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5fdUdhbW1hRmFjdG9yLCBzY2VuZS5nYW1tYUZhY3Rvcik7XG4gICAgfVxufTtcblxuZXhwb3J0IHtFbXBoYXNpc0ZpbGxSZW5kZXJlcn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillShaderSource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillShaderSource.js ***!
  \****************************************************************************************************/
/*! exports provided: EmphasisFillShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmphasisFillShaderSource\", function() { return EmphasisFillShaderSource; });\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n\n\n/**\n * @private\n */\nclass EmphasisFillShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n\n    const scene = mesh.scene;\n    const lightsState = scene._lightsState;\n    const normals = hasNormals(mesh);\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const src = [];\n\n    src.push(\"// EmphasisFillShaderSource vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"uniform vec4 colorize;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"varying float vFragDepth;\");\n        }\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    src.push(\"uniform vec4   lightAmbient;\");\n    src.push(\"uniform vec4   fillColor;\");\n    if (normals) {\n        src.push(\"attribute vec3 normal;\");\n        src.push(\"uniform mat4 modelNormalMatrix;\");\n        src.push(\"uniform mat4 viewNormalMatrix;\");\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n            const light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            src.push(\"uniform vec4 lightColor\" + i + \";\");\n            if (light.type === \"dir\") {\n                src.push(\"uniform vec3 lightDir\" + i + \";\");\n            }\n            if (light.type === \"point\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n            }\n            if (light.type === \"spot\") {\n                src.push(\"uniform vec3 lightPos\" + i + \";\");\n            }\n        }\n        if (quantizedGeometry) {\n            src.push(\"vec3 octDecode(vec2 oct) {\");\n            src.push(\"    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));\");\n            src.push(\"    if (v.z < 0.0) {\");\n            src.push(\"        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);\");\n            src.push(\"    }\");\n            src.push(\"    return normalize(v);\");\n            src.push(\"}\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    src.push(\"vec4 worldPosition;\");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    if (normals) {\n        if (quantizedGeometry) {\n            src.push(\"vec4 localNormal = vec4(octDecode(normal.xy), 0.0); \");\n        } else {\n            src.push(\"vec4 localNormal = vec4(normal, 0.0); \");\n        }\n        src.push(\"mat4 modelNormalMatrix2 = modelNormalMatrix;\");\n        src.push(\"mat4 viewNormalMatrix2 = viewNormalMatrix;\");\n    }\n    src.push(\"mat4 viewMatrix2 = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2 = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n        src.push(\"billboard(modelViewMatrix);\");\n        if (normals) {\n            src.push(\"mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;\");\n            src.push(\"billboard(modelNormalMatrix2);\");\n            src.push(\"billboard(viewNormalMatrix2);\");\n            src.push(\"billboard(modelViewNormalMatrix);\");\n        }\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"vec4 viewPosition = modelViewMatrix * localPosition;\");\n    } else {\n        src.push(\"worldPosition = modelMatrix2 * localPosition;\");\n        src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n        src.push(\"vec4 viewPosition  = viewMatrix2 * worldPosition; \");\n    }\n    if (normals) {\n        src.push(\"vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);\");\n    }\n    src.push(\"vec3 reflectedColor = vec3(0.0, 0.0, 0.0);\");\n    src.push(\"vec3 viewLightDir = vec3(0.0, 0.0, -1.0);\");\n    src.push(\"float lambertian = 1.0;\");\n    if (normals) {\n        for (let i = 0, len = lightsState.lights.length; i < len; i++) {\n            const light = lightsState.lights[i];\n            if (light.type === \"ambient\") {\n                continue;\n            }\n            if (light.type === \"dir\") {\n                if (light.space === \"view\") {\n                    src.push(\"viewLightDir = normalize(lightDir\" + i + \");\");\n                } else {\n                    src.push(\"viewLightDir = normalize((viewMatrix2 * vec4(lightDir\" + i + \", 0.0)).xyz);\");\n                }\n            } else if (light.type === \"point\") {\n                if (light.space === \"view\") {\n                    src.push(\"viewLightDir = normalize(lightPos\" + i + \" - viewPosition.xyz);\");\n                } else {\n                    src.push(\"viewLightDir = normalize((viewMatrix2 * vec4(lightPos\" + i + \", 0.0)).xyz);\");\n                }\n            } else {\n                continue;\n            }\n            src.push(\"lambertian = max(dot(-viewNormal, viewLightDir), 0.0);\");\n            src.push(\"reflectedColor += lambertian * (lightColor\" + i + \".rgb * lightColor\" + i + \".a);\");\n        }\n    }\n    // TODO: A blending mode for emphasis materials, to select add/multiply/mix\n    //src.push(\"vColor = vec4((mix(reflectedColor, fillColor.rgb, 0.7)), fillColor.a);\");\n    src.push(\"vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);\");\n    //src.push(\"vColor = vec4(reflectedColor + fillColor.rgb, fillColor.a);\");\n    if (clipping) {\n        src.push(\"vWorldPosition = worldPosition;\");\n    }\n    if (mesh._geometry._state.primitiveName === \"points\") {\n        src.push(\"gl_PointSize = pointSize;\");\n    }\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n        } else {\n            src.push(\"clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;\");\n            src.push(\"clipPos.z *= clipPos.w;\");\n        }\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction hasNormals(mesh) {\n    const primitive = mesh._geometry._state.primitiveName;\n    if ((mesh._geometry._state.autoVertexNormals || mesh._geometry._state.normalsBuf) && (primitive === \"triangles\" || primitive === \"triangle-strip\" || primitive === \"triangle-fan\")) {\n        return true;\n    }\n    return false;\n}\n\nfunction buildFragment(mesh) {\n\n    const scene = mesh.scene;\n    const sectionPlanesState = mesh.scene._sectionPlanesState;\n    const gammaOutput = mesh.scene.gammaOutput;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n\n    src.push(\"// Lambertian drawing fragment shader\");\n\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n\n    if (gammaOutput) {\n        src.push(\"uniform float gammaFactor;\");\n        src.push(\"vec4 linearToGamma( in vec4 value, in float gammaFactor ) {\");\n        src.push(\"  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\");\n        src.push(\"}\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n        src.push(\"uniform bool clippable;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (let i = 0, len = sectionPlanesState.sectionPlanes.length; i < len; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n    if (mesh._geometry._state.primitiveName === \"points\") {\n        src.push(\"vec2 cxy = 2.0 * gl_PointCoord - 1.0;\");\n        src.push(\"float r = dot(cxy, cxy);\");\n        src.push(\"if (r > 1.0) {\");\n        src.push(\"   discard;\");\n        src.push(\"}\");\n    }\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n    if (gammaOutput) {\n        src.push(\"gl_FragColor = linearToGamma(vColor, gammaFactor);\");\n    } else {\n        src.push(\"gl_FragColor = vColor;\");\n    }\n    src.push(\"}\");\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvZW1waGFzaXMvRW1waGFzaXNGaWxsU2hhZGVyU291cmNlLmpzP2MzZGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyx3REFBVTtBQUN6RDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxZQUFZLHdEQUFVO0FBQ3RCLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSwwQ0FBMEM7QUFDMUMsdUNBQXVDO0FBQ3ZDO0FBQ0Esd0NBQXdDO0FBQ3hDLGlEQUFpRDtBQUNqRCxnREFBZ0Q7QUFDaEQsd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCwrRUFBK0U7QUFDL0UsMENBQTBDO0FBQzFDLGdIQUFnSDtBQUNoSCwyQkFBMkI7QUFDM0IsOENBQThDO0FBQzlDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0RBQWtEO0FBQ2xELHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQyxtQkFBbUI7QUFDbkI7QUFDQSwrQkFBK0I7QUFDL0IsdURBQXVEO0FBQ3ZELGlDQUFpQztBQUNqQztBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBLDhEQUE4RDtBQUM5RCw0REFBNEQ7QUFDNUQ7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0M7QUFDQSwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELG1EQUFtRDtBQUNuRCx1REFBdUQ7QUFDdkQ7QUFDQSwrREFBK0Q7QUFDL0Qsc0VBQXNFO0FBQ3RFLEtBQUs7QUFDTCwrREFBK0Q7QUFDL0QsaUVBQWlFO0FBQ2pFLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0Esd0RBQXdEO0FBQ3hELHVEQUF1RDtBQUN2RCxxQ0FBcUM7QUFDckM7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsaUJBQWlCO0FBQ2pCLHlHQUF5RztBQUN6RztBQUNBLGFBQWE7QUFDYjtBQUNBLDZGQUE2RjtBQUM3RixpQkFBaUI7QUFDakIseUdBQXlHO0FBQ3pHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0Rix5RUFBeUU7QUFDekUsMkVBQTJFO0FBQzNFO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxZQUFZLHdEQUFVO0FBQ3RCLG1EQUFtRDtBQUNuRCxTQUFTO0FBQ1QsNkZBQTZGO0FBQzdGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDO0FBQ0Esc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQzs7QUFFQSwrQ0FBK0Msd0RBQVU7QUFDekQsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qyw2RUFBNkU7QUFDN0Usd0ZBQXdGO0FBQ3hGLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLHlDQUF5QztBQUN6QyxzRUFBc0UsU0FBUztBQUMvRSwrREFBK0Q7QUFDL0QsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsc0VBQXNFLFNBQVM7QUFDL0Usd0RBQXdEO0FBQ3hELDJJQUEySTtBQUMzSSx1QkFBdUI7QUFDdkI7QUFDQSxxQ0FBcUMsU0FBUyxFQUFFO0FBQ2hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELDBDQUEwQztBQUMxQyxnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCLG1CQUFtQjtBQUNuQjtBQUNBLCtDQUErQyx3REFBVTtBQUN6RCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDO0FBQ0EsZUFBZTtBQUNmO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWVzaC9lbXBoYXNpcy9FbXBoYXNpc0ZpbGxTaGFkZXJTb3VyY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1dFQkdMX0lORk99IGZyb20gXCIuLi8uLi93ZWJnbEluZm8uanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFbXBoYXNpc0ZpbGxTaGFkZXJTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lc2gpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSBidWlsZFZlcnRleChtZXNoKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQobWVzaCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFZlcnRleChtZXNoKSB7XG5cbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgbGlnaHRzU3RhdGUgPSBzY2VuZS5fbGlnaHRzU3RhdGU7XG4gICAgY29uc3Qgbm9ybWFscyA9IGhhc05vcm1hbHMobWVzaCk7XG4gICAgY29uc3QgY2xpcHBpbmcgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBxdWFudGl6ZWRHZW9tZXRyeSA9ICEhbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmNvbXByZXNzR2VvbWV0cnk7XG4gICAgY29uc3QgYmlsbGJvYXJkID0gbWVzaC5fc3RhdGUuYmlsbGJvYXJkO1xuICAgIGNvbnN0IHN0YXRpb25hcnkgPSBtZXNoLl9zdGF0ZS5zdGF0aW9uYXJ5O1xuICAgIGNvbnN0IHNyYyA9IFtdO1xuXG4gICAgc3JjLnB1c2goXCIvLyBFbXBoYXNpc0ZpbGxTaGFkZXJTb3VyY2UgdmVydGV4IHNoYWRlclwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0IGNvbG9yaXplO1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBvZmZzZXQ7XCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBwb3NpdGlvbnNEZWNvZGVNYXRyaXg7XCIpO1xuICAgIH1cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBpZiAoV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzQgICBsaWdodEFtYmllbnQ7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0ICAgZmlsbENvbG9yO1wiKTtcbiAgICBpZiAobm9ybWFscykge1xuICAgICAgICBzcmMucHVzaChcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG1vZGVsTm9ybWFsTWF0cml4O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgdmlld05vcm1hbE1hdHJpeDtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaWdodHNTdGF0ZS5saWdodHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzU3RhdGUubGlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiYW1iaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjNCBsaWdodENvbG9yXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgaWYgKGxpZ2h0LnR5cGUgPT09IFwiZGlyXCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodERpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBsaWdodFBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcInNwb3RcIikge1xuICAgICAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIGxpZ2h0UG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIG9jdERlY29kZSh2ZWMyIG9jdCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHZlYzMgdiA9IHZlYzMob2N0Lnh5LCAxLjAgLSBhYnMob2N0LngpIC0gYWJzKG9jdC55KSk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgaWYgKHYueiA8IDAuMCkge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgICAgICB2Lnh5ID0gKDEuMCAtIGFicyh2Lnl4KSkgKiB2ZWMyKHYueCA+PSAwLjAgPyAxLjAgOiAtMS4wLCB2LnkgPj0gMC4wID8gMS4wIDogLTEuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICAgfVwiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgIHJldHVybiBub3JtYWxpemUodik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZDb2xvcjtcIik7XG4gICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIiB8fCBiaWxsYm9hcmQgPT09IFwiY3lsaW5kcmljYWxcIikge1xuICAgICAgICBzcmMucHVzaChcInZvaWQgYmlsbGJvYXJkKGlub3V0IG1hdDQgbWF0KSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVswXSA9IDEuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzFdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMl0gPSAwLjA7XCIpO1xuICAgICAgICBpZiAoYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVswXSA9IDAuMDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVsxXSA9IDEuMDtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsxXVsyXSA9IDAuMDtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMF0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVsxXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzJdID0xLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGxvY2FsUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApOyBcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IHdvcmxkUG9zaXRpb247XCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcImxvY2FsUG9zaXRpb24gPSBwb3NpdGlvbnNEZWNvZGVNYXRyaXggKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZlYzQgbG9jYWxOb3JtYWwgPSB2ZWM0KG9jdERlY29kZShub3JtYWwueHkpLCAwLjApOyBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZlYzQgbG9jYWxOb3JtYWwgPSB2ZWM0KG5vcm1hbCwgMC4wKTsgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbE5vcm1hbE1hdHJpeDIgPSBtb2RlbE5vcm1hbE1hdHJpeDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwibWF0NCB2aWV3Tm9ybWFsTWF0cml4MiA9IHZpZXdOb3JtYWxNYXRyaXg7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIm1hdDQgdmlld01hdHJpeDIgPSB2aWV3TWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcIm1hdDQgbW9kZWxNYXRyaXgyID0gbW9kZWxNYXRyaXg7XCIpO1xuICAgIGlmIChzdGF0aW9uYXJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmlld01hdHJpeDJbM11bMF0gPSB2aWV3TWF0cml4MlszXVsxXSA9IHZpZXdNYXRyaXgyWzNdWzJdID0gMC4wO1wiKVxuICAgIH1cbiAgICBpZiAoYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiIHx8IGJpbGxib2FyZCA9PT0gXCJjeWxpbmRyaWNhbFwiKSB7XG4gICAgICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbFZpZXdNYXRyaXggPSB2aWV3TWF0cml4MiAqIG1vZGVsTWF0cml4MjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKG1vZGVsTWF0cml4Mik7XCIpO1xuICAgICAgICBzcmMucHVzaChcImJpbGxib2FyZCh2aWV3TWF0cml4Mik7XCIpO1xuICAgICAgICBzcmMucHVzaChcImJpbGxib2FyZChtb2RlbFZpZXdNYXRyaXgpO1wiKTtcbiAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbFZpZXdOb3JtYWxNYXRyaXggPSAgdmlld05vcm1hbE1hdHJpeDIgKiBtb2RlbE5vcm1hbE1hdHJpeDI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxOb3JtYWxNYXRyaXgyKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcImJpbGxib2FyZCh2aWV3Tm9ybWFsTWF0cml4Mik7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxWaWV3Tm9ybWFsTWF0cml4KTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXgyICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmVjNCB2aWV3UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcmMucHVzaChcIndvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeDIgKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uLnh5eiA9IHdvcmxkUG9zaXRpb24ueHl6ICsgb2Zmc2V0O1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWM0IHZpZXdQb3NpdGlvbiAgPSB2aWV3TWF0cml4MiAqIHdvcmxkUG9zaXRpb247IFwiKTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMzIHZpZXdOb3JtYWwgPSBub3JtYWxpemUoKHZpZXdOb3JtYWxNYXRyaXgyICogbW9kZWxOb3JtYWxNYXRyaXgyICogbG9jYWxOb3JtYWwpLnh5eik7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZlYzMgcmVmbGVjdGVkQ29sb3IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1wiKTtcbiAgICBzcmMucHVzaChcInZlYzMgdmlld0xpZ2h0RGlyID0gdmVjMygwLjAsIDAuMCwgLTEuMCk7XCIpO1xuICAgIHNyYy5wdXNoKFwiZmxvYXQgbGFtYmVydGlhbiA9IDEuMDtcIik7XG4gICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpZ2h0c1N0YXRlLmxpZ2h0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGlnaHQgPSBsaWdodHNTdGF0ZS5saWdodHNbaV07XG4gICAgICAgICAgICBpZiAobGlnaHQudHlwZSA9PT0gXCJhbWJpZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaWdodC50eXBlID09PSBcImRpclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ2h0LnNwYWNlID09PSBcInZpZXdcIikge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZShsaWdodERpclwiICsgaSArIFwiKTtcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2aWV3TGlnaHREaXIgPSBub3JtYWxpemUoKHZpZXdNYXRyaXgyICogdmVjNChsaWdodERpclwiICsgaSArIFwiLCAwLjApKS54eXopO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpZ2h0LnR5cGUgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgICAgIGlmIChsaWdodC5zcGFjZSA9PT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnB1c2goXCJ2aWV3TGlnaHREaXIgPSBub3JtYWxpemUobGlnaHRQb3NcIiArIGkgKyBcIiAtIHZpZXdQb3NpdGlvbi54eXopO1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcmMucHVzaChcInZpZXdMaWdodERpciA9IG5vcm1hbGl6ZSgodmlld01hdHJpeDIgKiB2ZWM0KGxpZ2h0UG9zXCIgKyBpICsgXCIsIDAuMCkpLnh5eik7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMucHVzaChcImxhbWJlcnRpYW4gPSBtYXgoZG90KC12aWV3Tm9ybWFsLCB2aWV3TGlnaHREaXIpLCAwLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwicmVmbGVjdGVkQ29sb3IgKz0gbGFtYmVydGlhbiAqIChsaWdodENvbG9yXCIgKyBpICsgXCIucmdiICogbGlnaHRDb2xvclwiICsgaSArIFwiLmEpO1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBBIGJsZW5kaW5nIG1vZGUgZm9yIGVtcGhhc2lzIG1hdGVyaWFscywgdG8gc2VsZWN0IGFkZC9tdWx0aXBseS9taXhcbiAgICAvL3NyYy5wdXNoKFwidkNvbG9yID0gdmVjNCgobWl4KHJlZmxlY3RlZENvbG9yLCBmaWxsQ29sb3IucmdiLCAwLjcpKSwgZmlsbENvbG9yLmEpO1wiKTtcbiAgICBzcmMucHVzaChcInZDb2xvciA9IHZlYzQocmVmbGVjdGVkQ29sb3IgKiBmaWxsQ29sb3IucmdiLCBmaWxsQ29sb3IuYSk7XCIpO1xuICAgIC8vc3JjLnB1c2goXCJ2Q29sb3IgPSB2ZWM0KHJlZmxlY3RlZENvbG9yICsgZmlsbENvbG9yLnJnYiwgZmlsbENvbG9yLmEpO1wiKTtcbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBpZiAobWVzaC5fZ2VvbWV0cnkuX3N0YXRlLnByaW1pdGl2ZU5hbWUgPT09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9Qb2ludFNpemUgPSBwb2ludFNpemU7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZlYzQgY2xpcFBvcyA9IHByb2pNYXRyaXggKiB2aWV3UG9zaXRpb247XCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBpZiAoV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZGcmFnRGVwdGggPSAxLjAgKyBjbGlwUG9zLnc7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJjbGlwUG9zLnogPSBsb2cyKCBtYXgoIDFlLTYsIGNsaXBQb3MudyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY2xpcFBvcy56ICo9IGNsaXBQb3MudztcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjLnB1c2goXCJnbF9Qb3NpdGlvbiA9IGNsaXBQb3M7XCIpO1xuICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBoYXNOb3JtYWxzKG1lc2gpIHtcbiAgICBjb25zdCBwcmltaXRpdmUgPSBtZXNoLl9nZW9tZXRyeS5fc3RhdGUucHJpbWl0aXZlTmFtZTtcbiAgICBpZiAoKG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5hdXRvVmVydGV4Tm9ybWFscyB8fCBtZXNoLl9nZW9tZXRyeS5fc3RhdGUubm9ybWFsc0J1ZikgJiYgKHByaW1pdGl2ZSA9PT0gXCJ0cmlhbmdsZXNcIiB8fCBwcmltaXRpdmUgPT09IFwidHJpYW5nbGUtc3RyaXBcIiB8fCBwcmltaXRpdmUgPT09IFwidHJpYW5nbGUtZmFuXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQobWVzaCkge1xuXG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IHNlY3Rpb25QbGFuZXNTdGF0ZSA9IG1lc2guc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICBjb25zdCBnYW1tYU91dHB1dCA9IG1lc2guc2NlbmUuZ2FtbWFPdXRwdXQ7XG4gICAgY29uc3QgY2xpcHBpbmcgPSBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNyYyA9IFtdO1xuXG4gICAgc3JjLnB1c2goXCIvLyBMYW1iZXJ0aWFuIGRyYXdpbmcgZnJhZ21lbnQgc2hhZGVyXCIpO1xuXG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcIiNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcIik7XG4gICAgfVxuXG4gICAgc3JjLnB1c2goXCIjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIGhpZ2hwIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZWxzZVwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZW5kaWZcIik7XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgIH1cblxuICAgIGlmIChnYW1tYU91dHB1dCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgZ2FtbWFGYWN0b3I7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZlYzQgbGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgcmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgY2xpcHBhYmxlO1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gYm9vbCBzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBzZWN0aW9uUGxhbmVQb3NcIiArIGkgKyBcIjtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBzZWN0aW9uUGxhbmVEaXJcIiArIGkgKyBcIjtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzQgdkNvbG9yO1wiKTtcbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcImlmIChjbGlwcGFibGUpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICBmbG9hdCBkaXN0ID0gMC4wO1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImlmIChzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkgKyBcIikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZGlzdCArPSBjbGFtcChkb3QoLXNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiLnh5eiwgdldvcmxkUG9zaXRpb24ueHl6IC0gc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCIueHl6KSwgMC4wLCAxMDAwLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgaWYgKGRpc3QgPiAwLjApIHsgZGlzY2FyZDsgfVwiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBpZiAobWVzaC5fZ2VvbWV0cnkuX3N0YXRlLnByaW1pdGl2ZU5hbWUgPT09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcImZsb2F0IHIgPSBkb3QoY3h5LCBjeHkpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJpZiAociA+IDEuMCkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBkaXNjYXJkO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcIik7XG4gICAgfVxuICAgIGlmIChnYW1tYU91dHB1dCkge1xuICAgICAgICBzcmMucHVzaChcImdsX0ZyYWdDb2xvciA9IGxpbmVhclRvR2FtbWEodkNvbG9yLCBnYW1tYUZhY3Rvcik7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmV4cG9ydCB7RW1waGFzaXNGaWxsU2hhZGVyU291cmNlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/emphasis/EmphasisFillShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionRenderer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionRenderer.js ***!
  \**********************************************************************************************/
/*! exports provided: OcclusionRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OcclusionRenderer\", function() { return OcclusionRenderer; });\n/* harmony import */ var _OcclusionShaderSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OcclusionShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].vec3();\n\n// No ID, because there is exactly one PickMeshRenderer per scene\n\n/**\n * @private\n */\nconst OcclusionRenderer = function (hash, mesh) {\n    this._hash = hash;\n    this._shaderSource = new _OcclusionShaderSource_js__WEBPACK_IMPORTED_MODULE_0__[\"OcclusionShaderSource\"](mesh);\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._allocate(mesh);\n};\n\nconst renderers = {};\n\nOcclusionRenderer.get = function (mesh) {\n    const hash = [\n        mesh.scene.canvas.canvas.id,\n        mesh.scene._sectionPlanesState.getHash(),\n        mesh._geometry._state.hash,\n        mesh._state.hash\n    ].join(\";\");\n    let renderer = renderers[hash];\n    if (!renderer) {\n        renderer = new OcclusionRenderer(hash, mesh);\n        if (renderer.errors) {\n            console.log(renderer.errors.join(\"\\n\"));\n            return null;\n        }\n        renderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nOcclusionRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete renderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs--;\n    }\n};\n\nOcclusionRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nOcclusionRenderer.prototype.drawMesh = function (frameCtx, mesh) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const materialState = mesh._material._state;\n    const meshState = mesh._state;\n    const geometryState = mesh._geometry._state;\n    const rtcCenter = mesh.rtcCenter;\n\n    if (frameCtx.lastProgramId !== this._program.id) {\n        frameCtx.lastProgramId = this._program.id;\n        this._bindProgram(frameCtx);\n    }\n\n    if (materialState.id !== this._lastMaterialId) {\n        const backfaces = materialState.backfaces;\n        if (frameCtx.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frameCtx.backfaces = backfaces;\n        }\n        const frontface = materialState.frontface;\n        if (frameCtx.frontface !== frontface) {\n            if (frontface) {\n                gl.frontFace(gl.CCW);\n            } else {\n                gl.frontFace(gl.CW);\n            }\n            frameCtx.frontface = frontface;\n        }\n        this._lastMaterialId = materialState.id;\n    }\n\n    const camera = scene.camera;\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCViewMatrix(meshState.rtcCenterHash, rtcCenter) : camera.viewMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_4__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    gl.uniformMatrix4fv(this._uProjMatrix, false, camera._project._state.matrix);\n    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);\n\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, mesh._state.clippable);\n    }\n\n    gl.uniform3fv(this._uOffset, mesh._state.offset);\n\n    if (geometryState.id !== this._lastGeometryId) {\n        if (this._uPositionsDecodeMatrix) {\n            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        }\n        if (this._aPosition) {\n            this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n            frameCtx.bindArray++;\n        }\n        if (geometryState.indicesBuf) {\n            geometryState.indicesBuf.bind();\n            frameCtx.bindArray++;\n        }\n        this._lastGeometryId = geometryState.id;\n    }\n    if (geometryState.indicesBuf) {\n        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n        frameCtx.drawElements++;\n    } else if (geometryState.positions) {\n        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);\n    }\n};\n\nOcclusionRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__[\"Program\"](gl, this._shaderSource);\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uSectionPlanes = [];\n    const clips = scene._sectionPlanesState.sectionPlanes;\n    for (let i = 0, len = clips.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._aPosition = program.getAttribute(\"position\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uOffset = program.getLocation(\"offset\");\n    if (scene.logarithmicDepthBufferEnabled ) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n};\n\nOcclusionRenderer.prototype._bindProgram = function (frameCtx) {\n    const scene = this._scene;\n    const project = scene.camera.project;\n    const gl = scene.canvas.gl;\n    this._program.bind();\n    frameCtx.useProgram++;\n    gl.uniformMatrix4fv(this._uProjMatrix, false, project.matrix);\n    if (scene.logarithmicDepthBufferEnabled ) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvb2NjbHVzaW9uL09jY2x1c2lvblJlbmRlcmVyLmpzP2QzMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ2xCO0FBQ1Y7QUFDRztBQUNlOztBQUV2RCxrQkFBa0Isa0RBQUk7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0VBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUs7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx5RUFBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvb2NjbHVzaW9uL09jY2x1c2lvblJlbmRlcmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yIHhlb2xhYnMgLyBodHRwczovL2dpdGh1Yi5jb20veGVvbGFic1xuICovXG5cbmltcG9ydCB7T2NjbHVzaW9uU2hhZGVyU291cmNlfSBmcm9tIFwiLi9PY2NsdXNpb25TaGFkZXJTb3VyY2UuanNcIjtcbmltcG9ydCB7UHJvZ3JhbX0gZnJvbSBcIi4uLy4uL3dlYmdsL1Byb2dyYW0uanNcIjtcbmltcG9ydCB7c3RhdHN9IGZyb20gXCIuLi8uLi9zdGF0cy5qc1wiO1xuaW1wb3J0IHttYXRofSBmcm9tIFwiLi4vLi4vbWF0aC9tYXRoLmpzXCI7XG5pbXBvcnQge2dldFBsYW5lUlRDUG9zfSBmcm9tIFwiLi4vLi4vbWF0aC9ydGNDb29yZHMuanNcIjtcblxuY29uc3QgdGVtcFZlYzNhID0gbWF0aC52ZWMzKCk7XG5cbi8vIE5vIElELCBiZWNhdXNlIHRoZXJlIGlzIGV4YWN0bHkgb25lIFBpY2tNZXNoUmVuZGVyZXIgcGVyIHNjZW5lXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgT2NjbHVzaW9uUmVuZGVyZXIgPSBmdW5jdGlvbiAoaGFzaCwgbWVzaCkge1xuICAgIHRoaXMuX2hhc2ggPSBoYXNoO1xuICAgIHRoaXMuX3NoYWRlclNvdXJjZSA9IG5ldyBPY2NsdXNpb25TaGFkZXJTb3VyY2UobWVzaCk7XG4gICAgdGhpcy5fc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIHRoaXMuX3VzZUNvdW50ID0gMDtcbiAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbn07XG5cbmNvbnN0IHJlbmRlcmVycyA9IHt9O1xuXG5PY2NsdXNpb25SZW5kZXJlci5nZXQgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgIGNvbnN0IGhhc2ggPSBbXG4gICAgICAgIG1lc2guc2NlbmUuY2FudmFzLmNhbnZhcy5pZCxcbiAgICAgICAgbWVzaC5zY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLmdldEhhc2goKSxcbiAgICAgICAgbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmhhc2gsXG4gICAgICAgIG1lc2guX3N0YXRlLmhhc2hcbiAgICBdLmpvaW4oXCI7XCIpO1xuICAgIGxldCByZW5kZXJlciA9IHJlbmRlcmVyc1toYXNoXTtcbiAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IE9jY2x1c2lvblJlbmRlcmVyKGhhc2gsIG1lc2gpO1xuICAgICAgICBpZiAocmVuZGVyZXIuZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZW5kZXJlci5lcnJvcnMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlcnNbaGFzaF0gPSByZW5kZXJlcjtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zKys7XG4gICAgfVxuICAgIHJlbmRlcmVyLl91c2VDb3VudCsrO1xuICAgIHJldHVybiByZW5kZXJlcjtcbn07XG5cbk9jY2x1c2lvblJlbmRlcmVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5fdXNlQ291bnQgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZW5kZXJlcnNbdGhpcy5faGFzaF07XG4gICAgICAgIHN0YXRzLm1lbW9yeS5wcm9ncmFtcy0tO1xuICAgIH1cbn07XG5cbk9jY2x1c2lvblJlbmRlcmVyLnByb3RvdHlwZS53ZWJnbENvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbn07XG5cbk9jY2x1c2lvblJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TWVzaCA9IGZ1bmN0aW9uIChmcmFtZUN0eCwgbWVzaCkge1xuXG4gICAgaWYgKCF0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgIHRoaXMuX2FsbG9jYXRlKG1lc2gpO1xuICAgIH1cblxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgbWF0ZXJpYWxTdGF0ZSA9IG1lc2guX21hdGVyaWFsLl9zdGF0ZTtcbiAgICBjb25zdCBtZXNoU3RhdGUgPSBtZXNoLl9zdGF0ZTtcbiAgICBjb25zdCBnZW9tZXRyeVN0YXRlID0gbWVzaC5fZ2VvbWV0cnkuX3N0YXRlO1xuICAgIGNvbnN0IHJ0Y0NlbnRlciA9IG1lc2gucnRjQ2VudGVyO1xuXG4gICAgaWYgKGZyYW1lQ3R4Lmxhc3RQcm9ncmFtSWQgIT09IHRoaXMuX3Byb2dyYW0uaWQpIHtcbiAgICAgICAgZnJhbWVDdHgubGFzdFByb2dyYW1JZCA9IHRoaXMuX3Byb2dyYW0uaWQ7XG4gICAgICAgIHRoaXMuX2JpbmRQcm9ncmFtKGZyYW1lQ3R4KTtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWxTdGF0ZS5pZCAhPT0gdGhpcy5fbGFzdE1hdGVyaWFsSWQpIHtcbiAgICAgICAgY29uc3QgYmFja2ZhY2VzID0gbWF0ZXJpYWxTdGF0ZS5iYWNrZmFjZXM7XG4gICAgICAgIGlmIChmcmFtZUN0eC5iYWNrZmFjZXMgIT09IGJhY2tmYWNlcykge1xuICAgICAgICAgICAgaWYgKGJhY2tmYWNlcykge1xuICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUN0eC5iYWNrZmFjZXMgPSBiYWNrZmFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbnRmYWNlID0gbWF0ZXJpYWxTdGF0ZS5mcm9udGZhY2U7XG4gICAgICAgIGlmIChmcmFtZUN0eC5mcm9udGZhY2UgIT09IGZyb250ZmFjZSkge1xuICAgICAgICAgICAgaWYgKGZyb250ZmFjZSkge1xuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZShnbC5DQ1cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ1cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVDdHguZnJvbnRmYWNlID0gZnJvbnRmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RNYXRlcmlhbElkID0gbWF0ZXJpYWxTdGF0ZS5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBjYW1lcmEgPSBzY2VuZS5jYW1lcmE7XG5cbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VWaWV3TWF0cml4LCBmYWxzZSwgcnRjQ2VudGVyID8gZnJhbWVDdHguZ2V0UlRDVmlld01hdHJpeChtZXNoU3RhdGUucnRjQ2VudGVySGFzaCwgcnRjQ2VudGVyKSA6IGNhbWVyYS52aWV3TWF0cml4KTtcblxuICAgIGlmIChtZXNoU3RhdGUuY2xpcHBhYmxlKSB7XG4gICAgICAgIGNvbnN0IG51bVNlY3Rpb25QbGFuZXMgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VjdGlvblBsYW5lcyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25QbGFuZXMgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXM7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJGbGFncyA9IG1lc2gucmVuZGVyRmxhZ3M7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWN0aW9uUGxhbmVJbmRleCA9IDA7IHNlY3Rpb25QbGFuZUluZGV4IDwgbnVtU2VjdGlvblBsYW5lczsgc2VjdGlvblBsYW5lSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25QbGFuZVVuaWZvcm1zID0gdGhpcy5fdVNlY3Rpb25QbGFuZXNbc2VjdGlvblBsYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHJlbmRlckZsYWdzLnNlY3Rpb25QbGFuZXNBY3RpdmVQZXJMYXllcltzZWN0aW9uUGxhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHNlY3Rpb25QbGFuZVVuaWZvcm1zLmFjdGl2ZSwgYWN0aXZlID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lID0gc2VjdGlvblBsYW5lc1tzZWN0aW9uUGxhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2VjdGlvblBsYW5lVW5pZm9ybXMucG9zLCBydGNDZW50ZXIgPyBnZXRQbGFuZVJUQ1BvcyhzZWN0aW9uUGxhbmUuZGlzdCwgc2VjdGlvblBsYW5lLmRpciwgcnRjQ2VudGVyLCB0ZW1wVmVjM2EpIDogc2VjdGlvblBsYW5lLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2VjdGlvblBsYW5lVW5pZm9ybXMuZGlyLCBzZWN0aW9uUGxhbmUuZGlyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VQcm9qTWF0cml4LCBmYWxzZSwgY2FtZXJhLl9wcm9qZWN0Ll9zdGF0ZS5tYXRyaXgpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTWF0cml4LCBnbC5GQUxTRSwgbWVzaC53b3JsZE1hdHJpeCk7XG5cbiAgICBpZiAodGhpcy5fdUNsaXBwYWJsZSkge1xuICAgICAgICBnbC51bmlmb3JtMWkodGhpcy5fdUNsaXBwYWJsZSwgbWVzaC5fc3RhdGUuY2xpcHBhYmxlKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtM2Z2KHRoaXMuX3VPZmZzZXQsIG1lc2guX3N0YXRlLm9mZnNldCk7XG5cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pZCAhPT0gdGhpcy5fbGFzdEdlb21ldHJ5SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCwgZmFsc2UsIGdlb21ldHJ5U3RhdGUucG9zaXRpb25zRGVjb2RlTWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hUG9zaXRpb24uYmluZEFycmF5QnVmZmVyKGdlb21ldHJ5U3RhdGUucG9zaXRpb25zQnVmLCBnZW9tZXRyeVN0YXRlLmNvbXByZXNzR2VvbWV0cnkgPyBnbC5VTlNJR05FRF9TSE9SVCA6IGdsLkZMT0FUKTtcbiAgICAgICAgICAgIGZyYW1lQ3R4LmJpbmRBcnJheSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zi5iaW5kKCk7XG4gICAgICAgICAgICBmcmFtZUN0eC5iaW5kQXJyYXkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IGdlb21ldHJ5U3RhdGUuaWQ7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYpIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlLCBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYubnVtSXRlbXMsIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1Zi5pdGVtVHlwZSwgMCk7XG4gICAgICAgIGZyYW1lQ3R4LmRyYXdFbGVtZW50cysrO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnMpIHtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGdlb21ldHJ5U3RhdGUucG9zaXRpb25zLm51bUl0ZW1zKTtcbiAgICB9XG59O1xuXG5PY2NsdXNpb25SZW5kZXJlci5wcm90b3R5cGUuX2FsbG9jYXRlID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB0aGlzLl9zaGFkZXJTb3VyY2UpO1xuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9zaXRpb25zRGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91Vmlld01hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJ2aWV3TWF0cml4XCIpO1xuICAgIHRoaXMuX3VQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInByb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMgPSBbXTtcbiAgICBjb25zdCBjbGlwcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2xpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMucHVzaCh7XG4gICAgICAgICAgICBhY3RpdmU6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkpLFxuICAgICAgICAgICAgcG9zOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lUG9zXCIgKyBpKSxcbiAgICAgICAgICAgIGRpcjogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZURpclwiICsgaSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2FQb3NpdGlvbiA9IHByb2dyYW0uZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgdGhpcy5fdUNsaXBwYWJsZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJjbGlwcGFibGVcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICkge1xuICAgICAgICB0aGlzLl91TG9nRGVwdGhCdWZGQyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsb2dEZXB0aEJ1ZkZDXCIpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZlcnRleEJ1ZnNJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xufTtcblxuT2NjbHVzaW9uUmVuZGVyZXIucHJvdG90eXBlLl9iaW5kUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFtZUN0eCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgcHJvamVjdCA9IHNjZW5lLmNhbWVyYS5wcm9qZWN0O1xuICAgIGNvbnN0IGdsID0gc2NlbmUuY2FudmFzLmdsO1xuICAgIHRoaXMuX3Byb2dyYW0uYmluZCgpO1xuICAgIGZyYW1lQ3R4LnVzZVByb2dyYW0rKztcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VQcm9qTWF0cml4LCBmYWxzZSwgcHJvamVjdC5tYXRyaXgpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCApIHtcbiAgICAgICAgY29uc3QgbG9nRGVwdGhCdWZGQyA9IDIuMCAvIChNYXRoLmxvZyhwcm9qZWN0LmZhciArIDEuMCkgLyBNYXRoLkxOMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91TG9nRGVwdGhCdWZGQywgbG9nRGVwdGhCdWZGQyk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RNYXRlcmlhbElkID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0VmVydGV4QnVmc0lkID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IG51bGw7XG59O1xuXG5leHBvcnQge09jY2x1c2lvblJlbmRlcmVyfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionShaderSource.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionShaderSource.js ***!
  \**************************************************************************************************/
/*! exports provided: OcclusionShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OcclusionShaderSource\", function() { return OcclusionShaderSource; });\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n/**\n * @private\n */\nclass OcclusionShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n    const scene = mesh.scene;\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const src = [];\n    src.push(\"// Mesh occlusion vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"varying float vFragDepth;\");\n        }\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    src.push(\"mat4 viewMatrix2 = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2 = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n    }\n    src.push(\"   vec4 worldPosition = modelMatrix2 * localPosition;\");\n    src.push(\"   worldPosition.xyz = worldPosition.xyz + offset;\");\n    src.push(\"   vec4 viewPosition = viewMatrix2 * worldPosition;\");\n    if (clipping) {\n        src.push(\"   vWorldPosition = worldPosition;\");\n    }\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n        } else {\n            src.push(\"clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;\");\n            src.push(\"clipPos.z *= clipPos.w;\");\n        }\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragment(mesh) {\n\n    const scene = mesh.scene;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n\n    src.push(\"// Mesh occlusion fragment shader\");\n\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n\n    if (clipping) {\n        src.push(\"uniform bool clippable;\");\n        src.push(\"varying vec4 vWorldPosition;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n\n    src.push(\"void main(void) {\");\n\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n\n    src.push(\"   gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0); \");\n\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n\n    src.push(\"}\");\n\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvb2NjbHVzaW9uL09jY2x1c2lvblNoYWRlclNvdXJjZS5qcz9lYjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxZQUFZLHdEQUFVO0FBQ3RCLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDLG1CQUFtQjtBQUNuQjtBQUNBLCtCQUErQjtBQUMvQix1REFBdUQ7QUFDdkQ7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLHlDQUF5QztBQUN6QztBQUNBLG1FQUFtRTtBQUNuRSxnRUFBZ0U7QUFDaEUsaUVBQWlFO0FBQ2pFO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsWUFBWSx3REFBVTtBQUN0QixtREFBbUQ7QUFDbkQsU0FBUztBQUNULDZGQUE2RjtBQUM3Riw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0Msd0RBQVU7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDOztBQUVBLCtDQUErQyx3REFBVTtBQUN6RCw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUM5Qyx1QkFBdUIsNkNBQTZDO0FBQ3BFLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsdUJBQXVCLDZDQUE2QztBQUNwRSx3REFBd0Q7QUFDeEQsMklBQTJJO0FBQzNJLHVCQUF1QjtBQUN2QjtBQUNBLHFDQUFxQyxTQUFTLEVBQUU7QUFDaEQsbUJBQW1CO0FBQ25COztBQUVBLHlEQUF5RDs7QUFFekQsK0NBQStDLHdEQUFVO0FBQ3pELDZFQUE2RTtBQUM3RTs7QUFFQSxlQUFlOztBQUVmO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWVzaC9vY2NsdXNpb24vT2NjbHVzaW9uU2hhZGVyU291cmNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yIHhlb2xhYnMgLyBodHRwczovL2dpdGh1Yi5jb20veGVvbGFic1xuICovXG5cbmltcG9ydCB7V0VCR0xfSU5GT30gZnJvbSBcIi4uLy4uL3dlYmdsSW5mby5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE9jY2x1c2lvblNoYWRlclNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IobWVzaCkge1xuICAgICAgICB0aGlzLnZlcnRleCA9IGJ1aWxkVmVydGV4KG1lc2gpO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gYnVpbGRGcmFnbWVudChtZXNoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmVydGV4KG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgY2xpcHBpbmcgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBxdWFudGl6ZWRHZW9tZXRyeSA9ICEhbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmNvbXByZXNzR2VvbWV0cnk7XG4gICAgY29uc3QgYmlsbGJvYXJkID0gbWVzaC5fc3RhdGUuYmlsbGJvYXJkO1xuICAgIGNvbnN0IHN0YXRpb25hcnkgPSBtZXNoLl9zdGF0ZS5zdGF0aW9uYXJ5O1xuICAgIGNvbnN0IHNyYyA9IFtdO1xuICAgIHNyYy5wdXNoKFwiLy8gTWVzaCBvY2NsdXNpb24gdmVydGV4IHNoYWRlclwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIG9mZnNldDtcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHBvc2l0aW9uc0RlY29kZU1hdHJpeDtcIik7XG4gICAgfVxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcIik7XG4gICAgICAgIGlmIChXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmlsbGJvYXJkID09PSBcInNwaGVyaWNhbFwiIHx8IGJpbGxib2FyZCA9PT0gXCJjeWxpbmRyaWNhbFwiKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidm9pZCBiaWxsYm9hcmQoaW5vdXQgbWF0NCBtYXQpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzBdID0gMS4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMV0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVsyXSA9IDAuMDtcIik7XG4gICAgICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIpIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzBdID0gMC4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzFdID0gMS4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzFdWzJdID0gMC4wO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVswXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzFdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMl0gPTEuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJ2b2lkIG1haW4odm9pZCkge1wiKTtcbiAgICBzcmMucHVzaChcInZlYzQgbG9jYWxQb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7IFwiKTtcbiAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJsb2NhbFBvc2l0aW9uID0gcG9zaXRpb25zRGVjb2RlTWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwibWF0NCB2aWV3TWF0cml4MiA9IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwibWF0NCBtb2RlbE1hdHJpeDIgPSBtb2RlbE1hdHJpeDtcIik7XG4gICAgaWYgKHN0YXRpb25hcnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2aWV3TWF0cml4MlszXVswXSA9IHZpZXdNYXRyaXgyWzNdWzFdID0gdmlld01hdHJpeDJbM11bMl0gPSAwLjA7XCIpXG4gICAgfVxuICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIgfHwgYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsVmlld01hdHJpeCA9IHZpZXdNYXRyaXgyICogbW9kZWxNYXRyaXgyO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQobW9kZWxNYXRyaXgyKTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiYmlsbGJvYXJkKHZpZXdNYXRyaXgyKTtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwiICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXgyICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCIgICB3b3JsZFBvc2l0aW9uLnh5eiA9IHdvcmxkUG9zaXRpb24ueHl6ICsgb2Zmc2V0O1wiKTtcbiAgICBzcmMucHVzaChcIiAgIHZlYzQgdmlld1Bvc2l0aW9uID0gdmlld01hdHJpeDIgKiB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZlYzQgY2xpcFBvcyA9IHByb2pNYXRyaXggKiB2aWV3UG9zaXRpb247XCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBpZiAoV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZGcmFnRGVwdGggPSAxLjAgKyBjbGlwUG9zLnc7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJjbGlwUG9zLnogPSBsb2cyKCBtYXgoIDFlLTYsIGNsaXBQb3MudyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY2xpcFBvcy56ICo9IGNsaXBQb3MudztcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjLnB1c2goXCJnbF9Qb3NpdGlvbiA9IGNsaXBQb3M7XCIpO1xuICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KG1lc2gpIHtcblxuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzU3RhdGUgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlO1xuICAgIGNvbnN0IGNsaXBwaW5nID0gc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBzcmMgPSBbXTtcblxuICAgIHNyYy5wdXNoKFwiLy8gTWVzaCBvY2NsdXNpb24gZnJhZ21lbnQgc2hhZGVyXCIpO1xuXG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcIiNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcIik7XG4gICAgfVxuXG4gICAgc3JjLnB1c2goXCIjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIGhpZ2hwIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZWxzZVwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBtZWRpdW1wIGludDtcIik7XG4gICAgc3JjLnB1c2goXCIjZW5kaWZcIik7XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgIH1cblxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gYm9vbCBjbGlwcGFibGU7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIHNlY3Rpb25QbGFuZUFjdGl2ZVwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZVBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG5cbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJpZiAoY2xpcHBhYmxlKSB7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgZmxvYXQgZGlzdCA9IDAuMDtcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiaWYgKHNlY3Rpb25QbGFuZUFjdGl2ZVwiICsgaSArIFwiKSB7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBkaXN0ICs9IGNsYW1wKGRvdCgtc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCIueHl6LCB2V29ybGRQb3NpdGlvbi54eXogLSBzZWN0aW9uUGxhbmVQb3NcIiArIGkgKyBcIi54eXopLCAwLjAsIDEwMDAuMCk7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwiICBpZiAoZGlzdCA+IDAuMCkgeyBkaXNjYXJkOyB9XCIpO1xuICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgfVxuXG4gICAgc3JjLnB1c2goXCIgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAxLjAsIDEuMCk7IFwiKTtcblxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCJnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1wiKTtcbiAgICB9XG5cbiAgICBzcmMucHVzaChcIn1cIik7XG5cbiAgICByZXR1cm4gc3JjO1xufVxuXG5leHBvcnQge09jY2x1c2lvblNoYWRlclNvdXJjZX07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/occlusion/OcclusionShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshRenderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshRenderer.js ***!
  \****************************************************************************************/
/*! exports provided: PickMeshRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PickMeshRenderer\", function() { return PickMeshRenderer; });\n/* harmony import */ var _PickMeshShaderSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PickMeshShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_3__[\"math\"].vec3();\n\n// No ID, because there is exactly one PickMeshRenderer per scene\n\n/**\n * @private\n */\nconst PickMeshRenderer = function (hash, mesh) {\n    this._hash = hash;\n    this._shaderSource = new _PickMeshShaderSource_js__WEBPACK_IMPORTED_MODULE_0__[\"PickMeshShaderSource\"](mesh);\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._allocate(mesh);\n};\n\nconst renderers = {};\n\nPickMeshRenderer.get = function (mesh) {\n    const hash = [\n        mesh.scene.canvas.canvas.id,\n        mesh.scene._sectionPlanesState.getHash(),\n        mesh._geometry._state.hash,\n        mesh._state.hash\n    ].join(\";\");\n    let renderer = renderers[hash];\n    if (!renderer) {\n        renderer = new PickMeshRenderer(hash, mesh);\n        if (renderer.errors) {\n            console.log(renderer.errors.join(\"\\n\"));\n            return null;\n        }\n        renderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nPickMeshRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete renderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs--;\n    }\n};\n\nPickMeshRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nPickMeshRenderer.prototype.drawMesh = function (frameCtx, mesh) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const meshState = mesh._state;\n    const materialState = mesh._material._state;\n    const geometryState = mesh._geometry._state;\n    const rtcCenter = mesh.rtcCenter;\n\n    if (frameCtx.lastProgramId !== this._program.id) {\n        frameCtx.lastProgramId = this._program.id;\n        this._bindProgram(frameCtx);\n    }\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCPickViewMatrix(meshState.rtcCenterHash, rtcCenter) : frameCtx.pickViewMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_4__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    if (materialState.id !== this._lastMaterialId) {\n        const backfaces = materialState.backfaces;\n        if (frameCtx.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frameCtx.backfaces = backfaces;\n        }\n        const frontface = materialState.frontface;\n        if (frameCtx.frontface !== frontface) {\n            if (frontface) {\n                gl.frontFace(gl.CCW);\n            } else {\n                gl.frontFace(gl.CW);\n            }\n            frameCtx.frontface = frontface;\n        }\n        this._lastMaterialId = materialState.id;\n    }\n\n    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);\n    gl.uniformMatrix4fv(this._uModelMatrix, false, mesh.worldMatrix);\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, mesh._state.clippable);\n    }\n    gl.uniform3fv(this._uOffset, mesh._state.offset);\n\n    if (geometryState.id !== this._lastGeometryId) {\n        if (this._uPositionsDecodeMatrix) {\n            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        }\n        if (this._aPosition) {\n            this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n            frameCtx.bindArray++;\n        }\n        if (geometryState.indicesBuf) {\n            geometryState.indicesBuf.bind();\n            frameCtx.bindArray++;\n        }\n        this._lastGeometryId = geometryState.id;\n    }\n\n    // Mesh-indexed color\n    var pickID = mesh._state.pickID;\n    const a = pickID >> 24 & 0xFF;\n    const b = pickID >> 16 & 0xFF;\n    const g = pickID >> 8 & 0xFF;\n    const r = pickID & 0xFF;\n    gl.uniform4f(this._uPickColor, r / 255, g / 255, b / 255, a / 255);\n\n    if (geometryState.indicesBuf) {\n        gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n        frameCtx.drawElements++;\n    } else if (geometryState.positions) {\n        gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);\n    }\n};\n\nPickMeshRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__[\"Program\"](gl, this._shaderSource);\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uSectionPlanes = [];\n    const clips = scene._sectionPlanesState.sectionPlanes;\n    for (let i = 0, len = clips.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._aPosition = program.getAttribute(\"position\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uPickColor = program.getLocation(\"pickColor\");\n    this._uOffset = program.getLocation(\"offset\");\n    if (scene.logarithmicDepthBufferEnabled ) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n    this._lastMaterialId = null;\n    this._lastGeometryId = null;\n};\n\nPickMeshRenderer.prototype._bindProgram = function (frameCtx) {\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const project = scene.camera.project;\n    this._program.bind();\n    frameCtx.useProgram++;\n    if (scene.logarithmicDepthBufferEnabled ) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n    this._lastMaterialId = null;\n    this._lastGeometryId = null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvcGljay9QaWNrTWVzaFJlbmRlcmVyLmpzPzYxZDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRStEO0FBQ2hCO0FBQ1Y7QUFDRztBQUNlOztBQUV2RCxrQkFBa0Isa0RBQUk7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkVBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUs7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUVBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL3BpY2svUGlja01lc2hSZW5kZXJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGF1dGhvciB4ZW9sYWJzIC8gaHR0cHM6Ly9naXRodWIuY29tL3hlb2xhYnNcbiAqL1xuXG5pbXBvcnQge1BpY2tNZXNoU2hhZGVyU291cmNlfSBmcm9tIFwiLi9QaWNrTWVzaFNoYWRlclNvdXJjZS5qc1wiO1xuaW1wb3J0IHtQcm9ncmFtfSBmcm9tIFwiLi4vLi4vd2ViZ2wvUHJvZ3JhbS5qc1wiO1xuaW1wb3J0IHtzdGF0c30gZnJvbSBcIi4uLy4uL3N0YXRzLmpzXCI7XG5pbXBvcnQge21hdGh9IGZyb20gXCIuLi8uLi9tYXRoL21hdGguanNcIjtcbmltcG9ydCB7Z2V0UGxhbmVSVENQb3N9IGZyb20gXCIuLi8uLi9tYXRoL3J0Y0Nvb3Jkcy5qc1wiO1xuXG5jb25zdCB0ZW1wVmVjM2EgPSBtYXRoLnZlYzMoKTtcblxuLy8gTm8gSUQsIGJlY2F1c2UgdGhlcmUgaXMgZXhhY3RseSBvbmUgUGlja01lc2hSZW5kZXJlciBwZXIgc2NlbmVcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBQaWNrTWVzaFJlbmRlcmVyID0gZnVuY3Rpb24gKGhhc2gsIG1lc2gpIHtcbiAgICB0aGlzLl9oYXNoID0gaGFzaDtcbiAgICB0aGlzLl9zaGFkZXJTb3VyY2UgPSBuZXcgUGlja01lc2hTaGFkZXJTb3VyY2UobWVzaCk7XG4gICAgdGhpcy5fc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIHRoaXMuX3VzZUNvdW50ID0gMDtcbiAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbn07XG5cbmNvbnN0IHJlbmRlcmVycyA9IHt9O1xuXG5QaWNrTWVzaFJlbmRlcmVyLmdldCA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgY29uc3QgaGFzaCA9IFtcbiAgICAgICAgbWVzaC5zY2VuZS5jYW52YXMuY2FudmFzLmlkLFxuICAgICAgICBtZXNoLnNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuZ2V0SGFzaCgpLFxuICAgICAgICBtZXNoLl9nZW9tZXRyeS5fc3RhdGUuaGFzaCxcbiAgICAgICAgbWVzaC5fc3RhdGUuaGFzaFxuICAgIF0uam9pbihcIjtcIik7XG4gICAgbGV0IHJlbmRlcmVyID0gcmVuZGVyZXJzW2hhc2hdO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBuZXcgUGlja01lc2hSZW5kZXJlcihoYXNoLCBtZXNoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyLmVycm9ycykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVuZGVyZXIuZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJzW2hhc2hdID0gcmVuZGVyZXI7XG4gICAgICAgIHN0YXRzLm1lbW9yeS5wcm9ncmFtcysrO1xuICAgIH1cbiAgICByZW5kZXJlci5fdXNlQ291bnQrKztcbiAgICByZXR1cm4gcmVuZGVyZXI7XG59O1xuXG5QaWNrTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5fdXNlQ291bnQgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZW5kZXJlcnNbdGhpcy5faGFzaF07XG4gICAgICAgIHN0YXRzLm1lbW9yeS5wcm9ncmFtcy0tO1xuICAgIH1cbn07XG5cblBpY2tNZXNoUmVuZGVyZXIucHJvdG90eXBlLndlYmdsQ29udGV4dFJlc3RvcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xufTtcblxuUGlja01lc2hSZW5kZXJlci5wcm90b3R5cGUuZHJhd01lc2ggPSBmdW5jdGlvbiAoZnJhbWVDdHgsIG1lc2gpIHtcblxuICAgIGlmICghdGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICB0aGlzLl9hbGxvY2F0ZShtZXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuICAgIGNvbnN0IGdsID0gc2NlbmUuY2FudmFzLmdsO1xuICAgIGNvbnN0IG1lc2hTdGF0ZSA9IG1lc2guX3N0YXRlO1xuICAgIGNvbnN0IG1hdGVyaWFsU3RhdGUgPSBtZXNoLl9tYXRlcmlhbC5fc3RhdGU7XG4gICAgY29uc3QgZ2VvbWV0cnlTdGF0ZSA9IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZTtcbiAgICBjb25zdCBydGNDZW50ZXIgPSBtZXNoLnJ0Y0NlbnRlcjtcblxuICAgIGlmIChmcmFtZUN0eC5sYXN0UHJvZ3JhbUlkICE9PSB0aGlzLl9wcm9ncmFtLmlkKSB7XG4gICAgICAgIGZyYW1lQ3R4Lmxhc3RQcm9ncmFtSWQgPSB0aGlzLl9wcm9ncmFtLmlkO1xuICAgICAgICB0aGlzLl9iaW5kUHJvZ3JhbShmcmFtZUN0eCk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91Vmlld01hdHJpeCwgZmFsc2UsIHJ0Y0NlbnRlciA/IGZyYW1lQ3R4LmdldFJUQ1BpY2tWaWV3TWF0cml4KG1lc2hTdGF0ZS5ydGNDZW50ZXJIYXNoLCBydGNDZW50ZXIpIDogZnJhbWVDdHgucGlja1ZpZXdNYXRyaXgpO1xuXG4gICAgaWYgKG1lc2hTdGF0ZS5jbGlwcGFibGUpIHtcbiAgICAgICAgY29uc3QgbnVtU2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWN0aW9uUGxhbmVzID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckZsYWdzID0gbWVzaC5yZW5kZXJGbGFncztcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb25QbGFuZUluZGV4ID0gMDsgc2VjdGlvblBsYW5lSW5kZXggPCBudW1TZWN0aW9uUGxhbmVzOyBzZWN0aW9uUGxhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lVW5pZm9ybXMgPSB0aGlzLl91U2VjdGlvblBsYW5lc1tzZWN0aW9uUGxhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gcmVuZGVyRmxhZ3Muc2VjdGlvblBsYW5lc0FjdGl2ZVBlckxheWVyW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoc2VjdGlvblBsYW5lVW5pZm9ybXMuYWN0aXZlLCBhY3RpdmUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmUgPSBzZWN0aW9uUGxhbmVzW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5wb3MsIHJ0Y0NlbnRlciA/IGdldFBsYW5lUlRDUG9zKHNlY3Rpb25QbGFuZS5kaXN0LCBzZWN0aW9uUGxhbmUuZGlyLCBydGNDZW50ZXIsIHRlbXBWZWMzYSkgOiBzZWN0aW9uUGxhbmUucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5kaXIsIHNlY3Rpb25QbGFuZS5kaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmlkICE9PSB0aGlzLl9sYXN0TWF0ZXJpYWxJZCkge1xuICAgICAgICBjb25zdCBiYWNrZmFjZXMgPSBtYXRlcmlhbFN0YXRlLmJhY2tmYWNlcztcbiAgICAgICAgaWYgKGZyYW1lQ3R4LmJhY2tmYWNlcyAhPT0gYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICBpZiAoYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lQ3R4LmJhY2tmYWNlcyA9IGJhY2tmYWNlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9udGZhY2UgPSBtYXRlcmlhbFN0YXRlLmZyb250ZmFjZTtcbiAgICAgICAgaWYgKGZyYW1lQ3R4LmZyb250ZmFjZSAhPT0gZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICBpZiAoZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZShnbC5DVyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUN0eC5mcm9udGZhY2UgPSBmcm9udGZhY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBtYXRlcmlhbFN0YXRlLmlkO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVByb2pNYXRyaXgsIGZhbHNlLCBmcmFtZUN0eC5waWNrUHJvak1hdHJpeCk7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91TW9kZWxNYXRyaXgsIGZhbHNlLCBtZXNoLndvcmxkTWF0cml4KTtcbiAgICBpZiAodGhpcy5fdUNsaXBwYWJsZSkge1xuICAgICAgICBnbC51bmlmb3JtMWkodGhpcy5fdUNsaXBwYWJsZSwgbWVzaC5fc3RhdGUuY2xpcHBhYmxlKTtcbiAgICB9XG4gICAgZ2wudW5pZm9ybTNmdih0aGlzLl91T2Zmc2V0LCBtZXNoLl9zdGF0ZS5vZmZzZXQpO1xuXG4gICAgaWYgKGdlb21ldHJ5U3RhdGUuaWQgIT09IHRoaXMuX2xhc3RHZW9tZXRyeUlkKSB7XG4gICAgICAgIGlmICh0aGlzLl91UG9zaXRpb25zRGVjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGZhbHNlLCBnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYVBvc2l0aW9uLmJpbmRBcnJheUJ1ZmZlcihnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0J1ZiwgZ2VvbWV0cnlTdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5GTE9BVCk7XG4gICAgICAgICAgICBmcmFtZUN0eC5iaW5kQXJyYXkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmKSB7XG4gICAgICAgICAgICBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYuYmluZCgpO1xuICAgICAgICAgICAgZnJhbWVDdHguYmluZEFycmF5Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBnZW9tZXRyeVN0YXRlLmlkO1xuICAgIH1cblxuICAgIC8vIE1lc2gtaW5kZXhlZCBjb2xvclxuICAgIHZhciBwaWNrSUQgPSBtZXNoLl9zdGF0ZS5waWNrSUQ7XG4gICAgY29uc3QgYSA9IHBpY2tJRCA+PiAyNCAmIDB4RkY7XG4gICAgY29uc3QgYiA9IHBpY2tJRCA+PiAxNiAmIDB4RkY7XG4gICAgY29uc3QgZyA9IHBpY2tJRCA+PiA4ICYgMHhGRjtcbiAgICBjb25zdCByID0gcGlja0lEICYgMHhGRjtcbiAgICBnbC51bmlmb3JtNGYodGhpcy5fdVBpY2tDb2xvciwgciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NSk7XG5cbiAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmKSB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZSwgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLm51bUl0ZW1zLCBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYuaXRlbVR5cGUsIDApO1xuICAgICAgICBmcmFtZUN0eC5kcmF3RWxlbWVudHMrKztcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5U3RhdGUucG9zaXRpb25zKSB7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBnZW9tZXRyeVN0YXRlLnBvc2l0aW9ucy5udW1JdGVtcyk7XG4gICAgfVxufTtcblxuUGlja01lc2hSZW5kZXJlci5wcm90b3R5cGUuX2FsbG9jYXRlID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB0aGlzLl9zaGFkZXJTb3VyY2UpO1xuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9zaXRpb25zRGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91Vmlld01hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJ2aWV3TWF0cml4XCIpO1xuICAgIHRoaXMuX3VQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInByb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMgPSBbXTtcbiAgICBjb25zdCBjbGlwcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2xpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMucHVzaCh7XG4gICAgICAgICAgICBhY3RpdmU6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkpLFxuICAgICAgICAgICAgcG9zOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lUG9zXCIgKyBpKSxcbiAgICAgICAgICAgIGRpcjogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZURpclwiICsgaSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2FQb3NpdGlvbiA9IHByb2dyYW0uZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgdGhpcy5fdUNsaXBwYWJsZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJjbGlwcGFibGVcIik7XG4gICAgdGhpcy5fdVBpY2tDb2xvciA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJwaWNrQ29sb3JcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICkge1xuICAgICAgICB0aGlzLl91TG9nRGVwdGhCdWZGQyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsb2dEZXB0aEJ1ZkZDXCIpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xufTtcblxuUGlja01lc2hSZW5kZXJlci5wcm90b3R5cGUuX2JpbmRQcm9ncmFtID0gZnVuY3Rpb24gKGZyYW1lQ3R4KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICBjb25zdCBnbCA9IHNjZW5lLmNhbnZhcy5nbDtcbiAgICBjb25zdCBwcm9qZWN0ID0gc2NlbmUuY2FtZXJhLnByb2plY3Q7XG4gICAgdGhpcy5fcHJvZ3JhbS5iaW5kKCk7XG4gICAgZnJhbWVDdHgudXNlUHJvZ3JhbSsrO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCApIHtcbiAgICAgICAgY29uc3QgbG9nRGVwdGhCdWZGQyA9IDIuMCAvIChNYXRoLmxvZyhwcm9qZWN0LmZhciArIDEuMCkgLyBNYXRoLkxOMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91TG9nRGVwdGhCdWZGQywgbG9nRGVwdGhCdWZGQyk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RNYXRlcmlhbElkID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IG51bGw7XG59O1xuXG5leHBvcnQge1BpY2tNZXNoUmVuZGVyZXJ9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshShaderSource.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshShaderSource.js ***!
  \********************************************************************************************/
/*! exports provided: PickMeshShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PickMeshShaderSource\", function() { return PickMeshShaderSource; });\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n/**\n * @private\n */\nclass PickMeshShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n    const scene = mesh.scene;\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const src = [];\n    src.push(\"// Mesh picking vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"varying vec4 vViewPosition;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"varying float vFragDepth;\");\n        }\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"void billboard(inout mat4 mat) {\");\n        src.push(\"   mat[0][0] = 1.0;\");\n        src.push(\"   mat[0][1] = 0.0;\");\n        src.push(\"   mat[0][2] = 0.0;\");\n        if (billboard === \"spherical\") {\n            src.push(\"   mat[1][0] = 0.0;\");\n            src.push(\"   mat[1][1] = 1.0;\");\n            src.push(\"   mat[1][2] = 0.0;\");\n        }\n        src.push(\"   mat[2][0] = 0.0;\");\n        src.push(\"   mat[2][1] = 0.0;\");\n        src.push(\"   mat[2][2] =1.0;\");\n        src.push(\"}\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    src.push(\"mat4 viewMatrix2 = viewMatrix;\");\n    src.push(\"mat4 modelMatrix2 = modelMatrix;\");\n    if (stationary) {\n        src.push(\"viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;\")\n    }\n    if (billboard === \"spherical\" || billboard === \"cylindrical\") {\n        src.push(\"mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;\");\n        src.push(\"billboard(modelMatrix2);\");\n        src.push(\"billboard(viewMatrix2);\");\n    }\n    src.push(\"   vec4 worldPosition = modelMatrix2 * localPosition;\");\n    src.push(\"   worldPosition.xyz = worldPosition.xyz + offset;\");\n    src.push(\"   vec4 viewPosition = viewMatrix2 * worldPosition;\");\n    if (clipping) {\n        src.push(\"   vWorldPosition = worldPosition;\");\n    }\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n        } else {\n            src.push(\"clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;\");\n            src.push(\"clipPos.z *= clipPos.w;\");\n        }\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragment(mesh) {\n    const scene = mesh.scene;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n    src.push(\"// Mesh picking fragment shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    src.push(\"uniform vec4 pickColor;\");\n    if (clipping) {\n        src.push(\"uniform bool clippable;\");\n        src.push(\"varying vec4 vWorldPosition;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n    src.push(\"   gl_FragColor = pickColor; \");\n    src.push(\"}\");\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvcGljay9QaWNrTWVzaFNoYWRlclNvdXJjZS5qcz9lNGJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLGtDQUFrQztBQUNsQztBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsWUFBWSx3REFBVTtBQUN0QiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQyxtQkFBbUI7QUFDbkI7QUFDQSwrQkFBK0I7QUFDL0IsdURBQXVEO0FBQ3ZEO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5QztBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekM7QUFDQSxtRUFBbUU7QUFDbkUsZ0VBQWdFO0FBQ2hFLGlFQUFpRTtBQUNqRTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLFlBQVksd0RBQVU7QUFDdEIsbURBQW1EO0FBQ25ELFNBQVM7QUFDVCw2RkFBNkY7QUFDN0YsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pELDhDQUE4QztBQUM5QywyQ0FBMkM7QUFDM0M7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSx5Q0FBeUM7QUFDekMsOENBQThDO0FBQzlDLHVCQUF1Qiw2Q0FBNkM7QUFDcEUsK0RBQStEO0FBQy9ELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsdUJBQXVCLDZDQUE2QztBQUNwRSx3REFBd0Q7QUFDeEQsMklBQTJJO0FBQzNJLHVCQUF1QjtBQUN2QjtBQUNBLHFDQUFxQyxTQUFTLEVBQUU7QUFDaEQsbUJBQW1CO0FBQ25CO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pELDZFQUE2RTtBQUM3RTtBQUNBLDBDQUEwQztBQUMxQyxlQUFlO0FBQ2Y7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL3BpY2svUGlja01lc2hTaGFkZXJTb3VyY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgeGVvbGFicyAvIGh0dHBzOi8vZ2l0aHViLmNvbS94ZW9sYWJzXG4gKi9cblxuaW1wb3J0IHtXRUJHTF9JTkZPfSBmcm9tIFwiLi4vLi4vd2ViZ2xJbmZvLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUGlja01lc2hTaGFkZXJTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lc2gpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSBidWlsZFZlcnRleChtZXNoKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQobWVzaCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFZlcnRleChtZXNoKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IGNsaXBwaW5nID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgcXVhbnRpemVkR2VvbWV0cnkgPSAhIW1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5jb21wcmVzc0dlb21ldHJ5O1xuICAgIGNvbnN0IGJpbGxib2FyZCA9IG1lc2guX3N0YXRlLmJpbGxib2FyZDtcbiAgICBjb25zdCBzdGF0aW9uYXJ5ID0gbWVzaC5fc3RhdGUuc3RhdGlvbmFyeTtcbiAgICBjb25zdCBzcmMgPSBbXTtcbiAgICBzcmMucHVzaChcIi8vIE1lc2ggcGlja2luZyB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgcHJvak1hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzQgdlZpZXdQb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgb2Zmc2V0O1wiKTtcbiAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgcG9zaXRpb25zRGVjb2RlTWF0cml4O1wiKTtcbiAgICB9XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgaWYgKFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiaWxsYm9hcmQgPT09IFwic3BoZXJpY2FsXCIgfHwgYmlsbGJvYXJkID09PSBcImN5bGluZHJpY2FsXCIpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2b2lkIGJpbGxib2FyZChpbm91dCBtYXQ0IG1hdCkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMF1bMF0gPSAxLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFswXVsxXSA9IDAuMDtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzBdWzJdID0gMC4wO1wiKTtcbiAgICAgICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIikge1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMF0gPSAwLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMV0gPSAxLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMV1bMl0gPSAwLjA7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wdXNoKFwiICAgbWF0WzJdWzBdID0gMC4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgICBtYXRbMl1bMV0gPSAwLjA7XCIpO1xuICAgICAgICBzcmMucHVzaChcIiAgIG1hdFsyXVsyXSA9MS4wO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbFBvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTsgXCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcImxvY2FsUG9zaXRpb24gPSBwb3NpdGlvbnNEZWNvZGVNYXRyaXggKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJtYXQ0IHZpZXdNYXRyaXgyID0gdmlld01hdHJpeDtcIik7XG4gICAgc3JjLnB1c2goXCJtYXQ0IG1vZGVsTWF0cml4MiA9IG1vZGVsTWF0cml4O1wiKTtcbiAgICBpZiAoc3RhdGlvbmFyeSkge1xuICAgICAgICBzcmMucHVzaChcInZpZXdNYXRyaXgyWzNdWzBdID0gdmlld01hdHJpeDJbM11bMV0gPSB2aWV3TWF0cml4MlszXVsyXSA9IDAuMDtcIilcbiAgICB9XG4gICAgaWYgKGJpbGxib2FyZCA9PT0gXCJzcGhlcmljYWxcIiB8fCBiaWxsYm9hcmQgPT09IFwiY3lsaW5kcmljYWxcIikge1xuICAgICAgICBzcmMucHVzaChcIm1hdDQgbW9kZWxWaWV3TWF0cml4ID0gdmlld01hdHJpeDIgKiBtb2RlbE1hdHJpeDI7XCIpO1xuICAgICAgICBzcmMucHVzaChcImJpbGxib2FyZChtb2RlbE1hdHJpeDIpO1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCJiaWxsYm9hcmQodmlld01hdHJpeDIpO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCIgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeDIgKiBsb2NhbFBvc2l0aW9uO1wiKTtcbiAgICBzcmMucHVzaChcIiAgIHdvcmxkUG9zaXRpb24ueHl6ID0gd29ybGRQb3NpdGlvbi54eXogKyBvZmZzZXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwiICAgdmVjNCB2aWV3UG9zaXRpb24gPSB2aWV3TWF0cml4MiAqIHdvcmxkUG9zaXRpb247XCIpO1xuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcIiAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmVjNCBjbGlwUG9zID0gcHJvak1hdHJpeCAqIHZpZXdQb3NpdGlvbjtcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIGlmIChXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidkZyYWdEZXB0aCA9IDEuMCArIGNsaXBQb3MudztcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImNsaXBQb3MueiA9IGxvZzIoIG1heCggMWUtNiwgY2xpcFBvcy53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJjbGlwUG9zLnogKj0gY2xpcFBvcy53O1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMucHVzaChcImdsX1Bvc2l0aW9uID0gY2xpcFBvcztcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQobWVzaCkge1xuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzU3RhdGUgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlO1xuICAgIGNvbnN0IGNsaXBwaW5nID0gc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBzcmMgPSBbXTtcbiAgICBzcmMucHVzaChcIi8vIE1lc2ggcGlja2luZyBmcmFnbWVudCBzaGFkZXJcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcIiNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwiI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBoaWdocCBpbnQ7XCIpO1xuICAgIHNyYy5wdXNoKFwiI2Vsc2VcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XCIpO1xuICAgIHNyYy5wdXNoKFwiI2VuZGlmXCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWM0IHBpY2tDb2xvcjtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIGNsaXBwYWJsZTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGJvb2wgc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIHZlYzMgc2VjdGlvblBsYW5lRGlyXCIgKyBpICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiaWYgKGNsaXBwYWJsZSkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgIGZsb2F0IGRpc3QgPSAwLjA7XCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImlmIChzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkgKyBcIikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZGlzdCArPSBjbGFtcChkb3QoLXNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiLnh5eiwgdldvcmxkUG9zaXRpb24ueHl6IC0gc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCIueHl6KSwgMC4wLCAxMDAwLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgaWYgKGRpc3QgPiAwLjApIHsgZGlzY2FyZDsgfVwiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiZ2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwiICAgZ2xfRnJhZ0NvbG9yID0gcGlja0NvbG9yOyBcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmV4cG9ydCB7UGlja01lc2hTaGFkZXJTb3VyY2V9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickMeshShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleRenderer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleRenderer.js ***!
  \********************************************************************************************/
/*! exports provided: PickTriangleRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PickTriangleRenderer\", function() { return PickTriangleRenderer; });\n/* harmony import */ var _PickTriangleShaderSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PickTriangleShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n/* harmony import */ var _math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/rtcCoords.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/rtcCoords.js\");\n/* harmony import */ var _math_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/math.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/math/math.js\");\n/**\n * @author xeolabs / https://github.com/xeolabs\n */\n\n\n\n\n\n\n\nconst tempVec3a = _math_math_js__WEBPACK_IMPORTED_MODULE_4__[\"math\"].vec3();\n\n/**\n * @private\n */\nconst PickTriangleRenderer = function (hash, mesh) {\n    this._hash = hash;\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._shaderSource = new _PickTriangleShaderSource_js__WEBPACK_IMPORTED_MODULE_0__[\"PickTriangleShaderSource\"](mesh);\n    this._allocate(mesh);\n};\n\nconst renderers = {};\n\nPickTriangleRenderer.get = function (mesh) {\n    const hash = [\n        mesh.scene.canvas.canvas.id,\n        mesh.scene._sectionPlanesState.getHash(),\n        mesh._geometry._state.compressGeometry ? \"cp\" : \"\",\n        mesh._state.hash\n    ].join(\";\");\n    let renderer = renderers[hash];\n    if (!renderer) {\n        renderer = new PickTriangleRenderer(hash, mesh);\n        if (renderer.errors) {\n            console.log(renderer.errors.join(\"\\n\"));\n            return null;\n        }\n        renderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nPickTriangleRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete renderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs--;\n    }\n};\n\nPickTriangleRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nPickTriangleRenderer.prototype.drawMesh = function (frameCtx, mesh) {\n\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const meshState = mesh._state;\n    const materialState = mesh._material._state;\n    const geometry = mesh._geometry;\n    const geometryState = mesh._geometry._state;\n    const rtcCenter = mesh.rtcCenter;\n    const backfaces = materialState.backfaces;\n    const frontface = materialState.frontface;\n    const project = scene.camera.project;\n    const positionsBuf = geometry._getPickTrianglePositions();\n    const pickColorsBuf = geometry._getPickTriangleColors();\n\n    this._program.bind();\n\n    frameCtx.useProgram++;\n\n    if (scene.logarithmicDepthBufferEnabled ) {\n        const logDepthBufFC = 2.0 / (Math.log(project.far + 1.0) / Math.LN2);\n        gl.uniform1f(this._uLogDepthBufFC, logDepthBufFC);\n    }\n\n    gl.uniformMatrix4fv(this._uViewMatrix, false, rtcCenter ? frameCtx.getRTCPickViewMatrix(meshState.rtcCenterHash, rtcCenter) : frameCtx.pickViewMatrix);\n\n    if (meshState.clippable) {\n        const numSectionPlanes = scene._sectionPlanesState.sectionPlanes.length;\n        if (numSectionPlanes > 0) {\n            const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n            const renderFlags = mesh.renderFlags;\n            for (let sectionPlaneIndex = 0; sectionPlaneIndex < numSectionPlanes; sectionPlaneIndex++) {\n                const sectionPlaneUniforms = this._uSectionPlanes[sectionPlaneIndex];\n                const active = renderFlags.sectionPlanesActivePerLayer[sectionPlaneIndex];\n                gl.uniform1i(sectionPlaneUniforms.active, active ? 1 : 0);\n                if (active) {\n                    const sectionPlane = sectionPlanes[sectionPlaneIndex];\n                    gl.uniform3fv(sectionPlaneUniforms.pos, rtcCenter ? Object(_math_rtcCoords_js__WEBPACK_IMPORTED_MODULE_3__[\"getPlaneRTCPos\"])(sectionPlane.dist, sectionPlane.dir, rtcCenter, tempVec3a) : sectionPlane.pos);\n                    gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n                }\n            }\n        }\n    }\n\n    gl.uniformMatrix4fv(this._uProjMatrix, false, frameCtx.pickProjMatrix);\n\n    if (scene.logarithmicDepthBufferEnabled) {\n        gl.uniform1f(this._uZFar, scene.camera.project.far);\n    }\n\n    if (frameCtx.backfaces !== backfaces) {\n        if (backfaces) {\n            gl.disable(gl.CULL_FACE);\n        } else {\n            gl.enable(gl.CULL_FACE);\n        }\n        frameCtx.backfaces = backfaces;\n    }\n    if (frameCtx.frontface !== frontface) {\n        if (frontface) {\n            gl.frontFace(gl.CCW);\n        } else {\n            gl.frontFace(gl.CW);\n        }\n        frameCtx.frontface = frontface;\n    }\n\n    gl.uniformMatrix4fv(this._uModelMatrix, false, mesh.worldMatrix);\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, mesh._state.clippable);\n    }\n    gl.uniform3fv(this._uOffset, mesh._state.offset);\n    if (this._uPositionsDecodeMatrix) {\n        gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        this._aPosition.bindArrayBuffer(positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n    } else {\n        this._aPosition.bindArrayBuffer(positionsBuf);\n    }\n    pickColorsBuf.bind();\n    gl.enableVertexAttribArray(this._aColor.location);\n    gl.vertexAttribPointer(this._aColor.location, pickColorsBuf.itemSize, pickColorsBuf.itemType, true, 0, 0); // Normalize\n    gl.drawArrays(geometryState.primitive, 0, positionsBuf.numItems / 3);\n};\n\nPickTriangleRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__[\"Program\"](gl, this._shaderSource);\n    this._useCount = 0;\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uViewMatrix = program.getLocation(\"viewMatrix\");\n    this._uProjMatrix = program.getLocation(\"projMatrix\");\n    this._uSectionPlanes = [];\n    const sectionPlanes = scene._sectionPlanesState.sectionPlanes;\n    for (let i = 0, len = sectionPlanes.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._aPosition = program.getAttribute(\"position\");\n    this._aColor = program.getAttribute(\"color\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uOffset = program.getLocation(\"offset\");\n    if (scene.logarithmicDepthBufferEnabled ) {\n        this._uLogDepthBufFC = program.getLocation(\"logDepthBufFC\");\n    }\n};\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvcGljay9QaWNrVHJpYW5nbGVSZW5kZXJlci5qcz9kNGMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUV1RTtBQUN4QjtBQUNWO0FBQ2tCO0FBQ2Y7O0FBRXhDLGtCQUFrQixrREFBSTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUZBQXdCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBSztBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx5RUFBYztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvcGljay9QaWNrVHJpYW5nbGVSZW5kZXJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGF1dGhvciB4ZW9sYWJzIC8gaHR0cHM6Ly9naXRodWIuY29tL3hlb2xhYnNcbiAqL1xuXG5pbXBvcnQge1BpY2tUcmlhbmdsZVNoYWRlclNvdXJjZX0gZnJvbSBcIi4vUGlja1RyaWFuZ2xlU2hhZGVyU291cmNlLmpzXCI7XG5pbXBvcnQge1Byb2dyYW19IGZyb20gXCIuLi8uLi93ZWJnbC9Qcm9ncmFtLmpzXCI7XG5pbXBvcnQge3N0YXRzfSBmcm9tIFwiLi4vLi4vc3RhdHMuanNcIjtcbmltcG9ydCB7Z2V0UGxhbmVSVENQb3N9IGZyb20gXCIuLi8uLi9tYXRoL3J0Y0Nvb3Jkcy5qc1wiO1xuaW1wb3J0IHttYXRofSBmcm9tIFwiLi4vLi4vbWF0aC9tYXRoLmpzXCI7XG5cbmNvbnN0IHRlbXBWZWMzYSA9IG1hdGgudmVjMygpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFBpY2tUcmlhbmdsZVJlbmRlcmVyID0gZnVuY3Rpb24gKGhhc2gsIG1lc2gpIHtcbiAgICB0aGlzLl9oYXNoID0gaGFzaDtcbiAgICB0aGlzLl9zY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIHRoaXMuX3NoYWRlclNvdXJjZSA9IG5ldyBQaWNrVHJpYW5nbGVTaGFkZXJTb3VyY2UobWVzaCk7XG4gICAgdGhpcy5fYWxsb2NhdGUobWVzaCk7XG59O1xuXG5jb25zdCByZW5kZXJlcnMgPSB7fTtcblxuUGlja1RyaWFuZ2xlUmVuZGVyZXIuZ2V0ID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBjb25zdCBoYXNoID0gW1xuICAgICAgICBtZXNoLnNjZW5lLmNhbnZhcy5jYW52YXMuaWQsXG4gICAgICAgIG1lc2guc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5nZXRIYXNoKCksXG4gICAgICAgIG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gXCJjcFwiIDogXCJcIixcbiAgICAgICAgbWVzaC5fc3RhdGUuaGFzaFxuICAgIF0uam9pbihcIjtcIik7XG4gICAgbGV0IHJlbmRlcmVyID0gcmVuZGVyZXJzW2hhc2hdO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBuZXcgUGlja1RyaWFuZ2xlUmVuZGVyZXIoaGFzaCwgbWVzaCk7XG4gICAgICAgIGlmIChyZW5kZXJlci5lcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlbmRlcmVyLmVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyc1toYXNoXSA9IHJlbmRlcmVyO1xuICAgICAgICBzdGF0cy5tZW1vcnkucHJvZ3JhbXMrKztcbiAgICB9XG4gICAgcmVuZGVyZXIuX3VzZUNvdW50Kys7XG4gICAgcmV0dXJuIHJlbmRlcmVyO1xufTtcblxuUGlja1RyaWFuZ2xlUmVuZGVyZXIucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoLS10aGlzLl91c2VDb3VudCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHJlbmRlcmVyc1t0aGlzLl9oYXNoXTtcbiAgICAgICAgc3RhdHMubWVtb3J5LnByb2dyYW1zLS07XG4gICAgfVxufTtcblxuUGlja1RyaWFuZ2xlUmVuZGVyZXIucHJvdG90eXBlLndlYmdsQ29udGV4dFJlc3RvcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xufTtcblxuUGlja1RyaWFuZ2xlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNZXNoID0gZnVuY3Rpb24gKGZyYW1lQ3R4LCBtZXNoKSB7XG5cbiAgICBpZiAoIXRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgdGhpcy5fYWxsb2NhdGUobWVzaCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICBjb25zdCBnbCA9IHNjZW5lLmNhbnZhcy5nbDtcbiAgICBjb25zdCBtZXNoU3RhdGUgPSBtZXNoLl9zdGF0ZTtcbiAgICBjb25zdCBtYXRlcmlhbFN0YXRlID0gbWVzaC5fbWF0ZXJpYWwuX3N0YXRlO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5fZ2VvbWV0cnk7XG4gICAgY29uc3QgZ2VvbWV0cnlTdGF0ZSA9IG1lc2guX2dlb21ldHJ5Ll9zdGF0ZTtcbiAgICBjb25zdCBydGNDZW50ZXIgPSBtZXNoLnJ0Y0NlbnRlcjtcbiAgICBjb25zdCBiYWNrZmFjZXMgPSBtYXRlcmlhbFN0YXRlLmJhY2tmYWNlcztcbiAgICBjb25zdCBmcm9udGZhY2UgPSBtYXRlcmlhbFN0YXRlLmZyb250ZmFjZTtcbiAgICBjb25zdCBwcm9qZWN0ID0gc2NlbmUuY2FtZXJhLnByb2plY3Q7XG4gICAgY29uc3QgcG9zaXRpb25zQnVmID0gZ2VvbWV0cnkuX2dldFBpY2tUcmlhbmdsZVBvc2l0aW9ucygpO1xuICAgIGNvbnN0IHBpY2tDb2xvcnNCdWYgPSBnZW9tZXRyeS5fZ2V0UGlja1RyaWFuZ2xlQ29sb3JzKCk7XG5cbiAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcblxuICAgIGZyYW1lQ3R4LnVzZVByb2dyYW0rKztcblxuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCApIHtcbiAgICAgICAgY29uc3QgbG9nRGVwdGhCdWZGQyA9IDIuMCAvIChNYXRoLmxvZyhwcm9qZWN0LmZhciArIDEuMCkgLyBNYXRoLkxOMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLl91TG9nRGVwdGhCdWZGQywgbG9nRGVwdGhCdWZGQyk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91Vmlld01hdHJpeCwgZmFsc2UsIHJ0Y0NlbnRlciA/IGZyYW1lQ3R4LmdldFJUQ1BpY2tWaWV3TWF0cml4KG1lc2hTdGF0ZS5ydGNDZW50ZXJIYXNoLCBydGNDZW50ZXIpIDogZnJhbWVDdHgucGlja1ZpZXdNYXRyaXgpO1xuXG4gICAgaWYgKG1lc2hTdGF0ZS5jbGlwcGFibGUpIHtcbiAgICAgICAgY29uc3QgbnVtU2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWN0aW9uUGxhbmVzID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckZsYWdzID0gbWVzaC5yZW5kZXJGbGFncztcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb25QbGFuZUluZGV4ID0gMDsgc2VjdGlvblBsYW5lSW5kZXggPCBudW1TZWN0aW9uUGxhbmVzOyBzZWN0aW9uUGxhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvblBsYW5lVW5pZm9ybXMgPSB0aGlzLl91U2VjdGlvblBsYW5lc1tzZWN0aW9uUGxhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gcmVuZGVyRmxhZ3Muc2VjdGlvblBsYW5lc0FjdGl2ZVBlckxheWVyW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkoc2VjdGlvblBsYW5lVW5pZm9ybXMuYWN0aXZlLCBhY3RpdmUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGxhbmUgPSBzZWN0aW9uUGxhbmVzW3NlY3Rpb25QbGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5wb3MsIHJ0Y0NlbnRlciA/IGdldFBsYW5lUlRDUG9zKHNlY3Rpb25QbGFuZS5kaXN0LCBzZWN0aW9uUGxhbmUuZGlyLCBydGNDZW50ZXIsIHRlbXBWZWMzYSkgOiBzZWN0aW9uUGxhbmUucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihzZWN0aW9uUGxhbmVVbmlmb3Jtcy5kaXIsIHNlY3Rpb25QbGFuZS5kaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVByb2pNYXRyaXgsIGZhbHNlLCBmcmFtZUN0eC5waWNrUHJvak1hdHJpeCk7XG5cbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuX3VaRmFyLCBzY2VuZS5jYW1lcmEucHJvamVjdC5mYXIpO1xuICAgIH1cblxuICAgIGlmIChmcmFtZUN0eC5iYWNrZmFjZXMgIT09IGJhY2tmYWNlcykge1xuICAgICAgICBpZiAoYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZUN0eC5iYWNrZmFjZXMgPSBiYWNrZmFjZXM7XG4gICAgfVxuICAgIGlmIChmcmFtZUN0eC5mcm9udGZhY2UgIT09IGZyb250ZmFjZSkge1xuICAgICAgICBpZiAoZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ0NXKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmZyb250RmFjZShnbC5DVyk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWVDdHguZnJvbnRmYWNlID0gZnJvbnRmYWNlO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTWF0cml4LCBmYWxzZSwgbWVzaC53b3JsZE1hdHJpeCk7XG4gICAgaWYgKHRoaXMuX3VDbGlwcGFibGUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHRoaXMuX3VDbGlwcGFibGUsIG1lc2guX3N0YXRlLmNsaXBwYWJsZSk7XG4gICAgfVxuICAgIGdsLnVuaWZvcm0zZnYodGhpcy5fdU9mZnNldCwgbWVzaC5fc3RhdGUub2Zmc2V0KTtcbiAgICBpZiAodGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCkge1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXgsIGZhbHNlLCBnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0RlY29kZU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2FQb3NpdGlvbi5iaW5kQXJyYXlCdWZmZXIocG9zaXRpb25zQnVmLCBnZW9tZXRyeVN0YXRlLmNvbXByZXNzR2VvbWV0cnkgPyBnbC5VTlNJR05FRF9TSE9SVCA6IGdsLkZMT0FUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hUG9zaXRpb24uYmluZEFycmF5QnVmZmVyKHBvc2l0aW9uc0J1Zik7XG4gICAgfVxuICAgIHBpY2tDb2xvcnNCdWYuYmluZCgpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2FDb2xvci5sb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hQ29sb3IubG9jYXRpb24sIHBpY2tDb2xvcnNCdWYuaXRlbVNpemUsIHBpY2tDb2xvcnNCdWYuaXRlbVR5cGUsIHRydWUsIDAsIDApOyAvLyBOb3JtYWxpemVcbiAgICBnbC5kcmF3QXJyYXlzKGdlb21ldHJ5U3RhdGUucHJpbWl0aXZlLCAwLCBwb3NpdGlvbnNCdWYubnVtSXRlbXMgLyAzKTtcbn07XG5cblBpY2tUcmlhbmdsZVJlbmRlcmVyLnByb3RvdHlwZS5fYWxsb2NhdGUgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBnbCA9IHNjZW5lLmNhbnZhcy5nbDtcbiAgICB0aGlzLl9wcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHRoaXMuX3NoYWRlclNvdXJjZSk7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9zaXRpb25zRGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91Vmlld01hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJ2aWV3TWF0cml4XCIpO1xuICAgIHRoaXMuX3VQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInByb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMgPSBbXTtcbiAgICBjb25zdCBzZWN0aW9uUGxhbmVzID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VTZWN0aW9uUGxhbmVzLnB1c2goe1xuICAgICAgICAgICAgYWN0aXZlOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpKSxcbiAgICAgICAgICAgIHBvczogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZVBvc1wiICsgaSksXG4gICAgICAgICAgICBkaXI6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVEaXJcIiArIGkpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9hUG9zaXRpb24gPSBwcm9ncmFtLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgIHRoaXMuX2FDb2xvciA9IHByb2dyYW0uZ2V0QXR0cmlidXRlKFwiY29sb3JcIik7XG4gICAgdGhpcy5fdUNsaXBwYWJsZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJjbGlwcGFibGVcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICkge1xuICAgICAgICB0aGlzLl91TG9nRGVwdGhCdWZGQyA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJsb2dEZXB0aEJ1ZkZDXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7UGlja1RyaWFuZ2xlUmVuZGVyZXJ9O1xuXG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleShaderSource.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleShaderSource.js ***!
  \************************************************************************************************/
/*! exports provided: PickTriangleShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PickTriangleShaderSource\", function() { return PickTriangleShaderSource; });\n/* harmony import */ var _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webglInfo.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\");\n/**\n * @private\n */\n\n\nclass PickTriangleShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n    const scene = mesh.scene;\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const billboard = mesh._state.billboard;\n    const stationary = mesh._state.stationary;\n    const src = [];\n    src.push(\"// Surface picking vertex shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"attribute vec3 position;\");\n    src.push(\"attribute vec4 color;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 viewMatrix;\");\n    src.push(\"uniform mat4 projMatrix;\");\n    src.push(\"uniform vec3 offset;\");\n    if (clipping) {\n        src.push(\"uniform bool clippable;\");\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    if (scene.logarithmicDepthBufferEnabled) {\n        src.push(\"uniform float logDepthBufFC;\");\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"varying float vFragDepth;\");\n        }\n    }\n    src.push(\"varying vec4 vColor;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    src.push(\"   vec4 worldPosition = modelMatrix * localPosition; \");\n    src.push(\"   worldPosition.xyz = worldPosition.xyz + offset;\");\n    src.push(\"   vec4 viewPosition = viewMatrix * worldPosition;\");\n    if (clipping) {\n        src.push(\"   vWorldPosition = worldPosition;\");\n    }\n    src.push(\"   vColor = color;\");\n    src.push(\"vec4 clipPos = projMatrix * viewPosition;\");\n    if (scene.logarithmicDepthBufferEnabled) {\n        if (_webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n            src.push(\"vFragDepth = 1.0 + clipPos.w;\");\n        } else {\n            src.push(\"clipPos.z = log2( max( 1e-6, clipPos.w + 1.0 ) ) * logDepthBufFC - 1.0;\");\n            src.push(\"clipPos.z *= clipPos.w;\");\n        }\n    }\n    src.push(\"gl_Position = clipPos;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragment(mesh) {\n    const scene = mesh.scene;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n    src.push(\"// Surface picking fragment shader\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"#extension GL_EXT_frag_depth : enable\");\n    }\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n    src.push(\"varying vec4 vColor;\");\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"uniform float logDepthBufFC;\");\n        src.push(\"varying float vFragDepth;\");\n    }\n    if (clipping) {\n        src.push(\"uniform bool clippable;\");\n        src.push(\"varying vec4 vWorldPosition;\");\n        for (let i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (let i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n    if (scene.logarithmicDepthBufferEnabled && _webglInfo_js__WEBPACK_IMPORTED_MODULE_0__[\"WEBGL_INFO\"].SUPPORTED_EXTENSIONS[\"EXT_frag_depth\"]) {\n        src.push(\"gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\");\n    }\n    src.push(\"   gl_FragColor = vColor;\");\n    src.push(\"}\");\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvcGljay9QaWNrVHJpYW5nbGVTaGFkZXJTb3VyY2UuanM/ZGQzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLGtDQUFrQztBQUNsQztBQUNBLHlDQUF5QztBQUN6Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxZQUFZLHdEQUFVO0FBQ3RCLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsK0JBQStCO0FBQy9CLHVEQUF1RDtBQUN2RDtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLGtFQUFrRTtBQUNsRSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsZ0NBQWdDO0FBQ2hDLHVEQUF1RDtBQUN2RDtBQUNBLFlBQVksd0RBQVU7QUFDdEIsbURBQW1EO0FBQ25ELFNBQVM7QUFDVCw2RkFBNkY7QUFDN0YsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDO0FBQ0Esa0NBQWtDO0FBQ2xDLCtDQUErQyx3REFBVTtBQUN6RCw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsOENBQThDO0FBQzlDLHVCQUF1Qiw2Q0FBNkM7QUFDcEUsK0RBQStEO0FBQy9ELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsdUJBQXVCLDZDQUE2QztBQUNwRSx3REFBd0Q7QUFDeEQsMklBQTJJO0FBQzNJLHVCQUF1QjtBQUN2QjtBQUNBLHFDQUFxQyxTQUFTLEVBQUU7QUFDaEQsbUJBQW1CO0FBQ25CO0FBQ0EsK0NBQStDLHdEQUFVO0FBQ3pELDZFQUE2RTtBQUM3RTtBQUNBLHVDQUF1QztBQUN2QyxlQUFlO0FBQ2Y7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL3BpY2svUGlja1RyaWFuZ2xlU2hhZGVyU291cmNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5pbXBvcnQge1dFQkdMX0lORk99IGZyb20gXCIuLi8uLi93ZWJnbEluZm8uanNcIjtcblxuY2xhc3MgUGlja1RyaWFuZ2xlU2hhZGVyU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNoKSB7XG4gICAgICAgIHRoaXMudmVydGV4ID0gYnVpbGRWZXJ0ZXgobWVzaCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KG1lc2gpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRWZXJ0ZXgobWVzaCkge1xuICAgIGNvbnN0IHNjZW5lID0gbWVzaC5zY2VuZTtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHF1YW50aXplZEdlb21ldHJ5ID0gISFtZXNoLl9nZW9tZXRyeS5fc3RhdGUuY29tcHJlc3NHZW9tZXRyeTtcbiAgICBjb25zdCBiaWxsYm9hcmQgPSBtZXNoLl9zdGF0ZS5iaWxsYm9hcmQ7XG4gICAgY29uc3Qgc3RhdGlvbmFyeSA9IG1lc2guX3N0YXRlLnN0YXRpb25hcnk7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBTdXJmYWNlIHBpY2tpbmcgdmVydGV4IHNoYWRlclwiKTtcbiAgICBpZiAoc2NlbmUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlckVuYWJsZWQgJiYgV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVwiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJhdHRyaWJ1dGUgdmVjNCBjb2xvcjtcIik7XG4gICAgc3JjLnB1c2goXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIG9mZnNldDtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIGNsaXBwYWJsZTtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1wiKTtcbiAgICAgICAgaWYgKFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidmFyeWluZyB2ZWM0IHZDb2xvcjtcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IHBvc2l0aW9uc0RlY29kZU1hdHJpeDtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG4gICAgc3JjLnB1c2goXCJ2ZWM0IGxvY2FsUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApOyBcIik7XG4gICAgaWYgKHF1YW50aXplZEdlb21ldHJ5KSB7XG4gICAgICAgIHNyYy5wdXNoKFwibG9jYWxQb3NpdGlvbiA9IHBvc2l0aW9uc0RlY29kZU1hdHJpeCAqIGxvY2FsUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogbG9jYWxQb3NpdGlvbjsgXCIpO1xuICAgIHNyYy5wdXNoKFwiICAgd29ybGRQb3NpdGlvbi54eXogPSB3b3JsZFBvc2l0aW9uLnh5eiArIG9mZnNldDtcIik7XG4gICAgc3JjLnB1c2goXCIgICB2ZWM0IHZpZXdQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCIgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiAgIHZDb2xvciA9IGNvbG9yO1wiKTtcbiAgICBzcmMucHVzaChcInZlYzQgY2xpcFBvcyA9IHByb2pNYXRyaXggKiB2aWV3UG9zaXRpb247XCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCkge1xuICAgICAgICBpZiAoV0VCR0xfSU5GTy5TVVBQT1JURURfRVhURU5TSU9OU1tcIkVYVF9mcmFnX2RlcHRoXCJdKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcInZGcmFnRGVwdGggPSAxLjAgKyBjbGlwUG9zLnc7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJjbGlwUG9zLnogPSBsb2cyKCBtYXgoIDFlLTYsIGNsaXBQb3MudyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiY2xpcFBvcy56ICo9IGNsaXBQb3MudztcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjLnB1c2goXCJnbF9Qb3NpdGlvbiA9IGNsaXBQb3M7XCIpO1xuICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBTdXJmYWNlIHBpY2tpbmcgZnJhZ21lbnQgc2hhZGVyXCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbHNlXCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbmRpZlwiKTtcbiAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2Q29sb3I7XCIpO1xuICAgIGlmIChzY2VuZS5sb2dhcml0aG1pY0RlcHRoQnVmZmVyRW5hYmxlZCAmJiBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiRVhUX2ZyYWdfZGVwdGhcIl0pIHtcbiAgICAgICAgc3JjLnB1c2goXCJ1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcIik7XG4gICAgfVxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gYm9vbCBjbGlwcGFibGU7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIHNlY3Rpb25QbGFuZUFjdGl2ZVwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZVBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcImlmIChjbGlwcGFibGUpIHtcIik7XG4gICAgICAgIHNyYy5wdXNoKFwiICBmbG9hdCBkaXN0ID0gMC4wO1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3JjLnB1c2goXCJpZiAoc2VjdGlvblBsYW5lQWN0aXZlXCIgKyBpICsgXCIpIHtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIiAgIGRpc3QgKz0gY2xhbXAoZG90KC1zZWN0aW9uUGxhbmVEaXJcIiArIGkgKyBcIi54eXosIHZXb3JsZFBvc2l0aW9uLnh5eiAtIHNlY3Rpb25QbGFuZVBvc1wiICsgaSArIFwiLnh5eiksIDAuMCwgMTAwMC4wKTtcIik7XG4gICAgICAgICAgICBzcmMucHVzaChcIn1cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2goXCIgIGlmIChkaXN0ID4gMC4wKSB7IGRpc2NhcmQ7IH1cIik7XG4gICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICB9XG4gICAgaWYgKHNjZW5lLmxvZ2FyaXRobWljRGVwdGhCdWZmZXJFbmFibGVkICYmIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbXCJFWFRfZnJhZ19kZXB0aFwiXSkge1xuICAgICAgICBzcmMucHVzaChcImdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcIiAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmV4cG9ydCB7UGlja1RyaWFuZ2xlU2hhZGVyU291cmNlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/pick/PickTriangleShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowRenderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowRenderer.js ***!
  \****************************************************************************************/
/*! exports provided: ShadowRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowRenderer\", function() { return ShadowRenderer; });\n/* harmony import */ var _ShadowShaderSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShadowShaderSource.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowShaderSource.js\");\n/* harmony import */ var _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/Program.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\");\n/* harmony import */ var _stats_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stats.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\");\n\n\n\n\n/**\n * @private\n */\nconst ShadowRenderer = function (hash, mesh) {\n    this._hash = hash;\n    this._shaderSource = new _ShadowShaderSource_js__WEBPACK_IMPORTED_MODULE_0__[\"ShadowShaderSource\"](mesh);\n    this._scene = mesh.scene;\n    this._useCount = 0;\n    this._allocate(mesh);\n};\n\nconst renderers = {};\n\nShadowRenderer.get = function (mesh) {\n    const scene = mesh.scene;\n    const hash = [scene.canvas.canvas.id, scene._sectionPlanesState.getHash(), mesh._geometry._state.hash, mesh._state.hash].join(\";\");\n    let renderer = renderers[hash];\n    if (!renderer) {\n        renderer = new ShadowRenderer(hash, mesh);\n        if (renderer.errors) {\n            console.log(renderer.errors.join(\"\\n\"));\n            return null;\n        }\n        renderers[hash] = renderer;\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs++;\n    }\n    renderer._useCount++;\n    return renderer;\n};\n\nShadowRenderer.prototype.put = function () {\n    if (--this._useCount === 0) {\n        if (this._program) {\n            this._program.destroy();\n        }\n        delete renderers[this._hash];\n        _stats_js__WEBPACK_IMPORTED_MODULE_2__[\"stats\"].memory.programs--;\n    }\n};\n\nShadowRenderer.prototype.webglContextRestored = function () {\n    this._program = null;\n};\n\nShadowRenderer.prototype.drawMesh = function (frame, mesh) {\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const materialState = mesh._material._state;\n    const geometryState = mesh._geometry._state;\n    if (frame.lastProgramId !== this._program.id) {\n        frame.lastProgramId = this._program.id;\n        this._bindProgram(frame);\n    }\n    if (materialState.id !== this._lastMaterialId) {\n        const backfaces = materialState.backfaces;\n        if (frame.backfaces !== backfaces) {\n            if (backfaces) {\n                gl.disable(gl.CULL_FACE);\n            } else {\n                gl.enable(gl.CULL_FACE);\n            }\n            frame.backfaces = backfaces;\n        }\n        const frontface = materialState.frontface;\n        if (frame.frontface !== frontface) {\n            if (frontface) {\n                gl.frontFace(gl.CCW);\n            } else {\n                gl.frontFace(gl.CW);\n            }\n            frame.frontface = frontface;\n        }\n        if (frame.lineWidth !== materialState.lineWidth) {\n            gl.lineWidth(materialState.lineWidth);\n            frame.lineWidth = materialState.lineWidth;\n        }\n        if (this._uPointSize) {\n            gl.uniform1i(this._uPointSize, materialState.pointSize);\n        }\n        this._lastMaterialId = materialState.id;\n    }\n    gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, mesh.worldMatrix);\n    if (geometryState.combineGeometry) {\n        const vertexBufs = mesh.vertexBufs;\n        if (vertexBufs.id !== this._lastVertexBufsId) {\n            if (vertexBufs.positionsBuf && this._aPosition) {\n                this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n                frame.bindArray++;\n            }\n            this._lastVertexBufsId = vertexBufs.id;\n        }\n    }\n    if (this._uClippable) {\n        gl.uniform1i(this._uClippable, mesh._state.clippable);\n    }\n    gl.uniform3fv(this._uOffset, mesh._state.offset);\n    if (geometryState.id !== this._lastGeometryId) {\n        if (this._uPositionsDecodeMatrix) {\n            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometryState.positionsDecodeMatrix);\n        }\n        if (geometryState.combineGeometry) { // VBOs were bound by the preceding VertexBufs chunk\n            if (geometryState.indicesBufCombined) {\n                geometryState.indicesBufCombined.bind();\n                frame.bindArray++;\n            }\n        } else {\n            if (this._aPosition) {\n                this._aPosition.bindArrayBuffer(geometryState.positionsBuf, geometryState.compressGeometry ? gl.UNSIGNED_SHORT : gl.FLOAT);\n                frame.bindArray++;\n            }\n            if (geometryState.indicesBuf) {\n                geometryState.indicesBuf.bind();\n                frame.bindArray++;\n            }\n        }\n        this._lastGeometryId = geometryState.id;\n    }\n    if (geometryState.combineGeometry) {\n        if (geometryState.indicesBufCombined) {\n            gl.drawElements(geometryState.primitive, geometryState.indicesBufCombined.numItems, geometryState.indicesBufCombined.itemType, 0);\n            frame.drawElements++;\n        } else {\n            // TODO: drawArrays() with VertexBufs positions\n        }\n    } else {\n        if (geometryState.indicesBuf) {\n            gl.drawElements(geometryState.primitive, geometryState.indicesBuf.numItems, geometryState.indicesBuf.itemType, 0);\n            frame.drawElements++;\n        } else if (geometryState.positions) {\n            gl.drawArrays(gl.TRIANGLES, 0, geometryState.positions.numItems);\n            frame.drawArrays++;\n        }\n    }\n};\n\nShadowRenderer.prototype._allocate = function (mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    this._program = new _webgl_Program_js__WEBPACK_IMPORTED_MODULE_1__[\"Program\"](gl, this._shaderSource);\n    this._scene = scene;\n    this._useCount = 0;\n    if (this._program.errors) {\n        this.errors = this._program.errors;\n        return;\n    }\n    const program = this._program;\n    this._uPositionsDecodeMatrix = program.getLocation(\"positionsDecodeMatrix\");\n    this._uModelMatrix = program.getLocation(\"modelMatrix\");\n    this._uShadowViewMatrix = program.getLocation(\"shadowViewMatrix\");\n    this._uShadowProjMatrix = program.getLocation(\"shadowProjMatrix\");\n    this._uSectionPlanes = {};\n    const clips = scene._sectionPlanesState.sectionPlanes;\n    for (let i = 0, len = clips.length; i < len; i++) {\n        this._uSectionPlanes.push({\n            active: program.getLocation(\"sectionPlaneActive\" + i),\n            pos: program.getLocation(\"sectionPlanePos\" + i),\n            dir: program.getLocation(\"sectionPlaneDir\" + i)\n        });\n    }\n    this._aPosition = program.getAttribute(\"position\");\n    this._uClippable = program.getLocation(\"clippable\");\n    this._uOffset = program.getLocation(\"offset\");\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n};\n\nShadowRenderer.prototype._bindProgram = function (frame) {\n    if (!this._program) {\n        this._allocate(mesh);\n    }\n    const scene = this._scene;\n    const gl = scene.canvas.gl;\n    const sectionPlanesState = scene._sectionPlanesState;\n    this._program.bind();\n    frame.useProgram++;\n    gl.uniformMatrix4fv(this._uShadowViewMatrix, false, frame.shadowViewMatrix);\n    gl.uniformMatrix4fv(this._uShadowProjMatrix, false, frame.shadowProjMatrix);\n    this._lastMaterialId = null;\n    this._lastVertexBufsId = null;\n    this._lastGeometryId = null;\n    if (sectionPlanesState.sectionPlanes.length > 0) {\n        let sectionPlaneUniforms;\n        let uSectionPlaneActive;\n        let sectionPlane;\n        let uSectionPlanePos;\n        let uSectionPlaneDir;\n        for (let i = 0, len = this._uSectionPlanes.length; i < len; i++) {\n            sectionPlaneUniforms = this._uSectionPlanes[i];\n            uSectionPlaneActive = sectionPlaneUniforms.active;\n            sectionPlane = sectionPlanesState.sectionPlanes[i];\n            if (uSectionPlaneActive) {\n                gl.uniform1i(uSectionPlaneActive, sectionPlane.active);\n            }\n            uSectionPlanePos = sectionPlaneUniforms.pos;\n            if (uSectionPlanePos) {\n                gl.uniform3fv(sectionPlaneUniforms.pos, sectionPlane.pos);\n            }\n            uSectionPlaneDir = sectionPlaneUniforms.dir;\n            if (uSectionPlaneDir) {\n                gl.uniform3fv(sectionPlaneUniforms.dir, sectionPlane.dir);\n            }\n        }\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvc2hhZG93L1NoYWRvd1JlbmRlcmVyLmpzPzg1YzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEyRDtBQUNaO0FBQ1Y7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUVBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFLO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvbWVzaC9zaGFkb3cvU2hhZG93UmVuZGVyZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NoYWRvd1NoYWRlclNvdXJjZX0gZnJvbSBcIi4vU2hhZG93U2hhZGVyU291cmNlLmpzXCI7XG5pbXBvcnQge1Byb2dyYW19IGZyb20gXCIuLi8uLi93ZWJnbC9Qcm9ncmFtLmpzXCI7XG5pbXBvcnQge3N0YXRzfSBmcm9tIFwiLi4vLi4vc3RhdHMuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBTaGFkb3dSZW5kZXJlciA9IGZ1bmN0aW9uIChoYXNoLCBtZXNoKSB7XG4gICAgdGhpcy5faGFzaCA9IGhhc2g7XG4gICAgdGhpcy5fc2hhZGVyU291cmNlID0gbmV3IFNoYWRvd1NoYWRlclNvdXJjZShtZXNoKTtcbiAgICB0aGlzLl9zY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIHRoaXMuX2FsbG9jYXRlKG1lc2gpO1xufTtcblxuY29uc3QgcmVuZGVyZXJzID0ge307XG5cblNoYWRvd1JlbmRlcmVyLmdldCA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBtZXNoLnNjZW5lO1xuICAgIGNvbnN0IGhhc2ggPSBbc2NlbmUuY2FudmFzLmNhbnZhcy5pZCwgc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZS5nZXRIYXNoKCksIG1lc2guX2dlb21ldHJ5Ll9zdGF0ZS5oYXNoLCBtZXNoLl9zdGF0ZS5oYXNoXS5qb2luKFwiO1wiKTtcbiAgICBsZXQgcmVuZGVyZXIgPSByZW5kZXJlcnNbaGFzaF07XG4gICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IG5ldyBTaGFkb3dSZW5kZXJlcihoYXNoLCBtZXNoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyLmVycm9ycykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVuZGVyZXIuZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJzW2hhc2hdID0gcmVuZGVyZXI7XG4gICAgICAgIHN0YXRzLm1lbW9yeS5wcm9ncmFtcysrO1xuICAgIH1cbiAgICByZW5kZXJlci5fdXNlQ291bnQrKztcbiAgICByZXR1cm4gcmVuZGVyZXI7XG59O1xuXG5TaGFkb3dSZW5kZXJlci5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgtLXRoaXMuX3VzZUNvdW50ID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcmVuZGVyZXJzW3RoaXMuX2hhc2hdO1xuICAgICAgICBzdGF0cy5tZW1vcnkucHJvZ3JhbXMtLTtcbiAgICB9XG59O1xuXG5TaGFkb3dSZW5kZXJlci5wcm90b3R5cGUud2ViZ2xDb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XG59O1xuXG5TaGFkb3dSZW5kZXJlci5wcm90b3R5cGUuZHJhd01lc2ggPSBmdW5jdGlvbiAoZnJhbWUsIG1lc2gpIHtcbiAgICBpZiAoIXRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgdGhpcy5fYWxsb2NhdGUobWVzaCk7XG4gICAgfVxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3QgbWF0ZXJpYWxTdGF0ZSA9IG1lc2guX21hdGVyaWFsLl9zdGF0ZTtcbiAgICBjb25zdCBnZW9tZXRyeVN0YXRlID0gbWVzaC5fZ2VvbWV0cnkuX3N0YXRlO1xuICAgIGlmIChmcmFtZS5sYXN0UHJvZ3JhbUlkICE9PSB0aGlzLl9wcm9ncmFtLmlkKSB7XG4gICAgICAgIGZyYW1lLmxhc3RQcm9ncmFtSWQgPSB0aGlzLl9wcm9ncmFtLmlkO1xuICAgICAgICB0aGlzLl9iaW5kUHJvZ3JhbShmcmFtZSk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbFN0YXRlLmlkICE9PSB0aGlzLl9sYXN0TWF0ZXJpYWxJZCkge1xuICAgICAgICBjb25zdCBiYWNrZmFjZXMgPSBtYXRlcmlhbFN0YXRlLmJhY2tmYWNlcztcbiAgICAgICAgaWYgKGZyYW1lLmJhY2tmYWNlcyAhPT0gYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICBpZiAoYmFja2ZhY2VzKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lLmJhY2tmYWNlcyA9IGJhY2tmYWNlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9udGZhY2UgPSBtYXRlcmlhbFN0YXRlLmZyb250ZmFjZTtcbiAgICAgICAgaWYgKGZyYW1lLmZyb250ZmFjZSAhPT0gZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICBpZiAoZnJvbnRmYWNlKSB7XG4gICAgICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmZyb250RmFjZShnbC5DVyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZS5mcm9udGZhY2UgPSBmcm9udGZhY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lLmxpbmVXaWR0aCAhPT0gbWF0ZXJpYWxTdGF0ZS5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGdsLmxpbmVXaWR0aChtYXRlcmlhbFN0YXRlLmxpbmVXaWR0aCk7XG4gICAgICAgICAgICBmcmFtZS5saW5lV2lkdGggPSBtYXRlcmlhbFN0YXRlLmxpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdVBvaW50U2l6ZSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHRoaXMuX3VQb2ludFNpemUsIG1hdGVyaWFsU3RhdGUucG9pbnRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG1hdGVyaWFsU3RhdGUuaWQ7XG4gICAgfVxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdU1vZGVsTWF0cml4LCBnbC5GQUxTRSwgbWVzaC53b3JsZE1hdHJpeCk7XG4gICAgaWYgKGdlb21ldHJ5U3RhdGUuY29tYmluZUdlb21ldHJ5KSB7XG4gICAgICAgIGNvbnN0IHZlcnRleEJ1ZnMgPSBtZXNoLnZlcnRleEJ1ZnM7XG4gICAgICAgIGlmICh2ZXJ0ZXhCdWZzLmlkICE9PSB0aGlzLl9sYXN0VmVydGV4QnVmc0lkKSB7XG4gICAgICAgICAgICBpZiAodmVydGV4QnVmcy5wb3NpdGlvbnNCdWYgJiYgdGhpcy5fYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYVBvc2l0aW9uLmJpbmRBcnJheUJ1ZmZlcih2ZXJ0ZXhCdWZzLnBvc2l0aW9uc0J1ZiwgdmVydGV4QnVmcy5jb21wcmVzc0dlb21ldHJ5ID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5GTE9BVCk7XG4gICAgICAgICAgICAgICAgZnJhbWUuYmluZEFycmF5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmVydGV4QnVmc0lkID0gdmVydGV4QnVmcy5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fdUNsaXBwYWJsZSkge1xuICAgICAgICBnbC51bmlmb3JtMWkodGhpcy5fdUNsaXBwYWJsZSwgbWVzaC5fc3RhdGUuY2xpcHBhYmxlKTtcbiAgICB9XG4gICAgZ2wudW5pZm9ybTNmdih0aGlzLl91T2Zmc2V0LCBtZXNoLl9zdGF0ZS5vZmZzZXQpO1xuICAgIGlmIChnZW9tZXRyeVN0YXRlLmlkICE9PSB0aGlzLl9sYXN0R2VvbWV0cnlJZCkge1xuICAgICAgICBpZiAodGhpcy5fdVBvc2l0aW9uc0RlY29kZU1hdHJpeCkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91UG9zaXRpb25zRGVjb2RlTWF0cml4LCBmYWxzZSwgZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnNEZWNvZGVNYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW9tZXRyeVN0YXRlLmNvbWJpbmVHZW9tZXRyeSkgeyAvLyBWQk9zIHdlcmUgYm91bmQgYnkgdGhlIHByZWNlZGluZyBWZXJ0ZXhCdWZzIGNodW5rXG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmQ29tYmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWZDb21iaW5lZC5iaW5kKCk7XG4gICAgICAgICAgICAgICAgZnJhbWUuYmluZEFycmF5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYVBvc2l0aW9uLmJpbmRBcnJheUJ1ZmZlcihnZW9tZXRyeVN0YXRlLnBvc2l0aW9uc0J1ZiwgZ2VvbWV0cnlTdGF0ZS5jb21wcmVzc0dlb21ldHJ5ID8gZ2wuVU5TSUdORURfU0hPUlQgOiBnbC5GTE9BVCk7XG4gICAgICAgICAgICAgICAgZnJhbWUuYmluZEFycmF5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLmJpbmQoKTtcbiAgICAgICAgICAgICAgICBmcmFtZS5iaW5kQXJyYXkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0R2VvbWV0cnlJZCA9IGdlb21ldHJ5U3RhdGUuaWQ7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVN0YXRlLmNvbWJpbmVHZW9tZXRyeSkge1xuICAgICAgICBpZiAoZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmQ29tYmluZWQpIHtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZSwgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmQ29tYmluZWQubnVtSXRlbXMsIGdlb21ldHJ5U3RhdGUuaW5kaWNlc0J1ZkNvbWJpbmVkLml0ZW1UeXBlLCAwKTtcbiAgICAgICAgICAgIGZyYW1lLmRyYXdFbGVtZW50cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogZHJhd0FycmF5cygpIHdpdGggVmVydGV4QnVmcyBwb3NpdGlvbnNcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYpIHtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnZW9tZXRyeVN0YXRlLnByaW1pdGl2ZSwgZ2VvbWV0cnlTdGF0ZS5pbmRpY2VzQnVmLm51bUl0ZW1zLCBnZW9tZXRyeVN0YXRlLmluZGljZXNCdWYuaXRlbVR5cGUsIDApO1xuICAgICAgICAgICAgZnJhbWUuZHJhd0VsZW1lbnRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlTdGF0ZS5wb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBnZW9tZXRyeVN0YXRlLnBvc2l0aW9ucy5udW1JdGVtcyk7XG4gICAgICAgICAgICBmcmFtZS5kcmF3QXJyYXlzKys7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TaGFkb3dSZW5kZXJlci5wcm90b3R5cGUuX2FsbG9jYXRlID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB0aGlzLl9zaGFkZXJTb3VyY2UpO1xuICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5fdXNlQ291bnQgPSAwO1xuICAgIGlmICh0aGlzLl9wcm9ncmFtLmVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuX3Byb2dyYW0uZXJyb3JzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgIHRoaXMuX3VQb3NpdGlvbnNEZWNvZGVNYXRyaXggPSBwcm9ncmFtLmdldExvY2F0aW9uKFwicG9zaXRpb25zRGVjb2RlTWF0cml4XCIpO1xuICAgIHRoaXMuX3VNb2RlbE1hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJtb2RlbE1hdHJpeFwiKTtcbiAgICB0aGlzLl91U2hhZG93Vmlld01hdHJpeCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzaGFkb3dWaWV3TWF0cml4XCIpO1xuICAgIHRoaXMuX3VTaGFkb3dQcm9qTWF0cml4ID0gcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNoYWRvd1Byb2pNYXRyaXhcIik7XG4gICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMgPSB7fTtcbiAgICBjb25zdCBjbGlwcyA9IHNjZW5lLl9zZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2xpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdVNlY3Rpb25QbGFuZXMucHVzaCh7XG4gICAgICAgICAgICBhY3RpdmU6IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkpLFxuICAgICAgICAgICAgcG9zOiBwcm9ncmFtLmdldExvY2F0aW9uKFwic2VjdGlvblBsYW5lUG9zXCIgKyBpKSxcbiAgICAgICAgICAgIGRpcjogcHJvZ3JhbS5nZXRMb2NhdGlvbihcInNlY3Rpb25QbGFuZURpclwiICsgaSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2FQb3NpdGlvbiA9IHByb2dyYW0uZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgdGhpcy5fdUNsaXBwYWJsZSA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJjbGlwcGFibGVcIik7XG4gICAgdGhpcy5fdU9mZnNldCA9IHByb2dyYW0uZ2V0TG9jYXRpb24oXCJvZmZzZXRcIik7XG4gICAgdGhpcy5fbGFzdE1hdGVyaWFsSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RWZXJ0ZXhCdWZzSWQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RHZW9tZXRyeUlkID0gbnVsbDtcbn07XG5cblNoYWRvd1JlbmRlcmVyLnByb3RvdHlwZS5fYmluZFByb2dyYW0gPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICBpZiAoIXRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgdGhpcy5fYWxsb2NhdGUobWVzaCk7XG4gICAgfVxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcbiAgICBmcmFtZS51c2VQcm9ncmFtKys7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl91U2hhZG93Vmlld01hdHJpeCwgZmFsc2UsIGZyYW1lLnNoYWRvd1ZpZXdNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5fdVNoYWRvd1Byb2pNYXRyaXgsIGZhbHNlLCBmcmFtZS5zaGFkb3dQcm9qTWF0cml4KTtcbiAgICB0aGlzLl9sYXN0TWF0ZXJpYWxJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZlcnRleEJ1ZnNJZCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEdlb21ldHJ5SWQgPSBudWxsO1xuICAgIGlmIChzZWN0aW9uUGxhbmVzU3RhdGUuc2VjdGlvblBsYW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzZWN0aW9uUGxhbmVVbmlmb3JtcztcbiAgICAgICAgbGV0IHVTZWN0aW9uUGxhbmVBY3RpdmU7XG4gICAgICAgIGxldCBzZWN0aW9uUGxhbmU7XG4gICAgICAgIGxldCB1U2VjdGlvblBsYW5lUG9zO1xuICAgICAgICBsZXQgdVNlY3Rpb25QbGFuZURpcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3VTZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzZWN0aW9uUGxhbmVVbmlmb3JtcyA9IHRoaXMuX3VTZWN0aW9uUGxhbmVzW2ldO1xuICAgICAgICAgICAgdVNlY3Rpb25QbGFuZUFjdGl2ZSA9IHNlY3Rpb25QbGFuZVVuaWZvcm1zLmFjdGl2ZTtcbiAgICAgICAgICAgIHNlY3Rpb25QbGFuZSA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHVTZWN0aW9uUGxhbmVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodVNlY3Rpb25QbGFuZUFjdGl2ZSwgc2VjdGlvblBsYW5lLmFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1U2VjdGlvblBsYW5lUG9zID0gc2VjdGlvblBsYW5lVW5pZm9ybXMucG9zO1xuICAgICAgICAgICAgaWYgKHVTZWN0aW9uUGxhbmVQb3MpIHtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLnBvcywgc2VjdGlvblBsYW5lLnBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1U2VjdGlvblBsYW5lRGlyID0gc2VjdGlvblBsYW5lVW5pZm9ybXMuZGlyO1xuICAgICAgICAgICAgaWYgKHVTZWN0aW9uUGxhbmVEaXIpIHtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNlY3Rpb25QbGFuZVVuaWZvcm1zLmRpciwgc2VjdGlvblBsYW5lLmRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQge1NoYWRvd1JlbmRlcmVyfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowRenderer.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowShaderSource.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowShaderSource.js ***!
  \********************************************************************************************/
/*! exports provided: ShadowShaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowShaderSource\", function() { return ShadowShaderSource; });\n/**\n * @private\n */\nclass ShadowShaderSource {\n    constructor(mesh) {\n        this.vertex = buildVertex(mesh);\n        this.fragment = buildFragment(mesh);\n    }\n}\n\nfunction buildVertex(mesh) {\n    const scene = mesh.scene;\n    const clipping = scene._sectionPlanesState.sectionPlanes.length > 0;\n    const quantizedGeometry = !!mesh._geometry._state.compressGeometry;\n    const src = [];\n    src.push(\"// Mesh shadow vertex shader\");\n    src.push(\"attribute vec3 position;\");\n    src.push(\"uniform mat4 modelMatrix;\");\n    src.push(\"uniform mat4 shadowViewMatrix;\");\n    src.push(\"uniform mat4 shadowProjMatrix;\");\n    src.push(\"uniform vec3 offset;\");\n    if (quantizedGeometry) {\n        src.push(\"uniform mat4 positionsDecodeMatrix;\");\n    }\n    if (clipping) {\n        src.push(\"varying vec4 vWorldPosition;\");\n    }\n    src.push(\"void main(void) {\");\n    src.push(\"vec4 localPosition = vec4(position, 1.0); \");\n    src.push(\"vec4 worldPosition;\");\n    if (quantizedGeometry) {\n        src.push(\"localPosition = positionsDecodeMatrix * localPosition;\");\n    }\n    src.push(\"worldPosition = modelMatrix * localPosition;\");\n    src.push(\"worldPosition.xyz = worldPosition.xyz + offset;\");\n    src.push(\"vec4 viewPosition  = shadowViewMatrix * worldPosition; \");\n    if (clipping) {\n        src.push(\"vWorldPosition = worldPosition;\");\n    }\n    src.push(\"   gl_Position = shadowProjMatrix * viewPosition;\");\n    src.push(\"}\");\n    return src;\n}\n\nfunction buildFragment(mesh) {\n    const scene = mesh.scene;\n    const gl = scene.canvas.gl;\n    const sectionPlanesState = scene._sectionPlanesState;\n    const clipping = sectionPlanesState.sectionPlanes.length > 0;\n    const src = [];\n    src.push(\"// Mesh shadow fragment shader\");\n\n    src.push(\"#ifdef GL_FRAGMENT_PRECISION_HIGH\");\n    src.push(\"precision highp float;\");\n    src.push(\"precision highp int;\");\n    src.push(\"#else\");\n    src.push(\"precision mediump float;\");\n    src.push(\"precision mediump int;\");\n    src.push(\"#endif\");\n\n    if (clipping) {\n        src.push(\"uniform bool clippable;\");\n        src.push(\"varying vec4 vWorldPosition;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"uniform bool sectionPlaneActive\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlanePos\" + i + \";\");\n            src.push(\"uniform vec3 sectionPlaneDir\" + i + \";\");\n        }\n    }\n\n    src.push(\"vec4 encodeFloat( const in float depth ) {\");\n    src.push(\"  const vec4 bitShift = vec4(256 * 256 * 256, 256 * 256, 256, 1.0);\");\n    src.push(\"  const vec4 bitMask = vec4(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\");\n    src.push(\"  vec4 comp = fract(depth * bitShift);\");\n    src.push(\"  comp -= comp.xxyz * bitMask;\");\n    src.push(\"  return comp;\");\n    src.push(\"}\");\n\n    src.push(\"void main(void) {\");\n    if (clipping) {\n        src.push(\"if (clippable) {\");\n        src.push(\"  float dist = 0.0;\");\n        for (var i = 0; i < sectionPlanesState.sectionPlanes.length; i++) {\n            src.push(\"if (sectionPlaneActive\" + i + \") {\");\n            src.push(\"   dist += clamp(dot(-sectionPlaneDir\" + i + \".xyz, vWorldPosition.xyz - sectionPlanePos\" + i + \".xyz), 0.0, 1000.0);\");\n            src.push(\"}\");\n        }\n        src.push(\"  if (dist > 0.0) { discard; }\");\n        src.push(\"}\");\n    }\n    src.push(\"gl_FragColor = encodeFloat(gl_FragCoord.z);\");\n    src.push(\"}\");\n    return src;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL21lc2gvc2hhZG93L1NoYWRvd1NoYWRlclNvdXJjZS5qcz84MzU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLGtDQUFrQztBQUNsQztBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsK0JBQStCO0FBQy9CLHVEQUF1RDtBQUN2RCxpQ0FBaUM7QUFDakM7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSwwREFBMEQ7QUFDMUQsNkRBQTZEO0FBQzdELG9FQUFvRTtBQUNwRTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLCtEQUErRDtBQUMvRCxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUM5Qyx1QkFBdUIsNkNBQTZDO0FBQ3BFLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hELGlGQUFpRjtBQUNqRixvRkFBb0Y7QUFDcEYsb0RBQW9EO0FBQ3BELDRDQUE0QztBQUM1Qyw0QkFBNEI7QUFDNUIsZUFBZTs7QUFFZiwrQkFBK0I7QUFDL0I7QUFDQSxrQ0FBa0M7QUFDbEMscUNBQXFDO0FBQ3JDLHVCQUF1Qiw2Q0FBNkM7QUFDcEUsd0RBQXdEO0FBQ3hELDJJQUEySTtBQUMzSSx1QkFBdUI7QUFDdkI7QUFDQSxxQ0FBcUMsU0FBUyxFQUFFO0FBQ2hELG1CQUFtQjtBQUNuQjtBQUNBLHlEQUF5RDtBQUN6RCxlQUFlO0FBQ2Y7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS9tZXNoL3NoYWRvdy9TaGFkb3dTaGFkZXJTb3VyY2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNoYWRvd1NoYWRlclNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IobWVzaCkge1xuICAgICAgICB0aGlzLnZlcnRleCA9IGJ1aWxkVmVydGV4KG1lc2gpO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gYnVpbGRGcmFnbWVudChtZXNoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmVydGV4KG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgY2xpcHBpbmcgPSBzY2VuZS5fc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBxdWFudGl6ZWRHZW9tZXRyeSA9ICEhbWVzaC5fZ2VvbWV0cnkuX3N0YXRlLmNvbXByZXNzR2VvbWV0cnk7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBNZXNoIHNoYWRvdyB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgIHNyYy5wdXNoKFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIpO1xuICAgIHNyYy5wdXNoKFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBzaGFkb3dWaWV3TWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBzaGFkb3dQcm9qTWF0cml4O1wiKTtcbiAgICBzcmMucHVzaChcInVuaWZvcm0gdmVjMyBvZmZzZXQ7XCIpO1xuICAgIGlmIChxdWFudGl6ZWRHZW9tZXRyeSkge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gbWF0NCBwb3NpdGlvbnNEZWNvZGVNYXRyaXg7XCIpO1xuICAgIH1cbiAgICBpZiAoY2xpcHBpbmcpIHtcbiAgICAgICAgc3JjLnB1c2goXCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcInZvaWQgbWFpbih2b2lkKSB7XCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCBsb2NhbFBvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTsgXCIpO1xuICAgIHNyYy5wdXNoKFwidmVjNCB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICBpZiAocXVhbnRpemVkR2VvbWV0cnkpIHtcbiAgICAgICAgc3JjLnB1c2goXCJsb2NhbFBvc2l0aW9uID0gcG9zaXRpb25zRGVjb2RlTWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgfVxuICAgIHNyYy5wdXNoKFwid29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogbG9jYWxQb3NpdGlvbjtcIik7XG4gICAgc3JjLnB1c2goXCJ3b3JsZFBvc2l0aW9uLnh5eiA9IHdvcmxkUG9zaXRpb24ueHl6ICsgb2Zmc2V0O1wiKTtcbiAgICBzcmMucHVzaChcInZlYzQgdmlld1Bvc2l0aW9uICA9IHNoYWRvd1ZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uOyBcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1wiKTtcbiAgICB9XG4gICAgc3JjLnB1c2goXCIgICBnbF9Qb3NpdGlvbiA9IHNoYWRvd1Byb2pNYXRyaXggKiB2aWV3UG9zaXRpb247XCIpO1xuICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICByZXR1cm4gc3JjO1xufVxuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KG1lc2gpIHtcbiAgICBjb25zdCBzY2VuZSA9IG1lc2guc2NlbmU7XG4gICAgY29uc3QgZ2wgPSBzY2VuZS5jYW52YXMuZ2w7XG4gICAgY29uc3Qgc2VjdGlvblBsYW5lc1N0YXRlID0gc2NlbmUuX3NlY3Rpb25QbGFuZXNTdGF0ZTtcbiAgICBjb25zdCBjbGlwcGluZyA9IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgc3JjLnB1c2goXCIvLyBNZXNoIHNoYWRvdyBmcmFnbWVudCBzaGFkZXJcIik7XG5cbiAgICBzcmMucHVzaChcIiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFwiKTtcbiAgICBzcmMucHVzaChcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgc3JjLnB1c2goXCJwcmVjaXNpb24gaGlnaHAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbHNlXCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIpO1xuICAgIHNyYy5wdXNoKFwicHJlY2lzaW9uIG1lZGl1bXAgaW50O1wiKTtcbiAgICBzcmMucHVzaChcIiNlbmRpZlwiKTtcblxuICAgIGlmIChjbGlwcGluZykge1xuICAgICAgICBzcmMucHVzaChcInVuaWZvcm0gYm9vbCBjbGlwcGFibGU7XCIpO1xuICAgICAgICBzcmMucHVzaChcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VjdGlvblBsYW5lc1N0YXRlLnNlY3Rpb25QbGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSBib29sIHNlY3Rpb25QbGFuZUFjdGl2ZVwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZVBvc1wiICsgaSArIFwiO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwidW5pZm9ybSB2ZWMzIHNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiO1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNyYy5wdXNoKFwidmVjNCBlbmNvZGVGbG9hdCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIpO1xuICAgIHNyYy5wdXNoKFwiICBjb25zdCB2ZWM0IGJpdFNoaWZ0ID0gdmVjNCgyNTYgKiAyNTYgKiAyNTYsIDI1NiAqIDI1NiwgMjU2LCAxLjApO1wiKTtcbiAgICBzcmMucHVzaChcIiAgY29uc3QgdmVjNCBiaXRNYXNrID0gdmVjNCgwLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wKTtcIik7XG4gICAgc3JjLnB1c2goXCIgIHZlYzQgY29tcCA9IGZyYWN0KGRlcHRoICogYml0U2hpZnQpO1wiKTtcbiAgICBzcmMucHVzaChcIiAgY29tcCAtPSBjb21wLnh4eXogKiBiaXRNYXNrO1wiKTtcbiAgICBzcmMucHVzaChcIiAgcmV0dXJuIGNvbXA7XCIpO1xuICAgIHNyYy5wdXNoKFwifVwiKTtcblxuICAgIHNyYy5wdXNoKFwidm9pZCBtYWluKHZvaWQpIHtcIik7XG4gICAgaWYgKGNsaXBwaW5nKSB7XG4gICAgICAgIHNyYy5wdXNoKFwiaWYgKGNsaXBwYWJsZSkge1wiKTtcbiAgICAgICAgc3JjLnB1c2goXCIgIGZsb2F0IGRpc3QgPSAwLjA7XCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25QbGFuZXNTdGF0ZS5zZWN0aW9uUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzcmMucHVzaChcImlmIChzZWN0aW9uUGxhbmVBY3RpdmVcIiArIGkgKyBcIikge1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwiICAgZGlzdCArPSBjbGFtcChkb3QoLXNlY3Rpb25QbGFuZURpclwiICsgaSArIFwiLnh5eiwgdldvcmxkUG9zaXRpb24ueHl6IC0gc2VjdGlvblBsYW5lUG9zXCIgKyBpICsgXCIueHl6KSwgMC4wLCAxMDAwLjApO1wiKTtcbiAgICAgICAgICAgIHNyYy5wdXNoKFwifVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucHVzaChcIiAgaWYgKGRpc3QgPiAwLjApIHsgZGlzY2FyZDsgfVwiKTtcbiAgICAgICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIH1cbiAgICBzcmMucHVzaChcImdsX0ZyYWdDb2xvciA9IGVuY29kZUZsb2F0KGdsX0ZyYWdDb29yZC56KTtcIik7XG4gICAgc3JjLnB1c2goXCJ9XCIpO1xuICAgIHJldHVybiBzcmM7XG59XG5cbmV4cG9ydCB7U2hhZG93U2hhZGVyU291cmNlfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/mesh/shadow/ShadowShaderSource.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js ***!
  \*******************************************************************/
/*! exports provided: stats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stats\", function() { return stats; });\n/**\n * xeokit runtime statistics.\n * @private\n * @type {{components: {models: number, objects: number, scenes: number, meshes: number}, memory: {indices: number, uvs: number, textures: number, materials: number, transforms: number, positions: number, programs: number, normals: number, meshes: number, colors: number}, build: {version: string}, client: {browser: string}, frame: {frameCount: number, useProgram: number, bindTexture: number, drawElements: number, bindArray: number, tasksRun: number, fps: number, drawArrays: number, tasksScheduled: number}}}\n */\nconst stats = {\n    build: {\n        version: \"0.8\"\n    },\n    client: {\n        browser: (navigator && navigator.userAgent) ? navigator.userAgent : \"n/a\"\n    },\n\n    components: {\n        scenes: 0,\n        models: 0,\n        meshes: 0,\n        objects: 0\n    },\n    memory: {\n        meshes: 0,\n        positions: 0,\n        colors: 0,\n        normals: 0,\n        uvs: 0,\n        indices: 0,\n        textures: 0,\n        transforms: 0,\n        materials: 0,\n        programs: 0\n    },\n    frame: {\n        frameCount: 0,\n        fps: 0,\n        useProgram: 0,\n        bindTexture: 0,\n        bindArray: 0,\n        drawElements: 0,\n        drawArrays: 0,\n        tasksRun: 0,\n        tasksScheduled: 0\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzPzg0NDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxnRUFBZ0UsV0FBVyw0S0FBNEssVUFBVSxnQkFBZ0IsV0FBVyxnQkFBZ0IsVUFBVTtBQUM5VTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3N0YXRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB4ZW9raXQgcnVudGltZSBzdGF0aXN0aWNzLlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHt7Y29tcG9uZW50czoge21vZGVsczogbnVtYmVyLCBvYmplY3RzOiBudW1iZXIsIHNjZW5lczogbnVtYmVyLCBtZXNoZXM6IG51bWJlcn0sIG1lbW9yeToge2luZGljZXM6IG51bWJlciwgdXZzOiBudW1iZXIsIHRleHR1cmVzOiBudW1iZXIsIG1hdGVyaWFsczogbnVtYmVyLCB0cmFuc2Zvcm1zOiBudW1iZXIsIHBvc2l0aW9uczogbnVtYmVyLCBwcm9ncmFtczogbnVtYmVyLCBub3JtYWxzOiBudW1iZXIsIG1lc2hlczogbnVtYmVyLCBjb2xvcnM6IG51bWJlcn0sIGJ1aWxkOiB7dmVyc2lvbjogc3RyaW5nfSwgY2xpZW50OiB7YnJvd3Nlcjogc3RyaW5nfSwgZnJhbWU6IHtmcmFtZUNvdW50OiBudW1iZXIsIHVzZVByb2dyYW06IG51bWJlciwgYmluZFRleHR1cmU6IG51bWJlciwgZHJhd0VsZW1lbnRzOiBudW1iZXIsIGJpbmRBcnJheTogbnVtYmVyLCB0YXNrc1J1bjogbnVtYmVyLCBmcHM6IG51bWJlciwgZHJhd0FycmF5czogbnVtYmVyLCB0YXNrc1NjaGVkdWxlZDogbnVtYmVyfX19XG4gKi9cbmNvbnN0IHN0YXRzID0ge1xuICAgIGJ1aWxkOiB7XG4gICAgICAgIHZlcnNpb246IFwiMC44XCJcbiAgICB9LFxuICAgIGNsaWVudDoge1xuICAgICAgICBicm93c2VyOiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IFwibi9hXCJcbiAgICB9LFxuXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBzY2VuZXM6IDAsXG4gICAgICAgIG1vZGVsczogMCxcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBvYmplY3RzOiAwXG4gICAgfSxcbiAgICBtZW1vcnk6IHtcbiAgICAgICAgbWVzaGVzOiAwLFxuICAgICAgICBwb3NpdGlvbnM6IDAsXG4gICAgICAgIGNvbG9yczogMCxcbiAgICAgICAgbm9ybWFsczogMCxcbiAgICAgICAgdXZzOiAwLFxuICAgICAgICBpbmRpY2VzOiAwLFxuICAgICAgICB0ZXh0dXJlczogMCxcbiAgICAgICAgdHJhbnNmb3JtczogMCxcbiAgICAgICAgbWF0ZXJpYWxzOiAwLFxuICAgICAgICBwcm9ncmFtczogMFxuICAgIH0sXG4gICAgZnJhbWU6IHtcbiAgICAgICAgZnJhbWVDb3VudDogMCxcbiAgICAgICAgZnBzOiAwLFxuICAgICAgICB1c2VQcm9ncmFtOiAwLFxuICAgICAgICBiaW5kVGV4dHVyZTogMCxcbiAgICAgICAgYmluZEFycmF5OiAwLFxuICAgICAgICBkcmF3RWxlbWVudHM6IDAsXG4gICAgICAgIGRyYXdBcnJheXM6IDAsXG4gICAgICAgIHRhc2tzUnVuOiAwLFxuICAgICAgICB0YXNrc1NjaGVkdWxlZDogMFxuICAgIH1cbn07XG5cbmV4cG9ydCB7c3RhdHN9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/stats.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js ***!
  \*******************************************************************/
/*! exports provided: utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n/**\n * @private\n */\nfunction xmlToJson(node, attributeRenamer) {\n    if (node.nodeType === node.TEXT_NODE) {\n        var v = node.nodeValue;\n        if (v.match(/^\\s+$/) === null) {\n            return v;\n        }\n    } else if (node.nodeType === node.ELEMENT_NODE ||\n        node.nodeType === node.DOCUMENT_NODE) {\n        var json = {type: node.nodeName, children: []};\n\n        if (node.nodeType === node.ELEMENT_NODE) {\n            for (var j = 0; j < node.attributes.length; j++) {\n                var attribute = node.attributes[j];\n                var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;\n                json[nm] = attribute.nodeValue;\n            }\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n            var item = node.childNodes[i];\n            var j = xmlToJson(item, attributeRenamer);\n            if (j) json.children.push(j);\n        }\n\n        return json;\n    }\n}\n\n/**\n * @private\n */\nfunction clone(ob) {\n    return JSON.parse(JSON.stringify(ob));\n}\n\n/**\n * @private\n */\nvar guidChars = [[\"0\", 10], [\"A\", 26], [\"a\", 26], [\"_\", 1], [\"$\", 1]].map(function (a) {\n    var li = [];\n    var st = a[0].charCodeAt(0);\n    var en = st + a[1];\n    for (var i = st; i < en; ++i) {\n        li.push(i);\n    }\n    return String.fromCharCode.apply(null, li);\n}).join(\"\");\n\n/**\n * @private\n */\nfunction b64(v, len) {\n    var r = (!len || len === 4) ? [0, 6, 12, 18] : [0, 6];\n    return r.map(function (i) {\n        return guidChars.substr(parseInt(v / (1 << i)) % 64, 1)\n    }).reverse().join(\"\");\n}\n\n/**\n * @private\n */\nfunction compressGuid(g) {\n    var bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function (i) {\n        return parseInt(g.substr(i, 2), 16);\n    });\n    return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function (i) {\n        return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2]);\n    }).join(\"\");\n}\n\n/**\n * @private\n */\nfunction findNodeOfType(m, t) {\n    var li = [];\n    var _ = function (n) {\n        if (n.type === t) li.push(n);\n        (n.children || []).forEach(function (c) {\n            _(c);\n        });\n    };\n    _(m);\n    return li;\n}\n\n/**\n * @private\n */\nfunction timeout(dt) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(resolve, dt);\n    });\n}\n\n/**\n * @private\n */\nfunction httpRequest(args) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(args.method || \"GET\", args.url, true);\n        xhr.onload = function (e) {\n            console.log(args.url, xhr.readyState, xhr.status);\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.responseXML);\n                } else {\n                    reject(xhr.statusText);\n                }\n            }\n        };\n        xhr.send(null);\n    });\n}\n\n/**\n * @private\n */\nconst queryString = function () {\n    // This function is anonymous, is executed immediately and\n    // the return value is assigned to QueryString!\n    var query_string = {};\n    var query = window.location.search.substring(1);\n    var vars = query.split(\"&\");\n    for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n        // If first entry with this name\n        if (typeof query_string[pair[0]] === \"undefined\") {\n            query_string[pair[0]] = decodeURIComponent(pair[1]);\n            // If second entry with this name\n        } else if (typeof query_string[pair[0]] === \"string\") {\n            var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];\n            query_string[pair[0]] = arr;\n            // If third or later entry with this name\n        } else {\n            query_string[pair[0]].push(decodeURIComponent(pair[1]));\n        }\n    }\n    return query_string;\n}();\n\n/**\n * @private\n */\nfunction loadJSON(url, ok, err) {\n    // Avoid checking ok and err on each use.\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n\n    var request = new XMLHttpRequest();\n    request.overrideMimeType(\"application/json\");\n    request.open('GET', url, true);\n    request.addEventListener('load', function (event) {\n        var response = event.target.response;\n        if (this.status === 200) {\n            var json;\n            try {\n                json = JSON.parse(response);\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n            ok(json);\n        } else if (this.status === 0) {\n            // Some browsers return HTTP Status 0 when using non-http protocol\n            // e.g. 'file://' or 'data://'. Handle as success.\n            console.warn('loadFile: HTTP Status 0 received.');\n            try {\n                ok(JSON.parse(response));\n            } catch (e) {\n                err(`utils.loadJSON(): Failed to parse JSON response - ${e}`);\n            }\n        } else {\n            err(event);\n        }\n    }, false);\n\n    request.addEventListener('error', function (event) {\n        err(event);\n    }, false);\n    request.send(null);\n}\n\n/**\n * @private\n */\nfunction loadArraybuffer(url, ok, err) {\n    // Check for data: URI\n    var defaultCallback = (_value) => undefined;\n    ok = ok || defaultCallback;\n    err = err || defaultCallback;\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n        const isBase64 = !!dataUriRegexResult[2];\n        var data = dataUriRegexResult[3];\n        data = window.decodeURIComponent(data);\n        if (isBase64) {\n            data = window.atob(data);\n        }\n        try {\n            const buffer = new ArrayBuffer(data.length);\n            const view = new Uint8Array(buffer);\n            for (var i = 0; i < data.length; i++) {\n                view[i] = data.charCodeAt(i);\n            }\n            window.setTimeout(function () {\n                ok(buffer);\n            }, 0);\n        } catch (error) {\n            window.setTimeout(function () {\n                err(error);\n            }, 0);\n        }\n    } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.responseType = 'arraybuffer';\n        request.onreadystatechange = function () {\n            if (request.readyState === 4) {\n                if (request.status === 200) {\n                    ok(request.response);\n                } else {\n                    err('loadArrayBuffer error : ' + request.response);\n                }\n            }\n        };\n        request.send(null);\n    }\n}\n\n/**\n Tests if the given object is an array\n @private\n */\nfunction isArray(value) {\n    return value && !(value.propertyIsEnumerable('length')) && typeof value === 'object' && typeof value.length === 'number';\n}\n\n/**\n Tests if the given value is a string\n @param value\n @returns {boolean}\n @private\n */\nfunction isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n Tests if the given value is a number\n @param value\n @returns {boolean}\n @private\n */\nfunction isNumeric(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/**\n Tests if the given value is an ID\n @param value\n @returns {boolean}\n @private\n */\nfunction isID(value) {\n    return utils.isString(value) || utils.isNumeric(value);\n}\n\n/**\n Tests if the given components are the same, where the components can be either IDs or instances.\n @param c1\n @param c2\n @returns {boolean}\n @private\n */\nfunction isSameComponent(c1, c2) {\n    if (!c1 || !c2) {\n        return false;\n    }\n    const id1 = (utils.isNumeric(c1) || utils.isString(c1)) ? `${c1}` : c1.id;\n    const id2 = (utils.isNumeric(c2) || utils.isString(c2)) ? `${c2}` : c2.id;\n    return id1 === id2;\n}\n\n/**\n Tests if the given value is a function\n @param value\n @returns {boolean}\n @private\n */\nfunction isFunction(value) {\n    return (typeof value === \"function\");\n}\n\n/**\n Tests if the given value is a JavaScript JSON object, eg, ````{ foo: \"bar\" }````.\n @param value\n @returns {boolean}\n @private\n */\nfunction isObject(value) {\n    const objectConstructor = {}.constructor;\n    return (!!value && value.constructor === objectConstructor);\n}\n\n/** Returns a shallow copy\n */\nfunction copy(o) {\n    return utils.apply(o, {});\n}\n\n/** Add properties of o to o2, overwriting them on o2 if already there\n */\nfunction apply(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            o2[name] = o[name];\n        }\n    }\n    return o2;\n}\n\n/**\n Add non-null/defined properties of o to o2\n @private\n */\nfunction apply2(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o[name] !== undefined && o[name] !== null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Add properties of o to o2 where undefined or null on o2\n @private\n */\nfunction applyIf(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            if (o2[name] === undefined || o2[name] === null) {\n                o2[name] = o[name];\n            }\n        }\n    }\n    return o2;\n}\n\n/**\n Returns true if the given map is empty.\n @param obj\n @returns {boolean}\n @private\n */\nfunction isEmptyObject(obj) {\n    for (const name in obj) {\n        if (obj.hasOwnProperty(name)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n Returns the given ID as a string, in quotes if the ID was a string to begin with.\n\n This is useful for logging IDs.\n\n @param {Number| String} id The ID\n @returns {String}\n @private\n */\nfunction inQuotes(id) {\n    return utils.isNumeric(id) ? (`${id}`) : (`'${id}'`);\n}\n\n/**\n Returns the concatenation of two typed arrays.\n @param a\n @param b\n @returns {*|a}\n @private\n */\nfunction concat(a, b) {\n    const c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n}\n\nfunction flattenParentChildHierarchy(root) {\n    var list = [];\n\n    function visit(node) {\n        node.id = node.uuid;\n        delete node.oid;\n        list.push(node);\n        var children = node.children;\n\n        if (children) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                child.parent = node.id;\n                visit(children[i]);\n            }\n        }\n        node.children = [];\n    }\n\n    visit(root);\n    return list;\n}\n\n/**\n * @private\n */\nconst utils = {\n    xmlToJson: xmlToJson,\n    clone: clone,\n    compressGuid: compressGuid,\n    findNodeOfType: findNodeOfType,\n    timeout: timeout,\n    httpRequest: httpRequest,\n    loadJSON: loadJSON,\n    loadArraybuffer: loadArraybuffer,\n    queryString: queryString,\n    isArray: isArray,\n    isString: isString,\n    isNumeric: isNumeric,\n    isID: isID,\n    isSameComponent: isSameComponent,\n    isFunction: isFunction,\n    isObject: isObject,\n    copy: copy,\n    apply: apply,\n    apply2: apply2,\n    applyIf: applyIf,\n    isEmptyObject: isEmptyObject,\n    inQuotes: inQuotes,\n    concat: concat,\n    flattenParentChildHierarchy: flattenParentChildHierarchy\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzLmpzP2NkYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlFQUF5RSxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5RUFBeUUsRUFBRTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsZUFBZTtBQUN4QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsVUFBVSxHQUFHO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHhtbFRvSnNvbihub2RlLCBhdHRyaWJ1dGVSZW5hbWVyKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIHZhciB2ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGlmICh2Lm1hdGNoKC9eXFxzKyQvKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFIHx8XG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIganNvbiA9IHt0eXBlOiBub2RlLm5vZGVOYW1lLCBjaGlsZHJlbjogW119O1xuXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBubSA9IGF0dHJpYnV0ZVJlbmFtZXJbYXR0cmlidXRlLm5vZGVOYW1lXSB8fCBhdHRyaWJ1dGUubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAganNvbltubV0gPSBhdHRyaWJ1dGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSB4bWxUb0pzb24oaXRlbSwgYXR0cmlidXRlUmVuYW1lcik7XG4gICAgICAgICAgICBpZiAoaikganNvbi5jaGlsZHJlbi5wdXNoKGopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2IpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZ3VpZENoYXJzID0gW1tcIjBcIiwgMTBdLCBbXCJBXCIsIDI2XSwgW1wiYVwiLCAyNl0sIFtcIl9cIiwgMV0sIFtcIiRcIiwgMV1dLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBzdCA9IGFbMF0uY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZW4gPSBzdCArIGFbMV07XG4gICAgZm9yICh2YXIgaSA9IHN0OyBpIDwgZW47ICsraSkge1xuICAgICAgICBsaS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBsaSk7XG59KS5qb2luKFwiXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGI2NCh2LCBsZW4pIHtcbiAgICB2YXIgciA9ICghbGVuIHx8IGxlbiA9PT0gNCkgPyBbMCwgNiwgMTIsIDE4XSA6IFswLCA2XTtcbiAgICByZXR1cm4gci5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGd1aWRDaGFycy5zdWJzdHIocGFyc2VJbnQodiAvICgxIDw8IGkpKSAlIDY0LCAxKVxuICAgIH0pLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzR3VpZChnKSB7XG4gICAgdmFyIGJzID0gWzAsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE2LCAxOCwgMjAsIDIyLCAyNCwgMjYsIDI4LCAzMF0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChnLnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiBiNjQoYnNbMF0sIDIpICsgWzEsIDQsIDcsIDEwLCAxM10ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBiNjQoKGJzW2ldIDw8IDE2KSArIChic1tpICsgMV0gPDwgOCkgKyBic1tpICsgMl0pO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmluZE5vZGVPZlR5cGUobSwgdCkge1xuICAgIHZhciBsaSA9IFtdO1xuICAgIHZhciBfID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4udHlwZSA9PT0gdCkgbGkucHVzaChuKTtcbiAgICAgICAgKG4uY2hpbGRyZW4gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF8oYyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXyhtKTtcbiAgICByZXR1cm4gbGk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKGFyZ3MubWV0aG9kIHx8IFwiR0VUXCIsIGFyZ3MudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLnVybCwgeGhyLnJlYWR5U3RhdGUsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZVhNTCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHhoci5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYW5vbnltb3VzLCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBhbmRcbiAgICAvLyB0aGUgcmV0dXJuIHZhbHVlIGlzIGFzc2lnbmVkIHRvIFF1ZXJ5U3RyaW5nIVxuICAgIHZhciBxdWVyeV9zdHJpbmcgPSB7fTtcbiAgICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgLy8gSWYgZmlyc3QgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgICAgIC8vIElmIHNlY29uZCBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBxdWVyeV9zdHJpbmdbcGFpclswXV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbcXVlcnlfc3RyaW5nW3BhaXJbMF1dLCBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSldO1xuICAgICAgICAgICAgcXVlcnlfc3RyaW5nW3BhaXJbMF1dID0gYXJyO1xuICAgICAgICAgICAgLy8gSWYgdGhpcmQgb3IgbGF0ZXIgZW50cnkgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXS5wdXNoKGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5X3N0cmluZztcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkSlNPTih1cmwsIG9rLCBlcnIpIHtcbiAgICAvLyBBdm9pZCBjaGVja2luZyBvayBhbmQgZXJyIG9uIGVhY2ggdXNlLlxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IGV2ZW50LnRhcmdldC5yZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBqc29uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9rKGpzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcbiAgICAgICAgICAgIC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2xvYWRGaWxlOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvayhKU09OLnBhcnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyKGB1dGlscy5sb2FkSlNPTigpOiBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSAtICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycihldmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVycihldmVudCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkQXJyYXlidWZmZXIodXJsLCBvaywgZXJyKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSAoX3ZhbHVlKSA9PiB1bmRlZmluZWQ7XG4gICAgb2sgPSBvayB8fCBkZWZhdWx0Q2FsbGJhY2s7XG4gICAgZXJyID0gZXJyIHx8IGRlZmF1bHRDYWxsYmFjaztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLztcbiAgICBjb25zdCBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KTtcbiAgICBpZiAoZGF0YVVyaVJlZ2V4UmVzdWx0KSB7IC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgZGF0YSBVUklzIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgY29uc3QgaXNCYXNlNjQgPSAhIWRhdGFVcmlSZWdleFJlc3VsdFsyXTtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhVXJpUmVnZXhSZXN1bHRbM107XG4gICAgICAgIGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB3aW5kb3cuYXRvYihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlld1tpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvayhidWZmZXIpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXJyKGVycm9yKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2socmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyKCdsb2FkQXJyYXlCdWZmZXIgZXJyb3IgOiAnICsgcmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgfVxufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGFycmF5XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhKHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gVGVzdHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXJcbiBAcGFyYW0gdmFsdWVcbiBAcmV0dXJucyB7Ym9vbGVhbn1cbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJRFxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSUQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNTdHJpbmcodmFsdWUpIHx8IHV0aWxzLmlzTnVtZXJpYyh2YWx1ZSk7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiBjb21wb25lbnRzIGFyZSB0aGUgc2FtZSwgd2hlcmUgdGhlIGNvbXBvbmVudHMgY2FuIGJlIGVpdGhlciBJRHMgb3IgaW5zdGFuY2VzLlxuIEBwYXJhbSBjMVxuIEBwYXJhbSBjMlxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZUNvbXBvbmVudChjMSwgYzIpIHtcbiAgICBpZiAoIWMxIHx8ICFjMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlkMSA9ICh1dGlscy5pc051bWVyaWMoYzEpIHx8IHV0aWxzLmlzU3RyaW5nKGMxKSkgPyBgJHtjMX1gIDogYzEuaWQ7XG4gICAgY29uc3QgaWQyID0gKHV0aWxzLmlzTnVtZXJpYyhjMikgfHwgdXRpbHMuaXNTdHJpbmcoYzIpKSA/IGAke2MyfWAgOiBjMi5pZDtcbiAgICByZXR1cm4gaWQxID09PSBpZDI7XG59XG5cbi8qKlxuIFRlc3RzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gQHBhcmFtIHZhbHVlXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuXG4vKipcbiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKYXZhU2NyaXB0IEpTT04gb2JqZWN0LCBlZywgYGBgYHsgZm9vOiBcImJhclwiIH1gYGBgLlxuIEBwYXJhbSB2YWx1ZVxuIEByZXR1cm5zIHtib29sZWFufVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqZWN0Q29uc3RydWN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gKCEhdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IG9iamVjdENvbnN0cnVjdG9yKTtcbn1cblxuLyoqIFJldHVybnMgYSBzaGFsbG93IGNvcHlcbiAqL1xuZnVuY3Rpb24gY29weShvKSB7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5KG8sIHt9KTtcbn1cblxuLyoqIEFkZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzIsIG92ZXJ3cml0aW5nIHRoZW0gb24gbzIgaWYgYWxyZWFkeSB0aGVyZVxuICovXG5mdW5jdGlvbiBhcHBseShvLCBvMikge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBBZGQgbm9uLW51bGwvZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIG8gdG8gbzJcbiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcHBseTIobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG9bbmFtZV0gIT09IHVuZGVmaW5lZCAmJiBvW25hbWVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbzJbbmFtZV0gPSBvW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvMjtcbn1cblxuLyoqXG4gQWRkIHByb3BlcnRpZXMgb2YgbyB0byBvMiB3aGVyZSB1bmRlZmluZWQgb3IgbnVsbCBvbiBvMlxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SWYobywgbzIpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG8yW25hbWVdID09PSB1bmRlZmluZWQgfHwgbzJbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvMltuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yO1xufVxuXG4vKipcbiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1hcCBpcyBlbXB0eS5cbiBAcGFyYW0gb2JqXG4gQHJldHVybnMge2Jvb2xlYW59XG4gQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgZ2l2ZW4gSUQgYXMgYSBzdHJpbmcsIGluIHF1b3RlcyBpZiB0aGUgSUQgd2FzIGEgc3RyaW5nIHRvIGJlZ2luIHdpdGguXG5cbiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9nZ2luZyBJRHMuXG5cbiBAcGFyYW0ge051bWJlcnwgU3RyaW5nfSBpZCBUaGUgSURcbiBAcmV0dXJucyB7U3RyaW5nfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluUXVvdGVzKGlkKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzTnVtZXJpYyhpZCkgPyAoYCR7aWR9YCkgOiAoYCcke2lkfSdgKTtcbn1cblxuLyoqXG4gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gdHlwZWQgYXJyYXlzLlxuIEBwYXJhbSBhXG4gQHBhcmFtIGJcbiBAcmV0dXJucyB7KnxhfVxuIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgYyA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5KHJvb3QpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgICAgICBub2RlLmlkID0gbm9kZS51dWlkO1xuICAgICAgICBkZWxldGUgbm9kZS5vaWQ7XG4gICAgICAgIGxpc3QucHVzaChub2RlKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgICAgICAgICB2aXNpdChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cblxuICAgIHZpc2l0KHJvb3QpO1xuICAgIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHV0aWxzID0ge1xuICAgIHhtbFRvSnNvbjogeG1sVG9Kc29uLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBjb21wcmVzc0d1aWQ6IGNvbXByZXNzR3VpZCxcbiAgICBmaW5kTm9kZU9mVHlwZTogZmluZE5vZGVPZlR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBodHRwUmVxdWVzdDogaHR0cFJlcXVlc3QsXG4gICAgbG9hZEpTT046IGxvYWRKU09OLFxuICAgIGxvYWRBcnJheWJ1ZmZlcjogbG9hZEFycmF5YnVmZmVyLFxuICAgIHF1ZXJ5U3RyaW5nOiBxdWVyeVN0cmluZyxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc051bWVyaWM6IGlzTnVtZXJpYyxcbiAgICBpc0lEOiBpc0lELFxuICAgIGlzU2FtZUNvbXBvbmVudDogaXNTYW1lQ29tcG9uZW50LFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGNvcHk6IGNvcHksXG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIGFwcGx5MjogYXBwbHkyLFxuICAgIGFwcGx5SWY6IGFwcGx5SWYsXG4gICAgaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcbiAgICBpblF1b3RlczogaW5RdW90ZXMsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZmxhdHRlblBhcmVudENoaWxkSGllcmFyY2h5OiBmbGF0dGVuUGFyZW50Q2hpbGRIaWVyYXJjaHlcbn07XG5cbmV4cG9ydCB7dXRpbHN9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js ***!
  \***********************************************************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return Map; });\n/** @private */\nclass Map {\n\n    constructor(items, baseId) {\n        this.items = items || [];\n        this._lastUniqueId = (baseId || 0) + 1;\n    }\n\n    /**\n     * Usage:\n     *\n     * id = myMap.addItem(\"foo\") // ID internally generated\n     * id = myMap.addItem(\"foo\", \"bar\") // ID is \"foo\"\n     */\n    addItem() {\n        let item;\n        if (arguments.length === 2) {\n            const id = arguments[0];\n            item = arguments[1];\n            if (this.items[id]) { // Won't happen if given ID is string\n                throw \"ID clash: '\" + id + \"'\";\n            }\n            this.items[id] = item;\n            return id;\n\n        } else {\n            item = arguments[0] || {};\n            while (true) {\n                const findId = this._lastUniqueId++;\n                if (!this.items[findId]) {\n                    this.items[findId] = item;\n                    return findId;\n                }\n            }\n        }\n    }\n\n    removeItem(id) {\n        const item = this.items[id];\n        delete this.items[id];\n        return item;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL01hcC5qcz84ZDZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS91dGlscy9NYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmNsYXNzIE1hcCB7XG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgYmFzZUlkKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5fbGFzdFVuaXF1ZUlkID0gKGJhc2VJZCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIikgLy8gSUQgaW50ZXJuYWxseSBnZW5lcmF0ZWRcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIiwgXCJiYXJcIikgLy8gSUQgaXMgXCJmb29cIlxuICAgICAqL1xuICAgIGFkZEl0ZW0oKSB7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaWRdKSB7IC8vIFdvbid0IGhhcHBlbiBpZiBnaXZlbiBJRCBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aHJvdyBcIklEIGNsYXNoOiAnXCIgKyBpZCArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kSWQgPSB0aGlzLl9sYXN0VW5pcXVlSWQrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXNbZmluZElkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ZpbmRJZF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oaWQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1tpZF07XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js ***!
  \*************************************************************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Queue\", function() { return Queue; });\n// Fast queue that avoids using potentially inefficient array .shift() calls\n// Based on https://github.com/creationix/fastqueue\n\n/** @private */\nclass Queue {\n\n    constructor() {\n\n        this._head = [];\n        this._headLength = 0;\n        this._tail = [];\n        this._index = 0;\n        this._length = 0;\n    }\n\n    get length() {\n        return this._length;\n    }\n\n    shift() {\n        if (this._index >= this._headLength) {\n            const t = this._head;\n            t.length = 0;\n            this._head = this._tail;\n            this._tail = t;\n            this._index = 0;\n            this._headLength = this._head.length;\n            if (!this._headLength) {\n                return;\n            }\n        }\n        const value = this._head[this._index];\n        if (this._index < 0) {\n            delete this._head[this._index++];\n        }\n        else {\n            this._head[this._index++] = undefined;\n        }\n        this._length--;\n        return value;\n    }\n\n    push(item) {\n        this._length++;\n        this._tail.push(item);\n        return this;\n    };\n\n    unshift(item) {\n        this._head[--this._index] = item;\n        this._length++;\n        return this;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzP2Y5YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL1F1ZXVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRmFzdCBxdWV1ZSB0aGF0IGF2b2lkcyB1c2luZyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCBhcnJheSAuc2hpZnQoKSBjYWxsc1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NyZWF0aW9uaXgvZmFzdHF1ZXVlXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY2xhc3MgUXVldWUge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5faGVhZCA9IFtdO1xuICAgICAgICB0aGlzLl9oZWFkTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IFtdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX2hlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRMZW5ndGggPSB0aGlzLl9oZWFkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGVhZExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2hlYWRbdGhpcy5faW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZFt0aGlzLl9pbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRbdGhpcy5faW5kZXgrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHRoaXMuX3RhaWwucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHVuc2hpZnQoaXRlbSkge1xuICAgICAgICB0aGlzLl9oZWFkWy0tdGhpcy5faW5kZXhdID0gaXRlbTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHtRdWV1ZX07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Queue.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Attribute.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Attribute.js ***!
  \*****************************************************************************/
/*! exports provided: Attribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Attribute\", function() { return Attribute; });\n/**\n * @desc Represents a WebGL vertex attribute buffer (VBO).\n * @private\n * @param gl {WebGLRenderingContext} The WebGL rendering context.\n */\nclass Attribute {\n\n    constructor(gl, location) {\n        this._gl = gl;\n        this.location = location;\n    }\n\n    bindArrayBuffer(arrayBuf) {\n        if (!arrayBuf) {\n            return;\n        }\n        arrayBuf.bind();\n        this._gl.enableVertexAttribArray(this.location);\n        this._gl.vertexAttribPointer(this.location, arrayBuf.itemSize, arrayBuf.itemType, arrayBuf.normalized, arrayBuf.stride, arrayBuf.offset);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL0F0dHJpYnV0ZS5qcz8xMmE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvd2ViZ2wvQXR0cmlidXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZGVzYyBSZXByZXNlbnRzIGEgV2ViR0wgdmVydGV4IGF0dHJpYnV0ZSBidWZmZXIgKFZCTykuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAqL1xuY2xhc3MgQXR0cmlidXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLl9nbCA9IGdsO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuXG4gICAgYmluZEFycmF5QnVmZmVyKGFycmF5QnVmKSB7XG4gICAgICAgIGlmICghYXJyYXlCdWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcnJheUJ1Zi5iaW5kKCk7XG4gICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMubG9jYXRpb24pO1xuICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMubG9jYXRpb24sIGFycmF5QnVmLml0ZW1TaXplLCBhcnJheUJ1Zi5pdGVtVHlwZSwgYXJyYXlCdWYubm9ybWFsaXplZCwgYXJyYXlCdWYuc3RyaWRlLCBhcnJheUJ1Zi5vZmZzZXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtBdHRyaWJ1dGV9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Attribute.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js ***!
  \***************************************************************************/
/*! exports provided: Program */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Program\", function() { return Program; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _Shader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shader.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Shader.js\");\n/* harmony import */ var _Sampler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sampler.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Sampler.js\");\n/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Attribute.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Attribute.js\");\n\n\n\n\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\nfunction joinSansComments(srcLines) {\n    const src = [];\n    let line;\n    let n;\n    for (let i = 0, len = srcLines.length; i < len; i++) {\n        line = srcLines[i];\n        n = line.indexOf(\"/\");\n        if (n > 0) {\n            if (line.charAt(n + 1) === \"/\") {\n                line = line.substring(0, n);\n            }\n        }\n        src.push(line);\n    }\n    return src.join(\"\\n\");\n}\n\nfunction logErrors(errors) {\n    console.error(errors.join(\"\\n\"));\n}\n\n/**\n * @desc Represents a WebGL program.\n * @private\n */\nclass Program {\n\n    constructor(gl, shaderSource) {\n        this.id = ids.addItem({});\n        this.source = shaderSource;\n        this.init(gl);\n    }\n\n    init(gl) {\n        this.gl = gl;\n        this.allocated = false;\n        this.compiled = false;\n        this.linked = false;\n        this.validated = false;\n        this.errors = null;\n        this.uniforms = {};\n        this.samplers = {};\n        this.attributes = {};\n        this._vertexShader = new _Shader_js__WEBPACK_IMPORTED_MODULE_1__[\"Shader\"](gl, gl.VERTEX_SHADER, joinSansComments(this.source.vertex));\n        this._fragmentShader = new _Shader_js__WEBPACK_IMPORTED_MODULE_1__[\"Shader\"](gl, gl.FRAGMENT_SHADER, joinSansComments(this.source.fragment));\n        if (!this._vertexShader.allocated) {\n            this.errors = [\"Vertex shader failed to allocate\"].concat(this._vertexShader.errors);\n            logErrors(this.errors);\n            return;\n        }\n        if (!this._fragmentShader.allocated) {\n            this.errors = [\"Fragment shader failed to allocate\"].concat(this._fragmentShader.errors);\n            logErrors(this.errors);\n            return;\n        }\n        this.allocated = true;\n        if (!this._vertexShader.compiled) {\n            this.errors = [\"Vertex shader failed to compile\"].concat(this._vertexShader.errors);\n            logErrors(this.errors);\n            return;\n        }\n        if (!this._fragmentShader.compiled) {\n            this.errors = [\"Fragment shader failed to compile\"].concat(this._fragmentShader.errors);\n            logErrors(this.errors);\n            return;\n        }\n        this.compiled = true;\n        let a;\n        let i;\n        let u;\n        let uName;\n        let location;\n        this.handle = gl.createProgram();\n        if (!this.handle) {\n            this.errors = [\"Failed to allocate program\"];\n            return;\n        }\n        gl.attachShader(this.handle, this._vertexShader.handle);\n        gl.attachShader(this.handle, this._fragmentShader.handle);\n        gl.linkProgram(this.handle);\n        this.linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n        // HACK: Disable validation temporarily: https://github.com/xeolabs/xeokit/issues/5\n        // Perhaps we should defer validation until render-time, when the program has values set for all inputs?\n        this.validated = true;\n        if (!this.linked || !this.validated) {\n            this.errors = [];\n            this.errors.push(\"\");\n            this.errors.push(gl.getProgramInfoLog(this.handle));\n            this.errors.push(\"\\nVertex shader:\\n\");\n            this.errors = this.errors.concat(this.source.vertex);\n            this.errors.push(\"\\nFragment shader:\\n\");\n            this.errors = this.errors.concat(this.source.fragment);\n            logErrors(this.errors);\n            return;\n        }\n        const numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n        for (i = 0; i < numUniforms; ++i) {\n            u = gl.getActiveUniform(this.handle, i);\n            if (u) {\n                uName = u.name;\n                if (uName[uName.length - 1] === \"\\u0000\") {\n                    uName = uName.substr(0, uName.length - 1);\n                }\n                location = gl.getUniformLocation(this.handle, uName);\n                if ((u.type === gl.SAMPLER_2D) || (u.type === gl.SAMPLER_CUBE) || (u.type === 35682)) {\n                    this.samplers[uName] = new _Sampler_js__WEBPACK_IMPORTED_MODULE_2__[\"Sampler\"](gl, location);\n                } else {\n                    this.uniforms[uName] = location;\n                }\n            }\n        }\n        const numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n        for (i = 0; i < numAttribs; i++) {\n            a = gl.getActiveAttrib(this.handle, i);\n            if (a) {\n                location = gl.getAttribLocation(this.handle, a.name);\n                this.attributes[a.name] = new _Attribute_js__WEBPACK_IMPORTED_MODULE_3__[\"Attribute\"](gl, location);\n            }\n        }\n        this.allocated = true;\n    }\n\n    bind() {\n        if (!this.allocated) {\n            return;\n        }\n        this.gl.useProgram(this.handle);\n    }\n\n    getLocation(name) {\n        if (!this.allocated) {\n            return;\n        }\n        return this.uniforms[name];\n    }\n\n    getAttribute(name) {\n        if (!this.allocated) {\n            return;\n        }\n        return this.attributes[name];\n    }\n\n    bindTexture(name, texture, unit) {\n        if (!this.allocated) {\n            return false;\n        }\n        const sampler = this.samplers[name];\n        if (sampler) {\n            return sampler.bindTexture(texture, unit);\n        } else {\n            return false;\n        }\n    }\n\n    destroy() {\n        if (!this.allocated) {\n            return;\n        }\n        ids.removeItem(this.id);\n        this.gl.deleteProgram(this.handle);\n        this.gl.deleteShader(this._vertexShader.handle);\n        this.gl.deleteShader(this._fragmentShader.handle);\n        this.handle = null;\n        this.attributes = null;\n        this.uniforms = null;\n        this.samplers = null;\n        this.allocated = false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1Byb2dyYW0uanM/OWFiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0M7QUFDRDtBQUNFO0FBQ0k7O0FBRXpDLGdCQUFnQixpREFBRyxHQUFHOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFNO0FBQ3ZDLG1DQUFtQyxpREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbURBQU87QUFDdEQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1REFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1Byb2dyYW0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcH0gZnJvbSBcIi4uL3V0aWxzL01hcC5qc1wiO1xuaW1wb3J0IHtTaGFkZXJ9IGZyb20gXCIuL1NoYWRlci5qc1wiO1xuaW1wb3J0IHtTYW1wbGVyfSBmcm9tIFwiLi9TYW1wbGVyLmpzXCI7XG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSBcIi4vQXR0cmlidXRlLmpzXCI7XG5cbmNvbnN0IGlkcyA9IG5ldyBNYXAoe30pO1xuXG5mdW5jdGlvbiBqb2luU2Fuc0NvbW1lbnRzKHNyY0xpbmVzKSB7XG4gICAgY29uc3Qgc3JjID0gW107XG4gICAgbGV0IGxpbmU7XG4gICAgbGV0IG47XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNyY0xpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmUgPSBzcmNMaW5lc1tpXTtcbiAgICAgICAgbiA9IGxpbmUuaW5kZXhPZihcIi9cIik7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KG4gKyAxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3JjLnB1c2gobGluZSk7XG4gICAgfVxuICAgIHJldHVybiBzcmMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3JzKGVycm9ycykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xufVxuXG4vKipcbiAqIEBkZXNjIFJlcHJlc2VudHMgYSBXZWJHTCBwcm9ncmFtLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJvZ3JhbSB7XG5cbiAgICBjb25zdHJ1Y3RvcihnbCwgc2hhZGVyU291cmNlKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZHMuYWRkSXRlbSh7fSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc2hhZGVyU291cmNlO1xuICAgICAgICB0aGlzLmluaXQoZ2wpO1xuICAgIH1cblxuICAgIGluaXQoZ2wpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlua2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgICAgICB0aGlzLnNhbXBsZXJzID0ge307XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCBqb2luU2Fuc0NvbW1lbnRzKHRoaXMuc291cmNlLnZlcnRleCkpO1xuICAgICAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IG5ldyBTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgam9pblNhbnNDb21tZW50cyh0aGlzLnNvdXJjZS5mcmFnbWVudCkpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcnRleFNoYWRlci5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gW1wiVmVydGV4IHNoYWRlciBmYWlsZWQgdG8gYWxsb2NhdGVcIl0uY29uY2F0KHRoaXMuX3ZlcnRleFNoYWRlci5lcnJvcnMpO1xuICAgICAgICAgICAgbG9nRXJyb3JzKHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50U2hhZGVyLmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXCJGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGFsbG9jYXRlXCJdLmNvbmNhdCh0aGlzLl9mcmFnbWVudFNoYWRlci5lcnJvcnMpO1xuICAgICAgICAgICAgbG9nRXJyb3JzKHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5fdmVydGV4U2hhZGVyLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IFtcIlZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGVcIl0uY29uY2F0KHRoaXMuX3ZlcnRleFNoYWRlci5lcnJvcnMpO1xuICAgICAgICAgICAgbG9nRXJyb3JzKHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50U2hhZGVyLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IFtcIkZyYWdtZW50IHNoYWRlciBmYWlsZWQgdG8gY29tcGlsZVwiXS5jb25jYXQodGhpcy5fZnJhZ21lbnRTaGFkZXIuZXJyb3JzKTtcbiAgICAgICAgICAgIGxvZ0Vycm9ycyh0aGlzLmVycm9ycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlZCA9IHRydWU7XG4gICAgICAgIGxldCBhO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHU7XG4gICAgICAgIGxldCB1TmFtZTtcbiAgICAgICAgbGV0IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXCJGYWlsZWQgdG8gYWxsb2NhdGUgcHJvZ3JhbVwiXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIHRoaXMuX3ZlcnRleFNoYWRlci5oYW5kbGUpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5oYW5kbGUsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLmhhbmRsZSk7XG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgdGhpcy5saW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBnbC5MSU5LX1NUQVRVUyk7XG4gICAgICAgIC8vIEhBQ0s6IERpc2FibGUgdmFsaWRhdGlvbiB0ZW1wb3JhcmlseTogaHR0cHM6Ly9naXRodWIuY29tL3hlb2xhYnMveGVva2l0L2lzc3Vlcy81XG4gICAgICAgIC8vIFBlcmhhcHMgd2Ugc2hvdWxkIGRlZmVyIHZhbGlkYXRpb24gdW50aWwgcmVuZGVyLXRpbWUsIHdoZW4gdGhlIHByb2dyYW0gaGFzIHZhbHVlcyBzZXQgZm9yIGFsbCBpbnB1dHM/XG4gICAgICAgIHRoaXMudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmtlZCB8fCAhdGhpcy52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChnbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLmhhbmRsZSkpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChcIlxcblZlcnRleCBzaGFkZXI6XFxuXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zb3VyY2UudmVydGV4KTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goXCJcXG5GcmFnbWVudCBzaGFkZXI6XFxuXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zb3VyY2UuZnJhZ21lbnQpO1xuICAgICAgICAgICAgbG9nRXJyb3JzKHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5oYW5kbGUsIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Vbmlmb3JtczsgKytpKSB7XG4gICAgICAgICAgICB1ID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSh0aGlzLmhhbmRsZSwgaSk7XG4gICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgIHVOYW1lID0gdS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICh1TmFtZVt1TmFtZS5sZW5ndGggLSAxXSA9PT0gXCJcXHUwMDAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdU5hbWUgPSB1TmFtZS5zdWJzdHIoMCwgdU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuaGFuZGxlLCB1TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCh1LnR5cGUgPT09IGdsLlNBTVBMRVJfMkQpIHx8ICh1LnR5cGUgPT09IGdsLlNBTVBMRVJfQ1VCRSkgfHwgKHUudHlwZSA9PT0gMzU2ODIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlcnNbdU5hbWVdID0gbmV3IFNhbXBsZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zW3VOYW1lXSA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1BdHRyaWJzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLmhhbmRsZSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQXR0cmliczsgaSsrKSB7XG4gICAgICAgICAgICBhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHRoaXMuaGFuZGxlLCBpKTtcbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLmhhbmRsZSwgYS5uYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYS5uYW1lXSA9IG5ldyBBdHRyaWJ1dGUoZ2wsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgYmluZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG4gICAgfVxuXG4gICAgZ2V0TG9jYXRpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgfVxuXG4gICAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgfVxuXG4gICAgYmluZFRleHR1cmUobmFtZSwgdGV4dHVyZSwgdW5pdCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHRoaXMuc2FtcGxlcnNbbmFtZV07XG4gICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlci5iaW5kVGV4dHVyZSh0ZXh0dXJlLCB1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZHMucmVtb3ZlSXRlbSh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodGhpcy5fdmVydGV4U2hhZGVyLmhhbmRsZSk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHRoaXMuX2ZyYWdtZW50U2hhZGVyLmhhbmRsZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FtcGxlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHtQcm9ncmFtfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Program.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderFlags.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderFlags.js ***!
  \*******************************************************************************/
/*! exports provided: RenderFlags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderFlags\", function() { return RenderFlags; });\n/**\n * Indicates what rendering needs to be done for the layers within a {@link Drawable}.\n *\n * Each Drawable has a RenderFlags in {@link Drawable#renderFlags}.\n *\n * Before rendering each frame, {@link Renderer} will call {@link Drawable#rebuildRenderFlags} on each {@link Drawable}.\n *\n * Then, when rendering a frame, Renderer will apply rendering passes to each Drawable according on what flags are set in {@link Drawable#renderFlags}.\n *\n * @private\n */\nclass RenderFlags {\n\n    /**\n     * @private\n     */\n    constructor() {\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate which layers are visible within the {@link Drawable}.\n         *\n         * This is a list of IDs of visible layers within the {@link Drawable}. The IDs will be whatever the\n         * {@link Drawable} uses to identify its layers, usually integers.\n         *\n         * @property visibleLayers\n         * @type {Number[]}\n         */\n        this.visibleLayers = [];\n\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate which {@link SectionPlane}s are active within each layer of the {@link Drawable}.\n         *\n         * Layout is as follows:\n         *\n         * ````[\n         *      false, false, true, // Layer 0, SectionPlanes 0, 1, 2\n         *      false, true, true,  // Layer 1, SectionPlanes 0, 1, 2\n         *      true, false, true   // Layer 2, SectionPlanes 0, 1, 2\n         * ]````\n         *\n         * @property sectionPlanesActivePerLayer\n         * @type {Boolean[]}\n         */\n        this.sectionPlanesActivePerLayer = [];\n\n        this.reset();\n    }\n\n    /**\n     * @private\n     */\n    reset() {\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is culled.\n         * \n         * When this is ````false````, then all of the other properties on ````RenderFlags```` will remain at their default values.\n         * \n         * @property culled\n         * @type {Boolean}\n         */\n        this.culled = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate whether the {@link Drawable} is sliced by any {@link SectionPlane}s.\n         *\n         * @property sectioned\n         * @type {Boolean}\n         */\n        this.sectioned  = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of layers within the {@link Drawable}.\n         *\n         * @property numLayers\n         * @type {Number}\n         */\n        this.numLayers = 0;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the number of visible layers within the {@link Drawable}.\n         *\n         * @property numVisibleLayers\n         * @type {Number}\n         */\n        this.numVisibleLayers = 0;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorOpaque}.\n         * @property colorOpaque\n         * @type {boolean}\n         */\n        this.colorOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawColorTransparent}.\n         * @property colorTransparent\n         * @type {boolean}\n         */\n        this.colorTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorOpaque}.\n         * @property edgesOpaque\n         * @type {boolean}\n         */\n        this.edgesOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs {@link Drawable#drawEdgesColorTransparent}.\n         * @property edgesTransparent\n         * @type {boolean}\n         */\n        this.edgesTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteXRayed}.\n         * @property xrayedSilhouetteOpaque\n         * @type {boolean}\n         */\n        this.xrayedSilhouetteOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesXRayed}.\n         * @property xrayedEdgesOpaque\n         * @type {boolean}\n         */\n        this.xrayedEdgesOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteXRayed}.\n         * @property xrayedSilhouetteTransparent\n         * @type {boolean}\n         */\n        this.xrayedSilhouetteTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesXRayed}.\n         * @property xrayedEdgesTransparent\n         * @type {boolean}\n         */\n        this.xrayedEdgesTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteHighlighted}.\n         * @property highlightedSilhouetteOpaque\n         * @type {boolean}\n         */\n        this.highlightedSilhouetteOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesHighlighted}.\n         * @property highlightedEdgesOpaque\n         * @type {boolean}\n         */\n        this.highlightedEdgesOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteHighlighted}.\n         * @property highlightedSilhouetteTransparent\n         * @type {boolean}\n         */\n        this.highlightedSilhouetteTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesHighlighted}.\n         * @property highlightedEdgesTransparent\n         * @type {boolean}\n         */\n        this.highlightedEdgesTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawSilhouetteSelected}.\n         * @property selectedSilhouetteOpaque\n         * @type {boolean}\n         */\n        this.selectedSilhouetteOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs an opaque {@link Drawable#drawEdgesSelected}.\n         * @property selectedEdgesOpaque\n         * @type {boolean}\n         */\n        this.selectedEdgesOpaque = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawSilhouetteSelected}.\n         * @property selectedSilhouetteTransparent\n         * @type {boolean}\n         */\n        this.selectedSilhouetteTransparent = false;\n\n        /**\n         * Set by {@link Drawable#rebuildRenderFlags} to indicate the {@link Drawable} needs a transparent {@link Drawable#drawEdgesSelected}.\n         * @property selectedEdgesTransparent\n         * @type {boolean}\n         */\n        this.selectedEdgesTransparent = false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1JlbmRlckZsYWdzLmpzPzY3MzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0EsaUNBQWlDLGVBQWUsWUFBWSxrQ0FBa0MsVUFBVSxlQUFlO0FBQ3ZIO0FBQ0EsMkhBQTJILDJCQUEyQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0RBQWtELGVBQWU7QUFDdEg7QUFDQSwrREFBK0QsZUFBZTtBQUM5RSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOzs7QUFHQTtBQUNBLG1CQUFtQixrQ0FBa0Msb0JBQW9CLG1CQUFtQix1Q0FBdUMsZUFBZTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLDBCQUEwQixlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLDBCQUEwQixlQUFlLG1CQUFtQixtQkFBbUI7QUFDcEk7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQyw4Q0FBOEMsZUFBZTtBQUNsSDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLHNEQUFzRCxlQUFlO0FBQzFIO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsUUFBUSwrQkFBK0I7QUFDN0g7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsUUFBUSxvQ0FBb0M7QUFDbEk7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsUUFBUSxvQ0FBb0M7QUFDbEk7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsUUFBUSx5Q0FBeUM7QUFDdkk7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsa0JBQWtCLG9DQUFvQztBQUM1STtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQyxrQkFBa0IsZUFBZSxrQkFBa0IsK0JBQStCO0FBQ3ZJO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLGtCQUFrQixlQUFlLHNCQUFzQixvQ0FBb0M7QUFDaEo7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsc0JBQXNCLCtCQUErQjtBQUMzSTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQyxrQkFBa0IsZUFBZSxrQkFBa0IseUNBQXlDO0FBQ2pKO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLGtCQUFrQixlQUFlLGtCQUFrQixvQ0FBb0M7QUFDNUk7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsc0JBQXNCLHlDQUF5QztBQUNySjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQyxrQkFBa0IsZUFBZSxzQkFBc0Isb0NBQW9DO0FBQ2hKO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLGtCQUFrQixlQUFlLGtCQUFrQixzQ0FBc0M7QUFDOUk7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0Msa0JBQWtCLGVBQWUsa0JBQWtCLGlDQUFpQztBQUN6STtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQyxrQkFBa0IsZUFBZSxzQkFBc0Isc0NBQXNDO0FBQ2xKO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0NBQWtDLGtCQUFrQixlQUFlLHNCQUFzQixpQ0FBaUM7QUFDN0k7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvd2ViZ2wvUmVuZGVyRmxhZ3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEluZGljYXRlcyB3aGF0IHJlbmRlcmluZyBuZWVkcyB0byBiZSBkb25lIGZvciB0aGUgbGF5ZXJzIHdpdGhpbiBhIHtAbGluayBEcmF3YWJsZX0uXG4gKlxuICogRWFjaCBEcmF3YWJsZSBoYXMgYSBSZW5kZXJGbGFncyBpbiB7QGxpbmsgRHJhd2FibGUjcmVuZGVyRmxhZ3N9LlxuICpcbiAqIEJlZm9yZSByZW5kZXJpbmcgZWFjaCBmcmFtZSwge0BsaW5rIFJlbmRlcmVyfSB3aWxsIGNhbGwge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gb24gZWFjaCB7QGxpbmsgRHJhd2FibGV9LlxuICpcbiAqIFRoZW4sIHdoZW4gcmVuZGVyaW5nIGEgZnJhbWUsIFJlbmRlcmVyIHdpbGwgYXBwbHkgcmVuZGVyaW5nIHBhc3NlcyB0byBlYWNoIERyYXdhYmxlIGFjY29yZGluZyBvbiB3aGF0IGZsYWdzIGFyZSBzZXQgaW4ge0BsaW5rIERyYXdhYmxlI3JlbmRlckZsYWdzfS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSZW5kZXJGbGFncyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgd2hpY2ggbGF5ZXJzIGFyZSB2aXNpYmxlIHdpdGhpbiB0aGUge0BsaW5rIERyYXdhYmxlfS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIGxpc3Qgb2YgSURzIG9mIHZpc2libGUgbGF5ZXJzIHdpdGhpbiB0aGUge0BsaW5rIERyYXdhYmxlfS4gVGhlIElEcyB3aWxsIGJlIHdoYXRldmVyIHRoZVxuICAgICAgICAgKiB7QGxpbmsgRHJhd2FibGV9IHVzZXMgdG8gaWRlbnRpZnkgaXRzIGxheWVycywgdXN1YWxseSBpbnRlZ2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHZpc2libGVMYXllcnNcbiAgICAgICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlTGF5ZXJzID0gW107XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHdoaWNoIHtAbGluayBTZWN0aW9uUGxhbmV9cyBhcmUgYWN0aXZlIHdpdGhpbiBlYWNoIGxheWVyIG9mIHRoZSB7QGxpbmsgRHJhd2FibGV9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBMYXlvdXQgaXMgYXMgZm9sbG93czpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgYFtcbiAgICAgICAgICogICAgICBmYWxzZSwgZmFsc2UsIHRydWUsIC8vIExheWVyIDAsIFNlY3Rpb25QbGFuZXMgMCwgMSwgMlxuICAgICAgICAgKiAgICAgIGZhbHNlLCB0cnVlLCB0cnVlLCAgLy8gTGF5ZXIgMSwgU2VjdGlvblBsYW5lcyAwLCAxLCAyXG4gICAgICAgICAqICAgICAgdHJ1ZSwgZmFsc2UsIHRydWUgICAvLyBMYXllciAyLCBTZWN0aW9uUGxhbmVzIDAsIDEsIDJcbiAgICAgICAgICogXWBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHNlY3Rpb25QbGFuZXNBY3RpdmVQZXJMYXllclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbltdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWN0aW9uUGxhbmVzQWN0aXZlUGVyTGF5ZXIgPSBbXTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZXNldCgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIHtAbGluayBEcmF3YWJsZX0gaXMgY3VsbGVkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogV2hlbiB0aGlzIGlzIGBgYGBmYWxzZWBgYGAsIHRoZW4gYWxsIG9mIHRoZSBvdGhlciBwcm9wZXJ0aWVzIG9uIGBgYGBSZW5kZXJGbGFnc2BgYGAgd2lsbCByZW1haW4gYXQgdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcHJvcGVydHkgY3VsbGVkXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdWxsZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIHtAbGluayBEcmF3YWJsZX0gaXMgc2xpY2VkIGJ5IGFueSB7QGxpbmsgU2VjdGlvblBsYW5lfXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzZWN0aW9uZWRcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlY3Rpb25lZCAgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSBudW1iZXIgb2YgbGF5ZXJzIHdpdGhpbiB0aGUge0BsaW5rIERyYXdhYmxlfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG51bUxheWVyc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5udW1MYXllcnMgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgdGhlIG51bWJlciBvZiB2aXNpYmxlIGxheWVycyB3aXRoaW4gdGhlIHtAbGluayBEcmF3YWJsZX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBudW1WaXNpYmxlTGF5ZXJzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm51bVZpc2libGVMYXllcnMgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgdGhlIHtAbGluayBEcmF3YWJsZX0gbmVlZHMge0BsaW5rIERyYXdhYmxlI2RyYXdDb2xvck9wYXF1ZX0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb2xvck9wYXF1ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3JPcGFxdWUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIHtAbGluayBEcmF3YWJsZSNkcmF3Q29sb3JUcmFuc3BhcmVudH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb2xvclRyYW5zcGFyZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvclRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBieSB7QGxpbmsgRHJhd2FibGUjcmVidWlsZFJlbmRlckZsYWdzfSB0byBpbmRpY2F0ZSB0aGUge0BsaW5rIERyYXdhYmxlfSBuZWVkcyB7QGxpbmsgRHJhd2FibGUjZHJhd0VkZ2VzQ29sb3JPcGFxdWV9LlxuICAgICAgICAgKiBAcHJvcGVydHkgZWRnZXNPcGFxdWVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkZ2VzT3BhcXVlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBieSB7QGxpbmsgRHJhd2FibGUjcmVidWlsZFJlbmRlckZsYWdzfSB0byBpbmRpY2F0ZSB0aGUge0BsaW5rIERyYXdhYmxlfSBuZWVkcyB7QGxpbmsgRHJhd2FibGUjZHJhd0VkZ2VzQ29sb3JUcmFuc3BhcmVudH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlZGdlc1RyYW5zcGFyZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGdlc1RyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBieSB7QGxpbmsgRHJhd2FibGUjcmVidWlsZFJlbmRlckZsYWdzfSB0byBpbmRpY2F0ZSB0aGUge0BsaW5rIERyYXdhYmxlfSBuZWVkcyBhbiBvcGFxdWUge0BsaW5rIERyYXdhYmxlI2RyYXdTaWxob3VldHRlWFJheWVkfS5cbiAgICAgICAgICogQHByb3BlcnR5IHhyYXllZFNpbGhvdWV0dGVPcGFxdWVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnhyYXllZFNpbGhvdWV0dGVPcGFxdWUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGFuIG9wYXF1ZSB7QGxpbmsgRHJhd2FibGUjZHJhd0VkZ2VzWFJheWVkfS5cbiAgICAgICAgICogQHByb3BlcnR5IHhyYXllZEVkZ2VzT3BhcXVlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54cmF5ZWRFZGdlc09wYXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgdGhlIHtAbGluayBEcmF3YWJsZX0gbmVlZHMgYSB0cmFuc3BhcmVudCB7QGxpbmsgRHJhd2FibGUjZHJhd1NpbGhvdWV0dGVYUmF5ZWR9LlxuICAgICAgICAgKiBAcHJvcGVydHkgeHJheWVkU2lsaG91ZXR0ZVRyYW5zcGFyZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54cmF5ZWRTaWxob3VldHRlVHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGEgdHJhbnNwYXJlbnQge0BsaW5rIERyYXdhYmxlI2RyYXdFZGdlc1hSYXllZH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB4cmF5ZWRFZGdlc1RyYW5zcGFyZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54cmF5ZWRFZGdlc1RyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBieSB7QGxpbmsgRHJhd2FibGUjcmVidWlsZFJlbmRlckZsYWdzfSB0byBpbmRpY2F0ZSB0aGUge0BsaW5rIERyYXdhYmxlfSBuZWVkcyBhbiBvcGFxdWUge0BsaW5rIERyYXdhYmxlI2RyYXdTaWxob3VldHRlSGlnaGxpZ2h0ZWR9LlxuICAgICAgICAgKiBAcHJvcGVydHkgaGlnaGxpZ2h0ZWRTaWxob3VldHRlT3BhcXVlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZFNpbGhvdWV0dGVPcGFxdWUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGFuIG9wYXF1ZSB7QGxpbmsgRHJhd2FibGUjZHJhd0VkZ2VzSGlnaGxpZ2h0ZWR9LlxuICAgICAgICAgKiBAcHJvcGVydHkgaGlnaGxpZ2h0ZWRFZGdlc09wYXF1ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRFZGdlc09wYXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgdGhlIHtAbGluayBEcmF3YWJsZX0gbmVlZHMgYSB0cmFuc3BhcmVudCB7QGxpbmsgRHJhd2FibGUjZHJhd1NpbGhvdWV0dGVIaWdobGlnaHRlZH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBoaWdobGlnaHRlZFNpbGhvdWV0dGVUcmFuc3BhcmVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRTaWxob3VldHRlVHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGEgdHJhbnNwYXJlbnQge0BsaW5rIERyYXdhYmxlI2RyYXdFZGdlc0hpZ2hsaWdodGVkfS5cbiAgICAgICAgICogQHByb3BlcnR5IGhpZ2hsaWdodGVkRWRnZXNUcmFuc3BhcmVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRFZGdlc1RyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBieSB7QGxpbmsgRHJhd2FibGUjcmVidWlsZFJlbmRlckZsYWdzfSB0byBpbmRpY2F0ZSB0aGUge0BsaW5rIERyYXdhYmxlfSBuZWVkcyBhbiBvcGFxdWUge0BsaW5rIERyYXdhYmxlI2RyYXdTaWxob3VldHRlU2VsZWN0ZWR9LlxuICAgICAgICAgKiBAcHJvcGVydHkgc2VsZWN0ZWRTaWxob3VldHRlT3BhcXVlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZFNpbGhvdWV0dGVPcGFxdWUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGFuIG9wYXF1ZSB7QGxpbmsgRHJhd2FibGUjZHJhd0VkZ2VzU2VsZWN0ZWR9LlxuICAgICAgICAgKiBAcHJvcGVydHkgc2VsZWN0ZWRFZGdlc09wYXF1ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlc09wYXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYnkge0BsaW5rIERyYXdhYmxlI3JlYnVpbGRSZW5kZXJGbGFnc30gdG8gaW5kaWNhdGUgdGhlIHtAbGluayBEcmF3YWJsZX0gbmVlZHMgYSB0cmFuc3BhcmVudCB7QGxpbmsgRHJhd2FibGUjZHJhd1NpbGhvdWV0dGVTZWxlY3RlZH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzZWxlY3RlZFNpbGhvdWV0dGVUcmFuc3BhcmVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTaWxob3VldHRlVHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGJ5IHtAbGluayBEcmF3YWJsZSNyZWJ1aWxkUmVuZGVyRmxhZ3N9IHRvIGluZGljYXRlIHRoZSB7QGxpbmsgRHJhd2FibGV9IG5lZWRzIGEgdHJhbnNwYXJlbnQge0BsaW5rIERyYXdhYmxlI2RyYXdFZGdlc1NlbGVjdGVkfS5cbiAgICAgICAgICogQHByb3BlcnR5IHNlbGVjdGVkRWRnZXNUcmFuc3BhcmVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFZGdlc1RyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQge1JlbmRlckZsYWdzfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderFlags.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js ***!
  \*******************************************************************************/
/*! exports provided: RenderState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderState\", function() { return RenderState; });\n/* harmony import */ var _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n\n\nconst ids = new _utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]({});\n\n/**\n * @desc Represents a chunk of state changes applied by the {@link Scene}'s renderer while it renders a frame.\n *\n * * Contains properties that represent the state changes.\n * * Has a unique automatically-generated numeric ID, which the renderer can use to sort these, in order to avoid applying redundant state changes for each frame.\n * * Initialize your own properties on a RenderState via its constructor.\n *\n * @private\n */\nclass RenderState {\n\n    constructor(cfg) {\n\n        /**\n         The RenderState's ID, unique within the renderer.\n         @property id\n         @type {Number}\n         @final\n         */\n        this.id = ids.addItem({});\n        for (const key in cfg) {\n            if (cfg.hasOwnProperty(key)) {\n                this[key] = cfg[key];\n            }\n        }\n    }\n\n    /**\n     Destroys this RenderState.\n     */\n    destroy() {\n        ids.removeItem(this.id);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1JlbmRlclN0YXRlLmpzP2I1MWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW9DOztBQUVwQyxnQkFBZ0IsaURBQUcsR0FBRzs7QUFFdEI7QUFDQSw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS93ZWJnbC9SZW5kZXJTdGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWFwfSBmcm9tIFwiLi4vdXRpbHMvTWFwLmpzXCI7XG5cbmNvbnN0IGlkcyA9IG5ldyBNYXAoe30pO1xuXG4vKipcbiAqIEBkZXNjIFJlcHJlc2VudHMgYSBjaHVuayBvZiBzdGF0ZSBjaGFuZ2VzIGFwcGxpZWQgYnkgdGhlIHtAbGluayBTY2VuZX0ncyByZW5kZXJlciB3aGlsZSBpdCByZW5kZXJzIGEgZnJhbWUuXG4gKlxuICogKiBDb250YWlucyBwcm9wZXJ0aWVzIHRoYXQgcmVwcmVzZW50IHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICogKiBIYXMgYSB1bmlxdWUgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgbnVtZXJpYyBJRCwgd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiB1c2UgdG8gc29ydCB0aGVzZSwgaW4gb3JkZXIgdG8gYXZvaWQgYXBwbHlpbmcgcmVkdW5kYW50IHN0YXRlIGNoYW5nZXMgZm9yIGVhY2ggZnJhbWUuXG4gKiAqIEluaXRpYWxpemUgeW91ciBvd24gcHJvcGVydGllcyBvbiBhIFJlbmRlclN0YXRlIHZpYSBpdHMgY29uc3RydWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUmVuZGVyU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoY2ZnKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBUaGUgUmVuZGVyU3RhdGUncyBJRCwgdW5pcXVlIHdpdGhpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgICBAcHJvcGVydHkgaWRcbiAgICAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBpZHMuYWRkSXRlbSh7fSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNmZykge1xuICAgICAgICAgICAgaWYgKGNmZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gY2ZnW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgRGVzdHJveXMgdGhpcyBSZW5kZXJTdGF0ZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZHMucmVtb3ZlSXRlbSh0aGlzLmlkKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7UmVuZGVyU3RhdGV9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/RenderState.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Sampler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Sampler.js ***!
  \***************************************************************************/
/*! exports provided: Sampler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sampler\", function() { return Sampler; });\n/**\n * @desc A low-level component that represents a WebGL Sampler.\n * @private\n */\nclass Sampler {\n\n    constructor(gl, location) {\n        this.bindTexture = function (texture, unit) {\n            if (texture.bind(unit)) {\n                gl.uniform1i(location, unit);\n                return true;\n            }\n            return false;\n        };\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1NhbXBsZXIuanM/MzkyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS93ZWJnbC9TYW1wbGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZGVzYyBBIGxvdy1sZXZlbCBjb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGEgV2ViR0wgU2FtcGxlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNhbXBsZXIge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYmluZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgdW5pdCkge1xuICAgICAgICAgICAgaWYgKHRleHR1cmUuYmluZCh1bml0KSkge1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdW5pdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQge1NhbXBsZXJ9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Sampler.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Shader.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Shader.js ***!
  \**************************************************************************/
/*! exports provided: Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shader\", function() { return Shader; });\n/**\n * @desc Represents a vertex or fragment stage within a {@link Program}.\n * @private\n */\nclass Shader {\n\n    constructor(gl, type, source) {\n\n        this.allocated = false;\n        this.compiled = false;\n        this.handle = gl.createShader(type);\n\n        if (!this.handle) {\n            this.errors = [\n                \"Failed to allocate\"\n            ];\n            return;\n        }\n\n        this.allocated = true;\n\n        gl.shaderSource(this.handle, source);\n        gl.compileShader(this.handle);\n\n        this.compiled = gl.getShaderParameter(this.handle, gl.COMPILE_STATUS);\n\n        if (!this.compiled) {\n\n            if (!gl.isContextLost()) { // Handled explicitly elsewhere, so won't re-handle here\n\n                const lines = source.split(\"\\n\");\n                const numberedLines = [];\n                for (let i = 0; i < lines.length; i++) {\n                    numberedLines.push((i + 1) + \": \" + lines[i] + \"\\n\");\n                }\n                this.errors = [];\n                this.errors.push(\"\");\n                this.errors.push(gl.getShaderInfoLog(this.handle));\n                this.errors = this.errors.concat(numberedLines.join(\"\"));\n            }\n        }\n    }\n\n    destroy() {\n\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsL1NoYWRlci5qcz83ZGU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS93ZWJnbC9TaGFkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBkZXNjIFJlcHJlc2VudHMgYSB2ZXJ0ZXggb3IgZnJhZ21lbnQgc3RhZ2Ugd2l0aGluIGEge0BsaW5rIFByb2dyYW19LlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB0eXBlLCBzb3VyY2UpIHtcblxuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gW1xuICAgICAgICAgICAgICAgIFwiRmFpbGVkIHRvIGFsbG9jYXRlXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFsbG9jYXRlZCA9IHRydWU7XG5cbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHRoaXMuaGFuZGxlLCBzb3VyY2UpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHRoaXMuaGFuZGxlKTtcblxuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG5cbiAgICAgICAgICAgIGlmICghZ2wuaXNDb250ZXh0TG9zdCgpKSB7IC8vIEhhbmRsZWQgZXhwbGljaXRseSBlbHNld2hlcmUsIHNvIHdvbid0IHJlLWhhbmRsZSBoZXJlXG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJlZExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJlZExpbmVzLnB1c2goKGkgKyAxKSArIFwiOiBcIiArIGxpbmVzW2ldICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGdsLmdldFNoYWRlckluZm9Mb2codGhpcy5oYW5kbGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLmNvbmNhdChudW1iZXJlZExpbmVzLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IHtTaGFkZXJ9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webgl/Shader.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js ***!
  \***********************************************************************/
/*! exports provided: WEBGL_INFO */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WEBGL_INFO\", function() { return WEBGL_INFO; });\n/**\n * @private\n * @type {{WEBGL: boolean, SUPPORTED_EXTENSIONS: {}}}\n */\nconst WEBGL_INFO = {\n    WEBGL: false,\n    SUPPORTED_EXTENSIONS: {}\n};\n\nconst canvas = document.createElement(\"canvas\");\n\nif (canvas) {\n\n    const gl = canvas.getContext(\"webgl\", {antialias: true}) || canvas.getContext(\"experimental-webgl\", {antialias: true});\n\n    WEBGL_INFO.WEBGL = !!gl;\n\n    if (WEBGL_INFO.WEBGL) {\n        WEBGL_INFO.ANTIALIAS = gl.getContextAttributes().antialias;\n        if (gl.getShaderPrecisionFormat) {\n            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n                WEBGL_INFO.FS_MAX_FLOAT_PRECISION = \"highp\";\n            } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n                WEBGL_INFO.FS_MAX_FLOAT_PRECISION = \"mediump\";\n            } else {\n                WEBGL_INFO.FS_MAX_FLOAT_PRECISION = \"lowp\";\n            }\n        } else {\n            WEBGL_INFO.FS_MAX_FLOAT_PRECISION = \"mediump\";\n        }\n        WEBGL_INFO.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);\n        WEBGL_INFO.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n        WEBGL_INFO.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n        WEBGL_INFO.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n        WEBGL_INFO.MAX_TEXTURE_UNITS = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        WEBGL_INFO.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        WEBGL_INFO.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        WEBGL_INFO.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        WEBGL_INFO.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);\n        gl.getSupportedExtensions().forEach(function (ext) {\n            WEBGL_INFO.SUPPORTED_EXTENSIONS[ext] = true;\n        });\n        WEBGL_INFO.depthTexturesSupported = WEBGL_INFO.SUPPORTED_EXTENSIONS[\"WEBGL_depth_texture\"];\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3dlYmdsSW5mby5qcz82YzUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLGdCQUFnQiw4Q0FBOEMsZ0JBQWdCOztBQUV6SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy92aWV3ZXIvc2NlbmUvd2ViZ2xJbmZvLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge3tXRUJHTDogYm9vbGVhbiwgU1VQUE9SVEVEX0VYVEVOU0lPTlM6IHt9fX1cbiAqL1xuY29uc3QgV0VCR0xfSU5GTyA9IHtcbiAgICBXRUJHTDogZmFsc2UsXG4gICAgU1VQUE9SVEVEX0VYVEVOU0lPTlM6IHt9XG59O1xuXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG5pZiAoY2FudmFzKSB7XG5cbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwge2FudGlhbGlhczogdHJ1ZX0pIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHthbnRpYWxpYXM6IHRydWV9KTtcblxuICAgIFdFQkdMX0lORk8uV0VCR0wgPSAhIWdsO1xuXG4gICAgaWYgKFdFQkdMX0lORk8uV0VCR0wpIHtcbiAgICAgICAgV0VCR0xfSU5GTy5BTlRJQUxJQVMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFudGlhbGlhcztcbiAgICAgICAgaWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLnByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBXRUJHTF9JTkZPLkZTX01BWF9GTE9BVF9QUkVDSVNJT04gPSBcImhpZ2hwXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uID4gMCkge1xuICAgICAgICAgICAgICAgIFdFQkdMX0lORk8uRlNfTUFYX0ZMT0FUX1BSRUNJU0lPTiA9IFwibWVkaXVtcFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBXRUJHTF9JTkZPLkZTX01BWF9GTE9BVF9QUkVDSVNJT04gPSBcImxvd3BcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFdFQkdMX0lORk8uRlNfTUFYX0ZMT0FUX1BSRUNJU0lPTiA9IFwibWVkaXVtcFwiO1xuICAgICAgICB9XG4gICAgICAgIFdFQkdMX0lORk8uREVQVEhfQlVGRkVSX0JJVFMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuREVQVEhfQklUUyk7XG4gICAgICAgIFdFQkdMX0lORk8uTUFYX1RFWFRVUkVfU0laRSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgICAgV0VCR0xfSU5GTy5NQVhfQ1VCRV9NQVBfU0laRSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKTtcbiAgICAgICAgV0VCR0xfSU5GTy5NQVhfUkVOREVSQlVGRkVSX1NJWkUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1JFTkRFUkJVRkZFUl9TSVpFKTtcbiAgICAgICAgV0VCR0xfSU5GTy5NQVhfVEVYVFVSRV9VTklUUyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgICAgIFdFQkdMX0lORk8uTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgICAgICBXRUJHTF9JTkZPLk1BWF9WRVJURVhfQVRUUklCUyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuICAgICAgICBXRUJHTF9JTkZPLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKTtcbiAgICAgICAgV0VCR0xfSU5GTy5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpO1xuICAgICAgICBXRUJHTF9JTkZPLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyk7XG4gICAgICAgIGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICAgIFdFQkdMX0lORk8uU1VQUE9SVEVEX0VYVEVOU0lPTlNbZXh0XSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBXRUJHTF9JTkZPLmRlcHRoVGV4dHVyZXNTdXBwb3J0ZWQgPSBXRUJHTF9JTkZPLlNVUFBPUlRFRF9FWFRFTlNJT05TW1wiV0VCR0xfZGVwdGhfdGV4dHVyZVwiXTtcbiAgICB9XG59XG5cbmV4cG9ydCB7V0VCR0xfSU5GT307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/webglInfo.js\n");

/***/ })

}]);