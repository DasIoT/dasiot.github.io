(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[7],{

/***/ "./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/ModelTreeView.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/ModelTreeView.js ***!
  \*************************************************************************************/
/*! exports provided: ModelTreeView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ModelTreeView\", function() { return ModelTreeView; });\n/* harmony import */ var _viewer_scene_utils_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../../viewer/scene/utils/Map.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\");\n/* harmony import */ var _modelValidation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modelValidation.js */ \"./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/modelValidation.js\");\n\n\n\nconst idMap = new _viewer_scene_utils_Map_js__WEBPACK_IMPORTED_MODULE_0__[\"Map\"]();\n\n/**\n * @desc Represents a model tree view within a {@link TreeViewPlugin}.\n *\n * * Stored in {@link treeViewPlugin#modelTreeViews}, mapped to the model ID.\n * * Created by each call to {@link TreeViewPlugin#addModel}.\n */\nclass ModelTreeView {\n\n    /**\n     * @private\n     */\n    constructor(viewer, treeViewPlugin, model, metaModel, cfg) {\n\n        if (!cfg.containerElement) {\n            throw \"Config expected: containerElement\";\n        }\n\n        const rootMetaObject = metaModel.rootMetaObject;\n        if (!rootMetaObject) {\n            return;\n        }\n\n        /**\n         * Contains messages for any errors found in the MetaModel for this ModelTreeView.\n         * @type {String[]}\n         */\n        this.errors = [];\n\n        /**\n         * True if errors were found in the MetaModel for this ModelTreeView.\n         * @type {boolean}\n         */\n        this.valid = true;\n\n        /**\n         * The MetaModel corresponding to this ModelTreeView.\n         * @type {MetaModel}\n         */\n        this.metaModel = metaModel;\n\n        this._id = idMap.addItem();\n        this._baseId = \"\" + this._id;\n        this._viewer = viewer;\n        this._treeViewPlugin = treeViewPlugin;\n        this._rootMetaObject = rootMetaObject;\n        this._containerElement = cfg.containerElement;\n        this._rootElement = null;\n        this._muteSceneEvents = false;\n        this._muteTreeEvents = false;\n        this._rootNodes = [];\n        this._objectNodes = {};\n        this._rootName = cfg.rootName;\n        this._sortNodes = cfg.sortNodes;\n        this._pruneEmptyNodes = cfg.pruneEmptyNodes;\n\n        this._showListItemElementId = null;\n\n        this._containerElement.oncontextmenu = (e) => {\n            e.preventDefault();\n        };\n\n        this._onObjectVisibility = this._viewer.scene.on(\"objectVisibility\", (entity) => {\n            if (this._muteSceneEvents) {\n                return;\n            }\n            const objectId = entity.id;\n            const node = this._objectNodes[objectId];\n            if (!node) {\n                return; // Not in this tree\n            }\n            const visible = entity.visible;\n            const updated = (visible !== node.checked);\n            if (!updated) {\n                return;\n            }\n            this._muteTreeEvents = true;\n            node.checked = visible;\n            if (visible) {\n                node.numVisibleEntities++;\n            } else {\n                node.numVisibleEntities--;\n            }\n            const checkbox = document.getElementById(node.nodeId);\n            if (checkbox) {\n                checkbox.checked = visible;\n            }\n            let parent = node.parent;\n            while (parent) {\n                parent.checked = visible;\n                if (visible) {\n                    parent.numVisibleEntities++;\n                } else {\n                    parent.numVisibleEntities--;\n                }\n                const parentCheckbox = document.getElementById(parent.nodeId);\n                if (parentCheckbox) {\n                    const newChecked = (parent.numVisibleEntities > 0);\n                    if (newChecked !== parentCheckbox.checked) {\n                        parentCheckbox.checked = newChecked;\n                    }\n                }\n                parent = parent.parent;\n            }\n            this._muteTreeEvents = false;\n        });\n\n        this.switchExpandHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            const switchElement = event.target;\n            this._expandSwitchElement(switchElement);\n        };\n\n        this.switchCollapseHandler = (event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            const switchElement = event.target;\n            this._collapseSwitchElement(switchElement);\n        };\n\n        this._checkboxChangeHandler = (event) => {\n            if (this._muteTreeEvents) {\n                return;\n            }\n            this._muteSceneEvents = true;\n            const checkbox = event.target;\n            const visible = checkbox.checked;\n            const nodeId = checkbox.id;\n            const checkedObjectId = this._nodeToObjectID(nodeId);\n            const checkedNode = this._objectNodes[checkedObjectId];\n            const objects = this._viewer.scene.objects;\n            let numUpdated = 0;\n            this._withNodeTree(checkedNode, (node) => {\n                const objectId = node.objectId;\n                const checkBoxId = node.nodeId;\n                const entity = objects[objectId];\n                const isLeaf = (node.children.length === 0);\n                node.numVisibleEntities = visible ? node.numEntities : 0;\n                if (isLeaf && (visible !== node.checked)) {\n                    numUpdated++;\n                }\n                node.checked = visible;\n                const checkbox2 = document.getElementById(checkBoxId);\n                if (checkbox2) {\n                    checkbox2.checked = visible;\n                }\n                if (entity) {\n                    entity.visible = visible;\n                }\n            });\n            let parent = checkedNode.parent;\n            while (parent) {\n                parent.checked = visible;\n                const checkbox2 = document.getElementById(parent.nodeId); // Parent checkboxes are always in DOM\n                if (visible) {\n                    parent.numVisibleEntities += numUpdated;\n                } else {\n                    parent.numVisibleEntities -= numUpdated;\n                }\n                const newChecked = (parent.numVisibleEntities > 0);\n                if (newChecked !== checkbox2.checked) {\n                    checkbox2.checked = newChecked;\n                }\n                parent = parent.parent;\n            }\n            this._muteSceneEvents = false;\n        };\n\n        this._hierarchy = cfg.hierarchy || \"containment\";\n        this._autoExpandDepth = cfg.autoExpandDepth || 0;\n\n        this._createNodes();\n    }\n\n    _nodeToObjectID(nodeId) {\n        return nodeId.substring(this._baseId.length);\n    }\n\n    _objectToNodeID(objectId) {\n        return this._baseId + objectId;\n    }\n\n    /**\n     * @private\n     * @param depth\n     */\n    setAutoExpandDepth(depth = 0) {\n        this._autoExpandDepth = depth;\n    }\n\n    /**\n     * @private\n     * @param hierarchy\n     */\n    setHierarchy(hierarchy) {\n        if (this._hierarchy === hierarchy) {\n            return;\n        }\n        this._hierarchy = hierarchy;\n        this._createNodes();\n    }\n\n    _createNodes() {\n        if (this._rootElement) {\n            this._rootElement.parentNode.removeChild(this._rootElement);\n            this._rootElement = null;\n        }\n        this._rootNodes = [];\n        this._objectNodes = {};\n        this._validate();\n        if (this.valid) {\n            this._createEnabledNodes();\n        } else {\n            this._createDisabledNodes();\n        }\n    }\n\n    _validate() {\n        this.errors = [];\n        switch (this._hierarchy) {\n            case \"storeys\":\n                this.valid = Object(_modelValidation_js__WEBPACK_IMPORTED_MODULE_1__[\"validateMetaModelForTreeViewStoreysHierarchy\"])(this.metaModel, this.errors);\n                break;\n            case \"types\":\n                this.valid = Object(_modelValidation_js__WEBPACK_IMPORTED_MODULE_1__[\"validateMetaModelForTreeViewTypesHierarchy\"])(this.metaModel, this.errors);\n                break;\n            case \"containment\":\n            default:\n                this.valid = Object(_modelValidation_js__WEBPACK_IMPORTED_MODULE_1__[\"validateMetaModelForTreeViewContainmentHierarchy\"])(this.metaModel, this.errors);\n                break;\n        }\n        return this.valid;\n    }\n\n    _createEnabledNodes() {\n        if (this._pruneEmptyNodes) {\n            this._findEmptyNodes();\n        }\n        switch (this._hierarchy) {\n            case \"storeys\":\n                this._createStoreysNodes();\n                if (this._rootNodes.length === 0) {\n                    this._treeViewPlugin.error(\"Failed to build storeys hierarchy for model '\" + this.metaModel.id + \"' - perhaps this model is not an IFC model?\");\n                }\n                break;\n            case \"types\":\n                this._createTypesNodes();\n                break;\n            case \"containment\":\n            default:\n                this._createContainmentNodes();\n        }\n        if (this._sortNodes) {\n            this._doSortNodes();\n        }\n        this._synchNodesToEntities();\n        this._createTrees();\n        this.expandToDepth(this._autoExpandDepth);\n    }\n\n    _createDisabledNodes() {\n\n        const metaObject = this._rootMetaObject;\n        const metaObjectType = metaObject.type;\n        const metaObjectName = metaObject.name;\n\n        const rootName = ((metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType);\n\n        const ul = document.createElement('ul');\n        const li = document.createElement('li');\n        ul.appendChild(li);\n        this._containerElement.appendChild(ul);\n        this._rootElement = ul;\n\n        const switchElement = document.createElement('a');\n        switchElement.href = '#';\n        switchElement.textContent = '!';\n        switchElement.classList.add('warn');\n        switchElement.classList.add('warning');\n        li.appendChild(switchElement);\n\n        const span = document.createElement('span');\n        span.textContent = rootName;\n        li.appendChild(span);\n    }\n\n    _findEmptyNodes(metaObject = this._rootMetaObject, countEntities = 0) {\n        const viewer = this._treeViewPlugin.viewer;\n        const scene = viewer.scene;\n        const children = metaObject.children;\n        const objectId = metaObject.id;\n        const entity = scene.objects[objectId];\n        metaObject._countEntities = 0;\n        if (entity) {\n            metaObject._countEntities++;\n        }\n        if (children) {\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childMetaObject = children[i];\n                childMetaObject._countEntities = this._findEmptyNodes(childMetaObject);\n                metaObject._countEntities += childMetaObject._countEntities;\n            }\n        }\n        return metaObject._countEntities;\n    }\n\n    _createStoreysNodes(\n        metaObject = this._rootMetaObject,\n        buildingNode,\n        storeyNode,\n        typeNodes) {\n        if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {\n            return;\n        }\n        const metaObjectType = metaObject.type;\n        const metaObjectName = metaObject.name;\n        const children = metaObject.children;\n        const objectId = metaObject.id;\n        if (metaObjectType === \"IfcBuilding\") {\n            buildingNode = {\n                nodeId: this._objectToNodeID(objectId),\n                objectId: objectId,\n                title: this._rootName || ((metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType),\n                type: metaObjectType,\n                parent: null,\n                numEntities: 0,\n                numVisibleEntities: 0,\n                checked: false,\n                children: []\n            };\n            this._rootNodes.push(buildingNode);\n            this._objectNodes[buildingNode.objectId] = buildingNode;\n        } else if (metaObjectType === \"IfcBuildingStorey\") {\n            if (!buildingNode) {\n                this._treeViewPlugin.error(\"Failed to build storeys hierarchy for model '\" + this.metaModel.id + \"' - model does not have an IfcBuilding object, or is not an IFC model\");\n                return;\n            }\n            storeyNode = {\n                nodeId: this._objectToNodeID(objectId),\n                objectId: objectId,\n                title: (metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType,\n                type: metaObjectType,\n                parent: buildingNode,\n                numEntities: 0,\n                numVisibleEntities: 0,\n                checked: false,\n                children: []\n            };\n            buildingNode.children.push(storeyNode);\n            this._objectNodes[storeyNode.objectId] = storeyNode;\n            typeNodes = {};\n        } else {\n            if (storeyNode) {\n                const objects = this._viewer.scene.objects;\n                const object = objects[objectId];\n                if (object) {\n                    typeNodes = typeNodes || {};\n                    let typeNode = typeNodes[metaObjectType];\n                    if (!typeNode) {\n                        const typeNodeObjectId = storeyNode.objectId + \".\" + metaObjectType;\n                        const typeNodeNodeId = this._objectToNodeID(typeNodeObjectId);\n                        typeNode = {\n                            nodeId: typeNodeNodeId,\n                            objectId: typeNodeObjectId,\n                            title: metaObjectType,\n                            type: metaObjectType,\n                            parent: storeyNode,\n                            numEntities: 0,\n                            numVisibleEntities: 0,\n                            checked: false,\n                            children: []\n                        };\n                        storeyNode.children.push(typeNode);\n                        this._objectNodes[typeNodeObjectId] = typeNode;\n                        typeNodes[metaObjectType] = typeNode;\n                    }\n                    const node = {\n                        nodeId: this._objectToNodeID(objectId),\n                        objectId: objectId,\n                        title: (metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType,\n                        type: metaObjectType,\n                        parent: typeNode,\n                        numEntities: 0,\n                        numVisibleEntities: 0,\n                        checked: false,\n                        children: []\n                    };\n                    typeNode.children.push(node);\n                    this._objectNodes[node.objectId] = node;\n                }\n            }\n        }\n        if (children) {\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childMetaObject = children[i];\n                this._createStoreysNodes(childMetaObject, buildingNode, storeyNode, typeNodes);\n            }\n        }\n    }\n\n    _createTypesNodes(metaObject = this._rootMetaObject, rootNode, typeNodes) {\n        if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {\n            return;\n        }\n        const metaObjectType = metaObject.type;\n        const metaObjectName = metaObject.name;\n        const children = metaObject.children;\n        const objectId = metaObject.id;\n        if (metaObject.id === this._rootMetaObject.id) {\n            rootNode = {\n                nodeId: this._objectToNodeID(objectId),\n                objectId: objectId,\n                title: this._rootName || ((metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType),\n                type: metaObjectType,\n                parent: null,\n                numEntities: 0,\n                numVisibleEntities: 0,\n                checked: false,\n                children: []\n            };\n            this._rootNodes.push(rootNode);\n            this._objectNodes[rootNode.objectId] = rootNode;\n            typeNodes = {};\n        } else {\n            if (rootNode) {\n                const objects = this._viewer.scene.objects;\n                const object = objects[objectId];\n                if (object) {\n                    let typeNode = typeNodes[metaObjectType];\n                    if (!typeNode) {\n                        typeNode = {\n                            nodeId: this._objectToNodeID(rootNode.objectId + \".\" + metaObjectType),\n                            objectId: rootNode.objectId + \".\" + metaObjectType,\n                            title: metaObjectType,\n                            type: metaObjectType,\n                            parent: rootNode,\n                            numEntities: 0,\n                            numVisibleEntities: 0,\n                            checked: false,\n                            children: []\n                        };\n                        rootNode.children.push(typeNode);\n                        this._objectNodes[typeNode.objectId] = typeNode;\n                        typeNodes[metaObjectType] = typeNode;\n                    }\n                    const node = {\n                        nodeId: this._objectToNodeID(objectId),\n                        objectId: objectId,\n                        title: (metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType,\n                        type: metaObjectType,\n                        parent: typeNode,\n                        numEntities: 0,\n                        numVisibleEntities: 0,\n                        checked: false,\n                        children: []\n                    };\n                    typeNode.children.push(node);\n                    this._objectNodes[node.objectId] = node;\n                }\n            }\n        }\n        if (children) {\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childMetaObject = children[i];\n                this._createTypesNodes(childMetaObject, rootNode, typeNodes);\n            }\n        }\n    }\n\n    _createContainmentNodes(metaObject = this._rootMetaObject, parent) {\n        if (this._pruneEmptyNodes && (metaObject._countEntities === 0)) {\n            return;\n        }\n        const metaObjectType = metaObject.type;\n        const metaObjectName = metaObject.name || metaObjectType;\n        const children = metaObject.children;\n        const objectId = metaObject.id;\n        const node = {\n            nodeId: this._objectToNodeID(objectId),\n            objectId: objectId,\n            title: (!parent) ? (this._rootName || metaObjectName) : (metaObjectName && metaObjectName !== \"\" && metaObjectName !== \"Undefined\" && metaObjectName !== \"Default\") ? metaObjectName : metaObjectType,\n            type: metaObjectType,\n            parent: parent,\n            numEntities: 0,\n            numVisibleEntities: 0,\n            checked: false,\n            children: []\n        };\n        if (parent) {\n            parent.children.push(node);\n        } else {\n            this._rootNodes.push(node);\n        }\n        this._objectNodes[node.objectId] = node;\n\n        if (children) {\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childMetaObject = children[i];\n                this._createContainmentNodes(childMetaObject, node);\n            }\n        }\n    }\n\n    _doSortNodes() {\n        for (let i = 0, len = this._rootNodes.length; i < len; i++) {\n            const rootNode = this._rootNodes[i];\n            this._sortChildren(rootNode);\n        }\n    }\n\n    _sortChildren(node) {\n        const children = node.children;\n        if (!children || children.length === 0) {\n            return;\n        }\n        if (this._hierarchy === \"storeys\" && node.type === \"IfcBuilding\") {\n            // Assumes that children of an IfcBuilding will always be IfcBuildingStoreys\n            children.sort(this._getSpatialSortFunc());\n        } else {\n            children.sort(this._alphaSortFunc);\n        }\n        for (let i = 0, len = children.length; i < len; i++) {\n            const node = children[i];\n            this._sortChildren(node);\n        }\n    }\n\n    _getSpatialSortFunc() { // Creates cached sort func with Viewer in scope\n        const viewer = this._treeViewPlugin.viewer;\n        const scene = viewer.scene;\n        const camera = scene.camera;\n        const metaScene = viewer.metaScene;\n        return this._spatialSortFunc || (this._spatialSortFunc = (node1, node2) => {\n            if (!node1.aabb || !node2.aabb) {\n                // Sorting on lowest point of the AABB is likely more more robust when objects could overlap storeys\n                if (!node1.aabb) {\n                    node1.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node1.objectId));\n                }\n                if (!node2.aabb) {\n                    node2.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node2.objectId));\n                }\n            }\n            let idx = 0;\n            if (camera.xUp) {\n                idx = 0;\n            } else if (camera.yUp) {\n                idx = 1;\n            } else {\n                idx = 2;\n            }\n            if (node1.aabb[idx] > node2.aabb[idx]) {\n                return -1;\n            }\n            if (node1.aabb[idx] < node2.aabb[idx]) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    _alphaSortFunc(node1, node2) {\n        const title1 = node1.title.toUpperCase(); // FIXME: Should be case sensitive?\n        const title2 = node2.title.toUpperCase();\n        if (title1 < title2) {\n            return -1;\n        }\n        if (title1 > title2) {\n            return 1;\n        }\n        return 0;\n    }\n\n    _synchNodesToEntities() {\n        const rootMetaObject = this._rootMetaObject;\n        const objectIds = rootMetaObject.getObjectIDsInSubtree();\n        const metaObjects = this._viewer.metaScene.metaObjects;\n        const objects = this._viewer.scene.objects;\n        for (let i = 0, len = objectIds.length; i < len; i++) {\n            const objectId = objectIds[i];\n            const metaObject = metaObjects[objectId];\n            if (metaObject) {\n                const node = this._objectNodes[objectId];\n                if (node) {\n                    const entity = objects[objectId];\n                    if (entity) {\n                        const visible = entity.visible;\n                        node.numEntities = 1;\n                        if (visible) {\n                            node.numVisibleEntities = 1;\n                            node.checked = true;\n                        } else {\n                            node.numVisibleEntities = 0;\n                            node.checked = false;\n                        }\n                        let parent = node.parent; // Synch parents\n                        while (parent) {\n                            parent.numEntities++;\n                            if (visible) {\n                                parent.numVisibleEntities++;\n                                parent.checked = true;\n                            }\n                            parent = parent.parent;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    _withNodeTree(node, callback) {\n        callback(node);\n        const children = node.children;\n        if (!children) {\n            return;\n        }\n        for (let i = 0, len = children.length; i < len; i++) {\n            this._withNodeTree(children[i], callback);\n        }\n    }\n\n    _createTrees() {\n        if (this._rootNodes.length === 0) {\n            return;\n        }\n        const rootNodeElements = this._rootNodes.map((rootNode) => {\n            return this._createNodeElement(rootNode);\n        });\n        const ul = document.createElement('ul');\n        rootNodeElements.forEach((nodeElement) => {\n            ul.appendChild(nodeElement);\n        });\n        this._containerElement.appendChild(ul);\n        this._rootElement = ul;\n    }\n\n    _createNodeElement(node) {\n        const nodeElement = document.createElement('li');\n        //const nodeId = this._objectToNodeID(node.objectId);\n        const nodeId = node.nodeId;\n        nodeElement.id = 'node-' + nodeId;\n        if (node.children.length > 0) {\n            const switchElementId = \"switch-\" + nodeId;\n            const switchElement = document.createElement('a');\n            switchElement.href = '#';\n            switchElement.id = switchElementId;\n            switchElement.textContent = '+';\n            switchElement.classList.add('plus');\n            switchElement.addEventListener('click', this.switchExpandHandler);\n            nodeElement.appendChild(switchElement);\n        }\n        const checkbox = document.createElement('input');\n        checkbox.id = nodeId;\n        checkbox.type = \"checkbox\";\n        checkbox.checked = node.checked;\n        checkbox.style[\"pointer-events\"] = \"all\";\n        checkbox.addEventListener(\"change\", this._checkboxChangeHandler);\n        nodeElement.appendChild(checkbox);\n        const span = document.createElement('span');\n        span.textContent = node.title;\n        nodeElement.appendChild(span);\n        span.oncontextmenu = (e) => {\n            this._treeViewPlugin.fire(\"contextmenu\", {\n                event: e,\n                viewer: this._viewer,\n                treeViewPlugin: this._treeViewPlugin,\n                treeViewNode: node\n            });\n            e.preventDefault();\n        };\n        span.onclick = (e) => {\n            this._treeViewPlugin.fire(\"nodeTitleClicked\", {\n                event: e,\n                viewer: this._viewer,\n                treeViewPlugin: this._treeViewPlugin,\n                treeViewNode: node\n            });\n            e.preventDefault();\n        };\n        return nodeElement;\n    }\n\n    /**\n     * @private\n     * @param depth\n     */\n    expandToDepth(depth) {\n        const expand = (node, countDepth) => {\n            if (countDepth === depth) {\n                return;\n            }\n            const nodeId = node.nodeId;\n            const switchElementId = \"switch-\" + nodeId;\n            const switchElement = document.getElementById(switchElementId);\n            if (switchElement) {\n                this._expandSwitchElement(switchElement);\n                const childNodes = node.children;\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    const childNode = childNodes[i];\n                    expand(childNode, countDepth + 1);\n                }\n            }\n        };\n        for (let i = 0, len = this._rootNodes.length; i < len; i++) {\n            const rootNode = this._rootNodes[i];\n            expand(rootNode, 0);\n        }\n    }\n\n    /**\n     * @private\n     */\n    collapse() {\n        for (let i = 0, len = this._rootNodes.length; i < len; i++) {\n            const rootNode = this._rootNodes[i];\n            const objectId = rootNode.objectId;\n            this._collapseNode(objectId);\n        }\n    }\n\n    /**\n     * @private\n     * @param objectId\n     */\n    showNode(objectId) {\n        if (this._showListItemElementId) {\n            this.unShowNode();\n        }\n        const node = this._objectNodes[objectId];\n        if (!node) {\n            return; // Node may not exist for the given object if (this._pruneEmptyNodes == true)\n        }\n        const nodeId = node.nodeId;\n        const switchElementId = \"switch-\" + nodeId;\n        const switchElement = document.getElementById(switchElementId);\n        if (switchElement) {\n            this._expandSwitchElement(switchElement);\n            switchElement.scrollIntoView();\n            return;\n        }\n        const path = [];\n        path.unshift(node);\n        let parent = node.parent;\n        while (parent) {\n            path.unshift(parent);\n            parent = parent.parent;\n        }\n        for (let i = 0, len = path.length; i < len; i++) {\n            const node = path[i];\n            const nodeId = node.nodeId;\n            const switchElementId = \"switch-\" + nodeId;\n            const switchElement = document.getElementById(switchElementId);\n            if (switchElement) {\n                this._expandSwitchElement(switchElement);\n            }\n        }\n        const listItemElementId = 'node-' + nodeId;\n        const listItemElement = document.getElementById(listItemElementId);\n        listItemElement.scrollIntoView({block: \"center\"});\n        listItemElement.classList.add(\"highlighted-node\");\n        this._showListItemElementId = listItemElementId;\n    }\n\n    /**\n     * @private\n     */\n    unShowNode() {\n        if (!this._showListItemElementId) {\n            return;\n        }\n        const listItemElement = document.getElementById(this._showListItemElementId);\n        if (!listItemElement) {\n            this._showListItemElementId = null;\n            return;\n        }\n        listItemElement.classList.remove(\"highlighted-node\");\n        this._showListItemElementId = null;\n    }\n\n    _expandSwitchElement(switchElement) {\n        const parentElement = switchElement.parentElement;\n        const expanded = parentElement.getElementsByTagName('li')[0];\n        if (expanded) {\n            return;\n        }\n        const nodeId = parentElement.id.replace('node-', '');\n        const objectId = this._nodeToObjectID(nodeId);\n        const switchNode = this._objectNodes[objectId];\n        const childNodes = switchNode.children;\n        const nodeElements = childNodes.map((node) => {\n            return this._createNodeElement(node);\n        });\n        const ul = document.createElement('ul');\n        nodeElements.forEach((nodeElement) => {\n            ul.appendChild(nodeElement);\n        });\n        parentElement.appendChild(ul);\n        switchElement.classList.remove('plus');\n        switchElement.classList.add('minus');\n        switchElement.textContent = '-';\n        switchElement.removeEventListener('click', this.switchExpandHandler);\n        switchElement.addEventListener('click', this.switchCollapseHandler);\n    }\n\n    _collapseNode(objectId) {\n        const nodeId = this._objectToNodeID(objectId);\n        const switchElementId = \"switch-\" + nodeId;\n        const switchElement = document.getElementById(switchElementId);\n        this._collapseSwitchElement(switchElement);\n    }\n\n    _collapseSwitchElement(switchElement) {\n        if (!switchElement) {\n            return;\n        }\n        const parent = switchElement.parentElement;\n        if (!parent) {\n            return;\n        }\n        const ul = parent.querySelector('ul');\n        if (!ul) {\n            return;\n        }\n        parent.removeChild(ul);\n        switchElement.classList.remove('minus');\n        switchElement.classList.add('plus');\n        switchElement.textContent = '+';\n        switchElement.removeEventListener('click', this.switchCollapseHandler);\n        switchElement.addEventListener('click', this.switchExpandHandler);\n    }\n\n    /**\n     * Destroys this ModelTreeView.\n     * @private\n     */\n    destroy() {\n        if (this._rootElement && !this._destroyed) {\n            this._rootElement.parentNode.removeChild(this._rootElement);\n            this._viewer.scene.off(this._onObjectVisibility);\n            this._destroyed = true;\n            idMap.removeItem(this._id);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9UcmVlVmlld1BsdWdpbi9Nb2RlbFRyZWVWaWV3LmpzP2Q4ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBc0Q7QUFJeEI7O0FBRTlCLGtCQUFrQiw4REFBRzs7QUFFckI7QUFDQSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRCw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0dBQTRDO0FBQ3pFO0FBQ0E7QUFDQSw2QkFBNkIsc0dBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0R0FBZ0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHhlb2tpdC94ZW9raXQtc2RrL3NyYy9wbHVnaW5zL1RyZWVWaWV3UGx1Z2luL01vZGVsVHJlZVZpZXcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcH0gZnJvbSBcIi4vLi4vLi4vdmlld2VyL3NjZW5lL3V0aWxzL01hcC5qc1wiO1xuaW1wb3J0IHtcbiAgICB2YWxpZGF0ZU1ldGFNb2RlbEZvclRyZWVWaWV3Q29udGFpbm1lbnRIaWVyYXJjaHksXG4gICAgdmFsaWRhdGVNZXRhTW9kZWxGb3JUcmVlVmlld1N0b3JleXNIaWVyYXJjaHksIHZhbGlkYXRlTWV0YU1vZGVsRm9yVHJlZVZpZXdUeXBlc0hpZXJhcmNoeVxufSBmcm9tIFwiLi9tb2RlbFZhbGlkYXRpb24uanNcIjtcblxuY29uc3QgaWRNYXAgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQGRlc2MgUmVwcmVzZW50cyBhIG1vZGVsIHRyZWUgdmlldyB3aXRoaW4gYSB7QGxpbmsgVHJlZVZpZXdQbHVnaW59LlxuICpcbiAqICogU3RvcmVkIGluIHtAbGluayB0cmVlVmlld1BsdWdpbiNtb2RlbFRyZWVWaWV3c30sIG1hcHBlZCB0byB0aGUgbW9kZWwgSUQuXG4gKiAqIENyZWF0ZWQgYnkgZWFjaCBjYWxsIHRvIHtAbGluayBUcmVlVmlld1BsdWdpbiNhZGRNb2RlbH0uXG4gKi9cbmNsYXNzIE1vZGVsVHJlZVZpZXcge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIHRyZWVWaWV3UGx1Z2luLCBtb2RlbCwgbWV0YU1vZGVsLCBjZmcpIHtcblxuICAgICAgICBpZiAoIWNmZy5jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvbmZpZyBleHBlY3RlZDogY29udGFpbmVyRWxlbWVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm9vdE1ldGFPYmplY3QgPSBtZXRhTW9kZWwucm9vdE1ldGFPYmplY3Q7XG4gICAgICAgIGlmICghcm9vdE1ldGFPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyBtZXNzYWdlcyBmb3IgYW55IGVycm9ycyBmb3VuZCBpbiB0aGUgTWV0YU1vZGVsIGZvciB0aGlzIE1vZGVsVHJlZVZpZXcuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgZXJyb3JzIHdlcmUgZm91bmQgaW4gdGhlIE1ldGFNb2RlbCBmb3IgdGhpcyBNb2RlbFRyZWVWaWV3LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTWV0YU1vZGVsIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBNb2RlbFRyZWVWaWV3LlxuICAgICAgICAgKiBAdHlwZSB7TWV0YU1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXRhTW9kZWwgPSBtZXRhTW9kZWw7XG5cbiAgICAgICAgdGhpcy5faWQgPSBpZE1hcC5hZGRJdGVtKCk7XG4gICAgICAgIHRoaXMuX2Jhc2VJZCA9IFwiXCIgKyB0aGlzLl9pZDtcbiAgICAgICAgdGhpcy5fdmlld2VyID0gdmlld2VyO1xuICAgICAgICB0aGlzLl90cmVlVmlld1BsdWdpbiA9IHRyZWVWaWV3UGx1Z2luO1xuICAgICAgICB0aGlzLl9yb290TWV0YU9iamVjdCA9IHJvb3RNZXRhT2JqZWN0O1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gY2ZnLmNvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXV0ZVNjZW5lRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX211dGVUcmVlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9vYmplY3ROb2RlcyA9IHt9O1xuICAgICAgICB0aGlzLl9yb290TmFtZSA9IGNmZy5yb290TmFtZTtcbiAgICAgICAgdGhpcy5fc29ydE5vZGVzID0gY2ZnLnNvcnROb2RlcztcbiAgICAgICAgdGhpcy5fcHJ1bmVFbXB0eU5vZGVzID0gY2ZnLnBydW5lRW1wdHlOb2RlcztcblxuICAgICAgICB0aGlzLl9zaG93TGlzdEl0ZW1FbGVtZW50SWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQub25jb250ZXh0bWVudSA9IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fb25PYmplY3RWaXNpYmlsaXR5ID0gdGhpcy5fdmlld2VyLnNjZW5lLm9uKFwib2JqZWN0VmlzaWJpbGl0eVwiLCAoZW50aXR5KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbXV0ZVNjZW5lRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0SWQgPSBlbnRpdHkuaWQ7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fb2JqZWN0Tm9kZXNbb2JqZWN0SWRdO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBOb3QgaW4gdGhpcyB0cmVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlID0gZW50aXR5LnZpc2libGU7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gKHZpc2libGUgIT09IG5vZGUuY2hlY2tlZCk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tdXRlVHJlZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICBub2RlLmNoZWNrZWQgPSB2aXNpYmxlO1xuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLm51bVZpc2libGVFbnRpdGllcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLm51bVZpc2libGVFbnRpdGllcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLm5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tib3gpIHtcbiAgICAgICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hlY2tlZCA9IHZpc2libGU7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lm51bVZpc2libGVFbnRpdGllcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5udW1WaXNpYmxlRW50aXRpZXMtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnQubm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q2hlY2tib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tlZCA9IChwYXJlbnQubnVtVmlzaWJsZUVudGl0aWVzID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkICE9PSBwYXJlbnRDaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDaGVja2JveC5jaGVja2VkID0gbmV3Q2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbXV0ZVRyZWVFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zd2l0Y2hFeHBhbmRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5fZXhwYW5kU3dpdGNoRWxlbWVudChzd2l0Y2hFbGVtZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN3aXRjaENvbGxhcHNlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlU3dpdGNoRWxlbWVudChzd2l0Y2hFbGVtZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9jaGVja2JveENoYW5nZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tdXRlVHJlZUV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX211dGVTY2VuZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSBjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gY2hlY2tib3guaWQ7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkT2JqZWN0SWQgPSB0aGlzLl9ub2RlVG9PYmplY3RJRChub2RlSWQpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZE5vZGUgPSB0aGlzLl9vYmplY3ROb2Rlc1tjaGVja2VkT2JqZWN0SWRdO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0cyA9IHRoaXMuX3ZpZXdlci5zY2VuZS5vYmplY3RzO1xuICAgICAgICAgICAgbGV0IG51bVVwZGF0ZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fd2l0aE5vZGVUcmVlKGNoZWNrZWROb2RlLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdElkID0gbm9kZS5vYmplY3RJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja0JveElkID0gbm9kZS5ub2RlSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gb2JqZWN0c1tvYmplY3RJZF07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNMZWFmID0gKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICBub2RlLm51bVZpc2libGVFbnRpdGllcyA9IHZpc2libGUgPyBub2RlLm51bUVudGl0aWVzIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWFmICYmICh2aXNpYmxlICE9PSBub2RlLmNoZWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVVwZGF0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5jaGVja2VkID0gdmlzaWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjaGVja0JveElkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tib3gyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94Mi5jaGVja2VkID0gdmlzaWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkudmlzaWJsZSA9IHZpc2libGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gY2hlY2tlZE5vZGUucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGVja2VkID0gdmlzaWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnQubm9kZUlkKTsgLy8gUGFyZW50IGNoZWNrYm94ZXMgYXJlIGFsd2F5cyBpbiBET01cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQubnVtVmlzaWJsZUVudGl0aWVzICs9IG51bVVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lm51bVZpc2libGVFbnRpdGllcyAtPSBudW1VcGRhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGVja2VkID0gKHBhcmVudC5udW1WaXNpYmxlRW50aXRpZXMgPiAwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZCAhPT0gY2hlY2tib3gyLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3gyLmNoZWNrZWQgPSBuZXdDaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbXV0ZVNjZW5lRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGllcmFyY2h5ID0gY2ZnLmhpZXJhcmNoeSB8fCBcImNvbnRhaW5tZW50XCI7XG4gICAgICAgIHRoaXMuX2F1dG9FeHBhbmREZXB0aCA9IGNmZy5hdXRvRXhwYW5kRGVwdGggfHwgMDtcblxuICAgICAgICB0aGlzLl9jcmVhdGVOb2RlcygpO1xuICAgIH1cblxuICAgIF9ub2RlVG9PYmplY3RJRChub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJZC5zdWJzdHJpbmcodGhpcy5fYmFzZUlkLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgX29iamVjdFRvTm9kZUlEKG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXNlSWQgKyBvYmplY3RJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBkZXB0aFxuICAgICAqL1xuICAgIHNldEF1dG9FeHBhbmREZXB0aChkZXB0aCA9IDApIHtcbiAgICAgICAgdGhpcy5fYXV0b0V4cGFuZERlcHRoID0gZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gaGllcmFyY2h5XG4gICAgICovXG4gICAgc2V0SGllcmFyY2h5KGhpZXJhcmNoeSkge1xuICAgICAgICBpZiAodGhpcy5faGllcmFyY2h5ID09PSBoaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU5vZGVzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZU5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fcm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9vYmplY3ROb2RlcyA9IHt9O1xuICAgICAgICB0aGlzLl92YWxpZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRW5hYmxlZE5vZGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEaXNhYmxlZE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsaWRhdGUoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHN3aXRjaCAodGhpcy5faGllcmFyY2h5KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RvcmV5c1wiOlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWQgPSB2YWxpZGF0ZU1ldGFNb2RlbEZvclRyZWVWaWV3U3RvcmV5c0hpZXJhcmNoeSh0aGlzLm1ldGFNb2RlbCwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInR5cGVzXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZCA9IHZhbGlkYXRlTWV0YU1vZGVsRm9yVHJlZVZpZXdUeXBlc0hpZXJhcmNoeSh0aGlzLm1ldGFNb2RlbCwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbnRhaW5tZW50XCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWQgPSB2YWxpZGF0ZU1ldGFNb2RlbEZvclRyZWVWaWV3Q29udGFpbm1lbnRIaWVyYXJjaHkodGhpcy5tZXRhTW9kZWwsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICB9XG5cbiAgICBfY3JlYXRlRW5hYmxlZE5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJ1bmVFbXB0eU5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5kRW1wdHlOb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5faGllcmFyY2h5KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RvcmV5c1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN0b3JleXNOb2RlcygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb290Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyZWVWaWV3UGx1Z2luLmVycm9yKFwiRmFpbGVkIHRvIGJ1aWxkIHN0b3JleXMgaGllcmFyY2h5IGZvciBtb2RlbCAnXCIgKyB0aGlzLm1ldGFNb2RlbC5pZCArIFwiJyAtIHBlcmhhcHMgdGhpcyBtb2RlbCBpcyBub3QgYW4gSUZDIG1vZGVsP1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidHlwZXNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVUeXBlc05vZGVzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29udGFpbm1lbnRcIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29udGFpbm1lbnROb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zb3J0Tm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvU29ydE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3luY2hOb2Rlc1RvRW50aXRpZXMoKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlVHJlZXMoKTtcbiAgICAgICAgdGhpcy5leHBhbmRUb0RlcHRoKHRoaXMuX2F1dG9FeHBhbmREZXB0aCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZURpc2FibGVkTm9kZXMoKSB7XG5cbiAgICAgICAgY29uc3QgbWV0YU9iamVjdCA9IHRoaXMuX3Jvb3RNZXRhT2JqZWN0O1xuICAgICAgICBjb25zdCBtZXRhT2JqZWN0VHlwZSA9IG1ldGFPYmplY3QudHlwZTtcbiAgICAgICAgY29uc3QgbWV0YU9iamVjdE5hbWUgPSBtZXRhT2JqZWN0Lm5hbWU7XG5cbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSAoKG1ldGFPYmplY3ROYW1lICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIlwiICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIlVuZGVmaW5lZFwiICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIkRlZmF1bHRcIikgPyBtZXRhT2JqZWN0TmFtZSA6IG1ldGFPYmplY3RUeXBlKTtcblxuICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHVsKTtcbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSB1bDtcblxuICAgICAgICBjb25zdCBzd2l0Y2hFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LmhyZWYgPSAnIyc7XG4gICAgICAgIHN3aXRjaEVsZW1lbnQudGV4dENvbnRlbnQgPSAnISc7XG4gICAgICAgIHN3aXRjaEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnd2FybicpO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3dhcm5pbmcnKTtcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoc3dpdGNoRWxlbWVudCk7XG5cbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHJvb3ROYW1lO1xuICAgICAgICBsaS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICB9XG5cbiAgICBfZmluZEVtcHR5Tm9kZXMobWV0YU9iamVjdCA9IHRoaXMuX3Jvb3RNZXRhT2JqZWN0LCBjb3VudEVudGl0aWVzID0gMCkge1xuICAgICAgICBjb25zdCB2aWV3ZXIgPSB0aGlzLl90cmVlVmlld1BsdWdpbi52aWV3ZXI7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdmlld2VyLnNjZW5lO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG1ldGFPYmplY3QuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IG9iamVjdElkID0gbWV0YU9iamVjdC5pZDtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gc2NlbmUub2JqZWN0c1tvYmplY3RJZF07XG4gICAgICAgIG1ldGFPYmplY3QuX2NvdW50RW50aXRpZXMgPSAwO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgICBtZXRhT2JqZWN0Ll9jb3VudEVudGl0aWVzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE1ldGFPYmplY3QgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZE1ldGFPYmplY3QuX2NvdW50RW50aXRpZXMgPSB0aGlzLl9maW5kRW1wdHlOb2RlcyhjaGlsZE1ldGFPYmplY3QpO1xuICAgICAgICAgICAgICAgIG1ldGFPYmplY3QuX2NvdW50RW50aXRpZXMgKz0gY2hpbGRNZXRhT2JqZWN0Ll9jb3VudEVudGl0aWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhT2JqZWN0Ll9jb3VudEVudGl0aWVzO1xuICAgIH1cblxuICAgIF9jcmVhdGVTdG9yZXlzTm9kZXMoXG4gICAgICAgIG1ldGFPYmplY3QgPSB0aGlzLl9yb290TWV0YU9iamVjdCxcbiAgICAgICAgYnVpbGRpbmdOb2RlLFxuICAgICAgICBzdG9yZXlOb2RlLFxuICAgICAgICB0eXBlTm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BydW5lRW1wdHlOb2RlcyAmJiAobWV0YU9iamVjdC5fY291bnRFbnRpdGllcyA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhT2JqZWN0VHlwZSA9IG1ldGFPYmplY3QudHlwZTtcbiAgICAgICAgY29uc3QgbWV0YU9iamVjdE5hbWUgPSBtZXRhT2JqZWN0Lm5hbWU7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbWV0YU9iamVjdC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3Qgb2JqZWN0SWQgPSBtZXRhT2JqZWN0LmlkO1xuICAgICAgICBpZiAobWV0YU9iamVjdFR5cGUgPT09IFwiSWZjQnVpbGRpbmdcIikge1xuICAgICAgICAgICAgYnVpbGRpbmdOb2RlID0ge1xuICAgICAgICAgICAgICAgIG5vZGVJZDogdGhpcy5fb2JqZWN0VG9Ob2RlSUQob2JqZWN0SWQpLFxuICAgICAgICAgICAgICAgIG9iamVjdElkOiBvYmplY3RJZCxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5fcm9vdE5hbWUgfHwgKChtZXRhT2JqZWN0TmFtZSAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJVbmRlZmluZWRcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJEZWZhdWx0XCIpID8gbWV0YU9iamVjdE5hbWUgOiBtZXRhT2JqZWN0VHlwZSksXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG51bUVudGl0aWVzOiAwLFxuICAgICAgICAgICAgICAgIG51bVZpc2libGVFbnRpdGllczogMCxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChidWlsZGluZ05vZGUpO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0Tm9kZXNbYnVpbGRpbmdOb2RlLm9iamVjdElkXSA9IGJ1aWxkaW5nTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXRhT2JqZWN0VHlwZSA9PT0gXCJJZmNCdWlsZGluZ1N0b3JleVwiKSB7XG4gICAgICAgICAgICBpZiAoIWJ1aWxkaW5nTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyZWVWaWV3UGx1Z2luLmVycm9yKFwiRmFpbGVkIHRvIGJ1aWxkIHN0b3JleXMgaGllcmFyY2h5IGZvciBtb2RlbCAnXCIgKyB0aGlzLm1ldGFNb2RlbC5pZCArIFwiJyAtIG1vZGVsIGRvZXMgbm90IGhhdmUgYW4gSWZjQnVpbGRpbmcgb2JqZWN0LCBvciBpcyBub3QgYW4gSUZDIG1vZGVsXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JleU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiB0aGlzLl9vYmplY3RUb05vZGVJRChvYmplY3RJZCksXG4gICAgICAgICAgICAgICAgb2JqZWN0SWQ6IG9iamVjdElkLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAobWV0YU9iamVjdE5hbWUgJiYgbWV0YU9iamVjdE5hbWUgIT09IFwiXCIgJiYgbWV0YU9iamVjdE5hbWUgIT09IFwiVW5kZWZpbmVkXCIgJiYgbWV0YU9iamVjdE5hbWUgIT09IFwiRGVmYXVsdFwiKSA/IG1ldGFPYmplY3ROYW1lIDogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBidWlsZGluZ05vZGUsXG4gICAgICAgICAgICAgICAgbnVtRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgbnVtVmlzaWJsZUVudGl0aWVzOiAwLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJ1aWxkaW5nTm9kZS5jaGlsZHJlbi5wdXNoKHN0b3JleU5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0Tm9kZXNbc3RvcmV5Tm9kZS5vYmplY3RJZF0gPSBzdG9yZXlOb2RlO1xuICAgICAgICAgICAgdHlwZU5vZGVzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RvcmV5Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLl92aWV3ZXIuc2NlbmUub2JqZWN0cztcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSBvYmplY3RzW29iamVjdElkXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVOb2RlcyA9IHR5cGVOb2RlcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGVOb2RlID0gdHlwZU5vZGVzW21ldGFPYmplY3RUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZU5vZGVPYmplY3RJZCA9IHN0b3JleU5vZGUub2JqZWN0SWQgKyBcIi5cIiArIG1ldGFPYmplY3RUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZU5vZGVOb2RlSWQgPSB0aGlzLl9vYmplY3RUb05vZGVJRCh0eXBlTm9kZU9iamVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZDogdHlwZU5vZGVOb2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SWQ6IHR5cGVOb2RlT2JqZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1ldGFPYmplY3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGFPYmplY3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogc3RvcmV5Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1FbnRpdGllczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1WaXNpYmxlRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmV5Tm9kZS5jaGlsZHJlbi5wdXNoKHR5cGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdE5vZGVzW3R5cGVOb2RlT2JqZWN0SWRdID0gdHlwZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTm9kZXNbbWV0YU9iamVjdFR5cGVdID0gdHlwZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZDogdGhpcy5fb2JqZWN0VG9Ob2RlSUQob2JqZWN0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SWQ6IG9iamVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IChtZXRhT2JqZWN0TmFtZSAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJVbmRlZmluZWRcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJEZWZhdWx0XCIpID8gbWV0YU9iamVjdE5hbWUgOiBtZXRhT2JqZWN0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGFPYmplY3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB0eXBlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUVudGl0aWVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtVmlzaWJsZUVudGl0aWVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZU5vZGUuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0Tm9kZXNbbm9kZS5vYmplY3RJZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTWV0YU9iamVjdCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN0b3JleXNOb2RlcyhjaGlsZE1ldGFPYmplY3QsIGJ1aWxkaW5nTm9kZSwgc3RvcmV5Tm9kZSwgdHlwZU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVUeXBlc05vZGVzKG1ldGFPYmplY3QgPSB0aGlzLl9yb290TWV0YU9iamVjdCwgcm9vdE5vZGUsIHR5cGVOb2Rlcykge1xuICAgICAgICBpZiAodGhpcy5fcHJ1bmVFbXB0eU5vZGVzICYmIChtZXRhT2JqZWN0Ll9jb3VudEVudGl0aWVzID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFPYmplY3RUeXBlID0gbWV0YU9iamVjdC50eXBlO1xuICAgICAgICBjb25zdCBtZXRhT2JqZWN0TmFtZSA9IG1ldGFPYmplY3QubmFtZTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBtZXRhT2JqZWN0LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBvYmplY3RJZCA9IG1ldGFPYmplY3QuaWQ7XG4gICAgICAgIGlmIChtZXRhT2JqZWN0LmlkID09PSB0aGlzLl9yb290TWV0YU9iamVjdC5pZCkge1xuICAgICAgICAgICAgcm9vdE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiB0aGlzLl9vYmplY3RUb05vZGVJRChvYmplY3RJZCksXG4gICAgICAgICAgICAgICAgb2JqZWN0SWQ6IG9iamVjdElkLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLl9yb290TmFtZSB8fCAoKG1ldGFPYmplY3ROYW1lICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIlwiICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIlVuZGVmaW5lZFwiICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIkRlZmF1bHRcIikgPyBtZXRhT2JqZWN0TmFtZSA6IG1ldGFPYmplY3RUeXBlKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRhT2JqZWN0VHlwZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbnVtRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgbnVtVmlzaWJsZUVudGl0aWVzOiAwLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKHJvb3ROb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdE5vZGVzW3Jvb3ROb2RlLm9iamVjdElkXSA9IHJvb3ROb2RlO1xuICAgICAgICAgICAgdHlwZU5vZGVzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RzID0gdGhpcy5fdmlld2VyLnNjZW5lLm9iamVjdHM7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gb2JqZWN0c1tvYmplY3RJZF07XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZU5vZGUgPSB0eXBlTm9kZXNbbWV0YU9iamVjdFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IHRoaXMuX29iamVjdFRvTm9kZUlEKHJvb3ROb2RlLm9iamVjdElkICsgXCIuXCIgKyBtZXRhT2JqZWN0VHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SWQ6IHJvb3ROb2RlLm9iamVjdElkICsgXCIuXCIgKyBtZXRhT2JqZWN0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByb290Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1FbnRpdGllczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1WaXNpYmxlRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaCh0eXBlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3ROb2Rlc1t0eXBlTm9kZS5vYmplY3RJZF0gPSB0eXBlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOb2Rlc1ttZXRhT2JqZWN0VHlwZV0gPSB0eXBlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiB0aGlzLl9vYmplY3RUb05vZGVJRChvYmplY3RJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJZDogb2JqZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogKG1ldGFPYmplY3ROYW1lICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIlwiICYmIG1ldGFPYmplY3ROYW1lICE9PSBcIkRlZmF1bHRcIikgPyBtZXRhT2JqZWN0TmFtZSA6IG1ldGFPYmplY3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0YU9iamVjdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHR5cGVOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1WaXNpYmxlRW50aXRpZXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0eXBlTm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3ROb2Rlc1tub2RlLm9iamVjdElkXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRNZXRhT2JqZWN0ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVHlwZXNOb2RlcyhjaGlsZE1ldGFPYmplY3QsIHJvb3ROb2RlLCB0eXBlTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNvbnRhaW5tZW50Tm9kZXMobWV0YU9iamVjdCA9IHRoaXMuX3Jvb3RNZXRhT2JqZWN0LCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BydW5lRW1wdHlOb2RlcyAmJiAobWV0YU9iamVjdC5fY291bnRFbnRpdGllcyA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhT2JqZWN0VHlwZSA9IG1ldGFPYmplY3QudHlwZTtcbiAgICAgICAgY29uc3QgbWV0YU9iamVjdE5hbWUgPSBtZXRhT2JqZWN0Lm5hbWUgfHwgbWV0YU9iamVjdFR5cGU7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbWV0YU9iamVjdC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3Qgb2JqZWN0SWQgPSBtZXRhT2JqZWN0LmlkO1xuICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgbm9kZUlkOiB0aGlzLl9vYmplY3RUb05vZGVJRChvYmplY3RJZCksXG4gICAgICAgICAgICBvYmplY3RJZDogb2JqZWN0SWQsXG4gICAgICAgICAgICB0aXRsZTogKCFwYXJlbnQpID8gKHRoaXMuX3Jvb3ROYW1lIHx8IG1ldGFPYmplY3ROYW1lKSA6IChtZXRhT2JqZWN0TmFtZSAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJVbmRlZmluZWRcIiAmJiBtZXRhT2JqZWN0TmFtZSAhPT0gXCJEZWZhdWx0XCIpID8gbWV0YU9iamVjdE5hbWUgOiBtZXRhT2JqZWN0VHlwZSxcbiAgICAgICAgICAgIHR5cGU6IG1ldGFPYmplY3RUeXBlLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBudW1FbnRpdGllczogMCxcbiAgICAgICAgICAgIG51bVZpc2libGVFbnRpdGllczogMCxcbiAgICAgICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JqZWN0Tm9kZXNbbm9kZS5vYmplY3RJZF0gPSBub2RlO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRNZXRhT2JqZWN0ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29udGFpbm1lbnROb2RlcyhjaGlsZE1ldGFPYmplY3QsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2RvU29ydE5vZGVzKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fcm9vdE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX3Jvb3ROb2Rlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRDaGlsZHJlbihyb290Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc29ydENoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9oaWVyYXJjaHkgPT09IFwic3RvcmV5c1wiICYmIG5vZGUudHlwZSA9PT0gXCJJZmNCdWlsZGluZ1wiKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWVzIHRoYXQgY2hpbGRyZW4gb2YgYW4gSWZjQnVpbGRpbmcgd2lsbCBhbHdheXMgYmUgSWZjQnVpbGRpbmdTdG9yZXlzXG4gICAgICAgICAgICBjaGlsZHJlbi5zb3J0KHRoaXMuX2dldFNwYXRpYWxTb3J0RnVuYygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnNvcnQodGhpcy5fYWxwaGFTb3J0RnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB0aGlzLl9zb3J0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0U3BhdGlhbFNvcnRGdW5jKCkgeyAvLyBDcmVhdGVzIGNhY2hlZCBzb3J0IGZ1bmMgd2l0aCBWaWV3ZXIgaW4gc2NvcGVcbiAgICAgICAgY29uc3Qgdmlld2VyID0gdGhpcy5fdHJlZVZpZXdQbHVnaW4udmlld2VyO1xuICAgICAgICBjb25zdCBzY2VuZSA9IHZpZXdlci5zY2VuZTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xuICAgICAgICBjb25zdCBtZXRhU2NlbmUgPSB2aWV3ZXIubWV0YVNjZW5lO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BhdGlhbFNvcnRGdW5jIHx8ICh0aGlzLl9zcGF0aWFsU29ydEZ1bmMgPSAobm9kZTEsIG5vZGUyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUxLmFhYmIgfHwgIW5vZGUyLmFhYmIpIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0aW5nIG9uIGxvd2VzdCBwb2ludCBvZiB0aGUgQUFCQiBpcyBsaWtlbHkgbW9yZSBtb3JlIHJvYnVzdCB3aGVuIG9iamVjdHMgY291bGQgb3ZlcmxhcCBzdG9yZXlzXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlMS5hYWJiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUxLmFhYmIgPSBzY2VuZS5nZXRBQUJCKG1ldGFTY2VuZS5nZXRPYmplY3RJRHNJblN1YnRyZWUobm9kZTEub2JqZWN0SWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlMi5hYWJiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLmFhYmIgPSBzY2VuZS5nZXRBQUJCKG1ldGFTY2VuZS5nZXRPYmplY3RJRHNJblN1YnRyZWUobm9kZTIub2JqZWN0SWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIGlmIChjYW1lcmEueFVwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FtZXJhLnlVcCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkeCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTEuYWFiYltpZHhdID4gbm9kZTIuYWFiYltpZHhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUxLmFhYmJbaWR4XSA8IG5vZGUyLmFhYmJbaWR4XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hbHBoYVNvcnRGdW5jKG5vZGUxLCBub2RlMikge1xuICAgICAgICBjb25zdCB0aXRsZTEgPSBub2RlMS50aXRsZS50b1VwcGVyQ2FzZSgpOyAvLyBGSVhNRTogU2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlP1xuICAgICAgICBjb25zdCB0aXRsZTIgPSBub2RlMi50aXRsZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGl0bGUxIDwgdGl0bGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlMSA+IHRpdGxlMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgX3N5bmNoTm9kZXNUb0VudGl0aWVzKCkge1xuICAgICAgICBjb25zdCByb290TWV0YU9iamVjdCA9IHRoaXMuX3Jvb3RNZXRhT2JqZWN0O1xuICAgICAgICBjb25zdCBvYmplY3RJZHMgPSByb290TWV0YU9iamVjdC5nZXRPYmplY3RJRHNJblN1YnRyZWUoKTtcbiAgICAgICAgY29uc3QgbWV0YU9iamVjdHMgPSB0aGlzLl92aWV3ZXIubWV0YVNjZW5lLm1ldGFPYmplY3RzO1xuICAgICAgICBjb25zdCBvYmplY3RzID0gdGhpcy5fdmlld2VyLnNjZW5lLm9iamVjdHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvYmplY3RJZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdElkID0gb2JqZWN0SWRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbWV0YU9iamVjdCA9IG1ldGFPYmplY3RzW29iamVjdElkXTtcbiAgICAgICAgICAgIGlmIChtZXRhT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX29iamVjdE5vZGVzW29iamVjdElkXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHkgPSBvYmplY3RzW29iamVjdElkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IGVudGl0eS52aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5udW1FbnRpdGllcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubnVtVmlzaWJsZUVudGl0aWVzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm51bVZpc2libGVFbnRpdGllcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQ7IC8vIFN5bmNoIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubnVtRW50aXRpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQubnVtVmlzaWJsZUVudGl0aWVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF93aXRoTm9kZVRyZWUobm9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fd2l0aE5vZGVUcmVlKGNoaWxkcmVuW2ldLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlVHJlZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb290Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdE5vZGVFbGVtZW50cyA9IHRoaXMuX3Jvb3ROb2Rlcy5tYXAoKHJvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlTm9kZUVsZW1lbnQocm9vdE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICByb290Tm9kZUVsZW1lbnRzLmZvckVhY2goKG5vZGVFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChub2RlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHVsKTtcbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSB1bDtcbiAgICB9XG5cbiAgICBfY3JlYXRlTm9kZUVsZW1lbnQobm9kZSkge1xuICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIC8vY29uc3Qgbm9kZUlkID0gdGhpcy5fb2JqZWN0VG9Ob2RlSUQobm9kZS5vYmplY3RJZCk7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IG5vZGUubm9kZUlkO1xuICAgICAgICBub2RlRWxlbWVudC5pZCA9ICdub2RlLScgKyBub2RlSWQ7XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaEVsZW1lbnRJZCA9IFwic3dpdGNoLVwiICsgbm9kZUlkO1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIHN3aXRjaEVsZW1lbnQuaHJlZiA9ICcjJztcbiAgICAgICAgICAgIHN3aXRjaEVsZW1lbnQuaWQgPSBzd2l0Y2hFbGVtZW50SWQ7XG4gICAgICAgICAgICBzd2l0Y2hFbGVtZW50LnRleHRDb250ZW50ID0gJysnO1xuICAgICAgICAgICAgc3dpdGNoRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwbHVzJyk7XG4gICAgICAgICAgICBzd2l0Y2hFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zd2l0Y2hFeHBhbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIG5vZGVFbGVtZW50LmFwcGVuZENoaWxkKHN3aXRjaEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3guaWQgPSBub2RlSWQ7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG4gICAgICAgIGNoZWNrYm94LnN0eWxlW1wicG9pbnRlci1ldmVudHNcIl0gPSBcImFsbFwiO1xuICAgICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuX2NoZWNrYm94Q2hhbmdlSGFuZGxlcik7XG4gICAgICAgIG5vZGVFbGVtZW50LmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IG5vZGUudGl0bGU7XG4gICAgICAgIG5vZGVFbGVtZW50LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICBzcGFuLm9uY29udGV4dG1lbnUgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdHJlZVZpZXdQbHVnaW4uZmlyZShcImNvbnRleHRtZW51XCIsIHtcbiAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICB2aWV3ZXI6IHRoaXMuX3ZpZXdlcixcbiAgICAgICAgICAgICAgICB0cmVlVmlld1BsdWdpbjogdGhpcy5fdHJlZVZpZXdQbHVnaW4sXG4gICAgICAgICAgICAgICAgdHJlZVZpZXdOb2RlOiBub2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3Bhbi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWVWaWV3UGx1Z2luLmZpcmUoXCJub2RlVGl0bGVDbGlja2VkXCIsIHtcbiAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICB2aWV3ZXI6IHRoaXMuX3ZpZXdlcixcbiAgICAgICAgICAgICAgICB0cmVlVmlld1BsdWdpbjogdGhpcy5fdHJlZVZpZXdQbHVnaW4sXG4gICAgICAgICAgICAgICAgdHJlZVZpZXdOb2RlOiBub2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5vZGVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgZXhwYW5kVG9EZXB0aChkZXB0aCkge1xuICAgICAgICBjb25zdCBleHBhbmQgPSAobm9kZSwgY291bnREZXB0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50RGVwdGggPT09IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gbm9kZS5ub2RlSWQ7XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hFbGVtZW50SWQgPSBcInN3aXRjaC1cIiArIG5vZGVJZDtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzd2l0Y2hFbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKHN3aXRjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTd2l0Y2hFbGVtZW50KHN3aXRjaEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZChjaGlsZE5vZGUsIGNvdW50RGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9yb290Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy5fcm9vdE5vZGVzW2ldO1xuICAgICAgICAgICAgZXhwYW5kKHJvb3ROb2RlLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29sbGFwc2UoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9yb290Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy5fcm9vdE5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0SWQgPSByb290Tm9kZS5vYmplY3RJZDtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlTm9kZShvYmplY3RJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBvYmplY3RJZFxuICAgICAqL1xuICAgIHNob3dOb2RlKG9iamVjdElkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93TGlzdEl0ZW1FbGVtZW50SWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5TaG93Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9vYmplY3ROb2Rlc1tvYmplY3RJZF07XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBOb2RlIG1heSBub3QgZXhpc3QgZm9yIHRoZSBnaXZlbiBvYmplY3QgaWYgKHRoaXMuX3BydW5lRW1wdHlOb2RlcyA9PSB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IG5vZGUubm9kZUlkO1xuICAgICAgICBjb25zdCBzd2l0Y2hFbGVtZW50SWQgPSBcInN3aXRjaC1cIiArIG5vZGVJZDtcbiAgICAgICAgY29uc3Qgc3dpdGNoRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN3aXRjaEVsZW1lbnRJZCk7XG4gICAgICAgIGlmIChzd2l0Y2hFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbmRTd2l0Y2hFbGVtZW50KHN3aXRjaEVsZW1lbnQpO1xuICAgICAgICAgICAgc3dpdGNoRWxlbWVudC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHBhdGhbaV07XG4gICAgICAgICAgICBjb25zdCBub2RlSWQgPSBub2RlLm5vZGVJZDtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaEVsZW1lbnRJZCA9IFwic3dpdGNoLVwiICsgbm9kZUlkO1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN3aXRjaEVsZW1lbnRJZCk7XG4gICAgICAgICAgICBpZiAoc3dpdGNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFN3aXRjaEVsZW1lbnQoc3dpdGNoRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdEl0ZW1FbGVtZW50SWQgPSAnbm9kZS0nICsgbm9kZUlkO1xuICAgICAgICBjb25zdCBsaXN0SXRlbUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsaXN0SXRlbUVsZW1lbnRJZCk7XG4gICAgICAgIGxpc3RJdGVtRWxlbWVudC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiY2VudGVyXCJ9KTtcbiAgICAgICAgbGlzdEl0ZW1FbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRlZC1ub2RlXCIpO1xuICAgICAgICB0aGlzLl9zaG93TGlzdEl0ZW1FbGVtZW50SWQgPSBsaXN0SXRlbUVsZW1lbnRJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVuU2hvd05vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd0xpc3RJdGVtRWxlbWVudElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fc2hvd0xpc3RJdGVtRWxlbWVudElkKTtcbiAgICAgICAgaWYgKCFsaXN0SXRlbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dMaXN0SXRlbUVsZW1lbnRJZCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRlZC1ub2RlXCIpO1xuICAgICAgICB0aGlzLl9zaG93TGlzdEl0ZW1FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cblxuICAgIF9leHBhbmRTd2l0Y2hFbGVtZW50KHN3aXRjaEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IHN3aXRjaEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBwYXJlbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpWzBdO1xuICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlSWQgPSBwYXJlbnRFbGVtZW50LmlkLnJlcGxhY2UoJ25vZGUtJywgJycpO1xuICAgICAgICBjb25zdCBvYmplY3RJZCA9IHRoaXMuX25vZGVUb09iamVjdElEKG5vZGVJZCk7XG4gICAgICAgIGNvbnN0IHN3aXRjaE5vZGUgPSB0aGlzLl9vYmplY3ROb2Rlc1tvYmplY3RJZF07XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzd2l0Y2hOb2RlLmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBub2RlRWxlbWVudHMgPSBjaGlsZE5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU5vZGVFbGVtZW50KG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICBub2RlRWxlbWVudHMuZm9yRWFjaCgobm9kZUVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKG5vZGVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodWwpO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BsdXMnKTtcbiAgICAgICAgc3dpdGNoRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtaW51cycpO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LnRleHRDb250ZW50ID0gJy0nO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zd2l0Y2hFeHBhbmRIYW5kbGVyKTtcbiAgICAgICAgc3dpdGNoRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc3dpdGNoQ29sbGFwc2VIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBfY29sbGFwc2VOb2RlKG9iamVjdElkKSB7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMuX29iamVjdFRvTm9kZUlEKG9iamVjdElkKTtcbiAgICAgICAgY29uc3Qgc3dpdGNoRWxlbWVudElkID0gXCJzd2l0Y2gtXCIgKyBub2RlSWQ7XG4gICAgICAgIGNvbnN0IHN3aXRjaEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzd2l0Y2hFbGVtZW50SWQpO1xuICAgICAgICB0aGlzLl9jb2xsYXBzZVN3aXRjaEVsZW1lbnQoc3dpdGNoRWxlbWVudCk7XG4gICAgfVxuXG4gICAgX2NvbGxhcHNlU3dpdGNoRWxlbWVudChzd2l0Y2hFbGVtZW50KSB7XG4gICAgICAgIGlmICghc3dpdGNoRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHN3aXRjaEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICAgICAgICBpZiAoIXVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHVsKTtcbiAgICAgICAgc3dpdGNoRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtaW51cycpO1xuICAgICAgICBzd2l0Y2hFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3BsdXMnKTtcbiAgICAgICAgc3dpdGNoRWxlbWVudC50ZXh0Q29udGVudCA9ICcrJztcbiAgICAgICAgc3dpdGNoRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc3dpdGNoQ29sbGFwc2VIYW5kbGVyKTtcbiAgICAgICAgc3dpdGNoRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc3dpdGNoRXhwYW5kSGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBNb2RlbFRyZWVWaWV3LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50ICYmICF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fcm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fdmlld2VyLnNjZW5lLm9mZih0aGlzLl9vbk9iamVjdFZpc2liaWxpdHkpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlkTWFwLnJlbW92ZUl0ZW0odGhpcy5faWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQge01vZGVsVHJlZVZpZXd9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/ModelTreeView.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/TreeViewPlugin.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/TreeViewPlugin.js ***!
  \**************************************************************************************/
/*! exports provided: TreeViewPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeViewPlugin\", function() { return TreeViewPlugin; });\n/* harmony import */ var _ModelTreeView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelTreeView.js */ \"./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/ModelTreeView.js\");\n/* harmony import */ var _viewer_Plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../viewer/Plugin.js */ \"./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js\");\n\n\n\n/**\n * @desc A {@link Viewer} plugin that provides an HTML tree view to navigate the IFC elements in models.\n * <br>\n *\n * <a href=\"https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital\" style=\"border: 1px solid black;\"><img src=\"http://xeokit.io/img/docs/TreeViewPlugin/TreeViewPlugin.png\"></a>\n *\n * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_WestRiverSideHospital)]\n *\n * ## Overview\n *\n * * A fast HTML tree view, with zero external dependencies, that works with huge numbers of objects.\n * * Each tree node has a checkbox to control the visibility of its object.\n * * Has three hierarchy modes: \"containment\", \"types\" and \"storeys\".\n * * Automatically contains all models (that have metadata) that are currently in the {@link Scene}.\n * * Sorts tree nodes by default - spatially, from top-to-bottom for ````IfcBuildingStorey```` nodes, and alphanumerically for other nodes.\n * * Allows custom CSS styling.\n * * Use {@link ContextMenu} to create a context menu for the tree nodes.\n *\n * ## Credits\n *\n * TreeViewPlugin is based on techniques described in [*Super Fast Tree View in JavaScript*](https://chrissmith.xyz/super-fast-tree-view-in-javascript/) by [Chris Smith](https://twitter.com/chris22smith).\n *\n * ## Usage\n *\n * In the example below, we'll add a TreeViewPlugin which, by default, will automatically show the structural\n * hierarchy of the IFC elements in each model we load.\n *\n * Then we'll use an {@link XKTLoaderPlugin} to load the Schependomlaan model from an\n * [.xkt file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/models/xkt/schependomlaan), along\n * with an accompanying JSON [IFC metadata file](https://github.com/xeokit/xeokit-sdk/tree/master/examples/metaModels/schependomlaan).\n *\n * [[Run this example](https://xeokit.github.io/xeokit-sdk/examples/#BIMOffline_XKT_Schependomlaan)]\n *\n * ````javascript\n * import {Viewer} from \"../src/viewer/Viewer.js\";\n * import {XKTLoaderPlugin} from \"../src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js\";\n * import {TreeViewPlugin} from \"../src/plugins/TreeViewPlugin/TreeViewPlugin.js\";\n *\n * const viewer = new Viewer({\n *      canvasId: \"myCanvas\",\n *      transparent: true\n * });\n *\n * viewer.camera.eye = [-2.56, 8.38, 8.27];\n * viewer.camera.look = [13.44, 3.31, -14.83];\n * viewer.camera.up = [0.10, 0.98, -0.14];\n *\n * const treeView = new TreeViewPlugin(viewer, {\n *     containerElement: document.getElementById(\"myTreeViewContainer\")\n * });\n *\n * const xktLoader = new XKTLoaderPlugin(viewer);\n *\n * const model = xktLoader.load({\n *     id: \"myModel\",\n *     src: \"./models/xkt/schependomlaan/schependomlaan.xkt\",\n *     metaModelSrc: \"./metaModels/schependomlaan/metaModel.json\",\n *     edges: true\n * });\n * ````\n *\n * ## Manually Adding Models\n *\n * Instead of adding models automatically, we can control which models appear in our TreeViewPlugin by adding them manually.\n *\n * In the next example, we'll configure the TreeViewPlugin to not add models automatically. Then, once the model\n * has loaded, we'll add it manually using {@link TreeViewPlugin#addModel}.\n *\n * ````javascript\n * const treeView = new TreeViewPlugin(viewer, {\n *      containerElement: document.getElementById(\"myTreeViewContainer\"),\n *      autoAddModels: false  // <<---------------- Don't auto-add models\n * });\n *\n * const xktLoader = new XKTLoaderPlugin(viewer);\n *\n * const model = xktLoader.load({\n *     id: \"myModel\",\n *     src: \"./models/xkt/schependomlaan/schependomlaan.xkt\",\n *     metaModelSrc: \"./metaModels/schependomlaan/metaModel.json\",\n *     edges: true\n * });\n *\n * model.on(\"loaded\", () => {\n *      treeView.addModel(model.id);\n * });\n * ````\n *\n * Adding models manually also allows us to set some options for the model. For example, the ````rootName```` option allows us to provide a custom name for\n * the root node, which is sometimes desirable when the model's \"IfcProject\" element's name is not suitable:\n *\n * ````javascript\n * model.on(\"loaded\", () => {\n *      treeView.addModel(model.id, {\n *          rootName: \"Schependomlaan Model\"\n *      });\n * });\n * ````\n *\n * ## Initially Expanding the Hierarchy\n *\n * We can also configure TreeViewPlugin to initially expand each model's nodes to a given depth.\n *\n * Let's automatically expand the first three nodes from the root, for every model added:\n *\n * ````javascript\n * const treeView = new TreeViewPlugin(viewer, {\n *      containerElement: document.getElementById(\"myTreeViewContainer\"),\n *      autoExpandDepth: 3\n * });\n * ````\n *\n * ## Showing a Node by ID\n *\n * We can show a given node using its ID. This causes the TreeViewPlugin to collapse, then expand and scroll the node into view, then highlight the node.\n *\n * See the documentation for the {@link TreeViewPlugin#showNode} method for more information, including how to define a custom highlighted appearance for the node using CSS.\n *\n * Let's make the TreeViewPlugin show the node corresponding to whatever object {@link Entity} that we pick:\n *\n * ````javascript\n * viewer.cameraControl.on(\"picked\", function (e) {\n *     var objectId = e.entity.id;\n *     treeView.showNode(objectId);\n * });\n * ````\n *\n * This will de-highlight any node that was previously shown by this method.\n *\n * Note that this method only works if the picked {@link Entity} is an object that belongs to a model that's represented in the TreeViewPlugin.\n *\n * ## Customizing Appearance\n *\n * We can customize the appearance of our TreeViewPlugin by defining custom CSS for its HTML\n * elements. See our example's [source code](https://github.com/xeokit/xeokit-sdk/blob/master/examples/BIMOffline_XKT_Schependomlaan.html)\n * for an example of custom CSS rules.\n *\n * ## Model Hierarchies\n *\n * TreeViewPlugin has three hierarchies for organizing its nodes:\n *\n * * \"containment\" - organizes the tree nodes to indicate the containment hierarchy of the {@link MetaObject}s.\n * * \"types\" - groups nodes by their IFC types.\n * * \"storeys\" - groups nodes within their ````IfcBuildingStoreys````, and sub-groups them by their IFC types.\n *\n * <br>\n * The table below shows what the hierarchies look like:\n * <br>\n *\n * | 1. Containment Hierarchy | 2. Types Hierarchy | 3. Storeys Hierarchy |\n * |---|---|---|\n * | <img src=\"http://xeokit.io/img/docs/TreeViewPlugin/structureMode.png\"> | <img src=\"http://xeokit.io/img/docs/TreeViewPlugin/typesMode.png\"> | <img src=\"http://xeokit.io/img/docs/TreeViewPlugin/storeysMode.png\"> |\n * <br>\n *\n * Let's create a TreeViewPlugin that groups nodes by their building stories and IFC types:\n *\n * ````javascript\n * const treeView = new TreeViewPlugin(viewer, {\n *      containerElement: document.getElementById(\"myTreeViewContainer\"),\n *      hierarchy: \"stories\"\n * });\n * ````\n *\n * ## Sorting Nodes\n *\n * TreeViewPlugin sorts its tree nodes by default. For a \"storeys\" hierarchy, it orders ````IfcBuildingStorey```` nodes\n * spatially, with the node for the highest story at the top, down to the lowest at the bottom.\n *\n * For all the hierarchy types (\"containment\", \"classes\" and \"storeys\"), TreeViewPlugin sorts the other node types\n * alphanumerically on their titles.\n *\n * If for some reason you need to prevent sorting, create your TreeViewPlugin with the option disabled, like so:\n *\n * ````javascript\n * const treeView = new TreeViewPlugin(viewer, {\n *      containerElement: document.getElementById(\"myTreeViewContainer\"),\n *      hierarchy: \"stories\",\n *      sortNodes: false // <<------ Disable node sorting\n * });\n * ````\n *\n * Note that, for all hierarchy modes, node sorting is only done for each model at the time that it is added to the TreeViewPlugin, and will not\n * update dynamically if we later transform the {@link Entity}s corresponding to the nodes.\n *\n * ## Pruning empty nodes\n *\n * Sometimes a model contains subtrees of objects that don't have any geometry. These are models whose\n * {@link MetaModel} contains trees of {@link MetaObject}s that don't have any {@link Entity}s in the {@link Scene}.\n *\n * For these models, the tree view would contain nodes that don't do anything in the Scene when we interact with them,\n * which is undesirable.\n *\n * By default, TreeViewPlugin will not create nodes for those objects. However, we can override that behaviour if we want\n * to have nodes for those objects (perhaps for debugging the model):\n *\n * ````javascript\n * const treeView = new TreeViewPlugin(viewer, {\n *      containerElement: document.getElementById(\"myTreeViewContainer\"),\n *      hierarchy: \"stories\",\n *      pruneEmptyNodes: false // <<------ Create nodes for object subtrees without geometry\n * });\n * ````\n *\n * ## Context Menu\n *\n * TreeViewPlugin fires a \"contextmenu\" event whenever we right-click on a tree node.\n *\n * The event contains:\n *\n * * ````event```` - the original [contextmenu](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)\n * * ````viewer```` - the {@link Viewer}\n * * ````treeViewPlugin```` - the TreeViewPlugin\n * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node\n *<br><br>\n *\n * Let's use {@link ContextMenu} to show a simple context menu for the node we clicked.\n *\n * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]\n *\n * ````javascript\n * import {ContextMenu} from \"../src/extras/ContextMenu/ContextMenu.js\";\n *\n * const treeViewContextMenu = new ContextMenu({\n *     items: [\n *         [\n *             [\n *                 {\n *                     title: \"Hide\",\n *                     doAction: function (context) {\n *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {\n *                             if (treeViewNode.objectId) {\n *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];\n *                                 if (entity) {\n *                                     entity.visible = false;\n *                                 }\n *                             }\n *                         });\n *                     }\n *                 },\n *                 {\n *                     title: \"Hide all\",\n *                     doAction: function (context) {\n *                         context.viewer.scene.setObjectsVisible(context.viewer.scene.visibleObjectIds, false);\n *                     }\n *                 }\n *             ],\n *             [\n *                 {\n *                     title: \"Show\",\n *                     doAction: function (context) {\n *                         context.treeViewPlugin.withNodeTree(context.treeViewNode, (treeViewNode) => {\n *                             if (treeViewNode.objectId) {\n *                                 const entity = context.viewer.scene.objects[treeViewNode.objectId];\n *                                 if (entity) {\n *                                     entity.visible = true;\n *                                     entity.xrayed = false;\n *                                     entity.selected = false;\n *                                 }\n *                             }\n *                         });\n *                     }\n *                 },\n *                 {\n *                     title: \"Show all\",\n *                     doAction: function (context) {\n *                         const scene = context.viewer.scene;\n *                         scene.setObjectsVisible(scene.objectIds, true);\n *                         scene.setObjectsXRayed(scene.xrayedObjectIds, false);\n *                         scene.setObjectsSelected(scene.selectedObjectIds, false);\n *                     }\n *                 }\n *             ]\n *         ]\n *     ]\n * });\n *\n * treeView.on(\"contextmenu\", (e) => {\n *\n *     const event = e.event;                           // MouseEvent\n *     const viewer = e.viewer;                         // Viewer\n *     const treeViewPlugin = e.treeViewPlugin;         // TreeViewPlugin\n *     const treeViewNode = e.treeViewNode;             // TreeViewNode\n *\n *     treeViewContextMenu.show(e.event.pageX, e.event.pageY);\n *\n *     treeViewContextMenu.context = {\n *         viewer: e.viewer,\n *         treeViewPlugin: e.treeViewPlugin,\n *         treeViewNode: e.treeViewNode\n *     };\n * });\n * ````\n *\n * ## Clicking Node Titles\n *\n * TreeViewPlugin fires a \"nodeTitleClicked\" event whenever we left-click on a tree node.\n *\n * Like the \"contextmenu\" event, this event contains:\n *\n * * ````event```` - the original [click](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event) [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)\n * * ````viewer```` - the {@link Viewer}\n * * ````treeViewPlugin```` - the TreeViewPlugin\n * * ````treeViewNode```` - the {@link TreeViewNode} representing the tree node\n *<br><br>\n *\n * Let's register a callback to isolate and fit-to-view the {@link Entity}(s) represented by the node. This callback is\n * going to X-ray all the other Entitys, fly the camera to fit the Entity(s) for the clicked node, then hide the other Entitys.\n *\n * [[Run an example](https://xeokit.github.io/xeokit-sdk/examples/#ContextMenu_Canvas_TreeViewPlugin_Custom)]\n *\n * ````javascript\n * treeView.on(\"nodeTitleClicked\", (e) => {\n *     const scene = viewer.scene;\n *     const objectIds = [];\n *     e.treeViewPlugin.withNodeTree(e.treeViewNode, (treeViewNode) => {\n *         if (treeViewNode.objectId) {\n *             objectIds.push(treeViewNode.objectId);\n *         }\n *     });\n *     scene.setObjectsXRayed(scene.objectIds, true);\n *     scene.setObjectsVisible(scene.objectIds, true);\n *     scene.setObjectsXRayed(objectIds, false);\n *     viewer.cameraFlight.flyTo({\n *         aabb: scene.getAABB(objectIds),\n *         duration: 0.5\n *     }, () => {\n *         setTimeout(function () {\n *             scene.setObjectsVisible(scene.xrayedObjectIds, false);\n *             scene.setObjectsXRayed(scene.xrayedObjectIds, false);\n *         }, 500);\n *     });\n * });\n * ````\n *\n * To make the cursor change to a pointer when we hover over the node titles, and also to make the titles change to blue, we'll also define this CSS for the ````<span>```` elements\n * that represent the titles of our TreeViewPlugin nodes:\n *\n * ````css\n * #treeViewContainer ul li span:hover {\n *      color: blue;\n *      cursor: pointer;\n * }\n * ````\n *\n * @class TreeViewPlugin\n */\nclass TreeViewPlugin extends _viewer_Plugin_js__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"] {\n\n    /**\n     * @constructor\n     *\n     * @param {Viewer} viewer The Viewer.\n     * @param {*} cfg Plugin configuration.\n     * @param {HTMLElement} cfg.containerElement DOM element to contain the TreeViewPlugin.\n     * @param {Boolean} [cfg.autoAddModels=true] When ````true```` (default), will automatically add each model as it's created. Set this ````false```` if you want to manually add models using {@link TreeViewPlugin#addModel} instead.\n     * @param {Number} [cfg.autoExpandDepth] Optional depth to which to initially expand the tree.\n     * @param {String} [cfg.hierarchy=\"containment\"] How to organize the tree nodes: \"containment\", \"storeys\" or \"types\". See the class documentation for details.\n     * @param {Boolean} [cfg.sortNodes=true] When true, will sort the children of each node. For a \"storeys\" hierarchy, the\n     * ````IfcBuildingStorey```` nodes will be ordered spatially, from the highest storey down to the lowest, on the\n     * vertical World axis. For all hierarchy types, other node types will be ordered in the ascending alphanumeric order of their titles.\n     * @param {Boolean} [cfg.pruneEmptyNodes=true] When true, will not contain nodes that don't have content in the {@link Scene}. These are nodes whose {@link MetaObject}s don't have {@link Entity}s.\n     */\n    constructor(viewer, cfg = {}) {\n\n        super(\"TreeViewPlugin\", viewer);\n\n        if (!cfg.containerElement) {\n            this.error(\"Config expected: containerElement\");\n            return;\n        }\n\n        this._containerElement = cfg.containerElement;\n        this._modelTreeViews = {};\n        this._autoAddModels = (cfg.autoAddModels !== false);\n        this._autoExpandDepth = (cfg.autoExpandDepth || 0);\n        this._sortNodes = (cfg.sortNodes !== false);\n        this._pruneEmptyNodes = (cfg.pruneEmptyNodes !== false);\n\n        if (this._autoAddModels) {\n            const modelIds = Object.keys(this.viewer.scene.models);\n            for (let i = 0, len = modelIds.length; i < len; i++) {\n                const modelId = modelIds[i];\n                this.addModel(modelId);\n            }\n            this.viewer.scene.on(\"modelLoaded\", (modelId) => {\n                if (this.viewer.metaScene.metaModels[modelId]) {\n                    this.addModel(modelId);\n                }\n            });\n        }\n\n        this.hierarchy = cfg.hierarchy;\n    }\n\n    /**\n     * Returns the map of {@link ModelTreeView}s.\n     *\n     * Each ModelTreeView is mapped to the ID of its model.\n     *\n     * @return {*|{}}\n     */\n    get modelTreeViews() {\n        return this._modelTreeViews;\n    }\n\n    /**\n     * Sets how the nodes are organized within this tree view.\n     *\n     * Accepted values are:\n     *\n     * * \"containment\" - organizes the nodes to indicate the containment hierarchy of the IFC objects.\n     * * \"types\" - groups the nodes within their IFC types.\n     * * \"storeys\" - groups the nodes within ````IfcBuildingStoreys```` and sub-groups them by their IFC types.\n     *\n     * <br>\n     * This can be updated dynamically.\n     *\n     * Default value is \"containment\".\n     *\n     * @type {String}\n     */\n    set hierarchy(hierarchy) {\n        hierarchy = hierarchy || \"containment\";\n        if (hierarchy !== \"containment\" && hierarchy !== \"storeys\" && hierarchy !== \"types\") {\n            this.error(\"Unsupported value for `hierarchy' - defaulting to 'containment'\");\n            hierarchy = \"containment\";\n        }\n        this._hierarchy = hierarchy;\n        for (let modelId in this._modelTreeViews) {\n            if (this._modelTreeViews.hasOwnProperty(modelId)) {\n                this._modelTreeViews[modelId].setHierarchy(this._hierarchy);\n            }\n        }\n    }\n\n    /**\n     * Gets how the nodes are organized within this tree view.\n     *\n     * @type {String}\n     */\n    get hierarchy() {\n        return this._hierarchy;\n    }\n\n    /**\n     * Adds a model to this tree view.\n     *\n     * The model will be automatically removed when destroyed.\n     *\n     * To automatically add each model as it's created, instead of manually calling this method each time,\n     * provide a ````autoAddModels: true```` to the TreeViewPlugin constructor.\n     *\n     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.\n     * @param {Object} [options] Options for model in the tree view.\n     * @param {String} [options.rootName] Optional display name for the root node. Ordinary, for \"containment\"\n     * and \"storeys\" hierarchy types, the tree would derive the root node name from the model's \"IfcProject\" element\n     * name. This option allows to override that name when it is not suitable as a display name.\n     * @returns {ModelTreeView} ModelTreeView for the newly-added model. If this method succeeded in adding the model,\n     * then {@link ModelTreeView#valid} will equal ````true````. Otherwise, that property will be ````false````\n     * and {@link ModelTreeView#errors} will contain error messages.\n     */\n    addModel(modelId, options = {}) {\n        if (!this._containerElement) {\n            return;\n        }\n        const model = this.viewer.scene.models[modelId];\n        if (!model) {\n            throw \"Model not found: \" + modelId;\n        }\n        const metaModel = this.viewer.metaScene.metaModels[modelId];\n        if (!metaModel) {\n            this.error(\"MetaModel not found: \" + modelId);\n            return;\n        }\n        if (this._modelTreeViews[modelId]) {\n            this.warn(\"Model already added: \" + modelId);\n            return;\n        }\n        const modelTreeView = new _ModelTreeView_js__WEBPACK_IMPORTED_MODULE_0__[\"ModelTreeView\"](this.viewer, this, model, metaModel, {\n            containerElement: this._containerElement,\n            autoExpandDepth: this._autoExpandDepth,\n            hierarchy: this._hierarchy,\n            sortNodes: this._sortNodes,\n            pruneEmptyNodes: this._pruneEmptyNodes,\n            rootName: options.rootName\n        });\n        this._modelTreeViews[modelId] = modelTreeView;\n        model.on(\"destroyed\", () => {\n            this.removeModel(model.id);\n        });\n        return modelTreeView;\n    }\n\n    /**\n     * Removes a model from this tree view.\n     *\n     * @param {String} modelId ID of a model {@link Entity} in {@link Scene#models}.\n     */\n    removeModel(modelId) {\n        if (!this._containerElement) {\n            return;\n        }\n        const modelTreeView = this._modelTreeViews[modelId];\n        if (!modelTreeView) {\n            this.warn(\"Model not added: \" + modelId);\n            return;\n        }\n        modelTreeView.destroy();\n        delete this._modelTreeViews[modelId];\n    }\n\n    /**\n     * Collapses all trees within this tree view.\n     */\n    collapse() {\n        for (let modelId in this._modelTreeViews) {\n            if (this._modelTreeViews.hasOwnProperty(modelId)) {\n                const modelTreeView = this._modelTreeViews[modelId];\n                modelTreeView.collapse();\n            }\n        }\n    }\n\n    /**\n     * Highlights the tree view node that represents the given object {@link Entity}.\n     *\n     * This causes the tree view to collapse, then expand to reveal the node, then highlight the node.\n     *\n     * If a node is previously highlighted, de-highlights that node and collapses the tree first.\n     *\n     * Note that if the TreeViewPlugin was configured with ````pruneEmptyNodes: true```` (default configuration), then the\n     * node won't exist in the tree if it has no Entitys in the {@link Scene}. in that case, nothing will happen.\n     *\n     * Within the DOM, the node is represented by an ````<li>```` element. This method will add a ````.highlighted-node```` class to\n     * the element to make it appear highlighted, removing that class when de-highlighting it again. See the CSS rules\n     * in the TreeViewPlugin examples for an example of that class.\n     *\n     * @param {String} objectId ID of the {@link Entity}.\n     */\n    showNode(objectId) {\n        this.unShowNode();\n        const metaObject = this.viewer.metaScene.metaObjects[objectId];\n        if (!metaObject) {\n            this.error(\"MetaObject not found: \" + objectId);\n            return;\n        }\n        const metaModel = metaObject.metaModel;\n        const modelId = metaModel.id;\n        const modelTreeView = this._modelTreeViews[modelId];\n        if (!modelTreeView) {\n            this.error(\"Object not in this TreeView: \" + objectId);\n            return;\n        }\n        modelTreeView.showNode(objectId);\n    }\n\n    /**\n     * De-highlights the node previously shown with {@link TreeViewPlugin#showNode}.\n     *\n     * Does nothing if no node is currently shown.\n     *\n     * If the node is currently scrolled into view, keeps the node in view.\n     */\n    unShowNode() {\n        for (let modelId in this._modelTreeViews) {\n            if (this._modelTreeViews.hasOwnProperty(modelId)) {\n                const modelTreeView = this._modelTreeViews[modelId];\n                modelTreeView.unShowNode();\n            }\n        }\n    }\n\n    /**\n     * Expands the tree to the given depth.\n     *\n     * Collapses the tree first.\n     *\n     * @param {Number} depth Depth to expand to.\n     */\n    expandToDepth(depth) {\n        for (let modelId in this._modelTreeViews) {\n            if (this._modelTreeViews.hasOwnProperty(modelId)) {\n                const modelTreeView = this._modelTreeViews[modelId];\n                modelTreeView.collapse();\n                modelTreeView.expandToDepth(depth);\n            }\n        }\n    }\n\n    /**\n     * Iterates over a subtree of the tree view's {@link TreeViewNode}s, calling the given callback for each\n     * node in depth-first pre-order.\n     *\n     * @param {TreeViewNode} node Root of the subtree.\n     * @param {Function} callback Callback called at each {@link TreeViewNode}, with the TreeViewNode given as the argument.\n     */\n    withNodeTree(node, callback) {\n        callback(node);\n        const children = node.children;\n        if (!children) {\n            return;\n        }\n        for (let i = 0, len = children.length; i < len; i++) {\n            this.withNodeTree(children[i], callback);\n        }\n    }\n\n    /**\n     * Destroys this TreeViewPlugin.\n     */\n    destroy() {\n        if (!this._containerElement) {\n            return;\n        }\n        for (let modelId in this._modelTreeViews) {\n            if (this._modelTreeViews.hasOwnProperty(modelId)) {\n                this._modelTreeViews[modelId].destroy();\n            }\n        }\n        this._modelTreeViews = {};\n        super.destroy();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9UcmVlVmlld1BsdWdpbi9UcmVlVmlld1BsdWdpbi5qcz80NDUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlEO0FBQ0g7O0FBRTlDO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixZQUFZO0FBQ25HO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEU7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixpQkFBaUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQixvQkFBb0IsaUJBQWlCLHVCQUF1QixhQUFhLFVBQVUsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsK0NBQStDO0FBQy9DLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFFBQVE7QUFDUixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBTTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRLDJLQUEySyw4QkFBOEI7QUFDaE8sZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsUUFBUSw4RkFBOEYsWUFBWSx5QkFBeUIsaUJBQWlCLGNBQWMsYUFBYTtBQUN0TTtBQUNBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLHdCQUF3QixhQUFhLEtBQUssbUJBQW1CO0FBQ25GLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGFBQWEsMEJBQTBCO0FBQ3ZDLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sd0JBQXdCLGFBQWEsS0FBSyxtQkFBbUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8scUJBQXFCLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCw4QkFBOEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVMsbUNBQW1DLG1CQUFtQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3BsdWdpbnMvVHJlZVZpZXdQbHVnaW4vVHJlZVZpZXdQbHVnaW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01vZGVsVHJlZVZpZXd9IGZyb20gXCIuL01vZGVsVHJlZVZpZXcuanNcIjtcbmltcG9ydCB7UGx1Z2lufSBmcm9tIFwiLi4vLi4vdmlld2VyL1BsdWdpbi5qc1wiO1xuXG4vKipcbiAqIEBkZXNjIEEge0BsaW5rIFZpZXdlcn0gcGx1Z2luIHRoYXQgcHJvdmlkZXMgYW4gSFRNTCB0cmVlIHZpZXcgdG8gbmF2aWdhdGUgdGhlIElGQyBlbGVtZW50cyBpbiBtb2RlbHMuXG4gKiA8YnI+XG4gKlxuICogPGEgaHJlZj1cImh0dHBzOi8veGVva2l0LmdpdGh1Yi5pby94ZW9raXQtc2RrL2V4YW1wbGVzLyNCSU1PZmZsaW5lX1hLVF9XZXN0Uml2ZXJTaWRlSG9zcGl0YWxcIiBzdHlsZT1cImJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1wiPjxpbWcgc3JjPVwiaHR0cDovL3hlb2tpdC5pby9pbWcvZG9jcy9UcmVlVmlld1BsdWdpbi9UcmVlVmlld1BsdWdpbi5wbmdcIj48L2E+XG4gKlxuICogW1tSdW4gdGhpcyBleGFtcGxlXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jQklNT2ZmbGluZV9YS1RfV2VzdFJpdmVyU2lkZUhvc3BpdGFsKV1cbiAqXG4gKiAjIyBPdmVydmlld1xuICpcbiAqICogQSBmYXN0IEhUTUwgdHJlZSB2aWV3LCB3aXRoIHplcm8gZXh0ZXJuYWwgZGVwZW5kZW5jaWVzLCB0aGF0IHdvcmtzIHdpdGggaHVnZSBudW1iZXJzIG9mIG9iamVjdHMuXG4gKiAqIEVhY2ggdHJlZSBub2RlIGhhcyBhIGNoZWNrYm94IHRvIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgaXRzIG9iamVjdC5cbiAqICogSGFzIHRocmVlIGhpZXJhcmNoeSBtb2RlczogXCJjb250YWlubWVudFwiLCBcInR5cGVzXCIgYW5kIFwic3RvcmV5c1wiLlxuICogKiBBdXRvbWF0aWNhbGx5IGNvbnRhaW5zIGFsbCBtb2RlbHMgKHRoYXQgaGF2ZSBtZXRhZGF0YSkgdGhhdCBhcmUgY3VycmVudGx5IGluIHRoZSB7QGxpbmsgU2NlbmV9LlxuICogKiBTb3J0cyB0cmVlIG5vZGVzIGJ5IGRlZmF1bHQgLSBzcGF0aWFsbHksIGZyb20gdG9wLXRvLWJvdHRvbSBmb3IgYGBgYElmY0J1aWxkaW5nU3RvcmV5YGBgYCBub2RlcywgYW5kIGFscGhhbnVtZXJpY2FsbHkgZm9yIG90aGVyIG5vZGVzLlxuICogKiBBbGxvd3MgY3VzdG9tIENTUyBzdHlsaW5nLlxuICogKiBVc2Uge0BsaW5rIENvbnRleHRNZW51fSB0byBjcmVhdGUgYSBjb250ZXh0IG1lbnUgZm9yIHRoZSB0cmVlIG5vZGVzLlxuICpcbiAqICMjIENyZWRpdHNcbiAqXG4gKiBUcmVlVmlld1BsdWdpbiBpcyBiYXNlZCBvbiB0ZWNobmlxdWVzIGRlc2NyaWJlZCBpbiBbKlN1cGVyIEZhc3QgVHJlZSBWaWV3IGluIEphdmFTY3JpcHQqXShodHRwczovL2Nocmlzc21pdGgueHl6L3N1cGVyLWZhc3QtdHJlZS12aWV3LWluLWphdmFzY3JpcHQvKSBieSBbQ2hyaXMgU21pdGhdKGh0dHBzOi8vdHdpdHRlci5jb20vY2hyaXMyMnNtaXRoKS5cbiAqXG4gKiAjIyBVc2FnZVxuICpcbiAqIEluIHRoZSBleGFtcGxlIGJlbG93LCB3ZSdsbCBhZGQgYSBUcmVlVmlld1BsdWdpbiB3aGljaCwgYnkgZGVmYXVsdCwgd2lsbCBhdXRvbWF0aWNhbGx5IHNob3cgdGhlIHN0cnVjdHVyYWxcbiAqIGhpZXJhcmNoeSBvZiB0aGUgSUZDIGVsZW1lbnRzIGluIGVhY2ggbW9kZWwgd2UgbG9hZC5cbiAqXG4gKiBUaGVuIHdlJ2xsIHVzZSBhbiB7QGxpbmsgWEtUTG9hZGVyUGx1Z2lufSB0byBsb2FkIHRoZSBTY2hlcGVuZG9tbGFhbiBtb2RlbCBmcm9tIGFuXG4gKiBbLnhrdCBmaWxlXShodHRwczovL2dpdGh1Yi5jb20veGVva2l0L3hlb2tpdC1zZGsvdHJlZS9tYXN0ZXIvZXhhbXBsZXMvbW9kZWxzL3hrdC9zY2hlcGVuZG9tbGFhbiksIGFsb25nXG4gKiB3aXRoIGFuIGFjY29tcGFueWluZyBKU09OIFtJRkMgbWV0YWRhdGEgZmlsZV0oaHR0cHM6Ly9naXRodWIuY29tL3hlb2tpdC94ZW9raXQtc2RrL3RyZWUvbWFzdGVyL2V4YW1wbGVzL21ldGFNb2RlbHMvc2NoZXBlbmRvbWxhYW4pLlxuICpcbiAqIFtbUnVuIHRoaXMgZXhhbXBsZV0oaHR0cHM6Ly94ZW9raXQuZ2l0aHViLmlvL3hlb2tpdC1zZGsvZXhhbXBsZXMvI0JJTU9mZmxpbmVfWEtUX1NjaGVwZW5kb21sYWFuKV1cbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHtWaWV3ZXJ9IGZyb20gXCIuLi9zcmMvdmlld2VyL1ZpZXdlci5qc1wiO1xuICogaW1wb3J0IHtYS1RMb2FkZXJQbHVnaW59IGZyb20gXCIuLi9zcmMvcGx1Z2lucy9YS1RMb2FkZXJQbHVnaW4vWEtUTG9hZGVyUGx1Z2luLmpzXCI7XG4gKiBpbXBvcnQge1RyZWVWaWV3UGx1Z2lufSBmcm9tIFwiLi4vc3JjL3BsdWdpbnMvVHJlZVZpZXdQbHVnaW4vVHJlZVZpZXdQbHVnaW4uanNcIjtcbiAqXG4gKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlld2VyKHtcbiAqICAgICAgY2FudmFzSWQ6IFwibXlDYW52YXNcIixcbiAqICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAqIH0pO1xuICpcbiAqIHZpZXdlci5jYW1lcmEuZXllID0gWy0yLjU2LCA4LjM4LCA4LjI3XTtcbiAqIHZpZXdlci5jYW1lcmEubG9vayA9IFsxMy40NCwgMy4zMSwgLTE0LjgzXTtcbiAqIHZpZXdlci5jYW1lcmEudXAgPSBbMC4xMCwgMC45OCwgLTAuMTRdO1xuICpcbiAqIGNvbnN0IHRyZWVWaWV3ID0gbmV3IFRyZWVWaWV3UGx1Z2luKHZpZXdlciwge1xuICogICAgIGNvbnRhaW5lckVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlUcmVlVmlld0NvbnRhaW5lclwiKVxuICogfSk7XG4gKlxuICogY29uc3QgeGt0TG9hZGVyID0gbmV3IFhLVExvYWRlclBsdWdpbih2aWV3ZXIpO1xuICpcbiAqIGNvbnN0IG1vZGVsID0geGt0TG9hZGVyLmxvYWQoe1xuICogICAgIGlkOiBcIm15TW9kZWxcIixcbiAqICAgICBzcmM6IFwiLi9tb2RlbHMveGt0L3NjaGVwZW5kb21sYWFuL3NjaGVwZW5kb21sYWFuLnhrdFwiLFxuICogICAgIG1ldGFNb2RlbFNyYzogXCIuL21ldGFNb2RlbHMvc2NoZXBlbmRvbWxhYW4vbWV0YU1vZGVsLmpzb25cIixcbiAqICAgICBlZGdlczogdHJ1ZVxuICogfSk7XG4gKiBgYGBgXG4gKlxuICogIyMgTWFudWFsbHkgQWRkaW5nIE1vZGVsc1xuICpcbiAqIEluc3RlYWQgb2YgYWRkaW5nIG1vZGVscyBhdXRvbWF0aWNhbGx5LCB3ZSBjYW4gY29udHJvbCB3aGljaCBtb2RlbHMgYXBwZWFyIGluIG91ciBUcmVlVmlld1BsdWdpbiBieSBhZGRpbmcgdGhlbSBtYW51YWxseS5cbiAqXG4gKiBJbiB0aGUgbmV4dCBleGFtcGxlLCB3ZSdsbCBjb25maWd1cmUgdGhlIFRyZWVWaWV3UGx1Z2luIHRvIG5vdCBhZGQgbW9kZWxzIGF1dG9tYXRpY2FsbHkuIFRoZW4sIG9uY2UgdGhlIG1vZGVsXG4gKiBoYXMgbG9hZGVkLCB3ZSdsbCBhZGQgaXQgbWFudWFsbHkgdXNpbmcge0BsaW5rIFRyZWVWaWV3UGx1Z2luI2FkZE1vZGVsfS5cbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogY29uc3QgdHJlZVZpZXcgPSBuZXcgVHJlZVZpZXdQbHVnaW4odmlld2VyLCB7XG4gKiAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlUcmVlVmlld0NvbnRhaW5lclwiKSxcbiAqICAgICAgYXV0b0FkZE1vZGVsczogZmFsc2UgIC8vIDw8LS0tLS0tLS0tLS0tLS0tLSBEb24ndCBhdXRvLWFkZCBtb2RlbHNcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHhrdExvYWRlciA9IG5ldyBYS1RMb2FkZXJQbHVnaW4odmlld2VyKTtcbiAqXG4gKiBjb25zdCBtb2RlbCA9IHhrdExvYWRlci5sb2FkKHtcbiAqICAgICBpZDogXCJteU1vZGVsXCIsXG4gKiAgICAgc3JjOiBcIi4vbW9kZWxzL3hrdC9zY2hlcGVuZG9tbGFhbi9zY2hlcGVuZG9tbGFhbi54a3RcIixcbiAqICAgICBtZXRhTW9kZWxTcmM6IFwiLi9tZXRhTW9kZWxzL3NjaGVwZW5kb21sYWFuL21ldGFNb2RlbC5qc29uXCIsXG4gKiAgICAgZWRnZXM6IHRydWVcbiAqIH0pO1xuICpcbiAqIG1vZGVsLm9uKFwibG9hZGVkXCIsICgpID0+IHtcbiAqICAgICAgdHJlZVZpZXcuYWRkTW9kZWwobW9kZWwuaWQpO1xuICogfSk7XG4gKiBgYGBgXG4gKlxuICogQWRkaW5nIG1vZGVscyBtYW51YWxseSBhbHNvIGFsbG93cyB1cyB0byBzZXQgc29tZSBvcHRpb25zIGZvciB0aGUgbW9kZWwuIEZvciBleGFtcGxlLCB0aGUgYGBgYHJvb3ROYW1lYGBgYCBvcHRpb24gYWxsb3dzIHVzIHRvIHByb3ZpZGUgYSBjdXN0b20gbmFtZSBmb3JcbiAqIHRoZSByb290IG5vZGUsIHdoaWNoIGlzIHNvbWV0aW1lcyBkZXNpcmFibGUgd2hlbiB0aGUgbW9kZWwncyBcIklmY1Byb2plY3RcIiBlbGVtZW50J3MgbmFtZSBpcyBub3Qgc3VpdGFibGU6XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIG1vZGVsLm9uKFwibG9hZGVkXCIsICgpID0+IHtcbiAqICAgICAgdHJlZVZpZXcuYWRkTW9kZWwobW9kZWwuaWQsIHtcbiAqICAgICAgICAgIHJvb3ROYW1lOiBcIlNjaGVwZW5kb21sYWFuIE1vZGVsXCJcbiAqICAgICAgfSk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiAjIyBJbml0aWFsbHkgRXhwYW5kaW5nIHRoZSBIaWVyYXJjaHlcbiAqXG4gKiBXZSBjYW4gYWxzbyBjb25maWd1cmUgVHJlZVZpZXdQbHVnaW4gdG8gaW5pdGlhbGx5IGV4cGFuZCBlYWNoIG1vZGVsJ3Mgbm9kZXMgdG8gYSBnaXZlbiBkZXB0aC5cbiAqXG4gKiBMZXQncyBhdXRvbWF0aWNhbGx5IGV4cGFuZCB0aGUgZmlyc3QgdGhyZWUgbm9kZXMgZnJvbSB0aGUgcm9vdCwgZm9yIGV2ZXJ5IG1vZGVsIGFkZGVkOlxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB0cmVlVmlldyA9IG5ldyBUcmVlVmlld1BsdWdpbih2aWV3ZXIsIHtcbiAqICAgICAgY29udGFpbmVyRWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteVRyZWVWaWV3Q29udGFpbmVyXCIpLFxuICogICAgICBhdXRvRXhwYW5kRGVwdGg6IDNcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqICMjIFNob3dpbmcgYSBOb2RlIGJ5IElEXG4gKlxuICogV2UgY2FuIHNob3cgYSBnaXZlbiBub2RlIHVzaW5nIGl0cyBJRC4gVGhpcyBjYXVzZXMgdGhlIFRyZWVWaWV3UGx1Z2luIHRvIGNvbGxhcHNlLCB0aGVuIGV4cGFuZCBhbmQgc2Nyb2xsIHRoZSBub2RlIGludG8gdmlldywgdGhlbiBoaWdobGlnaHQgdGhlIG5vZGUuXG4gKlxuICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUge0BsaW5rIFRyZWVWaWV3UGx1Z2luI3Nob3dOb2RlfSBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24sIGluY2x1ZGluZyBob3cgdG8gZGVmaW5lIGEgY3VzdG9tIGhpZ2hsaWdodGVkIGFwcGVhcmFuY2UgZm9yIHRoZSBub2RlIHVzaW5nIENTUy5cbiAqXG4gKiBMZXQncyBtYWtlIHRoZSBUcmVlVmlld1BsdWdpbiBzaG93IHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gd2hhdGV2ZXIgb2JqZWN0IHtAbGluayBFbnRpdHl9IHRoYXQgd2UgcGljazpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogdmlld2VyLmNhbWVyYUNvbnRyb2wub24oXCJwaWNrZWRcIiwgZnVuY3Rpb24gKGUpIHtcbiAqICAgICB2YXIgb2JqZWN0SWQgPSBlLmVudGl0eS5pZDtcbiAqICAgICB0cmVlVmlldy5zaG93Tm9kZShvYmplY3RJZCk7XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiBUaGlzIHdpbGwgZGUtaGlnaGxpZ2h0IGFueSBub2RlIHRoYXQgd2FzIHByZXZpb3VzbHkgc2hvd24gYnkgdGhpcyBtZXRob2QuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIHBpY2tlZCB7QGxpbmsgRW50aXR5fSBpcyBhbiBvYmplY3QgdGhhdCBiZWxvbmdzIHRvIGEgbW9kZWwgdGhhdCdzIHJlcHJlc2VudGVkIGluIHRoZSBUcmVlVmlld1BsdWdpbi5cbiAqXG4gKiAjIyBDdXN0b21pemluZyBBcHBlYXJhbmNlXG4gKlxuICogV2UgY2FuIGN1c3RvbWl6ZSB0aGUgYXBwZWFyYW5jZSBvZiBvdXIgVHJlZVZpZXdQbHVnaW4gYnkgZGVmaW5pbmcgY3VzdG9tIENTUyBmb3IgaXRzIEhUTUxcbiAqIGVsZW1lbnRzLiBTZWUgb3VyIGV4YW1wbGUncyBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS94ZW9raXQveGVva2l0LXNkay9ibG9iL21hc3Rlci9leGFtcGxlcy9CSU1PZmZsaW5lX1hLVF9TY2hlcGVuZG9tbGFhbi5odG1sKVxuICogZm9yIGFuIGV4YW1wbGUgb2YgY3VzdG9tIENTUyBydWxlcy5cbiAqXG4gKiAjIyBNb2RlbCBIaWVyYXJjaGllc1xuICpcbiAqIFRyZWVWaWV3UGx1Z2luIGhhcyB0aHJlZSBoaWVyYXJjaGllcyBmb3Igb3JnYW5pemluZyBpdHMgbm9kZXM6XG4gKlxuICogKiBcImNvbnRhaW5tZW50XCIgLSBvcmdhbml6ZXMgdGhlIHRyZWUgbm9kZXMgdG8gaW5kaWNhdGUgdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeSBvZiB0aGUge0BsaW5rIE1ldGFPYmplY3R9cy5cbiAqICogXCJ0eXBlc1wiIC0gZ3JvdXBzIG5vZGVzIGJ5IHRoZWlyIElGQyB0eXBlcy5cbiAqICogXCJzdG9yZXlzXCIgLSBncm91cHMgbm9kZXMgd2l0aGluIHRoZWlyIGBgYGBJZmNCdWlsZGluZ1N0b3JleXNgYGBgLCBhbmQgc3ViLWdyb3VwcyB0aGVtIGJ5IHRoZWlyIElGQyB0eXBlcy5cbiAqXG4gKiA8YnI+XG4gKiBUaGUgdGFibGUgYmVsb3cgc2hvd3Mgd2hhdCB0aGUgaGllcmFyY2hpZXMgbG9vayBsaWtlOlxuICogPGJyPlxuICpcbiAqIHwgMS4gQ29udGFpbm1lbnQgSGllcmFyY2h5IHwgMi4gVHlwZXMgSGllcmFyY2h5IHwgMy4gU3RvcmV5cyBIaWVyYXJjaHkgfFxuICogfC0tLXwtLS18LS0tfFxuICogfCA8aW1nIHNyYz1cImh0dHA6Ly94ZW9raXQuaW8vaW1nL2RvY3MvVHJlZVZpZXdQbHVnaW4vc3RydWN0dXJlTW9kZS5wbmdcIj4gfCA8aW1nIHNyYz1cImh0dHA6Ly94ZW9raXQuaW8vaW1nL2RvY3MvVHJlZVZpZXdQbHVnaW4vdHlwZXNNb2RlLnBuZ1wiPiB8IDxpbWcgc3JjPVwiaHR0cDovL3hlb2tpdC5pby9pbWcvZG9jcy9UcmVlVmlld1BsdWdpbi9zdG9yZXlzTW9kZS5wbmdcIj4gfFxuICogPGJyPlxuICpcbiAqIExldCdzIGNyZWF0ZSBhIFRyZWVWaWV3UGx1Z2luIHRoYXQgZ3JvdXBzIG5vZGVzIGJ5IHRoZWlyIGJ1aWxkaW5nIHN0b3JpZXMgYW5kIElGQyB0eXBlczpcbiAqXG4gKiBgYGBgamF2YXNjcmlwdFxuICogY29uc3QgdHJlZVZpZXcgPSBuZXcgVHJlZVZpZXdQbHVnaW4odmlld2VyLCB7XG4gKiAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlUcmVlVmlld0NvbnRhaW5lclwiKSxcbiAqICAgICAgaGllcmFyY2h5OiBcInN0b3JpZXNcIlxuICogfSk7XG4gKiBgYGBgXG4gKlxuICogIyMgU29ydGluZyBOb2Rlc1xuICpcbiAqIFRyZWVWaWV3UGx1Z2luIHNvcnRzIGl0cyB0cmVlIG5vZGVzIGJ5IGRlZmF1bHQuIEZvciBhIFwic3RvcmV5c1wiIGhpZXJhcmNoeSwgaXQgb3JkZXJzIGBgYGBJZmNCdWlsZGluZ1N0b3JleWBgYGAgbm9kZXNcbiAqIHNwYXRpYWxseSwgd2l0aCB0aGUgbm9kZSBmb3IgdGhlIGhpZ2hlc3Qgc3RvcnkgYXQgdGhlIHRvcCwgZG93biB0byB0aGUgbG93ZXN0IGF0IHRoZSBib3R0b20uXG4gKlxuICogRm9yIGFsbCB0aGUgaGllcmFyY2h5IHR5cGVzIChcImNvbnRhaW5tZW50XCIsIFwiY2xhc3Nlc1wiIGFuZCBcInN0b3JleXNcIiksIFRyZWVWaWV3UGx1Z2luIHNvcnRzIHRoZSBvdGhlciBub2RlIHR5cGVzXG4gKiBhbHBoYW51bWVyaWNhbGx5IG9uIHRoZWlyIHRpdGxlcy5cbiAqXG4gKiBJZiBmb3Igc29tZSByZWFzb24geW91IG5lZWQgdG8gcHJldmVudCBzb3J0aW5nLCBjcmVhdGUgeW91ciBUcmVlVmlld1BsdWdpbiB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQsIGxpa2Ugc286XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHRyZWVWaWV3ID0gbmV3IFRyZWVWaWV3UGx1Z2luKHZpZXdlciwge1xuICogICAgICBjb250YWluZXJFbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15VHJlZVZpZXdDb250YWluZXJcIiksXG4gKiAgICAgIGhpZXJhcmNoeTogXCJzdG9yaWVzXCIsXG4gKiAgICAgIHNvcnROb2RlczogZmFsc2UgLy8gPDwtLS0tLS0gRGlzYWJsZSBub2RlIHNvcnRpbmdcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqIE5vdGUgdGhhdCwgZm9yIGFsbCBoaWVyYXJjaHkgbW9kZXMsIG5vZGUgc29ydGluZyBpcyBvbmx5IGRvbmUgZm9yIGVhY2ggbW9kZWwgYXQgdGhlIHRpbWUgdGhhdCBpdCBpcyBhZGRlZCB0byB0aGUgVHJlZVZpZXdQbHVnaW4sIGFuZCB3aWxsIG5vdFxuICogdXBkYXRlIGR5bmFtaWNhbGx5IGlmIHdlIGxhdGVyIHRyYW5zZm9ybSB0aGUge0BsaW5rIEVudGl0eX1zIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5vZGVzLlxuICpcbiAqICMjIFBydW5pbmcgZW1wdHkgbm9kZXNcbiAqXG4gKiBTb21ldGltZXMgYSBtb2RlbCBjb250YWlucyBzdWJ0cmVlcyBvZiBvYmplY3RzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgZ2VvbWV0cnkuIFRoZXNlIGFyZSBtb2RlbHMgd2hvc2VcbiAqIHtAbGluayBNZXRhTW9kZWx9IGNvbnRhaW5zIHRyZWVzIG9mIHtAbGluayBNZXRhT2JqZWN0fXMgdGhhdCBkb24ndCBoYXZlIGFueSB7QGxpbmsgRW50aXR5fXMgaW4gdGhlIHtAbGluayBTY2VuZX0uXG4gKlxuICogRm9yIHRoZXNlIG1vZGVscywgdGhlIHRyZWUgdmlldyB3b3VsZCBjb250YWluIG5vZGVzIHRoYXQgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhlIFNjZW5lIHdoZW4gd2UgaW50ZXJhY3Qgd2l0aCB0aGVtLFxuICogd2hpY2ggaXMgdW5kZXNpcmFibGUuXG4gKlxuICogQnkgZGVmYXVsdCwgVHJlZVZpZXdQbHVnaW4gd2lsbCBub3QgY3JlYXRlIG5vZGVzIGZvciB0aG9zZSBvYmplY3RzLiBIb3dldmVyLCB3ZSBjYW4gb3ZlcnJpZGUgdGhhdCBiZWhhdmlvdXIgaWYgd2Ugd2FudFxuICogdG8gaGF2ZSBub2RlcyBmb3IgdGhvc2Ugb2JqZWN0cyAocGVyaGFwcyBmb3IgZGVidWdnaW5nIHRoZSBtb2RlbCk6XG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHRyZWVWaWV3ID0gbmV3IFRyZWVWaWV3UGx1Z2luKHZpZXdlciwge1xuICogICAgICBjb250YWluZXJFbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15VHJlZVZpZXdDb250YWluZXJcIiksXG4gKiAgICAgIGhpZXJhcmNoeTogXCJzdG9yaWVzXCIsXG4gKiAgICAgIHBydW5lRW1wdHlOb2RlczogZmFsc2UgLy8gPDwtLS0tLS0gQ3JlYXRlIG5vZGVzIGZvciBvYmplY3Qgc3VidHJlZXMgd2l0aG91dCBnZW9tZXRyeVxuICogfSk7XG4gKiBgYGBgXG4gKlxuICogIyMgQ29udGV4dCBNZW51XG4gKlxuICogVHJlZVZpZXdQbHVnaW4gZmlyZXMgYSBcImNvbnRleHRtZW51XCIgZXZlbnQgd2hlbmV2ZXIgd2UgcmlnaHQtY2xpY2sgb24gYSB0cmVlIG5vZGUuXG4gKlxuICogVGhlIGV2ZW50IGNvbnRhaW5zOlxuICpcbiAqICogYGBgYGV2ZW50YGBgYCAtIHRoZSBvcmlnaW5hbCBbY29udGV4dG1lbnVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NvbnRleHRtZW51X2V2ZW50KSBbTW91c2VFdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQpXG4gKiAqIGBgYGB2aWV3ZXJgYGBgIC0gdGhlIHtAbGluayBWaWV3ZXJ9XG4gKiAqIGBgYGB0cmVlVmlld1BsdWdpbmBgYGAgLSB0aGUgVHJlZVZpZXdQbHVnaW5cbiAqICogYGBgYHRyZWVWaWV3Tm9kZWBgYGAgLSB0aGUge0BsaW5rIFRyZWVWaWV3Tm9kZX0gcmVwcmVzZW50aW5nIHRoZSB0cmVlIG5vZGVcbiAqPGJyPjxicj5cbiAqXG4gKiBMZXQncyB1c2Uge0BsaW5rIENvbnRleHRNZW51fSB0byBzaG93IGEgc2ltcGxlIGNvbnRleHQgbWVudSBmb3IgdGhlIG5vZGUgd2UgY2xpY2tlZC5cbiAqXG4gKiBbW1J1biBhbiBleGFtcGxlXShodHRwczovL3hlb2tpdC5naXRodWIuaW8veGVva2l0LXNkay9leGFtcGxlcy8jQ29udGV4dE1lbnVfQ2FudmFzX1RyZWVWaWV3UGx1Z2luX0N1c3RvbSldXG4gKlxuICogYGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7Q29udGV4dE1lbnV9IGZyb20gXCIuLi9zcmMvZXh0cmFzL0NvbnRleHRNZW51L0NvbnRleHRNZW51LmpzXCI7XG4gKlxuICogY29uc3QgdHJlZVZpZXdDb250ZXh0TWVudSA9IG5ldyBDb250ZXh0TWVudSh7XG4gKiAgICAgaXRlbXM6IFtcbiAqICAgICAgICAgW1xuICogICAgICAgICAgICAgW1xuICogICAgICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiSGlkZVwiLFxuICogICAgICAgICAgICAgICAgICAgICBkb0FjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJlZVZpZXdQbHVnaW4ud2l0aE5vZGVUcmVlKGNvbnRleHQudHJlZVZpZXdOb2RlLCAodHJlZVZpZXdOb2RlKSA9PiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVWaWV3Tm9kZS5vYmplY3RJZCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHkgPSBjb250ZXh0LnZpZXdlci5zY2VuZS5vYmplY3RzW3RyZWVWaWV3Tm9kZS5vYmplY3RJZF07XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRpdHkpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eS52aXNpYmxlID0gZmFsc2U7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJIaWRlIGFsbFwiLFxuICogICAgICAgICAgICAgICAgICAgICBkb0FjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudmlld2VyLnNjZW5lLnNldE9iamVjdHNWaXNpYmxlKGNvbnRleHQudmlld2VyLnNjZW5lLnZpc2libGVPYmplY3RJZHMsIGZhbHNlKTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgIF0sXG4gKiAgICAgICAgICAgICBbXG4gKiAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTaG93XCIsXG4gKiAgICAgICAgICAgICAgICAgICAgIGRvQWN0aW9uOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmVlVmlld1BsdWdpbi53aXRoTm9kZVRyZWUoY29udGV4dC50cmVlVmlld05vZGUsICh0cmVlVmlld05vZGUpID0+IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZVZpZXdOb2RlLm9iamVjdElkKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IGNvbnRleHQudmlld2VyLnNjZW5lLm9iamVjdHNbdHJlZVZpZXdOb2RlLm9iamVjdElkXTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LnZpc2libGUgPSB0cnVlO1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LnhyYXllZCA9IGZhbHNlO1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LnNlbGVjdGVkID0gZmFsc2U7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTaG93IGFsbFwiLFxuICogICAgICAgICAgICAgICAgICAgICBkb0FjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gY29udGV4dC52aWV3ZXIuc2NlbmU7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5zZXRPYmplY3RzVmlzaWJsZShzY2VuZS5vYmplY3RJZHMsIHRydWUpO1xuICogICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmUuc2V0T2JqZWN0c1hSYXllZChzY2VuZS54cmF5ZWRPYmplY3RJZHMsIGZhbHNlKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5lLnNldE9iamVjdHNTZWxlY3RlZChzY2VuZS5zZWxlY3RlZE9iamVjdElkcywgZmFsc2UpO1xuICogICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgXVxuICogICAgICAgICBdXG4gKiAgICAgXVxuICogfSk7XG4gKlxuICogdHJlZVZpZXcub24oXCJjb250ZXh0bWVudVwiLCAoZSkgPT4ge1xuICpcbiAqICAgICBjb25zdCBldmVudCA9IGUuZXZlbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW91c2VFdmVudFxuICogICAgIGNvbnN0IHZpZXdlciA9IGUudmlld2VyOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWaWV3ZXJcbiAqICAgICBjb25zdCB0cmVlVmlld1BsdWdpbiA9IGUudHJlZVZpZXdQbHVnaW47ICAgICAgICAgLy8gVHJlZVZpZXdQbHVnaW5cbiAqICAgICBjb25zdCB0cmVlVmlld05vZGUgPSBlLnRyZWVWaWV3Tm9kZTsgICAgICAgICAgICAgLy8gVHJlZVZpZXdOb2RlXG4gKlxuICogICAgIHRyZWVWaWV3Q29udGV4dE1lbnUuc2hvdyhlLmV2ZW50LnBhZ2VYLCBlLmV2ZW50LnBhZ2VZKTtcbiAqXG4gKiAgICAgdHJlZVZpZXdDb250ZXh0TWVudS5jb250ZXh0ID0ge1xuICogICAgICAgICB2aWV3ZXI6IGUudmlld2VyLFxuICogICAgICAgICB0cmVlVmlld1BsdWdpbjogZS50cmVlVmlld1BsdWdpbixcbiAqICAgICAgICAgdHJlZVZpZXdOb2RlOiBlLnRyZWVWaWV3Tm9kZVxuICogICAgIH07XG4gKiB9KTtcbiAqIGBgYGBcbiAqXG4gKiAjIyBDbGlja2luZyBOb2RlIFRpdGxlc1xuICpcbiAqIFRyZWVWaWV3UGx1Z2luIGZpcmVzIGEgXCJub2RlVGl0bGVDbGlja2VkXCIgZXZlbnQgd2hlbmV2ZXIgd2UgbGVmdC1jbGljayBvbiBhIHRyZWUgbm9kZS5cbiAqXG4gKiBMaWtlIHRoZSBcImNvbnRleHRtZW51XCIgZXZlbnQsIHRoaXMgZXZlbnQgY29udGFpbnM6XG4gKlxuICogKiBgYGBgZXZlbnRgYGBgIC0gdGhlIG9yaWdpbmFsIFtjbGlja10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xpY2tfZXZlbnQpIFtNb3VzZUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudClcbiAqICogYGBgYHZpZXdlcmBgYGAgLSB0aGUge0BsaW5rIFZpZXdlcn1cbiAqICogYGBgYHRyZWVWaWV3UGx1Z2luYGBgYCAtIHRoZSBUcmVlVmlld1BsdWdpblxuICogKiBgYGBgdHJlZVZpZXdOb2RlYGBgYCAtIHRoZSB7QGxpbmsgVHJlZVZpZXdOb2RlfSByZXByZXNlbnRpbmcgdGhlIHRyZWUgbm9kZVxuICo8YnI+PGJyPlxuICpcbiAqIExldCdzIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gaXNvbGF0ZSBhbmQgZml0LXRvLXZpZXcgdGhlIHtAbGluayBFbnRpdHl9KHMpIHJlcHJlc2VudGVkIGJ5IHRoZSBub2RlLiBUaGlzIGNhbGxiYWNrIGlzXG4gKiBnb2luZyB0byBYLXJheSBhbGwgdGhlIG90aGVyIEVudGl0eXMsIGZseSB0aGUgY2FtZXJhIHRvIGZpdCB0aGUgRW50aXR5KHMpIGZvciB0aGUgY2xpY2tlZCBub2RlLCB0aGVuIGhpZGUgdGhlIG90aGVyIEVudGl0eXMuXG4gKlxuICogW1tSdW4gYW4gZXhhbXBsZV0oaHR0cHM6Ly94ZW9raXQuZ2l0aHViLmlvL3hlb2tpdC1zZGsvZXhhbXBsZXMvI0NvbnRleHRNZW51X0NhbnZhc19UcmVlVmlld1BsdWdpbl9DdXN0b20pXVxuICpcbiAqIGBgYGBqYXZhc2NyaXB0XG4gKiB0cmVlVmlldy5vbihcIm5vZGVUaXRsZUNsaWNrZWRcIiwgKGUpID0+IHtcbiAqICAgICBjb25zdCBzY2VuZSA9IHZpZXdlci5zY2VuZTtcbiAqICAgICBjb25zdCBvYmplY3RJZHMgPSBbXTtcbiAqICAgICBlLnRyZWVWaWV3UGx1Z2luLndpdGhOb2RlVHJlZShlLnRyZWVWaWV3Tm9kZSwgKHRyZWVWaWV3Tm9kZSkgPT4ge1xuICogICAgICAgICBpZiAodHJlZVZpZXdOb2RlLm9iamVjdElkKSB7XG4gKiAgICAgICAgICAgICBvYmplY3RJZHMucHVzaCh0cmVlVmlld05vZGUub2JqZWN0SWQpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgc2NlbmUuc2V0T2JqZWN0c1hSYXllZChzY2VuZS5vYmplY3RJZHMsIHRydWUpO1xuICogICAgIHNjZW5lLnNldE9iamVjdHNWaXNpYmxlKHNjZW5lLm9iamVjdElkcywgdHJ1ZSk7XG4gKiAgICAgc2NlbmUuc2V0T2JqZWN0c1hSYXllZChvYmplY3RJZHMsIGZhbHNlKTtcbiAqICAgICB2aWV3ZXIuY2FtZXJhRmxpZ2h0LmZseVRvKHtcbiAqICAgICAgICAgYWFiYjogc2NlbmUuZ2V0QUFCQihvYmplY3RJZHMpLFxuICogICAgICAgICBkdXJhdGlvbjogMC41XG4gKiAgICAgfSwgKCkgPT4ge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgICAgIHNjZW5lLnNldE9iamVjdHNWaXNpYmxlKHNjZW5lLnhyYXllZE9iamVjdElkcywgZmFsc2UpO1xuICogICAgICAgICAgICAgc2NlbmUuc2V0T2JqZWN0c1hSYXllZChzY2VuZS54cmF5ZWRPYmplY3RJZHMsIGZhbHNlKTtcbiAqICAgICAgICAgfSwgNTAwKTtcbiAqICAgICB9KTtcbiAqIH0pO1xuICogYGBgYFxuICpcbiAqIFRvIG1ha2UgdGhlIGN1cnNvciBjaGFuZ2UgdG8gYSBwb2ludGVyIHdoZW4gd2UgaG92ZXIgb3ZlciB0aGUgbm9kZSB0aXRsZXMsIGFuZCBhbHNvIHRvIG1ha2UgdGhlIHRpdGxlcyBjaGFuZ2UgdG8gYmx1ZSwgd2UnbGwgYWxzbyBkZWZpbmUgdGhpcyBDU1MgZm9yIHRoZSBgYGBgPHNwYW4+YGBgYCBlbGVtZW50c1xuICogdGhhdCByZXByZXNlbnQgdGhlIHRpdGxlcyBvZiBvdXIgVHJlZVZpZXdQbHVnaW4gbm9kZXM6XG4gKlxuICogYGBgYGNzc1xuICogI3RyZWVWaWV3Q29udGFpbmVyIHVsIGxpIHNwYW46aG92ZXIge1xuICogICAgICBjb2xvcjogYmx1ZTtcbiAqICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICogfVxuICogYGBgYFxuICpcbiAqIEBjbGFzcyBUcmVlVmlld1BsdWdpblxuICovXG5jbGFzcyBUcmVlVmlld1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Vmlld2VyfSB2aWV3ZXIgVGhlIFZpZXdlci5cbiAgICAgKiBAcGFyYW0geyp9IGNmZyBQbHVnaW4gY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjZmcuY29udGFpbmVyRWxlbWVudCBET00gZWxlbWVudCB0byBjb250YWluIHRoZSBUcmVlVmlld1BsdWdpbi5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuYXV0b0FkZE1vZGVscz10cnVlXSBXaGVuIGBgYGB0cnVlYGBgYCAoZGVmYXVsdCksIHdpbGwgYXV0b21hdGljYWxseSBhZGQgZWFjaCBtb2RlbCBhcyBpdCdzIGNyZWF0ZWQuIFNldCB0aGlzIGBgYGBmYWxzZWBgYGAgaWYgeW91IHdhbnQgdG8gbWFudWFsbHkgYWRkIG1vZGVscyB1c2luZyB7QGxpbmsgVHJlZVZpZXdQbHVnaW4jYWRkTW9kZWx9IGluc3RlYWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjZmcuYXV0b0V4cGFuZERlcHRoXSBPcHRpb25hbCBkZXB0aCB0byB3aGljaCB0byBpbml0aWFsbHkgZXhwYW5kIHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2ZnLmhpZXJhcmNoeT1cImNvbnRhaW5tZW50XCJdIEhvdyB0byBvcmdhbml6ZSB0aGUgdHJlZSBub2RlczogXCJjb250YWlubWVudFwiLCBcInN0b3JleXNcIiBvciBcInR5cGVzXCIuIFNlZSB0aGUgY2xhc3MgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjZmcuc29ydE5vZGVzPXRydWVdIFdoZW4gdHJ1ZSwgd2lsbCBzb3J0IHRoZSBjaGlsZHJlbiBvZiBlYWNoIG5vZGUuIEZvciBhIFwic3RvcmV5c1wiIGhpZXJhcmNoeSwgdGhlXG4gICAgICogYGBgYElmY0J1aWxkaW5nU3RvcmV5YGBgYCBub2RlcyB3aWxsIGJlIG9yZGVyZWQgc3BhdGlhbGx5LCBmcm9tIHRoZSBoaWdoZXN0IHN0b3JleSBkb3duIHRvIHRoZSBsb3dlc3QsIG9uIHRoZVxuICAgICAqIHZlcnRpY2FsIFdvcmxkIGF4aXMuIEZvciBhbGwgaGllcmFyY2h5IHR5cGVzLCBvdGhlciBub2RlIHR5cGVzIHdpbGwgYmUgb3JkZXJlZCBpbiB0aGUgYXNjZW5kaW5nIGFscGhhbnVtZXJpYyBvcmRlciBvZiB0aGVpciB0aXRsZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2ZnLnBydW5lRW1wdHlOb2Rlcz10cnVlXSBXaGVuIHRydWUsIHdpbGwgbm90IGNvbnRhaW4gbm9kZXMgdGhhdCBkb24ndCBoYXZlIGNvbnRlbnQgaW4gdGhlIHtAbGluayBTY2VuZX0uIFRoZXNlIGFyZSBub2RlcyB3aG9zZSB7QGxpbmsgTWV0YU9iamVjdH1zIGRvbid0IGhhdmUge0BsaW5rIEVudGl0eX1zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZXdlciwgY2ZnID0ge30pIHtcblxuICAgICAgICBzdXBlcihcIlRyZWVWaWV3UGx1Z2luXCIsIHZpZXdlcik7XG5cbiAgICAgICAgaWYgKCFjZmcuY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmZpZyBleHBlY3RlZDogY29udGFpbmVyRWxlbWVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjZmcuY29udGFpbmVyRWxlbWVudDtcbiAgICAgICAgdGhpcy5fbW9kZWxUcmVlVmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy5fYXV0b0FkZE1vZGVscyA9IChjZmcuYXV0b0FkZE1vZGVscyAhPT0gZmFsc2UpO1xuICAgICAgICB0aGlzLl9hdXRvRXhwYW5kRGVwdGggPSAoY2ZnLmF1dG9FeHBhbmREZXB0aCB8fCAwKTtcbiAgICAgICAgdGhpcy5fc29ydE5vZGVzID0gKGNmZy5zb3J0Tm9kZXMgIT09IGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcHJ1bmVFbXB0eU5vZGVzID0gKGNmZy5wcnVuZUVtcHR5Tm9kZXMgIT09IGZhbHNlKTtcblxuICAgICAgICBpZiAodGhpcy5fYXV0b0FkZE1vZGVscykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxJZHMgPSBPYmplY3Qua2V5cyh0aGlzLnZpZXdlci5zY2VuZS5tb2RlbHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vZGVsSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxJZCA9IG1vZGVsSWRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTW9kZWwobW9kZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdlci5zY2VuZS5vbihcIm1vZGVsTG9hZGVkXCIsIChtb2RlbElkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld2VyLm1ldGFTY2VuZS5tZXRhTW9kZWxzW21vZGVsSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTW9kZWwobW9kZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhpZXJhcmNoeSA9IGNmZy5oaWVyYXJjaHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwIG9mIHtAbGluayBNb2RlbFRyZWVWaWV3fXMuXG4gICAgICpcbiAgICAgKiBFYWNoIE1vZGVsVHJlZVZpZXcgaXMgbWFwcGVkIHRvIHRoZSBJRCBvZiBpdHMgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfHt9fVxuICAgICAqL1xuICAgIGdldCBtb2RlbFRyZWVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsVHJlZVZpZXdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaG93IHRoZSBub2RlcyBhcmUgb3JnYW5pemVkIHdpdGhpbiB0aGlzIHRyZWUgdmlldy5cbiAgICAgKlxuICAgICAqIEFjY2VwdGVkIHZhbHVlcyBhcmU6XG4gICAgICpcbiAgICAgKiAqIFwiY29udGFpbm1lbnRcIiAtIG9yZ2FuaXplcyB0aGUgbm9kZXMgdG8gaW5kaWNhdGUgdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeSBvZiB0aGUgSUZDIG9iamVjdHMuXG4gICAgICogKiBcInR5cGVzXCIgLSBncm91cHMgdGhlIG5vZGVzIHdpdGhpbiB0aGVpciBJRkMgdHlwZXMuXG4gICAgICogKiBcInN0b3JleXNcIiAtIGdyb3VwcyB0aGUgbm9kZXMgd2l0aGluIGBgYGBJZmNCdWlsZGluZ1N0b3JleXNgYGBgIGFuZCBzdWItZ3JvdXBzIHRoZW0gYnkgdGhlaXIgSUZDIHR5cGVzLlxuICAgICAqXG4gICAgICogPGJyPlxuICAgICAqIFRoaXMgY2FuIGJlIHVwZGF0ZWQgZHluYW1pY2FsbHkuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFwiY29udGFpbm1lbnRcIi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGhpZXJhcmNoeShoaWVyYXJjaHkpIHtcbiAgICAgICAgaGllcmFyY2h5ID0gaGllcmFyY2h5IHx8IFwiY29udGFpbm1lbnRcIjtcbiAgICAgICAgaWYgKGhpZXJhcmNoeSAhPT0gXCJjb250YWlubWVudFwiICYmIGhpZXJhcmNoeSAhPT0gXCJzdG9yZXlzXCIgJiYgaGllcmFyY2h5ICE9PSBcInR5cGVzXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgYGhpZXJhcmNoeScgLSBkZWZhdWx0aW5nIHRvICdjb250YWlubWVudCdcIik7XG4gICAgICAgICAgICBoaWVyYXJjaHkgPSBcImNvbnRhaW5tZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHRoaXMuX21vZGVsVHJlZVZpZXdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZWxUcmVlVmlld3MuaGFzT3duUHJvcGVydHkobW9kZWxJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbFRyZWVWaWV3c1ttb2RlbElkXS5zZXRIaWVyYXJjaHkodGhpcy5faGllcmFyY2h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaG93IHRoZSBub2RlcyBhcmUgb3JnYW5pemVkIHdpdGhpbiB0aGlzIHRyZWUgdmlldy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGhpZXJhcmNoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZXJhcmNoeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbW9kZWwgdG8gdGhpcyB0cmVlIHZpZXcuXG4gICAgICpcbiAgICAgKiBUaGUgbW9kZWwgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBUbyBhdXRvbWF0aWNhbGx5IGFkZCBlYWNoIG1vZGVsIGFzIGl0J3MgY3JlYXRlZCwgaW5zdGVhZCBvZiBtYW51YWxseSBjYWxsaW5nIHRoaXMgbWV0aG9kIGVhY2ggdGltZSxcbiAgICAgKiBwcm92aWRlIGEgYGBgYGF1dG9BZGRNb2RlbHM6IHRydWVgYGBgIHRvIHRoZSBUcmVlVmlld1BsdWdpbiBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlbElkIElEIG9mIGEgbW9kZWwge0BsaW5rIEVudGl0eX0gaW4ge0BsaW5rIFNjZW5lI21vZGVsc30uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciBtb2RlbCBpbiB0aGUgdHJlZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yb290TmFtZV0gT3B0aW9uYWwgZGlzcGxheSBuYW1lIGZvciB0aGUgcm9vdCBub2RlLiBPcmRpbmFyeSwgZm9yIFwiY29udGFpbm1lbnRcIlxuICAgICAqIGFuZCBcInN0b3JleXNcIiBoaWVyYXJjaHkgdHlwZXMsIHRoZSB0cmVlIHdvdWxkIGRlcml2ZSB0aGUgcm9vdCBub2RlIG5hbWUgZnJvbSB0aGUgbW9kZWwncyBcIklmY1Byb2plY3RcIiBlbGVtZW50XG4gICAgICogbmFtZS4gVGhpcyBvcHRpb24gYWxsb3dzIHRvIG92ZXJyaWRlIHRoYXQgbmFtZSB3aGVuIGl0IGlzIG5vdCBzdWl0YWJsZSBhcyBhIGRpc3BsYXkgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7TW9kZWxUcmVlVmlld30gTW9kZWxUcmVlVmlldyBmb3IgdGhlIG5ld2x5LWFkZGVkIG1vZGVsLiBJZiB0aGlzIG1ldGhvZCBzdWNjZWVkZWQgaW4gYWRkaW5nIHRoZSBtb2RlbCxcbiAgICAgKiB0aGVuIHtAbGluayBNb2RlbFRyZWVWaWV3I3ZhbGlkfSB3aWxsIGVxdWFsIGBgYGB0cnVlYGBgYC4gT3RoZXJ3aXNlLCB0aGF0IHByb3BlcnR5IHdpbGwgYmUgYGBgYGZhbHNlYGBgYFxuICAgICAqIGFuZCB7QGxpbmsgTW9kZWxUcmVlVmlldyNlcnJvcnN9IHdpbGwgY29udGFpbiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBhZGRNb2RlbChtb2RlbElkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnZpZXdlci5zY2VuZS5tb2RlbHNbbW9kZWxJZF07XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IFwiTW9kZWwgbm90IGZvdW5kOiBcIiArIG1vZGVsSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YU1vZGVsID0gdGhpcy52aWV3ZXIubWV0YVNjZW5lLm1ldGFNb2RlbHNbbW9kZWxJZF07XG4gICAgICAgIGlmICghbWV0YU1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTWV0YU1vZGVsIG5vdCBmb3VuZDogXCIgKyBtb2RlbElkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW9kZWxUcmVlVmlld3NbbW9kZWxJZF0pIHtcbiAgICAgICAgICAgIHRoaXMud2FybihcIk1vZGVsIGFscmVhZHkgYWRkZWQ6IFwiICsgbW9kZWxJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxUcmVlVmlldyA9IG5ldyBNb2RlbFRyZWVWaWV3KHRoaXMudmlld2VyLCB0aGlzLCBtb2RlbCwgbWV0YU1vZGVsLCB7XG4gICAgICAgICAgICBjb250YWluZXJFbGVtZW50OiB0aGlzLl9jb250YWluZXJFbGVtZW50LFxuICAgICAgICAgICAgYXV0b0V4cGFuZERlcHRoOiB0aGlzLl9hdXRvRXhwYW5kRGVwdGgsXG4gICAgICAgICAgICBoaWVyYXJjaHk6IHRoaXMuX2hpZXJhcmNoeSxcbiAgICAgICAgICAgIHNvcnROb2RlczogdGhpcy5fc29ydE5vZGVzLFxuICAgICAgICAgICAgcHJ1bmVFbXB0eU5vZGVzOiB0aGlzLl9wcnVuZUVtcHR5Tm9kZXMsXG4gICAgICAgICAgICByb290TmFtZTogb3B0aW9ucy5yb290TmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbW9kZWxUcmVlVmlld3NbbW9kZWxJZF0gPSBtb2RlbFRyZWVWaWV3O1xuICAgICAgICBtb2RlbC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1vZGVsKG1vZGVsLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2RlbFRyZWVWaWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBtb2RlbCBmcm9tIHRoaXMgdHJlZSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGVsSWQgSUQgb2YgYSBtb2RlbCB7QGxpbmsgRW50aXR5fSBpbiB7QGxpbmsgU2NlbmUjbW9kZWxzfS5cbiAgICAgKi9cbiAgICByZW1vdmVNb2RlbChtb2RlbElkKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsVHJlZVZpZXcgPSB0aGlzLl9tb2RlbFRyZWVWaWV3c1ttb2RlbElkXTtcbiAgICAgICAgaWYgKCFtb2RlbFRyZWVWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJNb2RlbCBub3QgYWRkZWQ6IFwiICsgbW9kZWxJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxUcmVlVmlldy5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RlbFRyZWVWaWV3c1ttb2RlbElkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYWxsIHRyZWVzIHdpdGhpbiB0aGlzIHRyZWUgdmlldy5cbiAgICAgKi9cbiAgICBjb2xsYXBzZSgpIHtcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9tb2RlbFRyZWVWaWV3cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsVHJlZVZpZXdzLmhhc093blByb3BlcnR5KG1vZGVsSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxUcmVlVmlldyA9IHRoaXMuX21vZGVsVHJlZVZpZXdzW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIG1vZGVsVHJlZVZpZXcuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZ2hsaWdodHMgdGhlIHRyZWUgdmlldyBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gb2JqZWN0IHtAbGluayBFbnRpdHl9LlxuICAgICAqXG4gICAgICogVGhpcyBjYXVzZXMgdGhlIHRyZWUgdmlldyB0byBjb2xsYXBzZSwgdGhlbiBleHBhbmQgdG8gcmV2ZWFsIHRoZSBub2RlLCB0aGVuIGhpZ2hsaWdodCB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqIElmIGEgbm9kZSBpcyBwcmV2aW91c2x5IGhpZ2hsaWdodGVkLCBkZS1oaWdobGlnaHRzIHRoYXQgbm9kZSBhbmQgY29sbGFwc2VzIHRoZSB0cmVlIGZpcnN0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGlmIHRoZSBUcmVlVmlld1BsdWdpbiB3YXMgY29uZmlndXJlZCB3aXRoIGBgYGBwcnVuZUVtcHR5Tm9kZXM6IHRydWVgYGBgIChkZWZhdWx0IGNvbmZpZ3VyYXRpb24pLCB0aGVuIHRoZVxuICAgICAqIG5vZGUgd29uJ3QgZXhpc3QgaW4gdGhlIHRyZWUgaWYgaXQgaGFzIG5vIEVudGl0eXMgaW4gdGhlIHtAbGluayBTY2VuZX0uIGluIHRoYXQgY2FzZSwgbm90aGluZyB3aWxsIGhhcHBlbi5cbiAgICAgKlxuICAgICAqIFdpdGhpbiB0aGUgRE9NLCB0aGUgbm9kZSBpcyByZXByZXNlbnRlZCBieSBhbiBgYGBgPGxpPmBgYGAgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCBhZGQgYSBgYGBgLmhpZ2hsaWdodGVkLW5vZGVgYGBgIGNsYXNzIHRvXG4gICAgICogdGhlIGVsZW1lbnQgdG8gbWFrZSBpdCBhcHBlYXIgaGlnaGxpZ2h0ZWQsIHJlbW92aW5nIHRoYXQgY2xhc3Mgd2hlbiBkZS1oaWdobGlnaHRpbmcgaXQgYWdhaW4uIFNlZSB0aGUgQ1NTIHJ1bGVzXG4gICAgICogaW4gdGhlIFRyZWVWaWV3UGx1Z2luIGV4YW1wbGVzIGZvciBhbiBleGFtcGxlIG9mIHRoYXQgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0SWQgSUQgb2YgdGhlIHtAbGluayBFbnRpdHl9LlxuICAgICAqL1xuICAgIHNob3dOb2RlKG9iamVjdElkKSB7XG4gICAgICAgIHRoaXMudW5TaG93Tm9kZSgpO1xuICAgICAgICBjb25zdCBtZXRhT2JqZWN0ID0gdGhpcy52aWV3ZXIubWV0YVNjZW5lLm1ldGFPYmplY3RzW29iamVjdElkXTtcbiAgICAgICAgaWYgKCFtZXRhT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiTWV0YU9iamVjdCBub3QgZm91bmQ6IFwiICsgb2JqZWN0SWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFNb2RlbCA9IG1ldGFPYmplY3QubWV0YU1vZGVsO1xuICAgICAgICBjb25zdCBtb2RlbElkID0gbWV0YU1vZGVsLmlkO1xuICAgICAgICBjb25zdCBtb2RlbFRyZWVWaWV3ID0gdGhpcy5fbW9kZWxUcmVlVmlld3NbbW9kZWxJZF07XG4gICAgICAgIGlmICghbW9kZWxUcmVlVmlldykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIk9iamVjdCBub3QgaW4gdGhpcyBUcmVlVmlldzogXCIgKyBvYmplY3RJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxUcmVlVmlldy5zaG93Tm9kZShvYmplY3RJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGUtaGlnaGxpZ2h0cyB0aGUgbm9kZSBwcmV2aW91c2x5IHNob3duIHdpdGgge0BsaW5rIFRyZWVWaWV3UGx1Z2luI3Nob3dOb2RlfS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90aGluZyBpZiBubyBub2RlIGlzIGN1cnJlbnRseSBzaG93bi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBub2RlIGlzIGN1cnJlbnRseSBzY3JvbGxlZCBpbnRvIHZpZXcsIGtlZXBzIHRoZSBub2RlIGluIHZpZXcuXG4gICAgICovXG4gICAgdW5TaG93Tm9kZSgpIHtcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9tb2RlbFRyZWVWaWV3cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsVHJlZVZpZXdzLmhhc093blByb3BlcnR5KG1vZGVsSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxUcmVlVmlldyA9IHRoaXMuX21vZGVsVHJlZVZpZXdzW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIG1vZGVsVHJlZVZpZXcudW5TaG93Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgdHJlZSB0byB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICpcbiAgICAgKiBDb2xsYXBzZXMgdGhlIHRyZWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggdG8gZXhwYW5kIHRvLlxuICAgICAqL1xuICAgIGV4cGFuZFRvRGVwdGgoZGVwdGgpIHtcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLl9tb2RlbFRyZWVWaWV3cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsVHJlZVZpZXdzLmhhc093blByb3BlcnR5KG1vZGVsSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxUcmVlVmlldyA9IHRoaXMuX21vZGVsVHJlZVZpZXdzW21vZGVsSWRdO1xuICAgICAgICAgICAgICAgIG1vZGVsVHJlZVZpZXcuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICBtb2RlbFRyZWVWaWV3LmV4cGFuZFRvRGVwdGgoZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHN1YnRyZWUgb2YgdGhlIHRyZWUgdmlldydzIHtAbGluayBUcmVlVmlld05vZGV9cywgY2FsbGluZyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2hcbiAgICAgKiBub2RlIGluIGRlcHRoLWZpcnN0IHByZS1vcmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJlZVZpZXdOb2RlfSBub2RlIFJvb3Qgb2YgdGhlIHN1YnRyZWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgY2FsbGVkIGF0IGVhY2gge0BsaW5rIFRyZWVWaWV3Tm9kZX0sIHdpdGggdGhlIFRyZWVWaWV3Tm9kZSBnaXZlbiBhcyB0aGUgYXJndW1lbnQuXG4gICAgICovXG4gICAgd2l0aE5vZGVUcmVlKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud2l0aE5vZGVUcmVlKGNoaWxkcmVuW2ldLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIFRyZWVWaWV3UGx1Z2luLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG1vZGVsSWQgaW4gdGhpcy5fbW9kZWxUcmVlVmlld3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlbFRyZWVWaWV3cy5oYXNPd25Qcm9wZXJ0eShtb2RlbElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGVsVHJlZVZpZXdzW21vZGVsSWRdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb2RlbFRyZWVWaWV3cyA9IHt9O1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuXG5leHBvcnQge1RyZWVWaWV3UGx1Z2lufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/TreeViewPlugin.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/modelValidation.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/modelValidation.js ***!
  \***************************************************************************************/
/*! exports provided: validateMetaModelForTreeViewTypesHierarchy, validateMetaModelForTreeViewStoreysHierarchy, validateMetaModelForTreeViewContainmentHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateMetaModelForTreeViewTypesHierarchy\", function() { return validateMetaModelForTreeViewTypesHierarchy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateMetaModelForTreeViewStoreysHierarchy\", function() { return validateMetaModelForTreeViewStoreysHierarchy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateMetaModelForTreeViewContainmentHierarchy\", function() { return validateMetaModelForTreeViewContainmentHierarchy; });\n/**\n * Tests if {@link TreeViewPlugin} would be able to create a \"types\" hierarchy for the given {@link MetaModel}.\n *\n * @param {MetaModel} metaModel The MetaModel.\n * @param {String[]} errors Accumulates messages for validation errors.\n * @return {boolean} Returns ````true```` if no errors found, else ````false````.\n */\nfunction validateMetaModelForTreeViewTypesHierarchy(metaModel, errors) {\n    const rootMetaObject = metaModel.rootMetaObject;\n    if (!rootMetaObject) {\n        errors.push(\"Can't build types hierarchy: model is empty\");\n        return false;\n    }\n    return true;\n}\n\n/**\n * Tests if {@link TreeViewPlugin} would be able to create a \"storeys\" hierarchy for the given {@link MetaModel}.\n *\n * @param {MetaModel} metaModel The MetaModel.\n * @param {String[]} errors Accumulates messages for validation errors.\n * @return {boolean} Returns ````true```` if no errors found, else ````false````.\n */\nfunction validateMetaModelForTreeViewStoreysHierarchy(metaModel, errors) {\n    const rootMetaObject = metaModel.rootMetaObject;\n    if (!rootMetaObject) {\n        errors.push(\"Can't build storeys hierarchy: model is empty\");\n        return false;\n    }\n    return _validateMetaModelForStoreysHierarchy(rootMetaObject, errors);\n}\n\n/**\n * Tests if {@link TreeViewPlugin} would be able to create a \"containment\" hierarchy for the given {@link MetaModel}.\n *\n * @param {MetaModel} metaModel The MetaModel.\n * @param {String[]} errors Accumulates messages for validation errors.\n * @return {boolean} Returns ````true```` if no errors found, else ````false````.\n */\nfunction validateMetaModelForTreeViewContainmentHierarchy(metaModel, errors) {\n    const rootMetaObject = metaModel.rootMetaObject;\n    if (!rootMetaObject) {\n        errors.push(\"Can't build containment hierarchy: model is empty\");\n        return false;\n    }\n    return true;\n}\n\n/**\n * @private\n */\nfunction _validateMetaModelForStoreysHierarchy(metaObject, errors, level = 0, ctx, buildingNode) {\n    ctx = ctx || {\n        foundIFCBuildingStoreys: false\n    };\n    const metaObjectType = metaObject.type;\n    const children = metaObject.children;\n    if (metaObjectType === \"IfcBuilding\") {\n        buildingNode = true;\n    } else if (metaObjectType === \"IfcBuildingStorey\") {\n        if (!buildingNode) {\n            errors.push(\"Can't build storeys hierarchy: IfcBuildingStorey found without parent IfcBuilding\");\n            return false;\n        }\n        ctx.foundIFCBuildingStoreys = true;\n    }\n    if (children) {\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childMetaObject = children[i];\n            if (!_validateMetaModelForStoreysHierarchy(childMetaObject, errors, level + 1, ctx, buildingNode)) {\n                return false;\n            }\n        }\n    }\n    if (level === 0) {\n        if (!ctx.foundIFCBuildingStoreys) {\n            // errors.push(\"Can't build storeys hierarchy: no IfcBuildingStoreys found\");\n        }\n    }\n    return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvcGx1Z2lucy9UcmVlVmlld1BsdWdpbi9tb2RlbFZhbGlkYXRpb24uanM/YzBhOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsYUFBYSxxQkFBcUIsNERBQTRELGdCQUFnQjtBQUM5RztBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUJBQXFCLDhEQUE4RCxnQkFBZ0I7QUFDaEg7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFCQUFxQixrRUFBa0UsZ0JBQWdCO0FBQ3BIO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3BsdWdpbnMvVHJlZVZpZXdQbHVnaW4vbW9kZWxWYWxpZGF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0cyBpZiB7QGxpbmsgVHJlZVZpZXdQbHVnaW59IHdvdWxkIGJlIGFibGUgdG8gY3JlYXRlIGEgXCJ0eXBlc1wiIGhpZXJhcmNoeSBmb3IgdGhlIGdpdmVuIHtAbGluayBNZXRhTW9kZWx9LlxuICpcbiAqIEBwYXJhbSB7TWV0YU1vZGVsfSBtZXRhTW9kZWwgVGhlIE1ldGFNb2RlbC5cbiAqIEBwYXJhbSB7U3RyaW5nW119IGVycm9ycyBBY2N1bXVsYXRlcyBtZXNzYWdlcyBmb3IgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIGBgYGB0cnVlYGBgYCBpZiBubyBlcnJvcnMgZm91bmQsIGVsc2UgYGBgYGZhbHNlYGBgYC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVNZXRhTW9kZWxGb3JUcmVlVmlld1R5cGVzSGllcmFyY2h5KG1ldGFNb2RlbCwgZXJyb3JzKSB7XG4gICAgY29uc3Qgcm9vdE1ldGFPYmplY3QgPSBtZXRhTW9kZWwucm9vdE1ldGFPYmplY3Q7XG4gICAgaWYgKCFyb290TWV0YU9iamVjdCkge1xuICAgICAgICBlcnJvcnMucHVzaChcIkNhbid0IGJ1aWxkIHR5cGVzIGhpZXJhcmNoeTogbW9kZWwgaXMgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGVzdHMgaWYge0BsaW5rIFRyZWVWaWV3UGx1Z2lufSB3b3VsZCBiZSBhYmxlIHRvIGNyZWF0ZSBhIFwic3RvcmV5c1wiIGhpZXJhcmNoeSBmb3IgdGhlIGdpdmVuIHtAbGluayBNZXRhTW9kZWx9LlxuICpcbiAqIEBwYXJhbSB7TWV0YU1vZGVsfSBtZXRhTW9kZWwgVGhlIE1ldGFNb2RlbC5cbiAqIEBwYXJhbSB7U3RyaW5nW119IGVycm9ycyBBY2N1bXVsYXRlcyBtZXNzYWdlcyBmb3IgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIGBgYGB0cnVlYGBgYCBpZiBubyBlcnJvcnMgZm91bmQsIGVsc2UgYGBgYGZhbHNlYGBgYC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVNZXRhTW9kZWxGb3JUcmVlVmlld1N0b3JleXNIaWVyYXJjaHkobWV0YU1vZGVsLCBlcnJvcnMpIHtcbiAgICBjb25zdCByb290TWV0YU9iamVjdCA9IG1ldGFNb2RlbC5yb290TWV0YU9iamVjdDtcbiAgICBpZiAoIXJvb3RNZXRhT2JqZWN0KSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiQ2FuJ3QgYnVpbGQgc3RvcmV5cyBoaWVyYXJjaHk6IG1vZGVsIGlzIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfdmFsaWRhdGVNZXRhTW9kZWxGb3JTdG9yZXlzSGllcmFyY2h5KHJvb3RNZXRhT2JqZWN0LCBlcnJvcnMpO1xufVxuXG4vKipcbiAqIFRlc3RzIGlmIHtAbGluayBUcmVlVmlld1BsdWdpbn0gd291bGQgYmUgYWJsZSB0byBjcmVhdGUgYSBcImNvbnRhaW5tZW50XCIgaGllcmFyY2h5IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIE1ldGFNb2RlbH0uXG4gKlxuICogQHBhcmFtIHtNZXRhTW9kZWx9IG1ldGFNb2RlbCBUaGUgTWV0YU1vZGVsLlxuICogQHBhcmFtIHtTdHJpbmdbXX0gZXJyb3JzIEFjY3VtdWxhdGVzIG1lc3NhZ2VzIGZvciB2YWxpZGF0aW9uIGVycm9ycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgYGBgYHRydWVgYGBgIGlmIG5vIGVycm9ycyBmb3VuZCwgZWxzZSBgYGBgZmFsc2VgYGBgLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGFNb2RlbEZvclRyZWVWaWV3Q29udGFpbm1lbnRIaWVyYXJjaHkobWV0YU1vZGVsLCBlcnJvcnMpIHtcbiAgICBjb25zdCByb290TWV0YU9iamVjdCA9IG1ldGFNb2RlbC5yb290TWV0YU9iamVjdDtcbiAgICBpZiAoIXJvb3RNZXRhT2JqZWN0KSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiQ2FuJ3QgYnVpbGQgY29udGFpbm1lbnQgaGllcmFyY2h5OiBtb2RlbCBpcyBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfdmFsaWRhdGVNZXRhTW9kZWxGb3JTdG9yZXlzSGllcmFyY2h5KG1ldGFPYmplY3QsIGVycm9ycywgbGV2ZWwgPSAwLCBjdHgsIGJ1aWxkaW5nTm9kZSkge1xuICAgIGN0eCA9IGN0eCB8fCB7XG4gICAgICAgIGZvdW5kSUZDQnVpbGRpbmdTdG9yZXlzOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgbWV0YU9iamVjdFR5cGUgPSBtZXRhT2JqZWN0LnR5cGU7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBtZXRhT2JqZWN0LmNoaWxkcmVuO1xuICAgIGlmIChtZXRhT2JqZWN0VHlwZSA9PT0gXCJJZmNCdWlsZGluZ1wiKSB7XG4gICAgICAgIGJ1aWxkaW5nTm9kZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChtZXRhT2JqZWN0VHlwZSA9PT0gXCJJZmNCdWlsZGluZ1N0b3JleVwiKSB7XG4gICAgICAgIGlmICghYnVpbGRpbmdOb2RlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIkNhbid0IGJ1aWxkIHN0b3JleXMgaGllcmFyY2h5OiBJZmNCdWlsZGluZ1N0b3JleSBmb3VuZCB3aXRob3V0IHBhcmVudCBJZmNCdWlsZGluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZm91bmRJRkNCdWlsZGluZ1N0b3JleXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE1ldGFPYmplY3QgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICghX3ZhbGlkYXRlTWV0YU1vZGVsRm9yU3RvcmV5c0hpZXJhcmNoeShjaGlsZE1ldGFPYmplY3QsIGVycm9ycywgbGV2ZWwgKyAxLCBjdHgsIGJ1aWxkaW5nTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIGlmICghY3R4LmZvdW5kSUZDQnVpbGRpbmdTdG9yZXlzKSB7XG4gICAgICAgICAgICAvLyBlcnJvcnMucHVzaChcIkNhbid0IGJ1aWxkIHN0b3JleXMgaGllcmFyY2h5OiBubyBJZmNCdWlsZGluZ1N0b3JleXMgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7XG4gICAgdmFsaWRhdGVNZXRhTW9kZWxGb3JUcmVlVmlld1R5cGVzSGllcmFyY2h5LFxuICAgIHZhbGlkYXRlTWV0YU1vZGVsRm9yVHJlZVZpZXdTdG9yZXlzSGllcmFyY2h5LFxuICAgIHZhbGlkYXRlTWV0YU1vZGVsRm9yVHJlZVZpZXdDb250YWlubWVudEhpZXJhcmNoeVxufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/plugins/TreeViewPlugin/modelValidation.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js ***!
  \**************************************************************/
/*! exports provided: Plugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugin\", function() { return Plugin; });\n/**\n @desc Base class for {@link Viewer} plugin classes.\n */\nclass Plugin {\n\n    /**\n     * Creates this Plugin and installs it into the given {@link Viewer}.\n     *\n     * @param {string} id ID for this plugin, unique among all plugins in the viewer.\n     * @param {Viewer} viewer The viewer.\n     * @param {Object} [cfg] Options\n     */\n    constructor(id, viewer, cfg) {\n\n        /**\n         * ID for this Plugin, unique within its {@link Viewer}.\n         *\n         * @type {string}\n         */\n        this.id = (cfg && cfg.id) ? cfg.id : id;\n\n        /**\n         * The Viewer that contains this Plugin.\n         *\n         * @type {Viewer}\n         */\n        this.viewer = viewer;\n\n        /**\n         * Subscriptions to events fired at this Plugin.\n         * @private\n         */\n        this._eventSubs = {};\n\n        viewer.addPlugin(this);\n    }\n\n    /**\n     Subscribes to an event fired at this Plugin.\n\n     @param {String} event The event\n     @param {Function} callback Callback fired on the event\n     */\n    on(event, callback) {\n        let subs = this._eventSubs[event];\n        if (!subs) {\n            subs = [];\n            this._eventSubs[event] = subs;\n        }\n        subs.push(callback);\n    }\n\n    /**\n     Fires an event at this Plugin.\n\n     @param {String} event The event type name\n     @param {Object} value The event parameters\n     */\n    fire(event, value) {\n        const subs = this._eventSubs[event];\n        if (subs) {\n            for (let i = 0, len = subs.length; i < len; i++) {\n                subs[i](value);\n            }\n        }\n    }\n\n    /**\n     * Logs a message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    log(msg) {\n        console.log(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Logs a warning message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    warn(msg) {\n        console.warn(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Logs an error message to the JavaScript developer console, prefixed with the ID of this Plugin.\n     *\n     * @param {String} msg The error message\n     */\n    error(msg) {\n        console.error(`[xeokit plugin ${this.id}]: ${msg}`);\n    }\n\n    /**\n     * Sends a message to this Plugin.\n     *\n     * @private\n     */\n    send(name, value) {\n        //...\n    }\n\n    /**\n     * Destroys this Plugin and removes it from its {@link Viewer}.\n     */\n    destroy() {\n        this.viewer.removePlugin(this);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL1BsdWdpbi5qcz85Yzk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsS0FBSyxJQUFJO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEsS0FBSyxJQUFJO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsS0FBSyxJQUFJO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL1BsdWdpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuIEBkZXNjIEJhc2UgY2xhc3MgZm9yIHtAbGluayBWaWV3ZXJ9IHBsdWdpbiBjbGFzc2VzLlxuICovXG5jbGFzcyBQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIFBsdWdpbiBhbmQgaW5zdGFsbHMgaXQgaW50byB0aGUgZ2l2ZW4ge0BsaW5rIFZpZXdlcn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgZm9yIHRoaXMgcGx1Z2luLCB1bmlxdWUgYW1vbmcgYWxsIHBsdWdpbnMgaW4gdGhlIHZpZXdlci5cbiAgICAgKiBAcGFyYW0ge1ZpZXdlcn0gdmlld2VyIFRoZSB2aWV3ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjZmddIE9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCwgdmlld2VyLCBjZmcpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSUQgZm9yIHRoaXMgUGx1Z2luLCB1bmlxdWUgd2l0aGluIGl0cyB7QGxpbmsgVmlld2VyfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSAoY2ZnICYmIGNmZy5pZCkgPyBjZmcuaWQgOiBpZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFZpZXdlciB0aGF0IGNvbnRhaW5zIHRoaXMgUGx1Z2luLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Vmlld2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmlwdGlvbnMgdG8gZXZlbnRzIGZpcmVkIGF0IHRoaXMgUGx1Z2luLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzID0ge307XG5cbiAgICAgICAgdmlld2VyLmFkZFBsdWdpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgU3Vic2NyaWJlcyB0byBhbiBldmVudCBmaXJlZCBhdCB0aGlzIFBsdWdpbi5cblxuICAgICBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50XG4gICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZpcmVkIG9uIHRoZSBldmVudFxuICAgICAqL1xuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgc3VicyA9IHRoaXMuX2V2ZW50U3Vic1tldmVudF07XG4gICAgICAgIGlmICghc3Vicykge1xuICAgICAgICAgICAgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRTdWJzW2V2ZW50XSA9IHN1YnM7XG4gICAgICAgIH1cbiAgICAgICAgc3Vicy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgRmlyZXMgYW4gZXZlbnQgYXQgdGhpcyBQbHVnaW4uXG5cbiAgICAgQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0eXBlIG5hbWVcbiAgICAgQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuX2V2ZW50U3Vic1tldmVudF07XG4gICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNbaV0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgdG8gdGhlIEphdmFTY3JpcHQgZGV2ZWxvcGVyIGNvbnNvbGUsIHByZWZpeGVkIHdpdGggdGhlIElEIG9mIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGxvZyhtc2cpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt4ZW9raXQgcGx1Z2luICR7dGhpcy5pZH1dOiAke21zZ31gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgd2FybmluZyBtZXNzYWdlIHRvIHRoZSBKYXZhU2NyaXB0IGRldmVsb3BlciBjb25zb2xlLCBwcmVmaXhlZCB3aXRoIHRoZSBJRCBvZiB0aGlzIFBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB3YXJuKG1zZykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFt4ZW9raXQgcGx1Z2luICR7dGhpcy5pZH1dOiAke21zZ31gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIEphdmFTY3JpcHQgZGV2ZWxvcGVyIGNvbnNvbGUsIHByZWZpeGVkIHdpdGggdGhlIElEIG9mIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGVycm9yKG1zZykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbeGVva2l0IHBsdWdpbiAke3RoaXMuaWR9XTogJHttc2d9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoaXMgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vLi4uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBQbHVnaW4gYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMge0BsaW5rIFZpZXdlcn0uXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy52aWV3ZXIucmVtb3ZlUGx1Z2luKHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHtQbHVnaW59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/Plugin.js\n");

/***/ }),

/***/ "./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js ***!
  \***********************************************************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return Map; });\n/** @private */\nclass Map {\n\n    constructor(items, baseId) {\n        this.items = items || [];\n        this._lastUniqueId = (baseId || 0) + 1;\n    }\n\n    /**\n     * Usage:\n     *\n     * id = myMap.addItem(\"foo\") // ID internally generated\n     * id = myMap.addItem(\"foo\", \"bar\") // ID is \"foo\"\n     */\n    addItem() {\n        let item;\n        if (arguments.length === 2) {\n            const id = arguments[0];\n            item = arguments[1];\n            if (this.items[id]) { // Won't happen if given ID is string\n                throw \"ID clash: '\" + id + \"'\";\n            }\n            this.items[id] = item;\n            return id;\n\n        } else {\n            item = arguments[0] || {};\n            while (true) {\n                const findId = this._lastUniqueId++;\n                if (!this.items[findId]) {\n                    this.items[findId] = item;\n                    return findId;\n                }\n            }\n        }\n    }\n\n    removeItem(id) {\n        const item = this.items[id];\n        delete this.items[id];\n        return item;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW9raXQveGVva2l0LXNkay9zcmMvdmlld2VyL3NjZW5lL3V0aWxzL01hcC5qcz84ZDZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AeGVva2l0L3hlb2tpdC1zZGsvc3JjL3ZpZXdlci9zY2VuZS91dGlscy9NYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmNsYXNzIE1hcCB7XG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgYmFzZUlkKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5fbGFzdFVuaXF1ZUlkID0gKGJhc2VJZCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIikgLy8gSUQgaW50ZXJuYWxseSBnZW5lcmF0ZWRcbiAgICAgKiBpZCA9IG15TWFwLmFkZEl0ZW0oXCJmb29cIiwgXCJiYXJcIikgLy8gSUQgaXMgXCJmb29cIlxuICAgICAqL1xuICAgIGFkZEl0ZW0oKSB7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaWRdKSB7IC8vIFdvbid0IGhhcHBlbiBpZiBnaXZlbiBJRCBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aHJvdyBcIklEIGNsYXNoOiAnXCIgKyBpZCArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kSWQgPSB0aGlzLl9sYXN0VW5pcXVlSWQrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXNbZmluZElkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ZpbmRJZF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oaWQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1tpZF07XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@xeokit/xeokit-sdk/src/viewer/scene/utils/Map.js\n");

/***/ })

}]);